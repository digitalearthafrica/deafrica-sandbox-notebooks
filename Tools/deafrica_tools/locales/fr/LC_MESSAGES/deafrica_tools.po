msgid ""
msgstr ""
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: POEditor.com\n"
"Project-Id-Version: DE Africa translation\n"
"Language: fr\n"

#: 
msgid "Contact & Help"
msgstr "Contact et aide"

#: 
msgid "Digital Earth Africa Help Desk"
msgstr "Service d'assistance de Digital Earth Africa"

#: 
msgid "Explore the `Help Desk <https://helpdesk.digitalearthafrica.org/>`_. It's full of useful materials such as the **Knowledge Base** of articles, **FAQs** and **User Guides**."
msgstr "Explorez le `Help Desk <https://helpdesk.digitalearthafrica.org/>`_. Il regorge de documents utiles tels que la **Base de connaissances** d'articles, les **FAQ** et les **Guides de l'utilisateur**."

#: 
msgid "For members you can submit and view tickets, join the community for discussions and ask your own questions."
msgstr ""

#: 
msgid "`helpdesk.digitalearthafrica.org <https://helpdesk.digitalearthafrica.org/>`_"
msgstr ""

#: 
msgid "If you can't find what you are looking for, you can ask for help by `submitting a ticket <https://helpdesk.digitalearthafrica.org/portal/en/newticket>`_."
msgstr ""

#: 
msgid "Email"
msgstr ""

#: 
msgid "Email us at helpdesk@digitalearthafrica.org."
msgstr ""

#: 
msgid "GIS Stack Exchange"
msgstr ""

#: 
msgid "If you need assistance with code or other technical matters, please post a question on the `GIS Stack Exchange <https://gis.stackexchange.com/questions/ask?tags=open-data-cube>`_ using the ``open-data-cube`` tag."
msgstr ""

#: 
msgid "You can also view `previous asked questions <https://gis.stackexchange.com/questions/tagged/open-data-cube>`_"
msgstr ""

#: 
msgid "Open Data Cube Slack"
msgstr ""

#: 
msgid "To talk to the DE Africa community, please join the `Open Data Cube Slack <http://slack.opendatacube.org/>`_, and join the ``#de-africa`` channel."
msgstr ""

#: 
msgid "Glossary"
msgstr ""

#: 
msgid "AEZ"
msgstr ""

#: 
msgid "Agro-Ecological Zone. Several DE Africa datasets, such as Water Observations from Space, use AEZs to subdivide the African continent when performing data validation and accuracy assessments."
msgstr ""

#: 
msgid "API"
msgstr ""

#: 
msgid "Application Programming Interface. The Open Data Cube Application Programming Interface gives programmers full access to the capabilities of the Cube, allowing query and advanced data retrieval."
msgstr ""

#: 
msgid "ARD"
msgstr ""

#: 
msgid "Analysis Ready Data. Data which has been pre-processed and compiled to make it more accessible. This makes it easier for users to perform their own analysis."
msgstr ""

#: 
msgid "ARN"
msgstr ""

#: 
msgid "Amazon Resource Name. The naming method used by Amazon Web Services to unambiguously specify resources."
msgstr ""

#: 
msgid "AWS"
msgstr ""

#: 
msgid "Amazon Web Services. Cloud computing infrastructure provided by Amazon (United States)."
msgstr ""

#: 
msgid "CEOS"
msgstr ""

#: 
msgid "Committee on Earth Observations. An international panel focusing on the interoperability, validation, and coordination of Earth observation activities. See https://ceos.org/."
msgstr ""

#: 
msgid "COG"
msgstr ""

#: 
msgid "Cloud Optimized GeoTIFF. A data file format optimised for efficient workflows on the cloud and remote reading. See https://www.cogeo.org/."
msgstr ""

#: 
msgid "DE Africa Notebooks"
msgstr ""

#: 
msgid "Digital Earth Africa Notebooks. An open-source repository containing Jupyter Notebooks, tools and workflows for geospatial analysis with Open Data Cube and xarray. See https://github.com/digitalearthafrica/deafrica-sandbox-notebooks."
msgstr ""

#: 
msgid "DE Africa Sandbox"
msgstr ""

#: 
msgid "Digital Earth Africa Sandbox. A learning and analysis environment for getting started with DE Africa and the Open Data Cube. It includes sample data and Jupyter notebooks that demonstrate the capability of the Open Data Cube."
msgstr ""

#: 
msgid "DE Africa"
msgstr ""

#: 
msgid "Digital Earth Africa. DE Africa delivers routine, reliable and operational services using Earth observations to produce decision-ready products for policy, science and industry. For more information see https://www.digitalearthafrica.org/."
msgstr ""

#: 
msgid "EO"
msgstr ""

#: 
msgid "Earth Observation. The field of gathering information about Earth using surveying techniques such as satellite-based remote sensing, or ground-based data collection."
msgstr ""

#: 
msgid "ESA"
msgstr ""

#: 
msgid "European Space Agency"
msgstr ""

#: 
msgid "FAO"
msgstr ""

#: 
msgid "Food and Agriculture Organization of the United Nations"
msgstr ""

#: 
msgid "FC"
msgstr ""

#: 
msgid "Fractional Cover. Fractional Cover (FC) is a measurement that splits the landscape into three parts, or fractions; green (leaves, grass, and growing crops), brown (branches, dry grass or hay, and dead leaf litter), and bare ground (soil or rock)."
msgstr ""

#: 
msgid "GeoMAD"
msgstr ""

#: 
msgid "Geomedian and Median Absolute Deviation product."
msgstr ""

#: 
msgid "Geomedian"
msgstr ""

#: 
msgid "A robust high-dimensional statistic that maintains relationships between spectral bands. Forms part of the GeoMAD product."
msgstr ""

#: 
msgid "GEE"
msgstr ""

#: 
msgid "Google Earth Engine"
msgstr ""

#: 
msgid "GIS"
msgstr ""

#: 
msgid "Geographic Information System"
msgstr ""

#: 
msgid "Jupyter Notebook"
msgstr ""

#: 
msgid "A user-friendly file type that allows code to be run and presented alongside explanatory documentation, figures, and scientific notation. Has the file extension .ipynb."
msgstr ""

#: 
msgid "JupyterLab"
msgstr ""

#: 
msgid "An interactive web-based user interface for editing and running Jupyter Notebooks. JupyterLab is used as an analysis environment on the DE Africa Sandbox."
msgstr ""

#: 
msgid "Landsat"
msgstr ""

#: 
msgid "A joint NASA/USGS program of medium resolution satellites that have been collecting publicly available Earth observation data continuously since 1972."
msgstr ""

#: 
msgid "MAD"
msgstr ""

#: 
msgid "Median Absolute Deviation. In DE Africa, MADs are a measure used to quantify variation in the geomedian. Forms part of the GeoMAD product, where three different MADs are used: Euclidean MAD, Spectral MAD, and Bray-Curtis MAD."
msgstr ""

#: 
msgid "MODIS"
msgstr ""

#: 
msgid "Moderate Resolution Imaging Spectroradiometer, a sensor on board NASA's Terra and Aqua satellites that collects publicly-available low resolution Earth observation data every one to two days."
msgstr ""

#: 
msgid "NASA"
msgstr ""

#: 
msgid "National Aeronautics and Space Administration (United States)"
msgstr ""

#: 
msgid "NBR"
msgstr ""

#: 
msgid "Normalised Burn Ratio, calculated from near-infrared (NIR) and short wave infrared (SWIR)."
msgstr ""

#: 
msgid "NDVI"
msgstr ""

#: 
msgid "Normalised Difference Vegetation Index, calculated from visible and near-infrared light reflected by vegetation."
msgstr ""

#: 
msgid "NIR"
msgstr ""

#: 
msgid "Near Infrared, referring to particular bands used to collect Earth observation data"
msgstr ""

#: 
msgid "ODC"
msgstr ""

#: 
msgid "Open Data Cube, an international open-source project developing the technology that powers Digital Earth Africa. For more information see http://opendatacube.org/."
msgstr ""

#: 
msgid "OGC"
msgstr ""

#: 
msgid "Open Geospatial Consortium"
msgstr ""

#: 
msgid "OWS"
msgstr ""

#: 
msgid "OGC Web Services. Geospatial services for data access, display and processing."
msgstr ""

#: 
msgid "Python"
msgstr ""

#: 
msgid "The programming language used to develop the Open Data Cube. It is easy to use while still allowing high performance access and processing capabilities. See http://www.python.org/ for more information."
msgstr ""

#: 
msgid "SAR"
msgstr ""

#: 
msgid "Synthetic Aperture Radar"
msgstr ""

#: 
msgid "Sentinel"
msgstr ""

#: 
msgid "A series of satellites from the ESA Copernicus programme. They collect publicly-available Earth observation data. The program includes the Sentinel-2 multispectral instrument mission, and the Sentinel-1 SAR mission."
msgstr ""

#: 
msgid "STAC"
msgstr ""

#: 
msgid "The SpatioTemporal Asset Catalog (STAC) is a specification that provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. See https://stacspec.org/."
msgstr ""

#: 
msgid "USGS"
msgstr ""

#: 
msgid "United States Geological Survey"
msgstr ""

#: 
msgid "WOfS"
msgstr ""

#: 
msgid "Water Observations from Space, a Digital Earth Africa product that provides images and data showing where water has been seen in by satellites."
msgstr ""

#: 
msgid "xarray"
msgstr ""

#: 
msgid "An open source project and Python package that for working with labelled multi-dimensional arrays such as those returned by the Open Data Cube (ODC). See http://xarray.pydata.org/."
msgstr ""

#: 
msgid "Training Courses"
msgstr ""

#: 
msgid "Training courses on using Digital Earth Africa are available at:"
msgstr ""

#: 
msgid "`learn.digitalearthafrica.org <https://learn.digitalearthafrica.org/>`_"
msgstr ""

#: 
msgid "There is a self-paced 6-week introductory training course on using the Sandbox:"
msgstr ""

#: 
msgid "English: `Introduction to Sandbox <https://learn.digitalearthafrica.org/courses/course-v1:digitalearthafrica+DEA101+2021/about>`_"
msgstr ""

#: 
msgid "Français: `Introduction à la sandbox <https://learn.digitalearthafrica.org/courses/course-v1:digitalearthafrica+DEA101-fr+2021/about>`_"
msgstr ""

#: 
msgid "The course covers:"
msgstr ""

#: 
msgid "Using the Digital Earth Africa Sandbox"
msgstr ""

#: 
msgid "The data products available through Digital Earth Africa"
msgstr ""

#: 
msgid "Using the Map Portal"
msgstr ""

#: 
msgid "Generating cloud-free composites"
msgstr ""

#: 
msgid "Calculating indices"
msgstr ""

#: 
msgid "Analysing vegetation and water resources"
msgstr ""

#: 
msgid "ALOS PALSAR, ALOS-2 PALSAR-2 and JERS-1 SAR Annual Mosaic"
msgstr ""

#: 
msgid "**Date modified:** Sept 2023"
msgstr ""

#: 
msgid "Product overview"
msgstr ""

#: 
msgid "Background"
msgstr ""

#: 
msgid "Synthetic Aperture Radar (SAR) data have been shown to provide different and complementary information to the more common optical remote sensing data. Radar backscatter response is a function of topography, land cover structure, orientation, and moisture characteristics-including vegetation biomass-and the radar signal can penetrate clouds, providing information about the earth’s surface where optical sensors cannot. Digital Earth Africa provides access to Normalized Radar Backscatter data, for which Radiometric Terrain Correction (RTC) has been applied so data acquired with different imaging geometries over the same region can be compared."
msgstr ""

#: 
msgid "The ALOS/PALSAR annual mosaic is a global 25 m resolution dataset that combines data from many images captured by JAXA's PALSAR and PALSAR-2 sensors on ALOS-1 and ALOS-2 satellites respectively. This product contains radar measurement in L-band and in HH and HV polarizations. It has a spatial resolution of 25 m and is available annually for 2007 to 2010 (ALOS/PALSAR) and 2015 to 2022 (ALOS-2/PALSAR-2)."
msgstr ""

#: 
msgid "The JERS annual mosaic is generated from images acquired by the SAR sensor on the Japanese Earth Resources Satellite-1 (JERS-1) satellite. This product contains radar measurement in L-band and HH polarization. It has a spatial resolution of 25 m and is available for 1996."
msgstr ""

#: 
msgid "This mosaic data is part of a global dataset provided by the Japan Aerospace Exploration Agency (JAXA) Earth Observation Research Center."
msgstr ""

#: 
msgid "For more information on the products, see https://www.eorc.jaxa.jp/ALOS/en/dataset/fnf_e.htm. A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/ALOS_PALSAR_Annual_Mosaic.ipynb>`__ which demonstrates loading and using this data in the Sandbox is also available."
msgstr ""

#: 
msgid "Specifications"
msgstr ""

#: 
msgid "DE Africa provides ALOS/ALOS-2 PALSAR/PALSAR-2 Mosaic and JERS-1 Mosaic as two seperate products. Relevant coverage and metadata can be viewed on DE Africa Metadata Exploer:"
msgstr ""

#: 
msgid "`ALOS/ALOS-2 PALSAR/PALSAR-2 Mosaic <https://explorer.digitalearth.africa/products/alos_palsar_mosaic>`__"
msgstr ""

#: 
msgid "`JERS-1 Mosaic <https://explorer.digitalearth.africa/products/jers_sar_mosaic>`__"
msgstr ""

#: 
msgid "**Table 1: SAR annual mosaic product specifications**"
msgstr ""

#: 
msgid "Satellite"
msgstr ""

#: 
msgid "JERS-1"
msgstr ""

#: 
msgid "ALOS"
msgstr ""

#: 
msgid "JERS-2"
msgstr ""

#: 
msgid "Instrument"
msgstr ""

#: 
msgid "PALSAR"
msgstr ""

#: 
msgid "PALSAR-2"
msgstr ""

#: 
msgid "Launch date"
msgstr ""

#: 
msgid "Feb 11, 1992"
msgstr ""

#: 
msgid "Jan 24, 2006"
msgstr ""

#: 
msgid "May 24, 2014"
msgstr ""

#: 
msgid "Frequency"
msgstr ""

#: 
msgid "L-band (1.27 GHz)"
msgstr ""

#: 
msgid "L-band"
msgstr ""

#: 
msgid "Polarisation"
msgstr ""

#: 
msgid "HH"
msgstr ""

#: 
msgid "HH + HV"
msgstr ""

#: 
msgid "Number of bands"
msgstr ""

#: 
msgid "4"
msgstr ""

#: 
msgid "5"
msgstr ""

#: 
msgid "Cell size - X (degree)"
msgstr ""

#: 
msgid "0.00022"
msgstr ""

#: 
msgid "Cell size - Y (degree)"
msgstr ""

#: 
msgid "Coordinate reference system"
msgstr ""

#: 
msgid "EPSG:4326"
msgstr ""

#: 
msgid "Temporal resolution"
msgstr ""

#: 
msgid "Annual"
msgstr ""

#: 
msgid "Temporal range"
msgstr ""

#: 
msgid "1996"
msgstr ""

#: 
msgid "2007-2010"
msgstr ""

#: 
msgid "2015 - 2022"
msgstr ""

#: 
msgid "More information about the dataset can be found on the `JAXA dataset description page <https://www.eorc.jaxa.jp/ALOS/en/dataset/fnf_e.htm>`__"
msgstr ""

#: 
msgid "**Table 2: ALOS/ALOS-2 annual mosaic measurements**"
msgstr ""

#: 
msgid "Band ID"
msgstr ""

#: 
msgid "Description"
msgstr ""

#: 
msgid "Data type"
msgstr ""

#: 
msgid "No data\\ :math:`^\\dagger`"
msgstr ""

#: 
msgid "HH backscatter"
msgstr ""

#: 
msgid "uint16"
msgstr ""

#: 
msgid "0"
msgstr ""

#: 
msgid "HV"
msgstr ""

#: 
msgid "HV backscatter"
msgstr ""

#: 
msgid "date"
msgstr ""

#: 
msgid "Observation date (days since launch)"
msgstr ""

#: 
msgid "linci"
msgstr ""

#: 
msgid "Local incidence angle"
msgstr ""

#: 
msgid "uint8"
msgstr ""

#: 
msgid "mask"
msgstr ""

#: 
msgid "Processing mask information"
msgstr ""

#: 
msgid ":math:`^\\dagger` No data or fill value."
msgstr ""

#: 
msgid "Backscatter data is provided as digital number (DN), which can be converted to backscatter in decibel unit using :math:`10*log10(𝐷𝑁^2)-83.0`."
msgstr ""

#: 
msgid "**Table 3: JERS annual mosaic measurements**"
msgstr ""

#: 
msgid "Backscatter data is provided as digital number (DN), which can be converted to backscatter in decibel unit using :math:`10*log10(𝐷𝑁^2)-84.66`."
msgstr ""

#: 
msgid "For the ALOS and JERS mosaics, a data mask is provided that can be used to exclude pixels with potentially problematic measurements."
msgstr ""

#: 
msgid "**Table 4: Processing mask specification.**"
msgstr ""

#: 
msgid "Value"
msgstr ""

#: 
msgid "no_data"
msgstr ""

#: 
msgid "50"
msgstr ""

#: 
msgid "water"
msgstr ""

#: 
msgid "100"
msgstr ""

#: 
msgid "lay_over"
msgstr ""

#: 
msgid "150"
msgstr ""

#: 
msgid "shadowing"
msgstr ""

#: 
msgid "255"
msgstr ""

#: 
msgid "land"
msgstr ""

#: 
msgid "Processing"
msgstr ""

#: 
msgid "The ALOS/PALSAR annual mosaic is a global 25 m resolution dataset that combines data from many images captured by JAXA's PALSAR and PALSAR-2 sensors on ALOS-1 and ALOS-2 satellites respectively. The JERS annual mosaic is generated from images acquired by the SAR sensor on the Japanese Earth Resources Satellite-1 (JERS-1) satellite."
msgstr ""

#: 
msgid "Media and example images"
msgstr ""

#: 
msgid "ALOS annual mosaics for crop near Cairo"
msgstr ""

#: 
msgid "**Figure 1: ALOS false color composites (HH, HV, HV/HH) over an area near Cairo, Egypt, showing changes in crop pattern from year to year.**"
msgstr ""

#: 
msgid "Related services"
msgstr ""

#: 
msgid "`Sentinel-1 SAR Backscatter <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-1_specs.html>`__"
msgstr ""

#: 
msgid "References"
msgstr ""

#: 
msgid "`JAXA Global PALSAR-2/PALSAR/JERS-1 Mosaic <https://www.eorc.jaxa.jp/ALOS/en/dataset/fnf_e.htm>`__"
msgstr ""

#: 
msgid "License"
msgstr ""

#: 
msgid "This dataset is available to use with no charge under the `Terms for Use <https://earth.jaxa.jp/policy/en.html>`__."
msgstr ""

#: 
msgid "Acknowledgements"
msgstr ""

#: 
msgid "This dataset is part of a global product provided by the Japan Aerospace Exploration Agency (JAXA)."
msgstr ""

#: 
msgid "Data access"
msgstr ""

#: 
msgid "Amazon Web Services S3"
msgstr ""

#: 
msgid "This product is available in AWS S3."
msgstr ""

#: 
msgid "**Table 5: AWS data access details.**"
msgstr ""

#: 
msgid "AWS S3 details"
msgstr ""

#: 
msgid "Bucket ARD"
msgstr ""

#: 
msgid "``arn:aws:s3:::deafrica-input-datasets``"
msgstr ""

#: 
msgid "Region"
msgstr ""

#: 
msgid "``af-south-1``"
msgstr ""

#: 
msgid "The bucket is in the AWS region ``af-south-1`` (Cape Town). Additional region specifications can be applied as follows:"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-input-datasets/``"
msgstr ""

#: 
msgid "The file paths follow the format ``<productname>/<year>/<tile_id>/``."
msgstr ""

#: 
msgid "**Table 6: AWS file path convention.**"
msgstr ""

#: 
msgid "File path element"
msgstr ""

#: 
msgid "Example"
msgstr ""

#: 
msgid "``productname``"
msgstr ""

#: 
msgid "Product name, ``alos_palsar_mosaic`` or ``jers_sar_mosaic``"
msgstr ""

#: 
msgid "``alos_palsar_mosaic``"
msgstr ""

#: 
msgid "``year``"
msgstr ""

#: 
msgid "Observation year"
msgstr ""

#: 
msgid "``2015``"
msgstr ""

#: 
msgid "``tile_id``"
msgstr ""

#: 
msgid "5x5 deg tile labeld by southwest corner coordinates"
msgstr ""

#: 
msgid "``S20E020``"
msgstr ""

#: 
msgid "OGC Web Services (OWS)"
msgstr ""

#: 
msgid "This product is available through DE Africa's OWS."
msgstr ""

#: 
msgid "**Table 7: OWS data access details.**"
msgstr ""

#: 
msgid "OWS details"
msgstr ""

#: 
msgid "Name"
msgstr ""

#: 
msgid "``DE Africa Services``"
msgstr ""

#: 
msgid "Web Map Services (WMS) URL"
msgstr ""

#: 
msgid "``https://ows.digitalearth.africa/wms?version=1.3.0``"
msgstr ""

#: 
msgid "Web Coverage Service (WCS) URL"
msgstr ""

#: 
msgid "``https://ows.digitalearth.africa/wcs?version=2.1.0``"
msgstr ""

#: 
msgid "Layer name"
msgstr ""

#: 
msgid "``alos_palsar_mosaic``, ``jers_sar_mosaic``"
msgstr ""

#: 
msgid "Digital Earth Africa OWS details can be found at https://ows.digitalearth.africa/."
msgstr ""

#: 
msgid "For instructions on how to connect to OWS, see `this tutorial <../web_services/index.ipynb>`__."
msgstr ""

#: 
msgid "Open Data Cube (ODC)"
msgstr ""

#: 
msgid "The Landsat Collection 2 Level-2 products can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product names:** ``alos_palsar_mosaic``, ``jers_sar_mosaic``"
msgstr ""

#: 
msgid "Specific bands of data can be called by using either the default names or any of a band's alternative names, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load all bands."
msgstr ""

#: 
msgid "**Table 8: ALOS/ALOS-2 annual mosaic (ODC product alos_palsar_mosaic) band names.**"
msgstr ""

#: 
msgid "Band name"
msgstr ""

#: 
msgid "Alternative names"
msgstr ""

#: 
msgid "Fill value"
msgstr ""

#: 
msgid "hh"
msgstr ""

#: 
msgid "–"
msgstr ""

#: 
msgid "hv"
msgstr ""

#: 
msgid "local incidence angle, incidence"
msgstr ""

#: 
msgid "**Table 9: JERS-1 annual mosaic (ODC product jers_sar_mosaic) band names.**"
msgstr ""

#: 
msgid "Band names are case-sensitive."
msgstr ""

#: 
msgid "For examples on how to use the ODC API, see the DE Africa `example notebook repository <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__."
msgstr ""

#: 
msgid "Technical information"
msgstr ""

#: 
msgid "Radiometric terrain correction"
msgstr ""

#: 
msgid "See relevant section in the `Sentinel-1 SAR backscatter product specification <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-1_specs.html#Radiometric-terrain-correction>`__."
msgstr ""

#: 
msgid "ESA Climate Change Initiative Land Cover at 300m spatial resolution"
msgstr ""

#: 
msgid "**Date modified:** 16 February 2022"
msgstr ""

#: 
msgid "Product Overview"
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) provides free and open access to a copy of ESA's Climate Change Initiative Land Cover product over Africa for 1992-2019."
msgstr ""

#: 
msgid "Among many potential uses, the CCI Land Cover product aims to:"
msgstr ""

#: 
msgid "build on the United Nations (UN) Food and Agriculture Organization (FAO) Land Cover Classification System (LCCS) for the sake of compatibility with other land cover products;"
msgstr ""

#: 
msgid "meet the needs of climate and global carbon flux modelling communities."
msgstr ""

#: 
msgid "The CCI maps were designed to be globally consistent. Therefore, their “level 1” legend was determined by the level of information that was available and that made sense at the scale of the entire world. This “level 1” legend is the one expressed by ten values (i.e. class values of 10, 20, 30, etc.). The land cover maps were also described by a more detailed legend, called “level 2” which corresponds to the non-ten values (i.e. class values of 11, 12, 61, 62, etc.). This “level 2” legend made use of more accurate and regional information where available."
msgstr ""

#: 
msgid "Further information is available at the `ESA landcover CCI website <https://www.esa-landcover-cci.org/>`__ and in the `user manual <http://maps.elie.ucl.ac.be/CCI/viewer/download/ESACCI-LC-Ph2-PUGv2_2.0.pdf>`__. A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landcover_Classification.ipynb>`__ which demonstrates loading and using landcover datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "Spatial and temporal coverage."
msgstr ""

#: 
msgid "Relevant metadata for the ESA Climate Change Initiative Land Cover at 300m product can be viewed on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/cci_landcover>`__."
msgstr ""

#: 
msgid "**Table 1: ESA Climate Change Initiative Land Cover at 300 m product specifications.**"
msgstr ""

#: 
msgid "Specification"
msgstr ""

#: 
msgid "Product name"
msgstr ""

#: 
msgid "``cci_landcover``"
msgstr ""

#: 
msgid "Cell size - X (degrees)"
msgstr ""

#: 
msgid "-0.003° (~300m)"
msgstr ""

#: 
msgid "Cell size - Y (degrees)"
msgstr ""

#: 
msgid "1992-2019"
msgstr ""

#: 
msgid "Update frequency"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/cci_landcover>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: ESA Climate Change Initiative Land Cover at 300 m product geographic extent.**"
msgstr ""

#: 
msgid "CGLS Geographic Extent"
msgstr ""

#: 
msgid "Measurements"
msgstr ""

#: 
msgid "**Table 2: ESA Climate Change Initiative Land Cover at 300 m product measurements.**"
msgstr ""

#: 
msgid "Units"
msgstr ""

#: 
msgid "Range"
msgstr ""

#: 
msgid "classification"
msgstr ""

#: 
msgid "LCCS Class"
msgstr ""

#: 
msgid "1"
msgstr ""

#: 
msgid "0 - 220"
msgstr ""

#: 
msgid "The ESA Climate Change Initiative Land Cover maps were made with a dominance of MERIS FR imagery. The MERIS RR dataset was also used to compensate for a lack of MERIS FR acquisitions in some areas and observations acquired by the SPOT. Vegetation (SPOT-VGT) were used to extend the temporal coverage of the project over the years 1998-2002."
msgstr ""

#: 
msgid "The `multi-year global land cover mapping at 300 M and characterization for climate modelling document <https://research.wur.nl/en/publications/multi-year-global-land-cover-mapping-at-300-m-and-characterizatio>`__ and `land cover mapping framework paper <https://ieeexplore.ieee.org/abstract/document/6351640>`__ describe the pre-processing and classification chains used to produce the most recent distibution of land cover maps."
msgstr ""

#: 
msgid "**Figure 2: CCI land cover classification data for Madagascar.**"
msgstr ""

#: 
msgid "CCI 2019 Madagascar"
msgstr ""

#: 
msgid "*Credit: Contains the CCI Land Cover 300m product courtesy of the ESA Climate Change Initiative, processed by Digital Earth Africa.*"
msgstr ""

#: 
msgid "Bontemps, P. Defourny, C. Brockmann, M. Herold, V. Kalogirou and O. Arino, \"New global land cover mapping exercise in the framework of the ESA Climate Change Initiative,\" 2012 IEEE International Geoscience and Remote Sensing Symposium, 2012, pp. 44-47, https://doi.org/10.1109/IGARSS.2012.6351640."
msgstr ""

#: 
msgid "Bontemps, S., Boettcher, M., Brockmann, C., Kirches, G., Lamarche, C., Radoux, J., Santoro, M., Van Bogaert, E., Wegmüller, U., Herold, M., Achard, F., Ramoino, F., Arino, O., & Defourny, P. (2015). Multi-year global land cover mapping at 300 M and characterization for climate modelling: Achievements of the land cover component of the ESA climate change initiative. In International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences - ISPRS Archives (Vol. XL-7/W3, pp. 323-328). International Society for Photogrammetry and Remote Sensing. https://doi.org/10.5194/isprsarchives-XL-7-W3-323-2015"
msgstr ""

#: 
msgid "As an official product of the ESA CCI Data Policy, access to this product is free and open to all users."
msgstr ""

#: 
msgid "This CCI-LC database has been processed by the CCI-LC consortium led by UCL-Geomatics (Belgium). The research leading to the current version of the product was led by the ESA CCI Land Cover project."
msgstr ""

#: 
msgid "Data Access"
msgstr ""

#: 
msgid "Amazon Web Service"
msgstr ""

#: 
msgid "The ESA Climate Change Initiative Land Cover at 300 m product is avaliable in AWS S3."
msgstr ""

#: 
msgid "**Table 3: AWS data acess details.**"
msgstr ""

#: 
msgid "The file paths follow the format: ``s3://deafrica-input-datasets/cci_landcover/<year>/``."
msgstr ""

#: 
msgid "The ESA Climate Change Initiative Land Cover at 300 m product is not yet avaliable through Digital Earth Africa’s OWS."
msgstr ""

#: 
msgid "The ESA Climate Change Initiative Land Cover at 300 m product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``cci_landcover``"
msgstr ""

#: 
msgid "Specific bands of data can be called by using either the default names or any of a band’s alternative names, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load all bands."
msgstr ""

#: 
msgid "**Table 4: ODC product cci_landcover band names**."
msgstr ""

#: 
msgid "class"
msgstr ""

#: 
msgid "``255``"
msgstr ""

#: 
msgid "Technical Information"
msgstr ""

#: 
msgid "The 2015 global overall accuracy was ``75.4 %``."
msgstr ""

#: 
msgid "Further information on validation and accuracy can be found in the `Land Cover CCI Product User Guide Version 2.0 <http://maps.elie.ucl.ac.be/CCI/viewer/download/ESACCI-LC-Ph2-PUGv2_2.0.pdf>`__."
msgstr ""

#: 
msgid "Copernicus Global Land Service Global Land Cover at 100m spatial resolution"
msgstr ""

#: 
msgid "**Date modified:** 25 January 2021"
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) provides free and open access to a copy of the Collection 3 (version 3) Copernicus Global Land Service Annual Dynamic Global Land Cover at 100 m spatial resolution (CGLS_LC100m) product over Africa for the years 2015 to 2019."
msgstr ""

#: 
msgid "The CGLS_LC100m product is an annual collection of landcover layers produced by the Copernicus Global Land Monitoring Service (CGLS). Each mapping period, contains 14-15 layers:"
msgstr ""

#: 
msgid "One discrete land cover classification layer (provides 23 classes defined according to the FAO LCCS scheme)"
msgstr ""

#: 
msgid "Fractional cover layers for 10 land cover classes (bare/sparse vegetation, cropland, herbaceous grassland, moss & lichen, shrubland, tree, permanent snow & ice, built-up, permanent water, seasonal water)"
msgstr ""

#: 
msgid "One forest type layer (forest type for all pixels where tree cover fraction is bigger than 1 %)"
msgstr ""

#: 
msgid "One discrete classification probability layer (quality indicator of the classifier)"
msgstr ""

#: 
msgid "Data Density Indicator for PROBA-V UTM 100m input data (quality of the EO input data between 0 – 100 (0 = bad, 100 = perfect data))"
msgstr ""

#: 
msgid "Change Confidence Layer showing the certainty that a change occurred compared to the previous year (only delivered for layers produced in conso or nrt mode)"
msgstr ""

#: 
msgid "DE Africa provides 13 of these layers which are described in the `Measurements <#Measurements>`__ section."
msgstr ""

#: 
msgid "This page details how to access the CGLS_LC100m product through the DE Africa platforms. For more information on the dataset see the `product user manual <https://doi.org/10.5281/zenodo.4723921>`__ and the `publication <https://doi.org/10.3390/rs12061044>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landcover_Classification.ipynb>`__ which demonstrates loading and using landcover datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "Relevant metadata for the Copernicus Global Land Service Land Use/Land Cover at 100 m product can be viewed on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/cgls_landcover>`__."
msgstr ""

#: 
msgid "**Table 1: Copernicus Global Land Service Land Use/Land Cover at 100 m product specifications.**"
msgstr ""

#: 
msgid "``cgls_landcover``"
msgstr ""

#: 
msgid "-0.001° (~100m)"
msgstr ""

#: 
msgid "2015 – 2019"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/cgls_landcover>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: Copernicus Global Land Service Land Use/Land Cover at 100 m product geographic extent.**"
msgstr ""

#: 
msgid "**Table 2: Copernicus Global Land Service Land Use/Land Cover at 100 m product measurements.**"
msgstr ""

#: 
msgid "Land cover classification"
msgstr ""

#: 
msgid "0 - 200"
msgstr ""

#: 
msgid "forest_type"
msgstr ""

#: 
msgid "Forest type for all pixels with tree percentage vegetation cover bigger than 1 %"
msgstr ""

#: 
msgid "percent"
msgstr ""

#: 
msgid "0 - 5"
msgstr ""

#: 
msgid "classification_probability"
msgstr ""

#: 
msgid "Quality indicator (classification probability) of the discrete classification"
msgstr ""

#: 
msgid "0 - 100"
msgstr ""

#: 
msgid "bare_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for bare-sparse-vegetation land cover class"
msgstr ""

#: 
msgid "builtup_cover_fraction"
msgstr ""

#: 
msgid "Percent ground cover for built-up land cover class"
msgstr ""

#: 
msgid "crops_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for cropland land cover class"
msgstr ""

#: 
msgid "grass_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for herbaceous vegetation land cover class"
msgstr ""

#: 
msgid "mosslichen_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for moss and lichen land cover class"
msgstr ""

#: 
msgid "permanentwater_cover_fraction"
msgstr ""

#: 
msgid "Percent ground cover for permanent water land cover class"
msgstr ""

#: 
msgid "seasonalwater_cover_fraction"
msgstr ""

#: 
msgid "Percent ground cover for seasonal water land cover class"
msgstr ""

#: 
msgid "shrub_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for shrubland land cover class"
msgstr ""

#: 
msgid "snow_cover_fraction"
msgstr ""

#: 
msgid "Percent ground cover for snow and ice land cover class"
msgstr ""

#: 
msgid "tree_cover_fraction"
msgstr ""

#: 
msgid "Percent vegetation cover for forest land cover class"
msgstr ""

#: 
msgid "The Copernicus Global Land Service Annual Dynamic Global Land Cover at 100 m spatial resolution (CGLS_LC100m) product is generated by the Copernicus Global Land Monitoring Service (CGLS) using PROBA-V satellite observations as the main inputs. The `Copernicus Global Land Service: Land Cover 100m: version 3 Globe 2015-2019: Algorithm Theoretical Basis Document <https://doi.org/10.5281/zenodo.4723924>`__ (ATBD) describes in detail the methodology used to produce the third collection of the 100m Land Cover product, the global annual maps for the period 2015-2019, including detailed technical descriptions of the algorithms, the ancillary data used, and the intermediate products produced."
msgstr ""

#: 
msgid "**Figure 2: CGLS land cover classification data for Madagascar.**"
msgstr ""

#: 
msgid "CGLS 2019 Madagascar"
msgstr ""

#: 
msgid "*Credit: Contains the CGLS Land Cover 100m product courtesy of the Copernicus Global Land Service, processed by Digital Earth Africa.*"
msgstr ""

#: 
msgid "Buchhorn, M.; Smets, B.; Bertels, L.; Lesiv, M.; Tsendbazar, N.-E.; Masiliunas, D.; Linlin, L.; Herold, M.; Fritz, S. (2020). Copernicus Global Land Service: Land Cover 100m: Collection 3: epoch 2019: Globe (Version V3.0.1). Zenodo. DOI: https://10.5281/zenodo.3939049;"
msgstr ""

#: 
msgid "Marcel Buchhorn, Bruno Smets, Luc Bertels, Bert De Roo, Myroslava Lesiv, Nandin-Erdene Tsendbazar, Linlin Li, & Agnieszka Tarko. (2020). Copernicus Global Land Service: Land Cover 100m: version 3 Globe 2015-2019: Product User Manual (Dataset v3.0, doc issue 3.3). Zenodo. https://doi.org/10.5281/zenodo.3938963"
msgstr ""

#: 
msgid "Marcel Buchhorn, Luc Bertels, Bruno Smets, Bert De Roo, Myroslava Lesiv, Nandin-Erdene Tsendbazar, Dainius Masiliunas, & Linlin Li. (2020). Copernicus Global Land Service: Land Cover 100m: version 3 Globe 2015-2019: Algorithm Theoretical Basis Document (Dataset v3.0, doc issue 3.3). Zenodo. https://doi.org/10.5281/zenodo.3938968"
msgstr ""

#: 
msgid "Nandin-Erdene Tsendbazar, Agnieszka Tarko, Linlin Li, Martin Herold, Myroslava Lesiv, Steffen Fritz, & Victor Maus. (2020). Copernicus Global Land Service: Land Cover 100m: version 3 Globe 2015-2019: Validation Report (Dataset v3.0, doc issue 1.0). Zenodo. https://doi.org/10.5281/zenodo.3938974"
msgstr ""

#: 
msgid "As an official product of the global component of the Copernicus Land Service, access to this land cover dataset, CGLS_LC100m, is fully free and open to all users."
msgstr ""

#: 
msgid "The Copernicus Global Land Service Annual Dynamic Global Land Cover at 100 m spatial resolution product was generated by the Global component of the Land Service of Copernicus, the Earth Observation programme of the European Commission. The research leading to the current version of the product has received funding from various European Commission Research and Technical Development programs. The product is based on PROBA-V data provided by Belgian Science Policy Office (BELSPO) and distributed by VITO."
msgstr ""

#: 
msgid "The Copernicus Global Land Service Land Use/Land Cover at 100 m product is avaliable in AWS S3."
msgstr ""

#: 
msgid "The file paths follow the format: ``s3://deafrica-input-datasets/cgls_landcover/<year>/``."
msgstr ""

#: 
msgid "The Copernicus Global Land Service, Land Use/Land Cover at 100 m product is not yet avaliable through Digital Earth Africa’s OWS."
msgstr ""

#: 
msgid "The Copernicus Global Land Service Land Use/Land Cover at 100 m product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``cgls_landcover``"
msgstr ""

#: 
msgid "**Table 4: ODC product cgls_landcover band names**."
msgstr ""

#: 
msgid "prob"
msgstr ""

#: 
msgid "bare"
msgstr ""

#: 
msgid "builtup"
msgstr ""

#: 
msgid "crops"
msgstr ""

#: 
msgid "grass"
msgstr ""

#: 
msgid "mosslichen"
msgstr ""

#: 
msgid "permanentwater"
msgstr ""

#: 
msgid "seasonalwater"
msgstr ""

#: 
msgid "shrub"
msgstr ""

#: 
msgid "snow"
msgstr ""

#: 
msgid "tree"
msgstr ""

#: 
msgid "The 2019 global overall accuracy and the continental level overall accuracy for Africa of the discrete land cover layer of the CGLS_LC100m product at level 1 are ``80.3 %`` and ``80.0 %`` respectively. At level 2 the global overall accuracy and the continental level overall accuracy for Africa are ``75.1 %`` and ``76.5 %`` respectively. In the level 1 discrete land cover layer the closed and open forests classes are not seperated whereas at level 2 they are separated."
msgstr ""

#: 
msgid "For more information on the validation of the discrete land cover layer and fractional landcover layers of the CGLS_LC100m product, see the `Copernicus Global Land Service: Land Cover 100m: version 3 Globe 2015-2019: Validation Report <https://doi.org/10.5281/zenodo.4723975>`__."
msgstr ""

#: 
msgid "Rainfall estimates (CHIRPS)"
msgstr ""

#: 
msgid "**Date modified:** 12 January 2022"
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) provides free and open access to a copy of the Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS) monthly and daily products over Africa. The CHIRPS rainfall maps are produced and provided by the Climate Hazards Center in collaboration with the US Geological Survey, and use both rain gauge and satellite observations."
msgstr ""

#: 
msgid "The ``CHIRPS-2.0 Africa Monthly`` dataset is regularly indexed to DE Africa from the `CHIRPS monthly data <https://data.chc.ucsb.edu/products/CHIRPS-2.0/africa_monthly/tifs/>`__. The ``CHIRPS-2.0 Africa Daily`` dataset is likewise indexed from the `CHIRPS daily data <https://data.chc.ucsb.edu/products/CHIRPS-2.0/africa_daily/tifs/>`__. Both products have been converted to cloud-opitmized GeoTIFFs, and can be accessed through DE Africa's Open Data Cube. This means the full archive of CHIRPS daily and monthly rainfall can be easily used for inspection or analysis across DE Africa platforms, including the user-interactive `DE Africa Map <https://maps.digitalearth.africa/>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Rainfall_CHIRPS.ipynb>`__ which demonstrates loading and using CHIRPS datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "This page details how to access CHIRPS products through DE Africa platforms. For more information on the dataset, see the `official CHIRPS website <https://www.chc.ucsb.edu/data/chirps>`__:"
msgstr ""

#: 
msgid "*\"Estimating rainfall variations in space and time is a key aspect of drought early warning and environmental monitoring. An evolving drier-than-normal season must be placed in a historical context so that the severity of rainfall deficits can be quickly evaluated. However, estimates derived from satellite data provide areal averages that suffer from biases due to complex terrain, which often underestimate the intensity of extreme precipitation events. Conversely, precipitation grids produced from station data suffer in more rural regions where there are less rain-gauge stations. CHIRPS was created in collaboration with scientists at the USGS Earth Resources Observation and Science (EROS) Center in order to deliver complete, reliable, up-to-date data sets for a number of early warning objectives, like trend analysis and seasonal drought monitoring.\"*"
msgstr ""

#: 
msgid "Spatial and temporal coverage"
msgstr ""

#: 
msgid "DE Africa provides the monthly and daily CHIRPS datasets as two seperate products."
msgstr ""

#: 
msgid "**Table 1: Rainfall CHIRPS products' specifications**"
msgstr ""

#: 
msgid "**Specification**"
msgstr ""

#: 
msgid "Rainfall - CHIRPS daily"
msgstr ""

#: 
msgid "Rainfall - CHIRPS monthly"
msgstr ""

#: 
msgid "0.05 (~5 km)"
msgstr ""

#: 
msgid "EPSG: 4326"
msgstr ""

#: 
msgid "1 day"
msgstr ""

#: 
msgid "1 month"
msgstr ""

#: 
msgid "1981 – present"
msgstr ""

#: 
msgid "Daily"
msgstr ""

#: 
msgid "Monthly"
msgstr ""

#: 
msgid "**Table 2: Rainfall CHIRPS products' measurements**"
msgstr ""

#: 
msgid "No data value"
msgstr ""

#: 
msgid "rainfall"
msgstr ""

#: 
msgid "Monthly Atmospheric Precipitation"
msgstr ""

#: 
msgid "``mm``"
msgstr ""

#: 
msgid "``float32``"
msgstr ""

#: 
msgid "``-9999.0``"
msgstr ""

#: 
msgid "Daily Atmospheric Precipitation"
msgstr ""

#: 
msgid "Both rainfall CHIRPS products have the same geographic extent. Data is available for the region shaded in Figure 1."
msgstr ""

#: 
msgid "Specific temporal and geographic extents can be explored as an interactive map on the Digital Earth Africa Metadata Explorer:"
msgstr ""

#: 
msgid "`Rainfall CHIRPS daily <https://explorer.digitalearth.africa/products/rainfall_chirps_daily>`__"
msgstr ""

#: 
msgid "`Rainfall CHIRPs monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__"
msgstr ""

#: 
msgid "**Figure 1: CHIRPS products' geographic extent**"
msgstr ""

#: 
msgid "Rainfall CHIRPS Geographic Extent"
msgstr ""

#: 
msgid "The Climate Hazards group Infrared Precipitation with Stations (CHIRPS) algorithm was developed by the `Climate Hazards Center <https://www.chc.ucsb.edu/data/chirps>`__ and is described in `Funk, C., Peterson, P., Landsfeld, M. et al. (2015) <https://doi.org/10.1038/sdata.2015.66>`__."
msgstr ""

#: 
msgid "**Image 1: Animation of monthly Rainfall CHIRPS over Nigeria from 2020 to 2021.**"
msgstr ""

#: 
msgid "Rainfall over Nigeria"
msgstr ""

#: 
msgid "*Credit: Contains Rainfall CHIRPS Product courtesy of the Climate Hazards Center, processed by Digital Earth Africa.*"
msgstr ""

#: 
msgid "**Image 2: Mean monthly rainfall for 2020, calculated using monthly CHIRPS rainfall.**"
msgstr ""

#: 
msgid "Mean monthly rainfall per country"
msgstr ""

#: 
msgid "Funk, C., Peterson, P., Landsfeld, M. et al. (2015). The climate hazards infrared precipitation with stations—a new environmental record for monitoring extremes. Sci Data 2, 150066. https://doi.org/10.1038/sdata.2015.66"
msgstr ""

#: 
msgid "`CHIRPS website <https://www.chc.ucsb.edu/data/chirps>`__"
msgstr ""

#: 
msgid "CHIRPS data is in the public domain as registered with Creative Commons. From the CHIRPS website:"
msgstr ""

#: 
msgid "To the extent possible under the law, Pete Peterson has waived all copyright and related or neighboring rights to Climate Hazards Group Infrared Precipitation with Stations (CHIRPS)."
msgstr ""

#: 
msgid "The CHIRPS monthly and daily products are provided by the Climate Hazards Center (CHC), UC Santa Barbara."
msgstr ""

#: 
msgid "Amazon Web Service S3"
msgstr ""

#: 
msgid "The Digital Earth Africa CHIRPS products are available in AWS S3."
msgstr ""

#: 
msgid "**Table 3: AWS data access details**"
msgstr ""

#: 
msgid "Bucket ARN"
msgstr ""

#: 
msgid "``rainfall_chirps_monthly``, ``rainfall_chirps_daily``"
msgstr ""

#: 
msgid "The following file path conventions apply to the ``rainfall_chirps_monthly`` and ``rainfall_chirps_daily`` products respectively:"
msgstr ""

#: 
msgid "``s3://deafrica-input-datasets/rainfall_chirps_monthly/``"
msgstr ""

#: 
msgid "``s3://deafrica-input-datasets/rainfall_chirps_daily/<year>/<month>/``"
msgstr ""

#: 
msgid "The CHIRPS product ``rainfall_chirps_monthly`` is available through Digital Earth Africa's OWS."
msgstr ""

#: 
msgid "**Table 4: OWS data access details**"
msgstr ""

#: 
msgid "``rainfall_chirps_monthly``"
msgstr ""

#: 
msgid "CHIRPS products can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product names:** ``rainfall_chirps_monthly``, ``rainfall_chirps_daily``"
msgstr ""

#: 
msgid "The ``rainfall_chirps_monthly`` and ``rainfall_chirps_daily`` products have only one band of data, ``rainfall``, which can be called by using the band name as listed in the table below. ODC ``Datacube.load`` commands without specified measurements will also load the ``rainfall`` band."
msgstr ""

#: 
msgid "**Table 5: Rainfall - CHIRPS ODC products and band names**"
msgstr ""

#: 
msgid "--"
msgstr ""

#: 
msgid "``rainfall_chirps_daily``"
msgstr ""

#: 
msgid "Product names and band names are case-sensitive."
msgstr ""

#: 
msgid "Instructions on how to access and use CHIRPS products from the DE Africa Open Data Cube are provided in the `Rainfall CHIRPS dataset example notebook <.notebooks/Datasets/Rainfall_CHIRPS.html>`__."
msgstr ""

#: 
msgid "Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS) is a 35+ year quasi-global rainfall data set, spanning 50°S-50°N (and all longitudes) and ranging from 1981 to near-present. CHIRPS incorporates the Climate Hazards group Precipitation climatology (CHPclim) that incorporates satellite information to represent sparsely gauged locations, 0.05° resolution satellite-only CCD-based Climate Hazards group Infrared Precipitation (CHIRP) estimates, and in-situ station data to create gridded rainfall time series for trend analysis and seasonal drought monitoring."
msgstr ""

#: 
msgid "For more information on the algorithm used to generate the CHIRPS datasets visit the `CHIRPS pulication <https://doi.org/10.1038/sdata.2015.66>`__."
msgstr ""

#: 
msgid "Copernicus DEM (COP-DEM)"
msgstr ""

#: 
msgid "The Copernicus DEM is a Digital Surface Model (DSM) that represents the Earth's surface. The Copernicus DEM is provided by the European Space Agency (ESA) in 3 different instances:"
msgstr ""

#: 
msgid "COP-DEM-EEA-10 : provides coverage of the European Economic Area (EEA) member states and the 6 cooperating countries at 0.3 arc seconds (~10m) spatial resolution"
msgstr ""

#: 
msgid "COP-DEM-GLO-30 : provides global coverage at 1.0 arc seconds (~30m) spatial resolution"
msgstr ""

#: 
msgid "COP-DEM-GLO-90 : provides global coverage at 3.0 arc second (~90m) spatial resolution"
msgstr ""

#: 
msgid "There are two instances of the COP-DEM-GLO-30 Copernicus DEM: COP-DEM-GLO-30-R and COP-DEM-GLO-30 Public. COP-DEM-GLO-30 Public provides limited worldwide coverage at 1.0 arc seconds (~30m) spatial resolution because a small subset of tiles covering specific countries are not yet released to the public by the Copernicus Programme. The list of countries presenting constraints in terms of access rights is available `here <https://spacedata.copernicus.eu/documents/20126/0/Non-released-tiles_GLO-30_PUBLIC_Dec.xlsx/bcdd6cef-6379-4890-de8f-788daf41dce8?t=1608549440765>`__. COP-DEM-GLO-30-R provides complete global coverage, but is only accessible to users belonging to the authorised users categories as defined in the `applicable license <https://spacedata.copernicus.eu/documents/20126/0/CSCDA_ESA_Mission-specific+Annex.pdf/5308d1e7-17de-b55b-2be8-8a3a286aa88b?t=1581077110498>`__."
msgstr ""

#: 
msgid "Digital Earth Africa provides free and open access to a copy of the COP-DEM-GLO-30 Public and COP-DEM-GLO-90 products over Africa. For more information on these products see the `Copernicus DEM website <https://spacedata.copernicus.eu/web/cscda/dataset-details?articleId=394198>`__ and `Copernicus DEM Product Handbook <https://spacedata.copernicus.eu/documents/20126/0/GEO1988-CopernicusDEM-SPE-002_ProductHandbook_I3.0+%281%29.pdf/68854203-e022-1446-b216-41becd2399b5?t=1618937501277>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Digital_Elevation_Models.ipynb>`__ which demonstrates loading and using DEM datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "Relevant metadata for the COP-DEM-GLO-30 Public and COP-DEM-GLO-90 products can be viewed on the DE Africa Metadata Explorer `here <https://explorer.digitalearth.africa/products/dem_cop_30>`__ and `here <https://explorer.digitalearth.africa/products/dem_cop_90>`__."
msgstr ""

#: 
msgid "**Table 1: COP-DEM-GLO-30 Public and COP-DEM-GLO-90 product specifications**"
msgstr ""

#: 
msgid "``dem_cop_30``"
msgstr ""

#: 
msgid "``dem_cop_90``"
msgstr ""

#: 
msgid "Cell size - X (arc seconds)"
msgstr ""

#: 
msgid "1.0 (~30 m)"
msgstr ""

#: 
msgid "3.0 (~90 m)"
msgstr ""

#: 
msgid "Cell size - Y (arc seconds)"
msgstr ""

#: 
msgid "None, except if the public tile list changes."
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:83
msgid "None"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the products can be explored as an interactive map on the Metadata Explorer `here <https://explorer.digitalearth.africa/products/dem_cop_30>`__ and `here <https://explorer.digitalearth.africa/products/dem_cop_90>`__. Data is available for the regions shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: COP-DEM-GLO-30 Public geographic extent**"
msgstr ""

#: 
msgid "COP-DEM-GLO-30 Public Geographic Extent"
msgstr ""

#: 
msgid "**Figure 2: COP-DEM-GLO-90 geographic extent**"
msgstr ""

#: 
msgid "COP-DEM-GLO-90 Geographic Extent"
msgstr ""

#: 
msgid "**Table 2: COP-DEM-GLO-30 Public and COP-DEM-GLO-90 product measurements**"
msgstr ""

#: 
msgid "elevation"
msgstr ""

#: 
msgid "Elevation data"
msgstr ""

#: 
msgid "``1``"
msgstr ""

#: 
msgid "``NaN``"
msgstr ""

#: 
msgid "The Copernicus DEM is derived from an edited DSM named WorldDEM which was based on the radar satellite data acquired during the TanDEM-X Mission. For the edited WorldDEM, the flattening of water bodies and consistent flow of rivers has been included, and editing of shore- and coastlines, special features such as airports and implausible terrain structures has also been applied. The edited WorldDEM was also infilled on a local basis with the following DEMs: ASTER, SRTM90, SRTM30, SRTM30plus, GMTED2010, TerraSAR-X Radargrammetric DEM, ALOS World 3D-30m. The Copernicus DEM product generation and editing process is described in the `Product Handbook <https://spacedata.copernicus.eu/documents/20126/0/GEO1988-CopernicusDEM-SPE-002_ProductHandbook_I3.0+%281%29.pdf/68854203-e022-1446-b216-41becd2399b5?t=1618937501277>`__."
msgstr ""

#: 
msgid "**Figure 3: COP-DEM-GLO-30 Public elevation data for Mt. Kilimanjaro**"
msgstr ""

#: 
msgid "COP-DEM-GLO-30 Public Mt. Kilimanjaro"
msgstr ""

#: 
msgid "**Figure 4: COP-DEM-GLO-90 elevation data for Mt. Kenya**"
msgstr ""

#: 
msgid "COP-DEM-GLO-90 Mt. Kenya"
msgstr ""

#: 
msgid "The `Copernicus DEM website <https://spacedata.copernicus.eu/web/cscda/dataset-details?articleId=394198>`__"
msgstr ""

#: 
msgid "The `Copernicus DEM Product Handbook <https://spacedata.copernicus.eu/documents/20126/0/GEO1988-CopernicusDEM-SPE-002_ProductHandbook_I3.0+%281%29.pdf/68854203-e022-1446-b216-41becd2399b5?t=1618937501277>`__"
msgstr ""

#: 
msgid "License and Acknowledgements"
msgstr ""

#: 
msgid "The GLO-90 dataset is available worldwide with a free license. The GLO-30 dataset is available worldwide with a free license with the exception of two countries, reported in a `dedicated list <https://spacedata.copernicus.eu/documents/20126/0/COP-DEM_delivery_sheet_v0.9.xlsx/9812e3a5-300d-a0ef-1c52-4d55391eaed8?t=1630080852713>`__ and available within the dataset COP-DEM_GLO-30-R. Full licences are available `here <https://spacedata.copernicus.eu/documents/20126/0/CSCDA_ESA_Mission-specific+Annex+%281%29.pdf/83b44c0a-244a-7ba3-b00c-b578a34e88a7?t=1604070311399>`__."
msgstr ""

#: 
msgid "Amazon web services S3"
msgstr ""

#: 
msgid "The GLO-30 Public and GLO-90 instances of the Copernicus DEM are available in AWS S3 sponsored by the `Public Dataset Program <https://registry.opendata.aws/copernicus-dem/>`__."
msgstr ""

#: 
msgid "**Table 3: Copernicus DEM GLO-30 Public and GLO-90 AWS data access details**"
msgstr ""

#: 
msgid "Product"
msgstr ""

#: 
msgid "GLO-30 Public"
msgstr ""

#: 
msgid "GLO-90"
msgstr ""

#: 
msgid "``arn:aws:s3:::copernicus-dem-30m``"
msgstr ""

#: 
msgid "``arn:aws:s3:::copernicus-dem-90m``"
msgstr ""

#: 
msgid "``eu-central-1``"
msgstr ""

#: 
msgid "The file paths follow the basic data formart: ``Copernicus_DSM_COG_[resolution]_[northing]_[easting]_DEM/`` e.g. ``s3://copernicus-dem-90m/Copernicus_DSM_COG_30_S90_00_W178_00_DEM/``"
msgstr ""

#: 
msgid "**Table 4: AWS file path convention**"
msgstr ""

#: 
msgid "``resolution``"
msgstr ""

#: 
msgid "Resolution in arc seconds."
msgstr ""

#: 
msgid "``10`` for GLO-30, and ``30`` for GLO-90"
msgstr ""

#: 
msgid "``northing``"
msgstr ""

#: 
msgid "This is the northing of the center of the bottom-most pixels in the original files."
msgstr ""

#: 
msgid "``S50_00``"
msgstr ""

#: 
msgid "``easting``"
msgstr ""

#: 
msgid "This is the easting of the center of the left-most pixels."
msgstr ""

#: 
msgid "``w125_00``"
msgstr ""

#: 
msgid "This GLO-30 Public and GLO-90 instances of the Copernicus DEM are available through DE Africa's OWS."
msgstr ""

#: 
msgid "**Table 5: OWS data access details.**"
msgstr ""

#: 
msgid "Layer names"
msgstr ""

#: 
msgid "``dem_cop_30``, ``dem_cop_90``"
msgstr ""

#: 
msgid "The GLO-30 Public and GLO-90 instances of the Copernicus DEM can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product names:** ``dem_cop_30``, ``dem_cop_90``"
msgstr ""

#: 
msgid "**Table 6: ODC products dem_cop_30 and dem_cop_90 band names**"
msgstr ""

#: 
msgid "NaN"
msgstr ""

#: 
msgid "The Copernicus DEM was validated using the Geoscience Laser Altimeter System (GLAS) of NASA’s Ice, Cloud and land Elevation Satellite (ICESat). The Global *RMSE* is 1.68 metres. The accuracy assessment is split into two parts, since the ice-covered regions have to be treated differently from the non-ice-covered regions, which are described in the `Validation Report <https://spacedata.copernicus.eu/documents/20126/0/GEO1988-CopernicusDEM-RP-001_ValidationReport_I3.0.pdf/996b90c4-49b1-0883-5553-4e29a29c4bd5?t=1609340156005>`__."
msgstr ""

#: 
msgid "DE Africa Coastlines: A Coastline Monitoring Service"
msgstr ""

#: 
msgid "**Date modified:** 15 July 2024"
msgstr ""

#: 
msgid "Service Overview"
msgstr ""

#: 
msgid "The Digital Earth Africa Coastlines is a continental dataset that includes annual shorelines and rates of coastal change along the entire African coastline. This is a provisional service that has been generated for 2000 to 2022 and we would like to improve and operationalize with users."
msgstr ""

#: 
msgid "The product combines satellite data from the Digital Earth Africa program with tidal modelling to map the typical location of the coastline at mean sea level each year. The product enables trends of coastal erosion and growth to be examined annually at both a local and continental scale, and for patterns of coastal change to be mapped historically and updated regularly as data continues to be acquired. This allows current rates of coastal change to be compared with that observed in previous years or decades."
msgstr ""

#: 
msgid "The ability to map shoreline positions for each year provides valuable insights into whether changes to the coastline are the result of particular events or actions, or a process of more gradual change over time. This information can enable scientists, managers, and policy makers to assess impact from the range of drivers impacting the coastlines and potentially assist planning and forecasting for future scenarios."
msgstr ""

#: 
msgid "There are several datasets that are available as part of the Coastlines suite."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/Coastlines.html>`__ which demonstrates loading and using Coastlines products in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: Coastlines product datasets**"
msgstr ""

#: 
msgid "Product type"
msgstr ""

#: 
msgid "Annual coastlines"
msgstr ""

#: 
msgid "``coastlines_v0.4.1_shorelines_annual``"
msgstr ""

#: 
msgid "Vector - line"
msgstr ""

#: 
msgid "Rate of change statistics"
msgstr ""

#: 
msgid "``coastlines_v0.4.1_rates_of_change``"
msgstr ""

#: 
msgid "Vector - point"
msgstr ""

#: 
msgid "Coastal change hotspots zoom 1 (15 km)"
msgstr ""

#: 
msgid "``coastlines_v0.4.1_hotspots_zoom_1``"
msgstr ""

#: 
msgid "Coastal change hotspots zoom 2 (5 km)"
msgstr ""

#: 
msgid "``coastlines_v0.4.1_hotspots_zoom_2``"
msgstr ""

#: 
msgid "Coastal change hotspots zoom 3 (1 km)"
msgstr ""

#: 
msgid "``coastlines_v0.4.1_hotspots_zoom_3``"
msgstr ""

#: 
msgid "**Table 2: Digital Earth Africa Coastlines extent**"
msgstr ""

#: 
msgid "DE Africa Coastlines"
msgstr ""

#: 
msgid "Cell size - X (metres)"
msgstr ""

#: 
msgid "30"
msgstr ""

#: 
msgid "Cell size - Y (metres)"
msgstr ""

#: 
msgid "ESPG:6933"
msgstr ""

#: 
msgid "Annually"
msgstr ""

#: 
msgid "2000 - 2022"
msgstr ""

#: 
msgid "Parent dataset"
msgstr ""

#: 
msgid "Landsat Collection 2 Surface Reflectance"
msgstr ""

#: 
msgid "TBD"
msgstr ""

#: 
msgid "**Figure 1: DE Africa Coastlines suite geographic extent**"
msgstr ""

#: 
msgid "Coastlines data extent."
msgstr ""

#: 
msgid "Digital Earth Africa Coastlines is a continental dataset that includes the rate of coastal change hotspots, with red hotspots representing coastal retreat and blue hotspots representing coastal growth."
msgstr ""

#: 
msgid "Annual Coastlines Shorelines"
msgstr ""

#: 
msgid "Annual shoreline vectors from 2000 that represent the median or 'most representative' position of the shoreline at approximately mean sea level tide (0 m Above Mean Sea Level) for each year."
msgstr ""

#: 
msgid "Light-coloured lines (e.g. yellow) in the plot represent recent shorelines (e.g. 2020), while dark-coloured lines represent older shorelines (e.g. 2000)."
msgstr ""

#: 
msgid "Dashed shorelines have low certainty due to either few non-cloudy satellite observations, or unstable data caused by poor tidal modelling performance or high coastal variability., or aerosol issues."
msgstr ""

#: 
msgid "**Figure 2: Annual coastlines from DE Africa Coastlines visualised on the** `interactive DE Africa web map <https://maps.digitalearth.africa/#share=s-6nceOTGVGJCRs1azNjgslFqFgRV>`__"
msgstr ""

#: 
msgid "Annual shoreline vector layer."
msgstr ""

#: 
msgid "Certainty Attribute"
msgstr ""

#: 
msgid "**Unstable data:** The quality of this shoreline is affected by unstable data (high MNDWI standard deviation). This may be caused by errors in the tidal model used to reduce the influence of tide, the presence of gently sloping intertidal mudflats or sandbars can lead to inaccurate shoreline mapping, or noisy satellite imagery caused by high levels of cloud."
msgstr ""

#: 
msgid "**Insufficient data:** The quality of shorelines may be affected by limited good quality satellite observations (less than five clear observations after gapfilling). This can lead to noisier and less reliable shorelines."
msgstr ""

#: 
msgid "Rate of Change Statistics"
msgstr ""

#: 
msgid "A point dataset providing robust rates of coastal change (in metres per year) for every 30 m along Africa's non-rocky (e.g. sandy and muddy) coastlines. These rates are calculated by linearly regressing annual shoreline positions against time, using the most recent shoreline as a baseline."
msgstr ""

#: 
msgid "Negative values (red points) indicate retreat (e.g. erosion), and positive values indicate growth (e.g. progradation) over time. By default, rates of change are shown for points with a statistically significant trend over time only."
msgstr ""

#: 
msgid "**Table 3: Rate of change statistics attribute descriptions**"
msgstr ""

#: 
msgid "Attribute"
msgstr ""

#: 
msgid "*rate_time*"
msgstr ""

#: 
msgid "Annual rates of change (in metres per year) calculated by linearly regressing annual shoreline distances against time (excluding outliers). Negative values indicate retreat and positive values indicate growth."
msgstr ""

#: 
msgid "*sig_time*"
msgstr ""

#: 
msgid "Significance (p-value) of the linear relationship between annual shoreline distances and time. Small values (e.g. p-value < 0.01) may indicate a coastline is undergoing consistent coastal change through time."
msgstr ""

#: 
msgid "*se_time*"
msgstr ""

#: 
msgid "Standard error (in metres) of the linear relationship between annual shoreline distances and time. This can be used to generate confidence intervals around the rate of change given by rate_time (e.g. 95% confidence interval = se_time \\* 1.96)."
msgstr ""

#: 
msgid "*outl_time*"
msgstr ""

#: 
msgid "Individual annual shoreline are noisy estimators of coastline position that can be influenced by environmental conditions (e.g. clouds, breaking waves, sea spray) or modelling issues (e.g. poor tidal modelling results or limited clear satellite observations). To obtain reliable rates of change, outlier shorelines are excluded using a robust Median Absolute Deviation outlier detection algorithm, and recorded in this column."
msgstr ""

#: 
msgid "*sce*"
msgstr ""

#: 
msgid "Shoreline Change Envelope (SCE). A measure of the maximum change or variability across all annual shorelines, calculated by computing the maximum distance between any two annual shoreline (excluding outliers). This statistic excludes sub-annual shoreline variability."
msgstr ""

#: 
msgid "*nsm*"
msgstr ""

#: 
msgid "Net Shoreline Movement (NSM). The distance between the oldest (2000) and most recent annual shoreline (excluding outliers). Negative values indicate the coastline retreated between the oldest and most recent shoreline; positive values indicate growth. This statistic does not reflect sub-annual shoreline variability, so will underestimate the full extent of variability at any given location."
msgstr ""

#: 
msgid "*max_year, min_year*"
msgstr ""

#: 
msgid "The year that annual shorelines were at their maximum (i.e. located furthest towards the ocean) and their minimum (i.e. located furthest inland) respectively (excluding outliers). This statistic excludes sub-annual shoreline variability."
msgstr ""

#: 
msgid "**Figure 3: Rate of change statistics from DE Africa Coastlines visualised on the** `interactive DE Africa web map <https://maps.digitalearth.africa/#share=s-6nceOTGVGJCRs1azNjgslFqFgRV>`__"
msgstr ""

#: 
msgid "Rate of change statistics vector layer."
msgstr ""

#: 
msgid "**Offshore islands:** Points located in offshore island nations where Coastlines data is affected by high levels of noise, potentially related to aerosol issues in the input Landsat Collection 2 ARD data."
msgstr ""

#: 
msgid "**Likely rocky coastline:** Rates of change can be unreliable in areas with steep rocky/bedrock shorelines due to terrain shadow."
msgstr ""

#: 
msgid "**Extreme value (> 200 m):** Extreme rate of change value (> 200 m per year change) are more likely to reflect modelling issues than real-world coastal change."
msgstr ""

#: 
msgid "**High angular variability:** Annual shorelines at this location do not fall on an approximate line, making rates of change invalid."
msgstr ""

#: 
msgid "**Insufficient observations:** Less than 15 valid annual shorelines at this location, which make the resulting rates of change more likely to be inaccurate."
msgstr ""

#: 
msgid "Coastal Change Hotspots"
msgstr ""

#: 
msgid "A summary layer producing moving window hotspots of coastal change at three differing scales including 15 km, 5 km, and 1 km. This is useful for visualising regional or continental-scale patterns of coastal change."
msgstr ""

#: 
msgid "**Figure 4: Coastal change hotspots from DE Africa Coastlines visualised on the** `interactive DE Africa web map <https://maps.digitalearth.africa/#share=s-6nceOTGVGJCRs1azNjgslFqFgRV>`__"
msgstr ""

#: 
msgid "Coastal change hotspot layer."
msgstr ""

#: 
msgid "**Insufficient points:** Insufficient rates of change at this location to produce reliable hotspots."
msgstr ""

#: 
msgid "The Coastlines product is generated by applying the method described in `Bishop-Taylor et al. (2021) <https://doi.org/10.1016/j.rse.2021.112734>`__ to Landsat Collection 2 Surface Reflectance data."
msgstr ""

#: 
msgid "The scripts used to produce the Coastlines are available from `the deafrica-coastlines github repository <https://github.com/digitalearthafrica/deafrica-coastlines>`__."
msgstr ""

#: 
msgid "`Landsat Collection 2 Surface Reflectance <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html>`__"
msgstr ""

#: 
msgid "Bishop-Taylor, R., Nanson, R., Sagar, S., Lymburner, L. (2021). Mapping Australia's dynamic coastline at mean sea level using three decades of Landsat imagery. Remote Sensing of Environment, 267, 112734. Available: https://doi.org/10.1016/j.rse.2021.112734"
msgstr ""

#: 
msgid "Bishop-Taylor, R., Sagar, S., Lymburner, L., Alam, I., Sixsmith, J. (2019). Sub-pixel waterline extraction: characterising accuracy and sensitivity to indices and spectra. Remote Sensing, 11 (24):2984. Available: https://doi.org/10.3390/rs11242984"
msgstr ""

#: 
msgid "CC BY Attribution 4.0 International License"
msgstr ""

#: 
msgid "Acknowledgments"
msgstr ""

#: 
msgid "The Coastlines algorithms incorporated in this product are the work of Robbi-Bishop Taylor, Rachel Nanson, Stephen Sagar, and Leo Lymburner, Geoscience Australia. Digital Earth Africa acknowledges the work done by the Centre de Suivi Ecologique (CSE), Dakar, in assessing the accuracy of the service with the participation of West African WACA stakeholders. Acknowledgements also go to the Regional Center for Mapping Resources for Development (RCMRD) for stakeholder engagement and feedback. Digital Earth Africa thanks the Digital Earth Africa Product Development task team for the co-design, the co-development and early feedback on the Service."
msgstr ""

#: 
msgid "The Digital Earth Africa Coastlines data can be accessed from the associated S3 bucket."
msgstr ""

#: 
msgid "**Table 4: AWS data access details**"
msgstr ""

#: 
msgid "``arn:aws:s3:::deafrica-services``"
msgstr ""

#: 
msgid "Product names"
msgstr ""

#: 
msgid "``coastlines``"
msgstr ""

#: 
msgid "Latest version of the Coastlines product can be downloaded from the links below:"
msgstr ""

#: 
msgid "`DE Africa Coastlines as a Geopackage <https://deafrica-services.s3.af-south-1.amazonaws.com/coastlines/v0.4.0/deafricacoastlines_v0.4.0.gpkg>`__"
msgstr ""

#: 
msgid "`DE Africa Coastlines as a Shapefile <https://deafrica-services.s3.af-south-1.amazonaws.com/coastlines/v0.4.0/deafricacoastlines_v0.4.0.shp.zip>`__"
msgstr ""

#: 
msgid "**Table 5: OWS data access details**"
msgstr ""

#: 
msgid "``https://geoserver.digitalearth.africa/geoserver/wms``"
msgstr ""

#: 
msgid "Web Feature Services (WFS) URL"
msgstr ""

#: 
msgid "``https://geoserver.digitalearth.africa/geoserver/wfs``"
msgstr ""

#: 
msgid "``coastlines_v0.4.1``, ``coastlines_v0.4.1_shorelines_annual``, ``coastlines_v0.4.1_rates_of_change``, ``coastlines_v0.4.1_hotspots_zoom_1``, ``coastlines_v0.4.1_hotspots_zoom_2``, ``coastlines_v0.4.1_hotspots_zoom_3``"
msgstr ""

#: 
msgid "The Coastlines product can be loaded and analysed in the DE Africa Sandbox following the `example Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/coastlines-notebook/Datasets/Coastlines.ipynb>`__."
msgstr ""

#: 
msgid "For further information regarding the use of DE Africa Coastlines product, `visit the Digital Earth Africa Help Desk <https://helpdesk.digitalearthafrica.org/portal/en/kb/search/coastlines>`__."
msgstr ""

#: 
msgid "Shoreline delineation"
msgstr ""

#: 
msgid "Shorelines are mapped using Landsat satellite observations. For each observation, the modified normalised difference water index (MNDWI) is calculated from the green and shortwave infrared (SWIR) bands to identify water. The formula is"
msgstr ""

#: 
msgid "\\text{MNDWI} = \\frac{\\text{Green-SWIR}}{\\text{Green+SWIR}}\n"
"\n"
""
msgstr ""

#: 
msgid "When interpreting this index, values greater than 0 indicate water."
msgstr ""

#: 
msgid "Accuracy and limitations"
msgstr ""

#: 
msgid "Accuracy assessment"
msgstr ""

#: 
msgid "The Centre de Suivi Ecologique, Dakar, has conducted a study to test the performance of the DE Africa Coastlines in collaboration with the member states of the WACA/ORLOA network (Investment Project for the Resilience of West African Coastal Zones / Regional Observatory of the West African Coast) Mauritania, Senegal, Gambia, Guinea Bissau, Republic of Guinea, Sierra Leone, Liberia, Cote d'Ivoire, Ghana, Togo, Benin, and Sao Tome and Principe. In each country, test sites have been selected depending on the size of the portion of the coast, the availability of reference data and metadata associated with each type of data. With imagery for each country having a consistant accuracy of 5 m."
msgstr ""

#: 
msgid "**Table 6: DE Africa Coastlines performance test locations and associated metadata**"
msgstr ""

#: 
msgid "Country"
msgstr ""

#: 
msgid "Image type"
msgstr ""

#: 
msgid "Source"
msgstr ""

#: 
msgid "Acquisition date"
msgstr ""

#: 
msgid "Resolution (m)"
msgstr ""

#: 
msgid "Spectral bands"
msgstr ""

#: 
msgid "Mauritania"
msgstr ""

#: 
msgid "WorldView constellation"
msgstr ""

#: 
msgid "Google Earth - Maxar"
msgstr ""

#: 
msgid "2 April 2021"
msgstr ""

#: 
msgid "<1"
msgstr ""

#: 
msgid "3 bands RGB"
msgstr ""

#: 
msgid "Senegal"
msgstr ""

#: 
msgid "WorldView Legion"
msgstr ""

#: 
msgid "Maxar Technologies"
msgstr ""

#: 
msgid "8 June 2021"
msgstr ""

#: 
msgid "0.5"
msgstr ""

#: 
msgid "4 bands RGBN"
msgstr ""

#: 
msgid "Gambia"
msgstr ""

#: 
msgid "Earth Google - Maxar"
msgstr ""

#: 
msgid "9 January 2021"
msgstr ""

#: 
msgid "Guinea Bissau"
msgstr ""

#: 
msgid "12 December 2018"
msgstr ""

#: 
msgid "Guinea"
msgstr ""

#: 
msgid "April 2017"
msgstr ""

#: 
msgid "1 <1"
msgstr ""

#: 
msgid "Liberia"
msgstr ""

#: 
msgid "31 October 2021"
msgstr ""

#: 
msgid "Sierra Leone"
msgstr ""

#: 
msgid "18 February 2018"
msgstr ""

#: 
msgid "Ivory Coast"
msgstr ""

#: 
msgid "12 January 2021"
msgstr ""

#: 
msgid "Ghana"
msgstr ""

#: 
msgid "31 October 2018"
msgstr ""

#: 
msgid "Togo"
msgstr ""

#: 
msgid "17 October 2019"
msgstr ""

#: 
msgid "Benin"
msgstr ""

#: 
msgid "31 July 2019"
msgstr ""

#: 
msgid "WorldView-1 Pan"
msgstr ""

#: 
msgid "1 June 2010"
msgstr ""

#: 
msgid "Sao Tome and Principe"
msgstr ""

#: 
msgid "Pleiades"
msgstr ""

#: 
msgid "CNES Airbus"
msgstr ""

#: 
msgid "21 October 2019"
msgstr ""

#: 
msgid "*RGB = Red, Green, Blue; BRGN =Red, Green, Blue, Near Infrared*"
msgstr ""

#: 
msgid "Accuracy indicators like root mean square error (RMSE), mean absolute error (MAE) and coefficient of determination (R^2) are used to test the performance of the DE Africa tool in extracting coastlines with good precision along transects."
msgstr ""

#: 
msgid "\\text{RMSE} = \\sqrt{\\Sigma_{i=1}^{n}{\\frac{\\big({\\hat{y}_i - y_i})^2}{n}}}\n"
"\n"
""
msgstr ""

#: 
msgid "R^2 = 1 - \\frac{(\\Sigma_{i=1}^{n}({y_i - \\hat{y}_i})^2)}{(\\Sigma_{i=1}^{n}({y_{(i -)} \\overline{y}})^2)}\n"
"\n"
""
msgstr ""

#: 
msgid "\\text{MAE} = \\frac{1}{n}\\Sigma_{(i=1)}^{n}|\\hat{y}_i - y_i|\n"
"\n"
""
msgstr ""

#: 
msgid "**Figure 5: Transect points along shoreline diagram**"
msgstr ""

#: 
msgid "Transect points along shoreline diagram"
msgstr ""

#: 
msgid "Following the evaluation of the precision of the DE Africa Coastlines tool, the monitoring of the dynamics of the coastline was carried out on the site of Saly Portudal (Senegal), `as a case study <https://www.digitalearthafrica.org/media-center/blog/monitoring-coastal-erosion-saly-portudal-resort-mbour-senegal>`__. The average RMSE obtained is around 7.27m. The results obtained are way below a pixel in size. In this study prove the reliability and relevance of the combined use of the DE Africa Coastlines tool with Landsat images for monitoring coastal erosion."
msgstr ""

#: 
msgid "**Table 7: DE Africa Coastlines performance test accuracy indicator results**"
msgstr ""

#: 
msgid "Min"
msgstr ""

#: 
msgid "Max"
msgstr ""

#: 
msgid "MAE"
msgstr ""

#: 
msgid "RMSE"
msgstr ""

#: 
msgid "RMSE (%)"
msgstr ""

#: 
msgid "RMSE (Px)"
msgstr ""

#: 
msgid "Precision"
msgstr ""

#: 
msgid "0.00"
msgstr ""

#: 
msgid "31.29"
msgstr ""

#: 
msgid "7.17"
msgstr ""

#: 
msgid "8.79"
msgstr ""

#: 
msgid "29.30"
msgstr ""

#: 
msgid "2/5"
msgstr ""

#: 
msgid "Good"
msgstr ""

#: 
msgid "0.36"
msgstr ""

#: 
msgid "10.17"
msgstr ""

#: 
msgid "4.51"
msgstr ""

#: 
msgid "5.42"
msgstr ""

#: 
msgid "18.07"
msgstr ""

#: 
msgid "1/5"
msgstr ""

#: 
msgid "Very good"
msgstr ""

#: 
msgid "22.32"
msgstr ""

#: 
msgid "5.26"
msgstr ""

#: 
msgid "7.77"
msgstr ""

#: 
msgid "25.90"
msgstr ""

#: 
msgid "0.37"
msgstr ""

#: 
msgid "16.00"
msgstr ""

#: 
msgid "6.41"
msgstr ""

#: 
msgid "7.80"
msgstr ""

#: 
msgid "26.00"
msgstr ""

#: 
msgid "0.25"
msgstr ""

#: 
msgid "24.81"
msgstr ""

#: 
msgid "8.14"
msgstr ""

#: 
msgid "9.75"
msgstr ""

#: 
msgid "32.50"
msgstr ""

#: 
msgid "0.12"
msgstr ""

#: 
msgid "17.15"
msgstr ""

#: 
msgid "8.21"
msgstr ""

#: 
msgid "9.31"
msgstr ""

#: 
msgid "31.03"
msgstr ""

#: 
msgid "0.02"
msgstr ""

#: 
msgid "21.43"
msgstr ""

#: 
msgid "6.21"
msgstr ""

#: 
msgid "7.87"
msgstr ""

#: 
msgid "26.23"
msgstr ""

#: 
msgid "0.15"
msgstr ""

#: 
msgid "12.50"
msgstr ""

#: 
msgid "4.34"
msgstr ""

#: 
msgid "5.48"
msgstr ""

#: 
msgid "18.27"
msgstr ""

#: 
msgid "2.43"
msgstr ""

#: 
msgid "17.44"
msgstr ""

#: 
msgid "10.33"
msgstr ""

#: 
msgid "10.91"
msgstr ""

#: 
msgid "36.37"
msgstr ""

#: 
msgid "0.01"
msgstr ""

#: 
msgid "16.30"
msgstr ""

#: 
msgid "2.95"
msgstr ""

#: 
msgid "4.39"
msgstr ""

#: 
msgid "14.63"
msgstr ""

#: 
msgid "14.85"
msgstr ""

#: 
msgid "4.83"
msgstr ""

#: 
msgid "5.61"
msgstr ""

#: 
msgid "18.70"
msgstr ""

#: 
msgid "12.19"
msgstr ""

#: 
msgid "2.64"
msgstr ""

#: 
msgid "4.12"
msgstr ""

#: 
msgid "13.73"
msgstr ""

#: 
msgid "Average"
msgstr ""

#: 
msgid "0.31"
msgstr ""

#: 
msgid "18.04"
msgstr ""

#: 
msgid "5.92"
msgstr ""

#: 
msgid "7.27"
msgstr ""

#: 
msgid "24.23"
msgstr ""

#: 
msgid "**Table 8: Precision indicator values**"
msgstr ""

#: 
msgid "< 1/5 Px"
msgstr ""

#: 
msgid "1/5 Px - 2/5 Px"
msgstr ""

#: 
msgid "2/5 Px - 3/5 Px"
msgstr ""

#: 
msgid "Moderate"
msgstr ""

#: 
msgid "3/5 Px - 4/5 Px"
msgstr ""

#: 
msgid "Low"
msgstr ""

#: 
msgid "> 4/5 Px"
msgstr ""

#: 
msgid "Very low"
msgstr ""

#: 
msgid "Caveats and Limitations"
msgstr ""

#: 
msgid "**Annual shorelines** summarise the median (i.e. \"dominant\") position of the shoreline throughout the entire year, corrected to a consistent tide height (0 m AMSL). Annual shorelines will therefore not reflect shorter-term coastal variability, for example changes in shoreline position between low and high tide, seasonal effects, or short-lived influences of individual storms. This means that these annual shorelines will show lower variability than the true range of coastal variability observed along the African coastline."
msgstr ""

#: 
msgid "**Rates of change** do not assign a reason for change, and do not necessarily represent processes of coastal erosion or sea level rise. In locations undergoing rapid coastal development, the construction of new inlets or marinas may be represented as hotspots of coastline retreat, while the construction of ports or piers may be represented as hotspots of coastline growth. Rates of change points should therefore be evaluated with reference to the underlying annual coastlines and external data sources or imagery."
msgstr ""

#: 
msgid "**Rates of change statistics** may be inaccurate or invalid within complex mouthbars, or other coastal environments undergoing rapid non-linear change through time. In these regions, it is advisable to visually assess the underlying annual coastline data when interpreting rates of change to ensure these values are fit-for-purpose."
msgstr ""

#: 
msgid "Data quality issues"
msgstr ""

#: 
msgid "**Annual shorelines** may be less accurate in regions with complex tidal dynamics or large tidal ranges, and low-lying intertidal flats where small tidal modelling errors can lead to large horizontal offsets in coastline positions. Annual shoreline accuracy in intertidal environments may also be reduced by the influence of wet muddy substrate or intertidal vegetation, which can make it difficult to extract a single unambiguous coastline. It is anticipated that future versions of this product will show improved results due to integrating more advanced methods for waterline detection in intertidal regions, and through improvements in tidal modelling methods.Shorelines may be noisier and more difficult to interpret in regions with low availability of satellite observations caused by persistent cloud cover. In these regions it can be difficult to obtain the minimum number of clear satellite observations required to generate clean, noise-free annual shorelines."
msgstr ""

#: 
msgid "In some urban locations, the spectra of bright white buildings located near the coastline may be inadvertently confused with water, causing a land-ward offset from true shoreline positions."
msgstr ""

#: 
msgid "Some areas of extremely dark and persistent shadows (e.g. steep coastal cliffs) may be inadvertently mapped as water, resulting in a landward offset from true shoreline positions."
msgstr ""

#: 
msgid "Some relatively small islands in the Indian Ocean are not well mapped by this technique as the number of suitable cloudless data throughout the year are insufficient to create a representative annual shoreline."
msgstr ""

#: 
msgid "Cropland extent maps for Africa"
msgstr ""

#: 
msgid "**Date modified:** March 2022"
msgstr ""

#: 
msgid "Service overview"
msgstr ""

#: 
msgid "A central focus for governing bodies in Africa is the need to secure the necessary food sources to support their populations. It has been estimated that the current production of crops will need to double by 2050 to meet future needs for food production. Higher level crop-based products that can assist with managing food insecurity, such as cropping watering intensities, crop types, or crop productivity, require as a starting point precise and accurate cropland extent maps indicating where cropland occurs. Current cropland extent maps are either inaccurate, have coarse spatial resolutions, or are not updated regularly. An accurate, high-resolution, and regularly updated cropland area map for the African continent is therefore recognised as a gap in the current crop monitoring services."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Cropland_extent.ipynb>`__ which demonstrates loading and using cropland extent datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "Digital Earth Africa's cropland extent map for Africa shows the estimated location of croplands in the following countries for the period January to December 2019:"
msgstr ""

#: 
msgid "``crop_mask``: Entire African continent"
msgstr ""

#: 
msgid "``crop_mask_eastern``: Tanzania, Kenya, Uganda, Ethiopia, Rwanda, and Burundi"
msgstr ""

#: 
msgid "``crop_mask_western``: Nigeria, Benin, Togo, Ghana, Cote d'Ivoire, Liberia, Sierra Leone, Guinea, and Guinea-Bissau"
msgstr ""

#: 
msgid "``crop_mask_northern``: Morocco, Algeria, Tunisia, Libya, and Egypt"
msgstr ""

#: 
msgid "``crop_mask_sahel``: Mauritania, Senegal, Gambia, Mali, Burkina Faso, Niger, Chad, Sudan, South Sudan, Somalia, and Djibouti"
msgstr ""

#: 
msgid "``crop_mask_southern``: South Africa, Namibia, Botswana, Lesotho, and Eswanti"
msgstr ""

#: 
msgid "``crop_mask_southeast``: Zimbabwe, Zambia, Mozambique, and Malawi"
msgstr ""

#: 
msgid "``crop_mask_central``: Angola, Democratic Republic of the Congo, Congo, Gabon, Cameroon, Equatorial Guinea, and Central African Republic"
msgstr ""

#: 
msgid "``crop_mask_indian_ocean``: Madagascar, Mauritius, Reunion, and Comoros"
msgstr ""

#: 
msgid "Cropland is defined as:"
msgstr ""

#: 
msgid "This definition will exclude non-planted grazing lands and perennial crops which can be difficult for satellite imagery to differentiate from natural vegetation."
msgstr ""

#: 
msgid "The provisional cropland extent maps have a resolution of 10 metres, and were built using Copernicus Sentinel-2 satellite images from 2019. The cropland extent maps were built seperately using extensive training data from Eastern, Western, Northern, and Sahel Africa, coupled with a Random Forest machine learning model. A detailed exploration of the methods used to produce the cropland extent map can be found in the Jupyter Notebooks in DE Africa's `crop-mask <https://github.com/digitalearthafrica/crop-mask>`__ GitHub repository."
msgstr ""

#: 
msgid "Independent validation datasets suggest the following accuracies:"
msgstr ""

#: 
msgid "The **Eastern Africa** crop mask has an **overall accuracy of 90.3 %, and an f-score of 0.85**"
msgstr ""

#: 
msgid "The **Western Africa** crop mask has an **overall accuracy of 83.6 %, and an f-score of 0.75**"
msgstr ""

#: 
msgid "The **Northern Africa** crop mask has an **overall accuracy of 94.0 %, and an f-score of 0.91**"
msgstr ""

#: 
msgid "The **Sahel Africa** crop mask has an **overall accuracy of 87.9 %, and an f-score of 0.78**"
msgstr ""

#: 
msgid "The **Southern Africa** crop mask has an **overall accuracy of 86.4 %, and an f-score of 0.75**"
msgstr ""

#: 
msgid "The **Southeast Africa** crop mask has an **overall accuracy of 87.3 %, and an f-score of 0.83**"
msgstr ""

#: 
msgid "The **Central Africa** crop mask has an **overall accuracy of 88.3 %, and an f-score of 0.82**"
msgstr ""

#: 
msgid "The **Indian Ocean Africa** crop mask has an **overall accuracy of 90.7 %, and an f-score of 0.84**"
msgstr ""

#: 
msgid "The algorithms for *most* regions tend to report more omission errors (labelling actual crops as non-crops) than commission errors (labelling non-crops as crops). Where commission errors occur, they tend to be focussed around wetlands and seasonal grasslands which spectrally resemble some kinds of cropping."
msgstr ""

#: 
msgid "The products contain three measurements:"
msgstr ""

#: 
msgid "``mask``: This band displays cropped regions as a binary map. Values of ``1`` indicate the presence of crops, while a value of ``0`` indicates the absence of cropping. This band is a *pixel-based* cropland extent map, meaning the map displays the raw output of the pixel-based Random Forest classification."
msgstr ""

#: 
msgid "``prob``: This band displays the prediction probabilities for the 'crop' class. As this service uses a random forest classifier, the prediction probabilities refer to the percentage of trees that voted for the random forest classification. For example, if the model had 200 decision trees in the random forest, and 150 of the trees voted 'crop', the prediction probability is **150 / 200 x 100 = 75 %**. Thresholding this band at > 50 % will produce a map identical to ``mask``."
msgstr ""

#: 
msgid "``filtered``: This band displays cropped regions as a binary map. Values of ``1`` indicate the presence of crops, while a value of ``0`` indicates the absence of cropping. This band is an *object-based* cropland extent map where the ``mask`` band has been filtered using an image segmentation algorithm (see `this paper <https://www.mdpi.com/2072-4292/6/7/6111/htm>`__ for details on the algorithm used). During this process, segments smaller than 1 Ha (100 10m x 10m pixels) are merged with neighbouring segments, resulting in a map where the smallest classified region is 1 Ha in size. The ``filtered`` dataset is provided as a complement to the ``mask`` band; small commission errors are removed by object-based filtering, and the 'salt and pepper' effect typical of classifying pixels is diminished."
msgstr ""

#: 
msgid "**Table 1: Cropland extent specifications**"
msgstr ""

#: 
msgid "``crop_mask_<region>``"
msgstr ""

#: 
msgid "10"
msgstr ""

#: 
msgid "EPSG: 6933"
msgstr ""

#: 
msgid "2019"
msgstr ""

#: 
msgid "Sentinel-2 Semiannual GeoMAD"
msgstr ""

#: 
msgid "**Table 2: Cropland extent measurements**"
msgstr ""

#: 
msgid "Value range"
msgstr ""

#: 
msgid "NoData/Fill value"
msgstr ""

#: 
msgid "crop extent (pixel)"
msgstr ""

#: 
msgid "``0 - 1``"
msgstr ""

#: 
msgid "``uint8``"
msgstr ""

#: 
msgid "``0``"
msgstr ""

#: 
msgid "crop probability (pixel)"
msgstr ""

#: 
msgid "``0 - 100``"
msgstr ""

#: 
msgid "filtered"
msgstr ""

#: 
msgid "crop extent (object-based)"
msgstr ""

#: 
msgid "**Figure 1: The dataset coverage for the provisional cropland extent maps; a) Northern Africa, b) Sahel Africa, c) Western Africa, d) Eastern Africa, e) Southeast Africa, f) Southern Africa, g) Central Africa, h) Indian Ocean**"
msgstr ""

#: 
msgid "**Image 1: Example of Eastern Africa cropland extent near Addis Ababa, Ethiopia.**"
msgstr ""

#: 
msgid "*1.1:* Cropland extent (pixel) for the entire East Africa region"
msgstr ""

#: 
msgid "*1.2:* True colour image"
msgstr ""

#: 
msgid "*1.3:* Cropland extent (object-filtered)"
msgstr ""

#: 
msgid "*1.4:* Cropland extent (pixel)"
msgstr ""

#: 
msgid "*1.5:* Crop probability; purple-to-pink regions show low probability, orange-yellow regions show high probability"
msgstr ""

#: 
msgid "The cropland extent service is available in AWS S3 thanks to the Public Dataset Program."
msgstr ""

#: 
msgid "``crop_mask``, ``crop_mask_eastern``, ``crop_mask_western``, ``crop_mask_northern``, ``crop_mask_sahel``, ``crop_mask_southern``, ``crop_mask_southeast``, ``crop_mask_central``, ``crop_mask_indian_ocean``"
msgstr ""

#: 
msgid "The bucket is located in the region ``af-south-1`` (Cape Town)"
msgstr ""

#: 
msgid "The following file path convention applies to the crop mask:"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_eastern/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_western/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_northern/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_sahel/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_southern/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_southeast/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_central/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "``s3://deafrica-services/crop_mask_indian_ocean/1-0-0/<path>/<row>/<year>/``"
msgstr ""

#: 
msgid "The cropland extent datasets can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product names:** ``crop_mask``, ``crop_mask_eastern``, ``crop_mask_western``, ``crop_mask_northern``, ``crop_mask_sahel``, ``crop_mask_southern``, ``crop_mask_southeast``, ``crop_mask_central``, ``crop_mask_indian_ocean``"
msgstr ""

#: 
msgid "This service is available through DE Africa's OWS."
msgstr ""

#: 
msgid "**Table 3: OWS data access details.**"
msgstr ""

#: 
msgid "Algorithm"
msgstr ""

#: 
msgid "**Figure 2: The algorithm used to generate the cropland extent map for each region of Africa.**"
msgstr ""

#: 
msgid "Training and Validation data"
msgstr ""

#: 
msgid "Reference data for the continental cropland extent map will be officially released when the remainder of the cropland extent maps are produced. For now, the training and validation data can be downloaded directly from github:"
msgstr ""

#: 
msgid "**Training data:**"
msgstr ""

#: 
msgid "Eastern cropland extent training data is located `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/eastern_cropmask/data/Eastern_training_data_20210427.geojson>`__"
msgstr ""

#: 
msgid "Western cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/western_cropmask/data/Western_training_data_20210609.geojson>`__."
msgstr ""

#: 
msgid "Northern cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/northern_cropmask/data/northern_training_data_20210803.geojson>`__."
msgstr ""

#: 
msgid "Sahel cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/sahel_cropmask/data/sahel_training_data_20211110.geojson>`__."
msgstr ""

#: 
msgid "Southern cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/southern_cropmask/data/Southern_training_data_20211108.geojson>`__."
msgstr ""

#: 
msgid "Southeast cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/southeast_cropmask/data/Southeast_training_data_20220222.geojson>`__."
msgstr ""

#: 
msgid "Central cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/central_cropmask/data/Central_training_data_20220304.geojson>`__."
msgstr ""

#: 
msgid "Indian Ocean cropland extent training data is `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/indian_ocean_cropmask/data/Indian_ocean_training_data_20220310.geojson>`__"
msgstr ""

#: 
msgid "**Validation data:**"
msgstr ""

#: 
msgid "Validation data for Eastern Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/eastern_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Western Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/western_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Northern Africa is located `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/northern_cropmask/data/>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Sahel Africa is located `here <https://github.com/digitalearthafrica/crop-mask/blob/main/testing/sahel_cropmask/data/>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Southern Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/southern_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Southeast Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/southeast_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Central Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/central_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation data for Indian Ocean Africa is located `here <https://github.com/digitalearthafrica/crop-mask/tree/main/testing/indian_ocean_cropmask/data>`__ as a shapefile and is called ``validation_samples.shp``."
msgstr ""

#: 
msgid "Validation method"
msgstr ""

#: 
msgid "Reference samples, used to both create and validate the cropland extent maps, were produced as part of the broader continental-scale cropland extent for Africa project lead by the Digital Earth Africa Establishment team. Polygons were labelled through the DE Africa distributed network of implementing partners as part of the DE Africa Validation Task Team. These partners include RCMRD, OSS, AfriGIST, AGRHYMET, NADMO, and DE Africa."
msgstr ""

#: 
msgid "The reference dataset was created using a stratified sampling design. Samples were stratified at two levels. First, samples were stratified by simplified Agro-Ecological Zones (AEZs). Second, within each AEZ, samples were stratified by a pre-existing, high-quality cropland extent map, namely the Global Food Security-Support Analysis Data (GFSAD) at 30m product. The GFSAD product was reprojected to 60 x 60m cells using ‘mode’ as the aggregating statistic. This increased the probability of samples falling within homogenous crop/non-crop regions. For each AEZ, 2,000 40 x 40 metre polygons were randomly generated, with polygons equally split between the crop and non-crop labels of the reprojected GFSAD product."
msgstr ""

#: 
msgid "Sample polygons for each AEZ were assessed using Collect Earth Online (CEO) tool developed by NASA SERVIR. Analysts used image interpretation to classify each polygon as either ‘crop’, ‘non-crop’, ‘mixed’, or ‘unsure’; where the ‘crop’ and ‘non-crop’ labels was only selected if the sample region is homogeneously crop or non-crop. Monthly Sentinel-2 mosaics, a two year NDVI time-series (2018-06 to 2020-06), and Bing ‘Aerial’ basemaps were available to assist the image interpretation."
msgstr ""

#: 
msgid "In total, around >25,000 training samples, and ~1,800 validation samples were collected as shown in Figure 3 below."
msgstr ""

#: 
msgid "**Figure 3: Reference locations for the cropland extent maps.**"
msgstr ""

#: 
msgid "*Left:* Locations of the map validation samples, *Right:* Locations of the training samples"
msgstr ""

#: 
msgid "The accuracy of the method for collecting reference samples described above was independently evaluated by `Radiant Earth <https://www.radiant.earth/>`__. Radiant Earth's team developed a visualisation app to validate a random subset of the labels collected using the CEO tool. The app retrieves Airbus SPOT imagery over the area of interest in four 6-month windows (covering the two-year of the training data specification). For each AEZ, the app would sequentially retrieve the images for each individual polygon, visualize all the available imagery and overlay the polygon on top of it. A member of Radiant's team would then interpret the class (Crop, No-Crop, Mixed) based on the guideline and examples provided by Digital Earth Africa, and record that in the app. After validating all polygons, a new GeoJSON file would be generated with the additional property for validation labels. The results of this independent validation of DE Africa's reference samples are shown in Table 4. The overall accuracy is 96.3 %, indicating that the reference samples are of a high quality and fit-for-purpose."
msgstr ""

#: 
msgid "**Table 4: Validation of the reference data samples**"
msgstr ""

#: 
msgid "Validation results"
msgstr ""

#: 
msgid "The cropland extent map for **Eastern Africa** was validated using an isolated set of 300 samples (100 crop, 200 non-crop). The results are shown as a confusion matrix in Table 5. The overall accuracy is 90.3%. The producer's accuracy for the crop class is 81 % (omission error of 19 %), and the user's accuracy is 89 % (commission error of 11 %)."
msgstr ""

#: 
msgid "**Table 5: Validation results for the Eastern Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Western Africa** was validated using an isolated set of 298 samples (97 crop, 201 non-crop). The results are shown as a confusion matrix in Table 6. The overall accuracy is 83.6 %. The producer's accuracy for the crop class is 74.2 % (omission error of 25.8 %), and the user's accuracy is 75.0 % (commission error of 25.0 %)."
msgstr ""

#: 
msgid "**Table 6: Validation results for the Western Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Northern Africa** was validated using an isolated set of 300 samples (100 crop, 200 non-crop). The results are shown as a confusion matrix in Table 7. The overall accuracy is 94.0 %. The producer's accuracy for the crop class is 90.0 % (omission error of 10.0 %), and the user's accuracy is 91.8 % (commission error of 8.2 %)."
msgstr ""

#: 
msgid "**Table 7: Validation results for the Northern Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Sahel Africa** was validated using an isolated set of 288 samples (88 crop, 200 non-crop). The results are shown as a confusion matrix in Table 8. The overall accuracy is 87.9 %. The producer's accuracy for the crop class is 70.5 % (omission error of 29.5 %), and the user's accuracy is 87.3 % (commission error of 12.7 %)."
msgstr ""

#: 
msgid "**Table 8: Validation results for the Sahel Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Southern Africa** was validated using an isolated set of 166 samples (49 crop, 113 non-crop). The results are shown as a confusion matrix in Table 9. The overall accuracy is 86.4 %. The producer's accuracy for the crop class is 67.4 % (omission error of 32.6 %), and the user's accuracy is 84.6 % (commission error of 15.4 %)."
msgstr ""

#: 
msgid "**Table 9: Validation results for the Southern Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Southeast Africa** was validated using an isolated set of 134 samples (47 crop, 87 non-crop). The results are shown as a confusion matrix in Table 10. The overall accuracy is 87.3 %. The producer's accuracy for the crop class is 89.4 % (omission error of 10.6 %), and the user's accuracy is 77.8 % (commission error of 22.2 %)."
msgstr ""

#: 
msgid "**Table 10: Validation results for the Southeast Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Central Africa** was validated using an isolated set of 145 samples (45 crop, 100 non-crop). The results are shown as a confusion matrix in Table 11. The overall accuracy is 88.3 %. The producer's accuracy for the crop class is 84.4 % (omission error of 15.6 %), and the user's accuracy is 79.2 % (commission error of 20.8 %)."
msgstr ""

#: 
msgid "**Table 11: Validation results for the Central Africa cropland extent map**"
msgstr ""

#: 
msgid "The cropland extent map for **Indian Ocean Africa** was validated using an isolated set of 150 samples (50 crop, 100 non-crop). The results are shown as a confusion matrix in Table 12. The overall accuracy is 90.7 %. The producer's accuracy for the crop class is 76.0 % (omission error of 24.0 %), and the user's accuracy is 95.0 % (commission error of 5.0 %)."
msgstr ""

#: 
msgid "**Table 12: Validation results for the Indian Ocean Africa cropland extent map**"
msgstr ""

#: 
msgid "ERA5 Climate Gridded Data"
msgstr ""

#: 
msgid "**Date modified**: March 2022"
msgstr ""

#: 
msgid "The European Centre for Medium Range Weather Forecasts (ECMWF) global climate reanalysis product, ERA5, is a comprehensive reanalysis, with data avaliable from 1979 (soon to be backed dated to January 1950) to near real time. This dataset provides a numerical assessment of the modern climate. The ERA5 dataset provides all essential atmospheric meteorological parameters such as air temperature, pressure and wind at different altitudes, along with surface parameters like rainfall, and sea parameters like sea-surface temperature and wave height. ERA5 is the fifth generation ECMWF atmospheric reanalyses of the global climate, and the first reanalysis produced as an operational service."
msgstr ""

#: 
msgid "The ERA5 dataset is produced using a similar process as a regular numerical weather forecast. It uses a data assimilation and forecast loop, taking into account most of the available meteorological observations and analysing them with a state of the art numerical model, producing a continuous, spatially consistent and homogeneous dataset. The ERA5 dataset produced contains one high resolution realisation at 31km horizontal resolution (referred to as \"reanalysis\" or \"HRES\") and a reduced resolution ten member ensemble (referred to as \"ensemble\" or \"EDA\")."
msgstr ""

#: 
msgid "The ERA5 dataset is external to the Digital Earth Africa Open Data Cube. Digital Earth Africa provides the ``load_era5()`` and ``load_era5_netcdf()`` `wrapper functions <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Tools/deafrica_tools/load_era5.py>`__ to enable users to access the data from the `AWS Public Dataset Program <https://registry.opendata.aws/ecmwf-era5/>`__ in the Sandbox environment. The `ERA5 Climate Gridded Data notebook <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/Climate_Data_ERA5_AWS.html>`__ demonstrates how to access and load the ERA5 data."
msgstr ""

#: 
msgid "For more information on the ERA5, see the `ERA5 data documentation from ECMWF <https://confluence.ecmwf.int/display/CKB/ERA5%3A+data+documentation>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Climate_Data_ERA5_AWS.ipynb>`__ which demonstrates loading and using ERA5 data in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: ERA5 product specifications.**"
msgstr ""

#: 
msgid "ECMWF ERA5 Reanalysis"
msgstr ""

#: 
msgid "Cell size - X (km) :math:`\\dagger`"
msgstr ""

#: 
msgid "31km (~0.28°) for the ERA5 HRES"
msgstr ""

#: 
msgid "63km (0.5625°) for the ERA5 EDA"
msgstr ""

#: 
msgid "Cell size - Y (km) :math:`\\dagger`"
msgstr ""

#: 
msgid "-31km (~-0.28°) for the ERA5 HRES"
msgstr ""

#: 
msgid "-63km (0.5625°) for the ERA5 EDA"
msgstr ""

#: 
msgid "Temporal Extent"
msgstr ""

#: 
msgid "1979 -"
msgstr ""

#: 
msgid "Data Format"
msgstr ""

#: 
msgid "NetCDF and Zarr"
msgstr ""

#: 
msgid ":math:`\\dagger` Wave data are produced and archived at a reduced latitude/longitude grid with a resolution of 0.36° (HRES) and 1.0° (EDA)."
msgstr ""

#: 
msgid "15 surface or single level variables are available in Zarr format and are accessible using the ``load_era5()`` wrapper function to stream the data."
msgstr ""

#: 
msgid "**Table 2: Measurements available in Zarr format.**"
msgstr ""

#: 
msgid "Catagory"
msgstr ""

#: 
msgid "Variable"
msgstr ""

#: 
msgid "Name for query"
msgstr ""

#: 
msgid "Precipitation"
msgstr ""

#: 
msgid "Total precipitation"
msgstr ""

#: 
msgid "precipitation_amount_1hour_Accumulation"
msgstr ""

#: 
msgid "Wind"
msgstr ""

#: 
msgid "10 metre U wind component"
msgstr ""

#: 
msgid "eastward_wind_at_10_metres"
msgstr ""

#: 
msgid "10 metre V wind component"
msgstr ""

#: 
msgid "northward_wind_at_10_metres"
msgstr ""

#: 
msgid "100 metre U wind component"
msgstr ""

#: 
msgid "eastward_wind_at_100_metres"
msgstr ""

#: 
msgid "100 metre V wind component"
msgstr ""

#: 
msgid "northward_wind_at_100_metres"
msgstr ""

#: 
msgid "Temperature"
msgstr ""

#: 
msgid "2 metre temperature"
msgstr ""

#: 
msgid "air_temperature_at_2_metres"
msgstr ""

#: 
msgid "2 metres maximum temperature since previous post-processing"
msgstr ""

#: 
msgid "air_temperature_at_2_metres_1hour_Maximum"
msgstr ""

#: 
msgid "2 metres minimum temperature since previous post-processing"
msgstr ""

#: 
msgid "air_temperature_at_2_metres_1hour_Minimum"
msgstr ""

#: 
msgid "2 metre dew point temperature"
msgstr ""

#: 
msgid "dew_point_temperature_at_2_metres"
msgstr ""

#: 
msgid "Sea surface temperature"
msgstr ""

#: 
msgid "sea_surface_temperature"
msgstr ""

#: 
msgid "Air Pressure"
msgstr ""

#: 
msgid "Mean sea level pressure"
msgstr ""

#: 
msgid "air_pressure_at_mean_sea_level"
msgstr ""

#: 
msgid "Surface pressure"
msgstr ""

#: 
msgid "surface_air_pressure"
msgstr ""

#: 
msgid "Snow"
msgstr ""

#: 
msgid "Snow density"
msgstr ""

#: 
msgid "snow_density"
msgstr ""

#: 
msgid "Snow depth"
msgstr ""

#: 
msgid "lwe_thickness_of_surface_snow_amount"
msgstr ""

#: 
msgid "Solar radiation"
msgstr ""

#: 
msgid "Surface solar radiation downwards"
msgstr ""

#: 
msgid "integral_wrt_time_of_surface_direct_downwelling_shortwave_flux_in_air_1hour_Accumulation"
msgstr ""

#: 
msgid "The following sea surface variables are only available in netcdf format, and can be downloaded using the ``load_era5_netcdf()`` function."
msgstr ""

#: 
msgid "**Table 3: Measurements available in NetCDF format.**"
msgstr ""

#: 
msgid "Wave"
msgstr ""

#: 
msgid "Mean wave period"
msgstr ""

#: 
msgid "sea_surface_wave_mean_period"
msgstr ""

#: 
msgid "Mean direction of waves"
msgstr ""

#: 
msgid "sea_surface_wave_from_direction"
msgstr ""

#: 
msgid "Significant height of combined wind waves and swell"
msgstr ""

#: 
msgid "significant_height_of_wind_and_swell_waves"
msgstr ""

#: 
msgid "The ERA5 product is produced from the best available observation data from satellites and in-situ stations using 4D-Var data assimilation and model forecasts in CY41R2 of the `ECMWF Integrated Forecast System (IFS) <https://confluence.ecmwf.int/display/CKB/ECMWF+Model+Documentation>`__. For more details on how the reanalysis product is produced see the `ERA5 data documentation <https://confluence.ecmwf.int/display/CKB/ERA5%3A+data+documentation>`__."
msgstr ""

#: 
msgid "**Figure 1: Maximum air temperature at 2 metres height for January 2021 for Africa**."
msgstr ""

#: 
msgid "ERA5 Air Temperature"
msgstr ""

#: 
msgid "*Credit: Contains ERA5 air temperature data generated using Copernicus Climate Change Service information 2021.*"
msgstr ""

#: 
msgid "Jon Olauson, ERA5: The new champion of wind power modelling?, Renewable Energy, Volume 126, 2018, Pages 322-331, ISSN 0960-1481, https://doi.org/10.1016/j.renene.2018.03.056. (https://www.sciencedirect.com/science/article/pii/S0960148118303677)"
msgstr ""

#: 
msgid "`ERA5: data documentation <https://confluence.ecmwf.int/display/CKB/ERA5+data+documentation>`__"
msgstr ""

#: 
msgid "`ERA5 Data on S3 via AWS Public Dataset Program <https://github.com/planet-os/notebooks/blob/master/aws/era5-pds.md#era5-data-on-s3-via-aws-public-dataset-program>`__"
msgstr ""

#: 
msgid "`ECMWF Reanalysis v5 (ERA5) website <https://www.ecmwf.int/en/forecasts/dataset/ecmwf-reanalysis-v5#:~:text=ERA5%20is%20produced%20by%20the,to%20a%20height%20of%2080km>`__"
msgstr ""

#: 
msgid "The ERA5 product is provided under a free of charge, worldwide, non-exclusive, royalty free and perpetual license. See https://cds.climate.copernicus.eu/api/v2/terms/static/licence-to-use-copernicus-products.pdf for additional information."
msgstr ""

#: 
msgid "ERA5 is produced by the Copernicus Climate Change Service (C3S) at the European Centre for Medium-Range Weather Forecasts (ECMWF)."
msgstr ""

#: 
msgid "The ERA5 data is available on AWS S3 via the AWS Public Dataset Program."
msgstr ""

#: 
msgid "``arn:aws:s3:::era5-pds``"
msgstr ""

#: 
msgid "``us-east-1``"
msgstr ""

#: 
msgid "``ecmwf-era5``"
msgstr ""

#: 
msgid "The ERA5 data is divided into distinct NetCDF granules organized by year, month, and variable name."
msgstr ""

#: 
msgid "The data is structured as follows:"
msgstr ""

#: 
msgid "where year is expressed as four digits (e.g. YYYY) and month as two digits (e.g. MM). Individual data variables (var1 through varN) use names corresponding to `NetCDF CF standard names convention <http://cfconventions.org/>`__ plus any applicable additional info, such as vertical coordinate."
msgstr ""

#: 
msgid "A sample path for air temperature would take the following form:"
msgstr ""

#: 
msgid "``/2008/01/data/air_temperature_at_2_metres.nc``"
msgstr ""

#: 
msgid "The `ERA5 Climate Gridded Data notebook <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/Climate_Data_ERA5_AWS.html>`__ demonstrates how to access the ERA5 data in the Sandbox environment using the ``load_era5()`` and ``load_era5_netcdf()`` wrapper functions."
msgstr ""

#: 
msgid "Information on the known issues with the ERA5 and the accuracy and uncertainity of the dataset is provided in the `ERA5 data documentation <https://confluence.ecmwf.int/display/CKB/ERA5%3A+data+documentation>`__."
msgstr ""

#: 
msgid "ESA WorldCover"
msgstr ""

#: 
msgid "**Date modified:** 31 July 2022"
msgstr ""

#: 
msgid "The ESA WorldCover product is a freely accessible global land cover map at 10m resolution for the year 2020 and 2021, based on both Sentinel-1 and Sentinel-2 data. The discrete classification map provides 11 land cover/land use classes and is defined using the Land Cover Classification System (LCCS) developed by the United Nations (UN) Food and Agricultre Organization (FAO)."
msgstr ""

#: 
msgid "Digital Earth Africa provides free and open access to a copy of the ESA WorldCover 10m for 2020 and 2021 product over Africa. For more information on the ESA WorldCover product, see the `ESA WorldCover website <https://esa-worldcover.org/>`__."
msgstr ""

#: 
msgid "Product User Manual"
msgstr ""

#: 
msgid "`Product User Manual for ESA WorldCover 2020 <https://esa-worldcover.s3.amazonaws.com/v100/2020/docs/WorldCover_PUM_V1.0.pdf>`__"
msgstr ""

#: 
msgid "`Product User Manual for ESA WorldCover 2021 <https://worldcover2021.esa.int/data/docs/WorldCover_PVR_V2.0.pdf>`__"
msgstr ""

#: 
msgid "Relevant metadata for the ESA WorldCover product can be viewed on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/esa_worldcover>`__."
msgstr ""

#: 
msgid "**Table 1: ESA WorldCover product specifications**"
msgstr ""

#: 
msgid "``esa_worldcover``"
msgstr ""

#: 
msgid "0.000083° (~10m)"
msgstr ""

#: 
msgid "``EPSG:4326``"
msgstr ""

#: 
msgid "2020 , 2021"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the `Metadata Explorer <https://explorer.digitalearth.africa/products/esa_worldcover>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: ESA WorldCover product geographic extent**"
msgstr ""

#: 
msgid "ESA WorldCover Geographic Extent"
msgstr ""

#: 
msgid "**Table 2: ESA WorldCover product measurements**"
msgstr ""

#: 
msgid "0.0"
msgstr ""

#: 
msgid "The ESA WorldCover global land cover product was generated using both Sentinel-2 multi-spectral imagery and Sentinel-1 C-band Synthetic Aperture Radar (SAR) imagery. The algorithm used to generate the product is based on the algorithm used to produce the dynamic annual Copernicus Global Land Service Land Cover map at 100m resolution (CGLS_LC100m). A summary of the algorithm is presented in the `Product User Manual <https://esa-worldcover.s3.amazonaws.com/v100/2020/docs/WorldCover_PUM_V1.0.pdf>`__ for 2020 and `Product User Manual <https://worldcover2021.esa.int/data/docs/WorldCover_PVR_V2.0.pdf>`__ for 2021."
msgstr ""

#: 
msgid "**Figure 2: ESA WorldCover 2020 land cover classification data for Madagascar**"
msgstr ""

#: 
msgid "ESA Worldcover Madagascar 2020"
msgstr ""

#: 
msgid "**Figure 3: ESA WorldCover 2021 land cover classification data for Madagascar**"
msgstr ""

#: 
msgid "ESA Worldcover Madagascar 2021"
msgstr ""

#: 
msgid "© ESA WorldCover project 2021 / Contains modified Copernicus Sentinel data (2021) processed by ESA WorldCover consortium"
msgstr ""

#: 
msgid "Zanaga, D., Van De Kerchove, R., De Keersmaecker, W., Souverijns, N., Brockmann, C., Quast, R., Wevers, J., Grosu, A., Paccini, A., Vergnaud, S., Cartus, O., Santoro, M., Fritz, S., Georgieva, I., Lesiv, M., Carter, S., Herold, M., Li, Linlin, Tsendbazar, N.E., Ramoino, F., Arino, O., 2021. ESA WorldCover 10 m 2020 v100. https://doi.org/10.5281/zenodo.5571936"
msgstr ""

#: 
msgid "Zanaga, D., Van De Kerchove, R.,Daems, D.,De Keersmaecker, W., Brockmann, C., Kirches, G., Wevers, J., Cartus, O., Santoro, M., Fritz, S., Lesiv, M., Herold, M., Tsendbazar, N.E., Xu, P., Ramoino, F., Arino, O. ESA WorldCover 10 m 2021 v200 https://zenodo.org/record/7254221"
msgstr ""

#: 
msgid "The ESA WorldCover product is provided free of charge, without restriction of use. For the full license information see the `Creative Commons Attribution 4.0 International License <https://creativecommons.org/licenses/by/4.0/>`__."
msgstr ""

#: 
msgid "Data Acess"
msgstr ""

#: 
msgid "The ESA WorldCover 10m 2020 and 2021 products are avaliable in AWS S3."
msgstr ""

#: 
msgid "``arn:aws:s3:::esa-worldcover``"
msgstr ""

#: 
msgid "The products are hosted on the ``esa-worldcover`` S3 bucket in the AWS ``eu-central-1`` region."
msgstr ""

#: 
msgid "The file paths follow the format: ``https://esa-worldcover.s3.eu-central-1.amazonaws.com/v100/{year}/map/``"
msgstr ""

#: 
msgid "The ESA WorldCover 10m product ``esa_worldcover`` is available through the Digital Earth Africa's OWS."
msgstr ""

#: 
msgid "**Table 4: OWS data access details.**"
msgstr ""

#: 
msgid "``esa_worldcover_{year}``"
msgstr ""

#: 
msgid "The ESA WorldCover product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``esa_worldcover_{year}``"
msgstr ""

#: 
msgid "The ``esa_worldcover`` product has only one specific band of data which can be called by using the default name, ``classification``, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load the ``classification`` band."
msgstr ""

#: 
msgid "**Table 5: ODC product esa_worldcover band names.**"
msgstr ""

#: 
msgid "``0.0``"
msgstr ""

#: 
msgid "The ESA WorldCover product was independently validated with accuracies shown below:"
msgstr ""

#: 
msgid "Global"
msgstr ""

#: 
msgid "Africa"
msgstr ""

#: 
msgid "ESA WorldCover 2020"
msgstr ""

#: 
msgid "``74.4% ±0.1%``"
msgstr ""

#: 
msgid "``73.6% ±0.2%``"
msgstr ""

#: 
msgid "ESA WorldCover 2021"
msgstr ""

#: 
msgid "``76.7% ±0.5``"
msgstr ""

#: 
msgid "``76.5% ±1.3``"
msgstr ""

#: 
msgid "In terms of land cover types, tree cover and snow/ice, cropland, water body, and bare/sparse vegetation classes had high accuracies, while shrubs, herbaceous wetland, and moss/lichen classes were mapped with lower accuracies. The validation dataset used was the multi-purpose Global Land Cover Validation dataset developed for Copernicus Global Land Service- Land Cover 100 product which was updated for the reference year 2020 by revisiting random and targeted (for land cover change) subsets."
msgstr ""

#: 
msgid "Overall, the WorldCover 2021 v200 product shows promising improvements in characterizing the World’s land cover at 10 m resolution making use of Sentinel 1 and Sentinel 2 data for the year 2021. Users of the map are encouraged to make use of the statistical accuracy analysis at the global and continental level to best apply the WorldCover product for their purposes."
msgstr ""

#: 
msgid "A detailed explanation of the validation results of the ESA WorldCover 10m product is presented in the:"
msgstr ""

#: 
msgid "`Product Validation Report 2022 <https://esa-worldcover.s3.amazonaws.com/v100/2020/docs/WorldCover_PVR_V1.1.pdf>`__"
msgstr ""

#: 
msgid "`Product Validation Report 2021 <https://worldcover2021.esa.int/data/docs/WorldCover_PVR_V2.0.pdf>`__"
msgstr ""

#: 
msgid "Fractional Cover"
msgstr ""

#: 
msgid "**Date modified:** 21 February 2022"
msgstr ""

#: 
msgid "Due to unavailability of suitable field data from Africa, the FC service hasn't been quantitatively evaluated in Africa and therefore is provided as a *provisional* service. We welcome feedback from users."
msgstr ""

#: 
msgid "The Fractional Cover (FC) service provides estimates of the proportions of green vegetation, non-green vegetation (including deciduous trees during autumn, dry grass, etc.), and bare soils for every Landsat pixel. Fractional cover provides valuable information for a range of environmental and agricultural applications, including:"
msgstr ""

#: 
msgid "soil erosion monitoring"
msgstr ""

#: 
msgid "land surface process modelling"
msgstr ""

#: 
msgid "land management practices (e.g. crop rotation, stubble management, rangeland management)"
msgstr ""

#: 
msgid "vegetation studies"
msgstr ""

#: 
msgid "fuel load estimation"
msgstr ""

#: 
msgid "ecosystem modelling"
msgstr ""

#: 
msgid "land cover mapping"
msgstr ""

#: 
msgid "The algorithm is developed by the `Joint Remote Sensing Research Program <https://www.jrsrp.org.au/>`__ (JRSRP) and is described in Scarth et al. (2010). Field data collected across Australia have been used to calibrate and validate the unmixing model."
msgstr ""

#: 
msgid "The DE Africa FC service has two components:"
msgstr ""

#: 
msgid "Fractional Cover, which is estimated from each Landsat scene, providing measurements from individual days."
msgstr ""

#: 
msgid "Fractional Cover Annual Summary (Percentiles), which provides 10th, 50th, and 90th percentiles estimated independently for the green vegetation, non-green vegetation, and bare soil fractions observed in each calendar year (1st of January - 31st December)."
msgstr ""

#: 
msgid "While the scene based Fractional Cover can be used to study dynamic processes, the annual summaries make it easier to analyse year to year changes. The percentiles provide robust estimates of the low, median and high proportion values observed for each cover type in a year, which can be used to characterise the land cover. Before the percentile calculation, areas of water and cloud cover, as mapped in the Water Observations from Space (WOfS) Feature Layer, are exluded."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Fractional_Cover.ipynb>`__ which demonstrates loading and using the Fractional Cover dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "Coverage and metadata can be viewed on DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products>`__ for:"
msgstr ""

#: 
msgid "`Fractional Cover <https://explorer.digitalearth.africa/products/fc_ls>`__"
msgstr ""

#: 
msgid "`Fractional Cover Annual Summary <https://explorer.digitalearth.africa/products/fc_ls_summary_annual>`__"
msgstr ""

#: 
msgid "**Table 1: Fractional Cover specifications**"
msgstr ""

#: 
msgid "Fractonal Cover"
msgstr ""

#: 
msgid "Fractonal Cover Annual Summary"
msgstr ""

#: 
msgid "Universal Transverse Mercator (UTM)"
msgstr ""

#: 
msgid "16 days"
msgstr ""

#: 
msgid "1984 – present"
msgstr ""

#: 
msgid "1984-2021"
msgstr ""

#: 
msgid "Fracitonal Cover scenes"
msgstr ""

#: 
msgid "Update latency"
msgstr ""

#: 
msgid "NA"
msgstr ""

#: 
msgid "2 months from end of previous year"
msgstr ""

#: 
msgid "**Table 2: Fractional Cover measurements**"
msgstr ""

#: 
msgid "bs"
msgstr ""

#: 
msgid "Bare soil percentage"
msgstr ""

#: 
msgid "pv"
msgstr ""

#: 
msgid "Photosynthetic (green) vegetation percentage"
msgstr ""

#: 
msgid "npv"
msgstr ""

#: 
msgid "Non-photosynthetic (non-green) vegetation percentage"
msgstr ""

#: 
msgid "ue"
msgstr ""

#: 
msgid "Unmixing error"
msgstr ""

#: 
msgid "``0 - 127``"
msgstr ""

#: 
msgid "Due to model uncertainties, some areas may show cover values in excess of 100%. These areas can either be excluded or treated as equivalent to 100%."
msgstr ""

#: 
msgid "For the unmixing error (ue) band, the values are scaled between 0 and 127. High unmixing error values represent areas of high model uncertainty (areas of water, cloud, cloud shadow or soil types/colours that were not included in the model training data)."
msgstr ""

#: 
msgid "**Table 3: Fractional Cover Annual Summary measurements**"
msgstr ""

#: 
msgid "bs_pc_10"
msgstr ""

#: 
msgid "10th percentile Bare soil percentage"
msgstr ""

#: 
msgid "bs_pc_50"
msgstr ""

#: 
msgid "50th percentile Bare soil percentage"
msgstr ""

#: 
msgid "bs_pc_90"
msgstr ""

#: 
msgid "90th percentile Bare soil percentage"
msgstr ""

#: 
msgid "pv_pc_10"
msgstr ""

#: 
msgid "10th percentile Photosynthetic (green) vegetation percentage"
msgstr ""

#: 
msgid "pv_pc_50"
msgstr ""

#: 
msgid "50th percentile Photosynthetic (green) vegetation percentage"
msgstr ""

#: 
msgid "pv_pc_90"
msgstr ""

#: 
msgid "90th percentile Photosynthetic (green) vegetation percentage"
msgstr ""

#: 
msgid "npv_pc_10"
msgstr ""

#: 
msgid "10th percentile Non-photosynthetic (non-green) vegetation percentage"
msgstr ""

#: 
msgid "npv_pc_50"
msgstr ""

#: 
msgid "50th percentile Non-photosynthetic (non-green) vegetation percentage"
msgstr ""

#: 
msgid "npv_pc_90"
msgstr ""

#: 
msgid "90th percentile Non-photosynthetic (non-green) vegetation percentage"
msgstr ""

#: 
msgid "count_valid"
msgstr ""

#: 
msgid "Count of clear and valid observations"
msgstr ""

#: 
msgid "``0 - 32767``"
msgstr ""

#: 
msgid "``int16``"
msgstr ""

#: 
msgid "qa†"
msgstr ""

#: 
msgid "Quality Assurance band"
msgstr ""

#: 
msgid "``0 - 2``"
msgstr ""

#: 
msgid ":math:`^\\dagger` The ``qa`` band contains addtional quality assurance information for downstream product generation, which is not currently used in DE Africa."
msgstr ""

#: 
msgid "**Figure 1: Fractional Cover geographic extent**"
msgstr ""

#: 
msgid "Fractional Cover data extent"
msgstr ""

#: 
msgid "The FC algorithm is developed by the `Joint Remote Sensing Research Program <https://www.jrsrp.org.au/>`__ (JRSRP) and is described in Scarth et al. (2010). Field data collected across Australia have been used to calibrate and validate the unmixing model."
msgstr ""

#: 
msgid "**Image 1: Fractional Cover time series**"
msgstr ""

#: 
msgid "Fractional cover time series for an area along Olifants river, South Africa. Images are selected every 3 months from year 2020 to show seasonal changes. Bare soil, green vegetation and non-green vegeation percentages are shown as Red, Green and Blue. Area identified as water are masked out."
msgstr ""

#: 
msgid "Fractional Cover along Olifants river."
msgstr ""

#: 
msgid "The chart below indicates how the RGB colour composition can be interpreted."
msgstr ""

#: 
msgid "**Image 2: Fractional Cover annual percentiles for green cover.**"
msgstr ""

#: 
msgid "The 10th, 50th, and 90th percentiles, as proxies for low, median and high values, of green cover fraction for 2020, along Olifants river, South Africa."
msgstr ""

#: 
msgid "Anual green cover percentiles along Olifants river for 2020."
msgstr ""

#: 
msgid "**Image 3: Fractional Cover annual summary**"
msgstr ""

#: 
msgid "The 50th percentile fractional covers from 2018 to 2020, along Olifants river, South Africa."
msgstr ""

#: 
msgid "50th percentile fractional cover along Olifants river for 2018 to 2020."
msgstr ""

#: 
msgid "`Water Observations from Space <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__"
msgstr ""

#: 
msgid "Flood, N. (2014). Continuity of reflectance data between Landsat-7 ETM+ and Landsat-8 OLI, for both top-of-atmosphere and surface reflectance: A study in the Australian landscape. Remote Sensing, 6(9), 7952-7970. https://doi.org/10.3390/rs6097952"
msgstr ""

#: 
msgid "Muir, J., Schmidt, M., Tindall, D., Trevithick, R., Scarth, P. and Stewart, J.B. (2011). Guidelines for field measurement of fractional ground cover: a technical handbook supporting the Australian Collaborative Land Use and Management Program. Queensland Department of Environment and Resource Management for the Australian Bureau of Agricultural and Resource Economics and Sciences."
msgstr ""

#: 
msgid "Scarth, P., Roder, A. and Schmidt, M. (2010). Tracking grazing pressure and climate interaction - the role of Landsat fractional cover in time series analysis. Proceedings of the 15th Australasian Remote Sensing & Photogrammetry Conference."
msgstr ""

#: 
msgid "Schmidt, M., Denham, R. and Scarth, P. (2010), Fractional ground cover monitoring of pastures and agricultural areas in Queensland. Proceedings of the 15th Australasian Remote Sensing & Photogrammetry Conference."
msgstr ""

#: 
msgid "The FC algorithms incorporated in this product are the work of Peter Scarth, Joint Remote Sensing Research Program."
msgstr ""

#: 
msgid "The Digital Earth Africa Fractional Cover data can be accessed from the associated S3 bucket."
msgstr ""

#: 
msgid "``fc_ls``, ``fc_ls_summary_annual``"
msgstr ""

#: 
msgid "The following file path convention applies to Fractional Cover scenes:"
msgstr ""

#: 
msgid "``fc_ls/<version>/<path>/<row>/<year>/<month>/<day>/``"
msgstr ""

#: 
msgid "Annual Summaries omit ``path``, ``row``, ``month`` and ``day``:"
msgstr ""

#: 
msgid "``fc_ls_summary_annual/<version>/<year>/``"
msgstr ""

#: 
msgid "**Table 5: AWS file path convention**"
msgstr ""

#: 
msgid "``product name``"
msgstr ""

#: 
msgid "``fc_ls`` or ``fc_ls_summary_annual``"
msgstr ""

#: 
msgid "``fc_ls``"
msgstr ""

#: 
msgid "``version``"
msgstr ""

#: 
msgid "Product version"
msgstr ""

#: 
msgid "``1-0-0``"
msgstr ""

#: 
msgid "``path``"
msgstr ""

#: 
msgid "Landsat path number ranging from ``157`` to ``206``."
msgstr ""

#: 
msgid "``165``"
msgstr ""

#: 
msgid "``row``"
msgstr ""

#: 
msgid "Landsat row number ranging from ``052`` to ``072``."
msgstr ""

#: 
msgid "``052``"
msgstr ""

#: 
msgid "Year the data was collected"
msgstr ""

#: 
msgid "``2019``"
msgstr ""

#: 
msgid "``month``"
msgstr ""

#: 
msgid "Month of the year the data was collected (with leading zeros)"
msgstr ""

#: 
msgid "``03``"
msgstr ""

#: 
msgid "``day``"
msgstr ""

#: 
msgid "Day of the month the data was collected (with leading zeros)"
msgstr ""

#: 
msgid "``28``"
msgstr ""

#: 
msgid "**Table 6: OWS data access details.**"
msgstr ""

#: 
msgid "The FC datasets can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``fc_ls``, ``fc_ls_summary_annual``"
msgstr ""

#: 
msgid "**Table 7: Fractional Cover scene ODC band names**"
msgstr ""

#: 
msgid "green_veg"
msgstr ""

#: 
msgid "dead_veg"
msgstr ""

#: 
msgid "err"
msgstr ""

#: 
msgid "**Table 8: Fractional Cover Annual Summary ODC band names**"
msgstr ""

#: 
msgid "Accuracy estimate"
msgstr ""

#: 
msgid "The bare soil, green vegetation and non-green vegetation endmembers are calculated using models linked to an intensive field sampling program that covers a wide range of Australian landscapes covering a wide variety of vegetation, soil and climate types were sampled to measure overstorey and ground cover following the procedure outlined in Muir et al (2011)."
msgstr ""

#: 
msgid "To provide an estimate of accuracy, the FC algorithm results were compared with 1565 field sites collected in Australia that were not used to train the FC model. Based on the comparison with this independent field data, the FC product has an overall Root Mean Squared Error (RMSE) of 12%. The error margins vary for the three different layers: green RMSE: 12%, non-green RMSE: 17% and bare RMSE: 15%."
msgstr ""

#: 
msgid "Due to unavailability of comparable field data from Africa, we have not been able to quantitatively evaluate the accuracy of the FC measurements for Africa. We therefore provide the service as provisional and welcome feedback from users."
msgstr ""

#: 
msgid "Limitations"
msgstr ""

#: 
msgid "The effect of soil moisture may impact the accuracy of the FC product, and the similarity between some bare soil endmembers and non-photosynthetic vegetation endmembers can lead to model instability. Soil types/colours that were not included in the model training data may also be error prone. Pixels that show poor model stability are flagged in the model error band, and can be omitted from further analysis if necessary."
msgstr ""

#: 
msgid "FC products have no water masking applied, so erroneous values for green vegetation over the water may appear. These should be ignored and can be masked out by applying the `Water Observations from Space <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ Feature layer. An example of masking cloud and water is available `here <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/master/Datasets/Fractional_Cover.ipynb>`__."
msgstr ""

#: 
msgid "Occasionally the sum of the three components is not equal to 100%. Differences are usually small and are not rounded in order to preserve what may be useful seasonal indicators."
msgstr ""

#: 
msgid "Landsat 8 OLI has different relative spectral response curves to the Landsat 5 TM and Landsat 7 ETM+ sensors. To account for this a spectral band adjustment factor is applied to the Landsat 8 data to make it more similar to reflectance as measured by Landsat 7. The adjustment factors are described in more detail in Flood (2014)."
msgstr ""

#: 
msgid "Whilst the same training data has been used to train both the JRSRP fractional cover product and the DE Africa fractional cover product, differences in the surface reflectance data that are used as model inputs mean that the two products are not identical."
msgstr ""

#: 
msgid "Interpreting the FC annual summary"
msgstr ""

#: 
msgid "The FC annual summary estimates 10th, 50th, and 90th percentiles independently for the green vegetation, non-green vegetation, and bare soil fractions observed in each calendar year."
msgstr ""

#: 
msgid "Percentiles provide an indicator of where an observation sits, relative to the rest of the observations for the pixel. For example, the 90th percentile is the value below which 90% of the observations fall. Because the percentiles are estimated independently for the three cover types, the 10th percentiles represent the low end of the measurements for the three covers, which may have been observed at different times of a year. Simiarly, the 90th percentiles respresent the high end of the measurements for the three covers, which may have occured at different times."
msgstr ""

#: 
msgid "The 10th, 50th, and 90th percentiles represent low, median and high values in a distribution that are robust against outliers. These values can be used separately or combined to understand the land cover dynamics. For example, the three percentiles for the green cover fraction can serve as proxies for the minimum, typical and maximum green cover for a given year. Difference between the 10th and 90th percentiles provides an estimate of the magnitude of change within a year. A large range of values may be observed in the agricultural land for all cover types while high green cover and a small difference between 10th and 90th percentiles are expected for forest cover."
msgstr ""

#: 
msgid "A representative view of the landscape in a year can be obtained by combining the 50th percentiles, or the median values, for the three cover types."
msgstr ""

#: 
msgid "Global Root-zone moisture Analysis & Forecasting System (GRAFS)"
msgstr ""

#: 
msgid "**Date modified:** April 2022"
msgstr ""

#: 
msgid "Root-zone soil moisture is a measure of water stored in the soil that is accessible to plant roots, making it a major contributing factor to plant health and crop yield."
msgstr ""

#: 
msgid "The Global Root-zone moisture Analysis & Forecasting System (GRAFS) is produced by the `ANU Centre for Water and Landscape Dynamics <http://wald.anu.edu.au/>`__. The model estimates the surface (0-5 cm) and root-zone (0-1 m) soil moisture at 10 km spatial resolution globally, using the precipitation measured by the Global Precipitation Measurement (GPM) mission and through assimilation of the soil moisture product from the `Soil Moisture Active/Passive <https://smap.jpl.nasa.gov/mission/description/>`__ (SMAP) mission."
msgstr ""

#: 
msgid "This product is regularly updated and made available through National Computational Infrastructure's open access THREDDS data server. The product base url is https://dapds00.nci.org.au/thredds/dodsC/ub8/global/GRAFS/."
msgstr ""

#: 
msgid "For more information on this product, contact `Luigi Renzullo <mailto:Luigi.Renzullo@anu.edu.au>`__ and `Siyuan Tian <mailto:siyuan.tian@anu.edu.au>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Soil_Moisture.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: GRAFS product specifications**"
msgstr ""

#: 
msgid "**Specifications**"
msgstr ""

#: 
msgid "Global Root-zone moisture Analysis and Forecasting System (GRAFS)"
msgstr ""

#: 
msgid "0.1"
msgstr ""

#: 
msgid "-0.1"
msgstr ""

#: 
msgid "Temporal extent"
msgstr ""

#: 
msgid "2015 - present"
msgstr ""

#: 
msgid "The Global Root-zone moisture Analysis and Forecasting System (GRAFS) is a near-real time data assimilation system that combines complementary information from model simulations and satellite observations to provide soil moisture estimates at near surface and root-zone. In GRAFS, satellite soil moisture observations from Soil Moisture Active Passive (SMAP) are assimilated into a simple first-order autoregressive model that captures the soil moisture conditions in response to precipitation, namely, the Antecedent Precipitation Index (API) model. Satellite precipitation from Global Precipitation Measurement (GPM) is used to drive the API model to simulate near surface soil moisture at 5cm. The assimilation of SMAP data relies on the four-dimensional variational (4DVAR) method to adjust the modelled surface soil moisture towards observations within a 4-day assimilation window. Soil Water Index (SWI) is then derived from the analysed surface soil moisture using an exponential filter and represents the root-zone soil wetness at approximate 1m depth. The surface and root-zone wetness from GRAFS can be converted into absolute soil moisture content using soil physical properties to provide essential support for a wide variety of hydrological and agricultural applications."
msgstr ""

#: 
msgid "**Figure 1: GRAFS surface soil moisture and rootzone soil moisture data for the Il Ngwesi region of Kenya from 01-07-2018 to 31-05-2019.**"
msgstr ""

#: 
msgid "Soil Moisture and Root Moisture Plot"
msgstr ""

#: 
msgid "*Credit: Contains surface soil moisture and rootzone soil moisture GRAFS data.*"
msgstr ""

#: 
msgid "The Global Root-zone moisture Analysis and Forecasting System (GRAFS) product is provided under a `Creative Commons 4.0 International (CC BY 4.0) License <https://creativecommons.org/licenses/by/4.0/>`__."
msgstr ""

#: 
msgid "The GRAFS dataset is external to the Digital Earth Africa Open Data Cube. Digital Earth Africa provides the ``load_soil_moisture()`` function in the `Soil Moisture Notebook <https://docs.digitalearthafrica.org/fr/latest/sandbox/notebooks/Datasets/Soil_Moisture.html>`__ to enable users to access the data from the National Computational Infrastructure’s THREDDS OPeNDAP service. The `Soil Moisture Notebook <https://docs.digitalearthafrica.org/fr/latest/sandbox/notebooks/Datasets/Soil_Moisture.html>`__ shows how to query and load the dataset."
msgstr ""

#: 
msgid "GeoMAD cloud-free composites"
msgstr ""

#: 
msgid "Header image - A section of Olifantsrivier in South Africa, imaged using the 2019 Sentinel-2 Annual GeoMAD. Contains modified Copernicus Sentinel data 2019, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "GeoMAD is the Digital Earth Africa (DE Africa) surface reflectance geomedian and triple Median Absolute Deviation data service. It is a cloud-free composite of satellite data compiled over specific timeframes. This service is ideal for:"
msgstr ""

#: 
msgid "Longer-term time series analysis"
msgstr ""

#: 
msgid "Cloud-free imagery"
msgstr ""

#: 
msgid "Statistical accuracy"
msgstr ""

#: 
msgid "GeoMAD has two main components:"
msgstr ""

#: 
msgid "Median Absolute Deviations (MADs)"
msgstr ""

#: 
msgid "The geomedian component combines measurements collected over the specified timeframe to produce one representative, multispectral measurement for every pixel unit of the African continent. The end result is a comprehensive dataset that can be used to generate true-colour images for visual inspection of anthropogenic or natural landmarks. The full spectral dataset can be used to develop more complex algorithms."
msgstr ""

#: 
msgid "For each pixel, invalid data is discarded, and the remaining observations are mathematically summarised using the geomedian statistic. Flyover coverage provided by collecting data over a period of time also helps scope intermittently cloudy areas."
msgstr ""

#: 
msgid "Variations between the geomedian and the individual measurements are captured by the three Median Absolute Deviation (MAD) layers. These are higher-order statistical measurements calculating variation relative to the geomedian. The MAD layers can be used on their own or together with geomedian to gain insights about the land surface, and understand change over time."
msgstr ""

#: 
msgid "Calculating GeoMAD over different timeframes and sensors provides a range of insights to the environment. An annual timeframe allows better correction for cloud cover and reduces artifacts for comparison over multiple years. A shorter timeframe, for example, six-month or three-month blocks, better captures seasonal variation within one year, and can be used to compare equivalent periods from different years. Landsat sensors allow full utility of the surface reflectance archive dating back to 1984, while more recent Sentinel-2 data provides higher-frequency flyovers and better resolution."
msgstr ""

#: 
msgid "The Digital Earth Africa GeoMAD service currently provides annual, six-month semiannual and rolling monthly (3-month moving window) datasets, with separate services for Landsat and Sentinel-2 sensors."
msgstr ""

#: 
msgid "Jupyter Notebooks that demonstrate loading and using `GeoMAD <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/GeoMAD.ipynb>`__ and `Rolling GeoMAD <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/RollingGeoMAD.ipynb>`__ datasets in the Sandbox are also available."
msgstr ""

#: 
msgid "The GeoMAD service spans all of Africa and is currently available in three timeframes:"
msgstr ""

#: 
msgid "Annual: observations from one calendar year are summarised into one set of measurements"
msgstr ""

#: 
msgid "Sentinel-2 Annual GeoMAD"
msgstr ""

#: 
msgid "Landsat 8 Annual GeoMAD"
msgstr ""

#: 
msgid "Landsat 5 & 7 Annual GeoMAD"
msgstr ""

#: 
msgid "Landsat 8 & 9 Annual GeoMAD"
msgstr ""

#: 
msgid "Semiannual: observations are summarised for each half of the calendar year, giving one set of measurements for January–June, and one for July–December"
msgstr ""

#: 
msgid "Rolling GeoMAD: observations are summarised over rolling three-month periods starting on the first day of each calendar month, giving a set of new measurements each month e.g Jan-Mar, Feb-Apr, Mar-May and so on."
msgstr ""

#: 
msgid "Sentinel-2 Rolling Monthly GeoMAD"
msgstr ""

#: 
msgid "GeoMAD metadata can also be viewed on Digital Earth Africa's `Metadata Explorer <https://explorer.digitalearth.africa/products/gm_s2_annual/extents>`__."
msgstr ""

#: 
msgid "**Table 1: Sentinel-2 GeoMAD service specifications**"
msgstr ""

#: 
msgid "Service name"
msgstr ""

#: 
msgid "Service status"
msgstr ""

#: 
msgid "Operational"
msgstr ""

#: 
msgid "14"
msgstr ""

#: 
msgid "Coordinate reference system (CRS)"
msgstr ""

#: 
msgid "6-monthly (Jan-Jun, Jul-Dec)"
msgstr ""

#: 
msgid "Monthly (3-month rolling window)"
msgstr ""

#: 
msgid "2017 – current"
msgstr ""

#: 
msgid "2019 – current"
msgstr ""

#: 
msgid "Sentinel-2 Level-2A"
msgstr ""

#: 
msgid "6 months"
msgstr ""

#: 
msgid "2 months from end of previous half year"
msgstr ""

#: 
msgid "1 month from end of previous period"
msgstr ""

#: 
msgid "**Table 2: Landsat GeoMAD service specifications**"
msgstr ""

#: 
msgid "2021 –"
msgstr ""

#: 
msgid "2013 – 2020"
msgstr ""

#: 
msgid "1984 – 2012"
msgstr ""

#: 
msgid "Landsat Level-2 Collection 2"
msgstr ""

#: 
msgid "*The Landsat 5 & 7 Annual GeoMAD service combines data from both the Landsat 5 and Landsat 7 sensors. It is produced for the 1984 – 2012 archive only. Similarly, the Landsat 8 & 9 Annual GeoMAD came into production after Landsat 9 data became available in late 2021.*"
msgstr ""

#: 
msgid "**Figure 1: GeoMAD geographic extent**"
msgstr ""

#: 
msgid "S-2 GeoMAD data extent"
msgstr ""

#: 
msgid "Digital Earth Africa GeoMAD data is available for the regions shaded in blue. Specific temporal and geographic extents can be explored as an interactive map on the Digital Earth Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/gm_s2_annual/extents>`__."
msgstr ""

#: 
msgid "Sentinel-2, Landsat 8, and Landsat 8 & 9 GeoMAD services are generated from parent datasets with frequent satellite flyovers consistent with the geographic extent shown in Figure 1. While the Landsat 5 & Landsat 7 Annual GeoMAD also covers the same area, there are some limitations associated with the sparsity of the Landsat archive over Africa, particularly before the launch of Landsat 7 in 1999."
msgstr ""

#: 
msgid "This is visually displayed in the ``count`` imagery in Figure 2. Northern and southern Africa have the best coverage over the archive period. Central and western Africa show lower data counts, and therefore less years where a geomedian and MADs have been calculated. It is recommended to consult the Digital Earth Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/gm_ls5_ls7_annual/extents>`__ for precise data availability of the Landsat 5 and 7 GeoMAD."
msgstr ""

#: 
msgid "**Figure 2: Landsat 5 & 7 GeoMAD data extent**"
msgstr ""

#: 
msgid "*Left:* An animation showing data count over Africa for the years 1984 to 2012. Darker blue indicates higher counts, while lighter blue is lower counts. Areas with very low or zero counts in one year do not have enough data to calculate a geomedian or MADs for that year."
msgstr ""

#: 
msgid "*Right:* A static image showing the number of years for which a geomedian has been calculated. In the 29 years between 1984 and 2012, northern and southern Africa show almost complete geomedian coverage, while central and western Africa have a lower geomedian count associated with less data acquisition over the time period."
msgstr ""

#: 
msgid "LS5-7 GeoMAD data extent over time"
msgstr ""

#: 
msgid "LS5-7 GeoMAD count summary"
msgstr ""

#: 
msgid "**Table 3.1: Sentinel-2 GeoMAD measurements**"
msgstr ""

#: 
msgid "B02"
msgstr ""

#: 
msgid "Geomedian B02 (Blue)"
msgstr ""

#: 
msgid "``1 - 10000``"
msgstr ""

#: 
msgid "``uint16``"
msgstr ""

#: 
msgid "B03"
msgstr ""

#: 
msgid "Geomedian B03 (Green)"
msgstr ""

#: 
msgid "B04"
msgstr ""

#: 
msgid "Geomedian B04 (Red)"
msgstr ""

#: 
msgid "B05"
msgstr ""

#: 
msgid "Geomedian B05 (Red edge 1)"
msgstr ""

#: 
msgid "B06"
msgstr ""

#: 
msgid "Geomedian B06 (Red edge 2)"
msgstr ""

#: 
msgid "B07"
msgstr ""

#: 
msgid "Geomedian B07 (Red edge 3)"
msgstr ""

#: 
msgid "B08"
msgstr ""

#: 
msgid "Geomedian B08 (Near infrared (NIR) 1)"
msgstr ""

#: 
msgid "B8A"
msgstr ""

#: 
msgid "Geomedian B8A (NIR 2)"
msgstr ""

#: 
msgid "B11"
msgstr ""

#: 
msgid "Geomedian B11 (Short-wave infrared (SWIR) 1)"
msgstr ""

#: 
msgid "B12"
msgstr ""

#: 
msgid "Geomedian B12 (SWIR 2)"
msgstr ""

#: 
msgid "SMAD"
msgstr ""

#: 
msgid "Spectral Median Absolute Deviation"
msgstr ""

#: 
msgid "EMAD"
msgstr ""

#: 
msgid "Euclidean Median Absolute Deviation"
msgstr ""

#: 
msgid "``0 - 31623``"
msgstr ""

#: 
msgid "BCMAD"
msgstr ""

#: 
msgid "Bray-Curtis Median Absolute Deviation"
msgstr ""

#: 
msgid "COUNT"
msgstr ""

#: 
msgid "Number of clear observations"
msgstr ""

#: 
msgid "``1 - 65535``"
msgstr ""

#: 
msgid "**Table 3.2: Landsat 8 and Landsat 8 & 9 GeoMAD measurements**"
msgstr ""

#: 
msgid "SR_B2"
msgstr ""

#: 
msgid "Geomedian SR_B2 (Blue)"
msgstr ""

#: 
msgid "SR_B3"
msgstr ""

#: 
msgid "Geomedian SR_B3 (Green)"
msgstr ""

#: 
msgid "SR_B4"
msgstr ""

#: 
msgid "Geomedian SR_B4 (Red)"
msgstr ""

#: 
msgid "SR_B5"
msgstr ""

#: 
msgid "Geomedian SR_B5 (NIR)"
msgstr ""

#: 
msgid "SR_B6"
msgstr ""

#: 
msgid "Geomedian SR_B6 (SWIR 1)"
msgstr ""

#: 
msgid "SR_B7"
msgstr ""

#: 
msgid "Geomedian SR_B7 (SWIR 2)"
msgstr ""

#: 
msgid "**Table 3.3: Landsat 5 & Landsat 7 GeoMAD measurements**"
msgstr ""

#: 
msgid "SR_B1"
msgstr ""

#: 
msgid "Geomedian SR_B1 (Blue)"
msgstr ""

#: 
msgid "Geomedian SR_B2 (Green)"
msgstr ""

#: 
msgid "Geomedian SR_B3 (Red)"
msgstr ""

#: 
msgid "Geomedian SR_B4 (NIR)"
msgstr ""

#: 
msgid "Geomedian SR_B5 (SWIR 1)"
msgstr ""

#: 
msgid "Bands can be subdivided as follows:"
msgstr ""

#: 
msgid "**Geomedian - 10 bands (Sentinel-2), 6 bands (Landsat 5/7/8/9):** The geomedian is calculated using the spectral bands of data collected during the specified time period. Surface reflectance values have been scaled between ``1`` and ``10000`` to allow for more efficient data storage as unsigned 16-bit integers (``uint16``). Note parent datasets often contain more bands, some of which are not used in GeoMAD."
msgstr ""

#: 
msgid "The geomedian band IDs correspond to bands in the parent Sentinel-2 Level-2A data. For example, the Annual GeoMAD band ``B02`` contains the annual geomedian of the Sentinel-2 ``B02`` band."
msgstr ""

#: 
msgid "**Median Absolute Deviations (MADs) - 3 bands:** Deviations from the geomedian are quantified through median absolute deviation calculations. The GeoMAD service utilises three MADs, each stored in a separate band: Euclidean MAD (EMAD), spectral MAD (SMAD), and Bray-Curtis MAD (BCMAD). Each MAD is calculated using the same ten bands as in the geomedian. SMAD and BCMAD are normalised ratios, therefore they are unitless and their values always fall between ``0`` and ``1``. EMAD is a function of surface reflectance but is neither a ratio nor normalised, therefore its valid value range depends on the number of bands used in the geomedian calculation - ten in GeoMAD."
msgstr ""

#: 
msgid "**Count - 1 band:** The number of clear satellite measurements of a pixel for that calendar year. This is around 60 for Sentinel-2 and 20 for Landsat 8 annually, but doubles at areas of overlap between scenes. \"Count\" is not incorporated in either the geomedian or MADs calculations. It is intended for metadata analysis and data validation."
msgstr ""

#: 
msgid "All clear observations for the given time period are collated from the parent dataset. Cloudy pixels are identified and excluded. The geomedian and MADs calculations are then performed by the `hdstats <https://libraries.io/pypi/hdstats>`__ package."
msgstr ""

#: 
msgid "**Image 1: Animations over northern Africa. 1984 – 2012 Landsat 5 & 7 Annual geomedian, true-colour (RGB).**"
msgstr ""

#: 
msgid "*Left:* Agricultural area expansion near Sadat City, Egypt."
msgstr ""

#: 
msgid "*Right:* Urbanisation in Tangier, Morocco."
msgstr ""

#: 
msgid "Credit: Contains Landsat Level-2 Surface Reflectance Science Product courtesy of the U.S. Geological Survey, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "**Image 2: Mangroves in Guinea-Bissau. 2019 Sentinel-2 Annual geomedian, true-colour (RGB).**"
msgstr ""

#: 
msgid "Credit: Contains modified Copernicus Sentinel data 2019, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "Geomedian composite"
msgstr ""

#: 
msgid "**Image 3: Croplands in South Africa. 2019 Sentinel-2 Annual triple MADs, plotted as RGB.**"
msgstr ""

#: 
msgid "MADs"
msgstr ""

#: 
msgid "**Image 4: Irrigated fields in Egypt. Jan-Jun 2020 (right), Jul-Dec 2020 (left). 2020 Sentinel-2 Semiannual geomedian, true-colour (RGB).**"
msgstr ""

#: 
msgid "Credit: Contains modified Copernicus Sentinel data 2020, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "Semiannual geomedian"
msgstr ""

#: 
msgid "**Image 5: The Okavango Delta, Botswana. 2020 Landsat 8 Annual triple MADs, plotted as RGB.**"
msgstr ""

#: 
msgid "Annual LS8 geomedian"
msgstr ""

#: 
msgid "**Image 6: Animations 2020–2022 using Sentinel-2 Rolling GeoMAD, true-colour (RGB)**"
msgstr ""

#: 
msgid "The dates shown are the midpoints of the Rolling GeoMAD."
msgstr ""

#: 
msgid "Credit: Contains modified Copernicus Sentinel data 2022, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "Farmland in northern Egypt"
msgstr ""

#: 
msgid "Wetland in Guinea Bissua"
msgstr ""

#: 
msgid "Known limitations"
msgstr ""

#: 
msgid "The Landsat 8 (& 9) GeoMAD has a known issue with data quality over marine regions. The GeoMAD algorithm uses pixel quality information from the input data to identify and mask pixels with poor quality obervations. Landsat 8 & 9 analysis ready satellite images over the ocean often contain negative surface reflectance values, and the GeoMAD masking procedures remove pixels where any negative values occur. Thus, in regions where pixels are persistently negative throughout the year, the GeoMAD product will contain a no-data value. An example of this can be seen in **Image 7** below where a shallow marine system contains no-data values in the GeoMAD because the NIR band values in the input data are persistently negative."
msgstr ""

#: 
msgid "**Image 7: Shallow marine system, Mauritius. 2021 Landsat 8 Annual GeoMAD (left), versus Sentinel-2 GeoMAD (right), plotted as RGB.**"
msgstr ""

#: 
msgid "`Maps portal link <https://maps.digitalearth.africa/#share=s-m8QKPZKiT1V0ODbIgVAwg9o5scp>`__"
msgstr ""

#: 
msgid "`Sentinel-2 Level-2A Surface Reflectance <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-2_Level-2A_specs.html>`__"
msgstr ""

#: 
msgid "`Landsat Collection 2 Level-2 Surface Reflectance <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html>`__"
msgstr ""

#: 
msgid "Roberts, D., Mueller, N., & Mcintyre, A. (2017). High-dimensional pixel composites from Earth observation time series. *IEEE Transactions on Geoscience and Remote Sensing*, 55(11), 6254-6264. https://doi.org/10.1109/TGRS.2017.2723896"
msgstr ""

#: 
msgid "Roberts, D., Dunn, B., Mueller, N. (2018). Open Data Cube products using high-dimensional statistics of time series. 8647-8650. https://doi.org/10.1109/IGARSS.2018.8518312."
msgstr ""

#: 
msgid "The high-dimensional statistics algorithms incorporated in this service are the work of Dr Dale Roberts, Australian National University."
msgstr ""

#: 
msgid "GeoMAD data can be accessed from the associated S3 bucket."
msgstr ""

#: 
msgid "``gm_s2_annual``, ``gm_ls8_annual``, ``gm_ls5_ls7_annual``, ``gm_s2_semiannual``, ``gm_s2_rolling``"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-services/gm_s2_annual/``"
msgstr ""

#: 
msgid "The file paths follow the format:"
msgstr ""

#: 
msgid "``<productname>/<version>/<x>/<y>/<timeperiod>/<x><y>_<timeperiod>_<band>.<extension>``"
msgstr ""

#: 
msgid "``gm_s2_annual``"
msgstr ""

#: 
msgid "``1.0.0``"
msgstr ""

#: 
msgid "``x``"
msgstr ""

#: 
msgid "Tile number in the ``x`` direction."
msgstr ""

#: 
msgid "``x17``"
msgstr ""

#: 
msgid "``y``"
msgstr ""

#: 
msgid "Tile number in the ``y`` direction."
msgstr ""

#: 
msgid "``y156``"
msgstr ""

#: 
msgid "``timeperiod``"
msgstr ""

#: 
msgid "Year of data collection followed by period of time and time unit in the format ``YYYY--P<period><unit>``. Time units are designated by capitalised letters, ``Y`` for years and ``M`` for months. Annual data is ``P1Y`` while 6-monthly data (such as the semiannuals) is ``P6M``."
msgstr ""

#: 
msgid "``2019--P1Y``"
msgstr ""

#: 
msgid "``x_y_timeperiod_band.extension``"
msgstr ""

#: 
msgid "File name. Combines ``x``, ``y``, ``timeperiod`` with ``band``, using Band IDs, and file extensions. For most tiles, the file extension is ``.tif``."
msgstr ""

#: 
msgid "Tile numbering uses 96 km grid squares based on the default CRS for this product, ``EPSG:6933``, with the origin set at the bottom-leftmost corner of the valid ``EPSG:6933`` region."
msgstr ""

#: 
msgid "``gm_s2_annual``, ``gm_ls8_annual``, ``gm_ls5_ls7_annual``, ``gm_s2_semiannual``"
msgstr ""

#: 
msgid "GeoMAD datasets are accessible in the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "Specific bands of data can be called by using either the default names or any of a band's alternative names, as listed in the table below. ODC ``datacube.Datacube.load`` commands without specified bands will load all bands; see `ODC documentation <https://datacube-core.readthedocs.io/en/latest/api/indexed-data/generate/datacube.Datacube.load.html>`__."
msgstr ""

#: 
msgid "**Table 6.1: Sentinel-2 GeoMAD ODC product and band names**"
msgstr ""

#: 
msgid "**ODC product name:** ``gm_s2_annual``, ``gm_s2_semiannual``, ``gm_s2_rolling``"
msgstr ""

#: 
msgid "band_02, blue"
msgstr ""

#: 
msgid "band_03, green"
msgstr ""

#: 
msgid "band_04, red"
msgstr ""

#: 
msgid "band_05, red_edge_1"
msgstr ""

#: 
msgid "band_06, red_edge_2"
msgstr ""

#: 
msgid "band_07, red_edge_3"
msgstr ""

#: 
msgid "band_08, nir, nir_1"
msgstr ""

#: 
msgid "band_8a, nir_narrow, nir_2"
msgstr ""

#: 
msgid "band_11, swir_1, swir_16"
msgstr ""

#: 
msgid "band_12, swir_2, swir_22"
msgstr ""

#: 
msgid "smad, sdev, SDEV"
msgstr ""

#: 
msgid "emad, edev, EDEV"
msgstr ""

#: 
msgid "bcmad, bcdev, BCDEV"
msgstr ""

#: 
msgid "count"
msgstr ""

#: 
msgid "**Table 6.2: Landsat 8 GeoMAD ODC product and band names**"
msgstr ""

#: 
msgid "**ODC product name:** ``gm_ls8_annual``"
msgstr ""

#: 
msgid "band_2, blue"
msgstr ""

#: 
msgid "band_3, green"
msgstr ""

#: 
msgid "band_4, red"
msgstr ""

#: 
msgid "band_5, nir"
msgstr ""

#: 
msgid "band_6, swir_1"
msgstr ""

#: 
msgid "band_7, swir_2"
msgstr ""

#: 
msgid "**Table 6.3: Landsat 5 & 7 GeoMAD ODC product and band names**"
msgstr ""

#: 
msgid "**ODC product name:** ``gm_ls5_ls7_annual``"
msgstr ""

#: 
msgid "band_1, blue"
msgstr ""

#: 
msgid "band_2, green"
msgstr ""

#: 
msgid "band_3, red"
msgstr ""

#: 
msgid "band_4, nir"
msgstr ""

#: 
msgid "band_5, swir_1"
msgstr ""

#: 
msgid "Pixel composites are created by compiling multiple satellite observations of the same area to form one representative image. They have become a staple to Earth observation research as combining measurements compensates for missing data, such as gaps caused by cloud cover. This results in comprehensive datasets that allow thorough analysis of large areas of interest."
msgstr ""

#: 
msgid "There are many ways of forming this image. GeoMAD uses the *geomedian* summary statistic to combine six months or a year of data into one scientifically-rigorous composite. It produces one multispectral observation for each pixel on continental Africa."
msgstr ""

#: 
msgid "The geomedian statistic is sometimes referred to as the \"geometric median\", as in the figure below. To remove ambiguity with other kinds of statistics with similar names, it is always referred to in DE Africa as the \"geomedian\"."
msgstr ""

#: 
msgid "**Figure 2: Illustrated explanation of the geomedian.**"
msgstr ""

#: 
msgid "Figure 2 uses a three-dimensional example to illustrate how the geomedian is calculated for a single pixel containing multiple measurements of red, blue and green data."
msgstr ""

#: 
msgid "The dataset has :math:`N` timesteps of satellite data. In the case of Figure 2, :math:`N=20`"
msgstr ""

#: 
msgid "Each timestep contains :math:`p` bands. In this case, :math:`p =3` (one dimension each for red, green, blue)"
msgstr ""

#: 
msgid "Therefore each timestep can be represented by a 3-dimensional vector :math:`\\mathbf{x}`. A single vector at timestep :math:`t`, :math:`\\mathbf{x}^{(t)}`, looks like this:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\mathbf{x}^{(t)} = \\begin{bmatrix}"
msgstr ""

#: 
msgid "x^{(t)}_{red} \\\\ x^{(t)}_{green}\\\\ x^{(t)}_{blue}"
msgstr ""

#: 
msgid "\\end{bmatrix} \\end{align*}`"
msgstr ""

#: 
msgid "The entire dataset can be represented as the collection of the vectors at every timestep :math:`\\mathbf{x}^{(1)}, \\mathbf{x}^{(2)}, \\dots \\mathbf{x}^{(20)}`"
msgstr ""

#: 
msgid "Projected onto a plane, it will look like the plot in Figure 2.2 - twenty points placed depending on their values of red, green and blue. The geomedian of this pixel is then the point where the Euclidean distance (straight-line distance) between all data points is minimised. This is depicted in Figure 2.3; for further information on Euclidean distance, see the section below on the **Euclidean MAD**."
msgstr ""

#: 
msgid "Let's call the geomedian point in this example :math:`\\mathbf{m}_\\text{example}`. Euclidean distance between a point :math:`\\mathbf{x}` and the data points :math:`\\mathbf{x}^{(t)}` is given by :math:`\\lVert \\mathbf{x} - \\mathbf{x}^{(t)} \\rVert`. The point at which all twenty distances are minimised is found by taking the :math:`\\mathrm{argmin}`; the argument of the minima. The geomedian can then be expressed by the following equation:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\mathbf{m}_\\text{example} = \\underset{\\mathbf{x} \\in \\mathbb{R}^3}{\\mathrm{argmin}} \\sum^{20}_{t=1} \\lVert \\mathbf{x} - \\mathbf{x}^{(t)} \\rVert \\end{align*}`"
msgstr ""

#: 
msgid "In this example, the resulting :math:`\\mathbf{m}_\\text{example}`, like any :math:`\\mathbf{x}`, will be a 3-dimensional vector, with a value each for red, green, and blue."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\mathbf{m}_\\text{example} =\\begin{bmatrix}"
msgstr ""

#: 
msgid "m_{red} \\\\ m_{green}\\\\ m_{blue}"
msgstr ""

#: 
msgid "The geomedian point :math:`\\mathbf{m}` is not selected from one of the twenty data points. It is a separate vector with unique values that do not necessarily correspond to existing band values from the observation dataset."
msgstr ""

#: 
msgid "The formula for the geomedian of a single pixel can be generalised for :math:`p` bands and :math:`N` timesteps, as given in `Roberts et al, 2017 <https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004469>`__:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\mathbf{m} = \\underset{\\mathbf{x} \\in \\mathbb{R}^p}{\\mathrm{argmin}} \\sum^{N}_{t=1} \\lVert \\mathbf{x} - \\mathbf{x}^{(t)} \\rVert \\end{align*}`"
msgstr ""

#: 
msgid "In the Sentinel-2 GeoMADs, the ten bands of the geomedian result in a 10-dimensional space - in the Landsat GeoMADs, the six geomedian bands give a 6-dimensional space. It is difficult to illustrate this example in six (or ten!) dimensions, but we can instead provide the equation, and the form of the result. Here, the number of timesteps :math:`N` varies per pixel; pixels on the overlap between satellite swathes may have very large :math:`N` (up to around 140 per year for Sentinel-2 annual services), while pixels in the centre of the path are only observed once per flyover, and have :math:`N` closer to 70."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\mathbf{m}_\\text{GeoMAD} = \\underset{\\mathbf{x} \\in \\mathbb{R}^{10}}{\\mathrm{argmin}} \\sum^{N}_{t=1} \\lVert \\mathbf{x} - \\mathbf{x}^{(t)} \\rVert = \\begin{bmatrix}"
msgstr ""

#: 
msgid "m_{B02} \\\\ m_{B03}\\\\ m_{B04}\\\\ m_{B05} \\\\ m_{B06}\\\\ m_{B07}\\\\ m_{B08} \\\\ m_{B8A}\\\\ m_{B11}\\\\ m_{B12}"
msgstr ""

#: 
msgid "This calculation is repeated for every pixel in the specified extent."
msgstr ""

#: 
msgid "The significance of the geomedian is that all bands are considered simultaneously. This maintains the spectral relationship between bands, providing the most representative value. Additionally, the geomedian statistic reduces spatial noise and improves colour balance compared to similar statistics such as the median or medoid."
msgstr ""

#: 
msgid "The geomedian is therefore a vital foundational dataset for applications such as band index analysis on vegetation, water and urban area detection. It is also useful as a feature layer in machine learning algorithms."
msgstr ""

#: 
msgid "DE Africa provides an interactive geomedian visualisation available as a `Jupyter Notebook widget <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/GeoMAD.html>`__. It graphically compares the geomedian to a median for a 3-D example. An example screenshot is shown below."
msgstr ""

#: 
msgid "**Figure 3: Geomedian visualisation widget.**"
msgstr ""

#: 
msgid "To interact with the widget, log in to the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/>`__ and navigate to the **Datasets** folder > **GeoMAD**."
msgstr ""

#: 
msgid "Triple Median Absolute Deviations (MADs)"
msgstr ""

#: 
msgid "By definition, the geomedian smooths variations in the satellite data to pick the most central, representative value. Outlying extreme highs and lows are generally filtered out by the robustness of the geomedian calculation. However, it is still useful to know about the variation within the dataset. This results in a set of second-order statistics: the Median Absolute Deviations (MADs)."
msgstr ""

#: 
msgid "MADs are change statistics based on the geomedian. They show how much variation each pixel underwent in the given timeframe."
msgstr ""

#: 
msgid "Let us break down the acronym \"MAD\"; as in the title, it stands for *median absolute deviation*:"
msgstr ""

#: 
msgid "This implies we have a collection of measurements"
msgstr ""

#: 
msgid "We then find the deviation of each measurement from a baseline value, obtaining one deviation for every measurement"
msgstr ""

#: 
msgid "These deviations are all absolute values, so each deviation is equal to or greater than 0"
msgstr ""

#: 
msgid "We then find the median, or middle value, of these deviations"
msgstr ""

#: 
msgid "This gives us a median absolute deviation"
msgstr ""

#: 
msgid "In this case, our \"collection of measurements\" is satellite data from each flyover. Even for a single pixel, we have multiple measurements in the time axis: one from every pass."
msgstr ""

#: 
msgid "The \"baseline value\" is the geomedian, which provides one multispectral result for each pixel."
msgstr ""

#: 
msgid "The \"deviations\" here are three different *distance* or *dissimilarity* values. There are multiple ways of quantifying how change has occurred, so this service computes three different MADs for use in data analysis. We are calculating, in three separate ways, the deviation between the geomedian and a single flyover's measurement. These three values have been chosen to reflect a range of changes that appear in Earth observation data, and hence this section of the dataset is often referred to as \"triple MADs\"."
msgstr ""

#: 
msgid "The three MADs used in DE Africa are:"
msgstr ""

#: 
msgid "Euclidean MAD, EMAD (based on Euclidean distance)"
msgstr ""

#: 
msgid "Spectral MAD, SMAD (based on cosine distance)"
msgstr ""

#: 
msgid "Bray-Curtis MAD, BCMAD (based on Bray-Curtis dissimilarity)"
msgstr ""

#: 
msgid "Each will be explained in their own sections below. Example calculations with real numbers are in the appendix."
msgstr ""

#: 
msgid "Note there are many other types of statistical distances and dissimilarities that can be used for median absolute deviation analysis (for example: Manhattan distance, Canberra distance, `there are many <https://ricottalab.files.wordpress.com/2015/05/ricotta-podani-2017-ecocom-full.pdf>`__ and they can all be used to calculate a MAD). However, in DE Africa services, the terms \"triple MADs\" or \"MADs\" are always specifically referring to the three MADs included in the GeoMAD dataset: EMAD, SMAD, and BCMAD."
msgstr ""

#: 
msgid "Euclidean MAD (EMAD)"
msgstr ""

#: 
msgid "The most logical place to start thinking about any of the MADs is the Euclidean MAD (EMAD). This is because EMAD comes from Euclidean distance, and Euclidean distance can be explained with a physical analogy: it is how we measure straight-line distances between points. In our three-dimensional world, it may look like this:"
msgstr ""

#: 
msgid "**Figure 4: Euclidean distance in three dimensions.**"
msgstr ""

#: 
msgid "Euclidean"
msgstr ""

#: 
msgid "In the case of satellite data, we are measuring the Euclidean distance between a pixel's geomedian value and a single multispectral measurement. The number of dimensions is equal to the number of bands in the data. In the illustration below, :math:`m` is the geomedian value and :math:`\\mathbf{x}` the measured value. In real data, there will be multiple measurements over a time period, so :math:`t` is the timestep number, otherwise noted in equations as superscript :math:`(t)`."
msgstr ""

#: 
msgid "For example, if we had three bands of data (red, green and blue), and three timesteps of data, then we can calculate the Euclidean distances as follows:"
msgstr ""

#: 
msgid "**Figure 5: Euclidean distance in three dimensions over three timesteps.**"
msgstr ""

#: 
msgid "Each timestep gives a separate Euclidean distance result. Then EMAD is the median of all those distances."
msgstr ""

#: 
msgid "In most real life conditions, there will be more than three timesteps and more than three bands. A general expression of Euclidean distance for :math:`p` bands is given as:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} &\\text{Multispectral Euclidean distance for timestep }t \\\\ =& \\sqrt{ \\left( x^{(t)}_{\\text{band 1}} - m_{\\text{band 1}} \\right)^2 + \\left( x^{(t)}_{\\text{band 2}} - m_{\\text{band 2}} \\right)^2  + \\dots  + \\left( x^{(t)}_{\\text{band p}} - m_{\\text{band p}} \\right)^2 }\\\\ =& \\lVert \\mathbf{x}^{(t)} - m \\rVert_{\\mathbb{R}^p} \\end{align*}`"
msgstr ""

#: 
msgid "Then EMAD for :math:`N` timesteps is given by `Roberts et al, 2018 <https://ieeexplore.ieee.org/abstract/document/8518312>`__, as the median of the Euclidean distances from all the timesteps."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{EMAD} = \\text{median} \\left( \\left\\{ \\lVert \\mathbf{x}^{(t)} - \\mathbf{m} \\rVert_{\\mathbb{R}^p}, t = 1, \\dots , N \\right\\}  \\right) \\end{align*}`"
msgstr ""

#: 
msgid "In GeoMAD, the MADs are calculated from the same ten bands used in the geomedian, therefore :math:`p=10`. The result of :math:`\\lVert \\mathbf{x}^{(t)} - \\mathbf{m} \\rVert_{\\mathbb{R}^p}` is a positive scalar, so :math:`\\text{EMAD}_\\text{GeoMAD}` is a positive scalar number. As in the geomedian, :math:`N` is dependent on the number of satellite flyovers particular to that pixel."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{EMAD}_\\text{GeoMAD} = \\text{median} \\left( \\left\\{ \\lVert \\mathbf{x}^{(t)} - \\mathbf{m} \\rVert_{\\mathbb{R}^{10}}, t = 1, \\dots , N \\right\\}  \\right) \\end{align*}`"
msgstr ""

#: 
msgid "The maximum possible value for EMAD depends on the value ranges for each of the bands in the dataset. In the case of GeoMAD, which uses at maximum annual timescales of ten bands of Sentinel-2 data, valid EMAD values range from ``0 - 31623``."
msgstr ""

#: 
msgid "EMAD is useful for showing albedo shifts in satellite spectra."
msgstr ""

#: 
msgid "Spectral MAD (SMAD)"
msgstr ""

#: 
msgid "The spectral MAD (SMAD) is based on the median absolute deviations in the cosine distance between the geomedian and individual measurements."
msgstr ""

#: 
msgid "In two dimensions, cosine distance can be graphically compared to Euclidean distance by the following figure:"
msgstr ""

#: 
msgid "**Figure 6: Relative relationships between Euclidean and cosine distances.**"
msgstr ""

#: 
msgid "Cosine distance"
msgstr ""

#: 
msgid "In a general sense, cosine distance is related to the angle between the two points :math:`\\theta`, while Euclidean distance is related to the straight-line distance between the two points :math:`d`. Like Euclidean distance, points are more similar when the cosine distance between them is small. The value of the cosine distance is smaller when :math:`\\theta` is small (i.e. close to 0) or when :math:`\\theta` is close to 180\\ :math:`^{\\circ}`."
msgstr ""

#: 
msgid "Notice we could have a small cosine distance but a large Euclidean distance; for example, if the angle between the vectors is small, but one is much longer than the other. This is an important property of cosine distance (and thus SMAD) - unlike Euclidean distance, cosine distance is not skewed by the magnitude of the measurements."
msgstr ""

#: 
msgid "Cosine distance is defined more formally as:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{Cosine distance (two dimensions)} = 1 - \\frac{x_1 y_1 + x_2 y_2}{ \\left( \\sqrt{ \\left( x_1\\right) ^2 + \\left( x_2\\right) ^2 } \\right) \\left( \\sqrt{ \\left( y_1\\right) ^2 + \\left( y_2\\right) ^2 } \\right)} \\end{align*}`"
msgstr ""

#: 
msgid "For more than two dimensions, we can generalise the cosine distance formula for a single pixel. For a multispectral measurement of :math:`p` bands at timestep :math:`t`, :math:`\\mathbf{x}^{(t)}`, and the geomedian at the same point :math:`\\mathbf{m}`, the cosine distance is:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*}\\small &\\text{Multispectral cosdist}\\left( \\mathbf{x}^{(t)}, m \\right) \\text{ for timestep } t  \\\\ &= 1 - \\frac{ \\mathbf{x}^{(t)} \\cdot \\mathbf{m} }{ \\lVert \\mathbf{x}^{(t)} \\rVert \\ \\lVert \\mathbf{m} \\rVert} \\ \\text{ for }  \\mathbf{x}^{(t)}, \\mathbf{m} \\in \\mathbb{R}_{p}\\\\ &=  1 - \\left( \\frac{\\left( x_{\\text{band 1}}^{(t)} \\right) \\left(m_{\\text{band 1}} \\right) + \\left( x_{\\text{band 2}}^{(t)} \\right) \\left(m_{\\text{band 2}} \\right) + \\cdots + \\left( x_{\\text{band p}}^{(t)} \\right) \\left(m_{\\text{band p}} \\right)}{ \\left(\\sqrt{\\left( x_{\\text{band 1}}^{(t)} \\right)^2 + \\cdots+ \\left( x_{\\text{band p}}^{(t)} \\right)^2} \\right) \\left( \\sqrt{\\left( m_{\\text{band 1}} \\right)^2 + \\cdots+ \\left( m_{\\text{band p}} \\right)^2 } \\right)} \\right) \\end{align*}`"
msgstr ""

#: 
msgid "Then for :math:`N` timesteps, SMAD is the median of the cosine distances."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{SMAD} = \\text{median} \\left( \\left\\{ \\text{cosdist}\\left( \\mathbf{x}^{(t)}, \\mathbf{m} \\right), t = 1, \\dots , N \\right\\}  \\right) \\end{align*}`"
msgstr ""

#: 
msgid "As with the other distances and dissimilarities used in the MADs, this results in a positive scalar value, thus SMAD is a positive scalar. Valid values for SMAD fall between ``0`` – ``1``."
msgstr ""

#: 
msgid "In applications of Earth observation data, SMAD is useful for showing areas of land cover change. One reason is that SMAD is less affected by cloud; unlike EMAD, it is invariant to albedo changes, such as that caused by the diffusion of solar radiation. SMAD can also be used to track water bodies, as water has high variation in reflectance."
msgstr ""

#: 
msgid "Bray-Curtis MAD (BCMAD)"
msgstr ""

#: 
msgid "The Bray-Curtis MAD (BCMAD) is calculated from the Bray-Curtis dissimilarity. The Bray-Curtis dissimilarity emphasises differences in each band between the measurement and the geomedian."
msgstr ""

#: 
msgid "For a single band of satellite data, the Bray-Curtis dissimilarity looks remarkably like a normalised band index. For example, if we only had red band data, it might look something like this:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{Single-band Bray-Curtis dissimilarity at timestep }t = \\frac{\\left| x_{\\text{red}}^{(t)} - m_{\\text{red}}\\right|}{ \\left| x_{\\text{red}}^{(t)} + m_{\\text{red}} \\right| } \\end{align*}`"
msgstr ""

#: 
msgid "It can be generalised to a multispectral dataset with :math:`p` bands:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} &\\text{Multispectral Bray-Curtis dissimilarity for timestep }t\\\\ &= \\frac{\\left| x_{\\text{band 1}}^{(t)} - m_{\\text{band 1}}\\right| + \\left| x_{\\text{band 2}}^{(t)} - m_{\\text{band 2}} \\right| + \\dots + \\left| x_{\\text{band p}}^{(t)} - m_{\\text{band p}} \\right| }{ \\left| x_{\\text{band 1}}^{(t)} + m_{\\text{band 1}} \\right| + \\left| x_{\\text{band 2}}^{(t)} + m_{\\text{band 2}} \\right| + \\dots + \\left| x_{\\text{band p}}^{(t)} + m_{\\text{band p}} \\right|} \\end{align*}`"
msgstr ""

#: 
msgid "The Bray-Curtis dissimilarity will be maximised at a value of ``1`` when the measurements in each band are completely different. Conversely, the value of the dissimilarity will be small where each band observation is similar to the geomedian of that band."
msgstr ""

#: 
msgid "As with the other MADs, the BCMAD is found by taking the median of all the Bray-Curtis dissimilarities from :math:`N` timesteps. For GeoMAD, :math:`p=10`."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{BCMAD} = \\text{median} \\left( \\left\\{ \\frac{\\left| \\mathbf{x}^{(t)} - \\mathbf{m}  \\right|_{\\mathbb{R}^p}}{\\left| \\mathbf{x}^{(t)} + \\mathbf{m}  \\right| _{\\mathbb{R}^p}}, t = 1, \\dots , N \\right\\}  \\right) \\end{align*}`"
msgstr ""

#: 
msgid "BCMAD takes on values from ``0 - 1``."
msgstr ""

#: 
msgid "Appendix"
msgstr ""

#: 
msgid "Example: calculating Euclidean distance"
msgstr ""

#: 
msgid "Let's take a selection of bands from one pixel, from one timestep. For that pixel, we have both the measurements taken by the single satellite flyover, and the geomedian value."
msgstr ""

#: 
msgid "**Table A.1: Example multispectral data - one timestep, four bands**"
msgstr ""

#: 
msgid "Band"
msgstr ""

#: 
msgid "Surface reflectance measurement :math:`x^{(t)}`"
msgstr ""

#: 
msgid "Surface reflectance geomedian :math:`m`"
msgstr ""

#: 
msgid "Blue"
msgstr ""

#: 
msgid "1028"
msgstr ""

#: 
msgid "969"
msgstr ""

#: 
msgid "Green"
msgstr ""

#: 
msgid "1468"
msgstr ""

#: 
msgid "1406"
msgstr ""

#: 
msgid "Red"
msgstr ""

#: 
msgid "2176"
msgstr ""

#: 
msgid "2032"
msgstr ""

#: 
msgid "Near Infrared (NIR) 1"
msgstr ""

#: 
msgid "3090"
msgstr ""

#: 
msgid "3078"
msgstr ""

#: 
msgid "Then the Euclidean distance for this pixel at this timestep, :math:`t`, is:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} &\\text{Euclidean distance} \\\\ \\tiny &= \\sqrt{\\left( x^{(t)}_{\\text{band 1}} - m_{\\text{band 1}} \\right)^2 + \\left( x^{(t)}_{\\text{band 2}} - m_{\\text{band 2}} \\right)^2  + \\dots  + \\left( x^{(t)}_{\\text{band p}} - m_{\\text{band p}} \\right)^2 }\\\\ &= \\sqrt{\\left( x^{(t)}_{\\text{red}} - m_{\\text{red}} \\right)^2 + \\left( x^{(t)}_{\\text{green}} - m_{\\text{green}} \\right)^2  + \\left( x^{(t)}_{\\text{blue}} - m_{\\text{blue}} \\right)^2 + \\left( x^{(t)}_{\\text{nir1}} - m_{\\text{nir1}} \\right)^2}\\\\ &= \\sqrt{\\left( 2176 - 2032 \\right)^2 + \\left( 1468 - 1406 \\right)^2  + \\left(1028 - 969 \\right)^2 + \\left( 3090 - 3078 \\right)^2}\\\\ &= 167.9 \\end{align*}`"
msgstr ""

#: 
msgid "To then find the EMAD of this dataset, the calculation for Euclidean distance would first need to be repeated for all the other timesteps (not provided in the example data)."
msgstr ""

#: 
msgid "Example: calculating cosine distance"
msgstr ""

#: 
msgid "Using the example multispectral data from Table A.1, we can manually calculate the value of cosine distance for timestep :math:`t`."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} &\\text{Cosine distance} \\\\ &= 1 - \\left( \\frac{\\left( x_{\\text{band 1}}^{(t)} \\right) \\left(m_{\\text{band 1}} \\right) + \\left( x_{\\text{band 2}}^{(t)} \\right) \\left(m_{\\text{band 2}} \\right) + \\cdots + \\left( x_{\\text{band p}}^{(t)} \\right) \\left(m_{\\text{band p}} \\right)}{ \\left(\\sqrt{\\left( x_{\\text{band 1}}^{(t)} \\right)^2 + \\cdots+ \\left( x_{\\text{band p}}^{(t)} \\right)^2} \\right) \\left( \\sqrt{\\left( m_{\\text{band 1}} \\right)^2 + \\cdots+ \\left( m_{\\text{band p}} \\right)^2 } \\right)} \\right) \\\\ &= 1 -\\\\ & \\ \\frac{\\left( x_{\\text{blue}}^{(t)} \\right) \\left(m_{\\text{blue}} \\right) + \\left( x_{\\text{green}}^{(t)} \\right) \\left(m_{\\text{green}} \\right) + \\left( x_{\\text{red}}^{(t)} \\right) \\left(m_{\\text{red}} \\right) + \\left( x_{\\text{nir1}}^{(t)} \\right) \\left(m_{\\text{nir1}} \\right)}{\\sqrt{\\left( x_{\\text{blue}}^{(t)} \\right)^2 + \\left( x_{\\text{green}}^{(t)} \\right)^2 + \\left( x_{\\text{red}}^{(t)} \\right)^2+ \\left( x_{\\text{nir1}}^{(t)} \\right)^2}\\sqrt{\\left( m_{\\text{blue}} \\right)^2 + \\left( m_{\\text{green}} \\right)^2 + \\left( m_{\\text{red}} \\right)^2 +  \\left(m_{\\text{nir1}}\\right)^2 } }\\\\ &=  1 -\\\\ & \\ \\frac{\\left( 1028 \\right) \\left(969 \\right) + \\left(1468 \\right) \\left(1406 \\right) + \\left(2176 \\right) \\left(2032\\right) + \\left( 3090 \\right) \\left(3078\\right)}{\\sqrt{\\left( 1028 \\right)^2 + \\left( 1468\\right)^2 + \\left( 2176 \\right)^2+ \\left(3090\\right)^2} \\sqrt{\\left( 969 \\right)^2 + \\left(1406 \\right)^2 + \\left( 2032\\right)^2 + \\left(3078 \\right)^2 }}\\\\ &=0.0004176 \\end{align*}`"
msgstr ""

#: 
msgid "Example: calculating Bray-Curtis dissimilarity"
msgstr ""

#: 
msgid "Using the example multispectral data from Table A.1, we can manually calculate the value of the Bray-Curtis dissimilarity for timestep :math:`t`."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} &\\text{Bray-Curtis dissimilarity} \\\\ &=  \\frac{\\left| x_{\\text{band 1}}^{(t)} - m_{\\text{band 1}}\\right| + \\left| x_{\\text{band 2}}^{(t)} - m_{\\text{band 2}} \\right| + \\dots + \\left| x_{\\text{band p}}^{(t)} - m_{\\text{band p}} \\right| }{ \\left| x_{\\text{band 1}}^{(t)} + m_{\\text{band 1}} \\right| + \\left| x_{\\text{band 2}}^{(t)} + m_{\\text{band 2}} \\right| + \\dots + \\left| x_{\\text{band p}}^{(t)} + m_{\\text{band p}} \\right|} \\\\ &=  \\frac{\\left| x_{\\text{nir1}}^{(t)} - m_{\\text{nir1}}\\right| + \\left| x_{\\text{green}}^{(t)} - m_{\\text{green}} \\right| + \\left| x_{\\text{red}}^{(t)} - m_{\\text{red}} \\right| + \\left| x_{\\text{blue}}^{(t)} - m_{\\text{blue}} \\right|}{\\left| x_{\\text{nir1}}^{(t)} + m_{\\text{nir1}}\\right| + \\left| x_{\\text{green}}^{(t)} + m_{\\text{green}} \\right| + \\left| x_{\\text{red}}^{(t)} + m_{\\text{red}} \\right| + \\left| x_{\\text{blue}}^{(t)} + m_{\\text{blue}} \\right|} \\\\ &= \\frac{\\left| 3090 - 3078\\right| + \\left| 1468 - 1406 \\right| + \\left|2176 - 2032 \\right| + \\left| 1028 - 969 \\right|}{\\left| 3090 + 3078\\right| + \\left| 1468 + 1406 \\right| + \\left|2176 + 2032 \\right| + \\left| 1028 + 969 \\right|}\\\\ &= 0.01817 \\end{align*}`"
msgstr ""

#: 
msgid "Global Mangrove Watch"
msgstr ""

#: 
msgid "The Global Mangrove Watch (GMW) dataset is a result of the collaboration between Aberystwyth University (U.K.), solo Earth Observation (soloEO; Japan), Wetlands International the World Conservation Monitoring Centre (UNEP-WCMC) and the Japan Aerospace Exploration Agency (JAXA). The primary objective of producing this dataset is to provide countries lacking a national mangrove monitoring system with first cut mangrove extent and change maps, to help safeguard against further mangrove forest loss and degradation."
msgstr ""

#: 
msgid "The Global Mangrove Watch dataset consists of a global baseline map of mangroves for 2010 and changes from this baseline for eleven epochs i.e. 1996, 2007, 2008, 2009 and 2015 to 2020. Annual maps are planned from 2018 and onwards. The dataset can be used to identify mangrove ecosystems and monitor changes in mangrove extent. This is important in applications such as quantifying 'blue carbon', mitigating risks from natural disasters, and prioritising restoration activities. For more information on the Global Watch Mangrove product see the `Global Mangrove Watch website <https://www.globalmangrovewatch.org/?map=eyJiYXNlbWFwIjoibGlnaHQiLCJ2aWV3cG9ydCI6eyJsYXRpdHVkZSI6MjAsImxvbmdpdHVkZSI6MCwiem9vbSI6MiwiYmVhcmluZyI6MCwicGl0Y2giOjB9fQ%3D%3D>`__."
msgstr ""

#: 
msgid "Digital Earth Africa provides free and open access to a copy of the Global Mangrove Watch product over Africa for the period 1996 to 2016 sourced from the UN Environment Program at https://data.unep-wcmc.org/datasets/45."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Global_Mangrove_Watch.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "Relevant metadata for the Global Mangrove Watch product can be viewed on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/gmw>`__."
msgstr ""

#: 
msgid "**Table 1: Global Mangrove Watch product specifications.**"
msgstr ""

#: 
msgid "Product Name"
msgstr ""

#: 
msgid "``gmw``"
msgstr ""

#: 
msgid "0.0002 (~20m)"
msgstr ""

#: 
msgid "1996 - 2020"
msgstr ""

#: 
msgid "The specific temporal and geographical extents for the product can be explored as an interactive map on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/gmw>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: Global Mangrove Watch product geographic extent.**"
msgstr ""

#: 
msgid "GMW Geographic Extent"
msgstr ""

#: 
msgid "**Table 2: Global Mangrove Watch product measurements.**"
msgstr ""

#: 
msgid "mangrove"
msgstr ""

#: 
msgid "Binary classification where 1 corresponds to mangroves and 0 is no mangroves."
msgstr ""

#: 
msgid "The Global Mangrove Watch global baseline map of mangroves for 2010 was generated by Extremely Randomized Trees classification of a combination of L-band ALOS PALSAR (radar) and Landsat-5 and Landsat-7 (optical) satellite data covering the coastlines along the tropical and sub-tropical coastlines in the Americas, Africa, Asia and Oceania. The classification was constrained using a mangrove habitat mask, which defined regions where mangrove ecosystems likely exist. This definition was based on geographical parameters such as latitude, elevation and distance from ocean water. Mangrove pixels forming the classification training data were randomly extracted from a union of existing global mangrove maps from `Giri et al., 2011 <https://doi.org/10.1111/j.1466-8238.2010.00584.x>`__ and `Spalding et al. 2010 <https://doi.org/10.4324/9781849776608>`__. The generation of the global baseline map is covered in `Bunting, P. et al., 2018 <https://www.mdpi.com/2072-4292/10/10/1669>`__."
msgstr ""

#: 
msgid "The changes in mangrove forest extent from the 2010 baseline map to 2014 and after, were derived from ALOS-2 PALSAR-2 (radar) data whereas historic changes in mangrove forest exent were derived from JERS-1 and ALOS PALSAR (radar) data using a histogram thresholding approach `Thomas et al., 2017 <https://doi.org/10.1371/journal.pone.0179302>`__."
msgstr ""

#: 
msgid "**Figure 2: Global Mangrove Watch mangrove extent along the coast of Mozambique in the year 1996.**"
msgstr ""

#: 
msgid "GMW Mozambique"
msgstr ""

#: 
msgid "*Credit: Contains the Global Mangrove Watch product courtesy of the UN Environment World Conservation Monitoring Centre processed by Digital Earth Africa.*"
msgstr ""

#: 
msgid "Bunting P., Rosenqvist A., Lucas R., Rebelo L-M., Hilarides L., Thomas N., Hardy A., Itoh T., Shimada M. and Finlayson C.M. (2018). The Global Mangrove Watch – a New 2010 Global Baseline of Mangrove Extent. Remote Sensing 10(10): 1669. doi: 10.3390/rs1010669."
msgstr ""

#: 
msgid "Thomas N, Lucas R, Bunting P, Hardy A, Rosenqvist A, Simard M. (2017). Distribution and drivers of global mangrove forest change, 1996-2010. PLOS ONE 12: e0179302. doi: 10.1371/journal.pone.0179302"
msgstr ""

#: 
msgid "`Global Mangrove Watch Metadata <https://data.unep-wcmc.org/pdfs/45/GMW_001_Metadata.pdf?1560444488>`__"
msgstr ""

#: 
msgid "`Global Mangrove Watch (GMW) online platform <https://www.globalmangrovewatch.org/>`__"
msgstr ""

#: 
msgid "The Global Mangrove Watch dataset is available under a Creative Commons Attribution 4.0 International (CC BY 4.0) license. See https://creativecommons.org/licenses/by/4.0/ for details."
msgstr ""

#: 
msgid "The Global Mangrove Watch dataset was generated by Aberystwyth University and soloEO within the framework of the Global Mangrove Watch (GMW) project, which is a part of the Japan Aerospace Exploration Agency’s (JAXA) Kyoto & Carbon Initiative and the Mangrove Capital Africa Programme coordinated by Wetlands International and financed by DOB Ecology."
msgstr ""

#: 
msgid "The Global Mangrove Watch product is available in AWS S3."
msgstr ""

#: 
msgid "The file paths follow the format: ``s3://deafrica-input-datasets/gmw/<year>/``."
msgstr ""

#: 
msgid "The Global Mangrove Watch product ``gmw`` is available through the Digital Earth Africa's OWS."
msgstr ""

#: 
msgid "The Global Forest Watch product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``gmw``"
msgstr ""

#: 
msgid "The ``gmw`` product has only one specific band of data which can be called by using the default name, ``mangrove``, or by the band’s alternative name, ``classification``, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load the ``mangrove`` band."
msgstr ""

#: 
msgid "**Table 4: ODC product gmw band names.**"
msgstr ""

#: 
msgid "The quality of Global Mangrove Watch was assessed in 2018 by assessing the classification accuracy over 53,800 randomly sampled points accross 20 randomly selected regions. The global overall accuracy was found to be 95.25% with the user's and producer's accuracies for the mangrove class estimated at 97.5% and 94.0% respectively. The validation method is described in `Bunting, P. et al., 2018 <https://www.mdpi.com/2072-4292/10/10/1669>`__."
msgstr ""

#: 
msgid "ESRI Global Land Use Land Cover"
msgstr ""

#: 
msgid "**Date modified:** 02 August 2022"
msgstr ""

#: 
msgid "The ESRI global land use land cover (LULC) map at 10 meter resolution was developed by the `Impact Observatory (IO) <https://www.impactobservatory.com/global_maps>`__ with the `Environmental Systems Research Institute (ESRI) <https://livingatlas.arcgis.com/landcover/>`__ and in patnership with `Microsoft AI for Earth <https://www.microsoft.com/en-us/ai/ai-for-earth>`__."
msgstr ""

#: 
msgid "Digital Earth Africa provides free and open access to a copy of the ESRI/IO Land Cover product over Africa."
msgstr ""

#: 
msgid "Relevant metadata for the ESRI/IO Land Cover product can be viewed on the DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/io_lulc>`__."
msgstr ""

#: 
msgid "**Table 1: ESRI/IO Land Cover product specifications**"
msgstr ""

#: 
msgid "``io_lulc``"
msgstr ""

#: 
msgid "0.0000898° (~10m)"
msgstr ""

#: 
msgid "``Product has no default CRS.``"
msgstr ""

#: 
msgid "2017 - 2021"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the `DE Africa Metadata Explorer <https://explorer.digitalearth.africa/products/io_lulc>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: ESRI/IO Land Cover product geographic extent**"
msgstr ""

#: 
msgid "ESRI LULC Geographic Extent"
msgstr ""

#: 
msgid "**Table 2: ESRI/IO Land Cover product measurements**"
msgstr ""

#: 
msgid "data"
msgstr ""

#: 
msgid "The ESRI/IO global LULC map is derived from the European Space Agency (ESA) Sentinel-2 imagery. A deep learning AI land classification model was trained using a massive training dataset curated by the National Geographic Society. This dataset contains over 5 billion hand-labelled Sentinel-2 imagery pixels, from 6 bands of surface reflectance data: visible blue, green, red, near infrared, and two shortwave infrared bands. The pixels were sampled from over 20,000 sites distributed across all major biomes of the world."
msgstr ""

#: 
msgid "The UNET, deep learning model was applied to multiple ESA Sentinel-2 scenes across a year, accessed via Microsoft’s Planetary Computer and scaled using Microsoft Azure Batch. The images were classified into 9 discrete land use/land cover classes. The LULC predictions were then composited to generate a representative map of the year."
msgstr ""

#: 
msgid "The original Esri 2020 Land Cover collection uses 10 classes and an older version of the underlying deep learning model. This new map uses an updated model from the 10-class model and combines Grass(formerly class 3) and Scrub (formerly class 6) into a single Rangeland class (class 11)."
msgstr ""

#: 
msgid "**Figure 2: ESRI/IO Land Cover classification for Madagascar in 2020**"
msgstr ""

#: 
msgid "IO LULC Geographic Extent"
msgstr ""

#: 
msgid "Karra, C. Kontgis, Z. Statman-Weil, J. C. Mazzariello, M. Mathis and S. P. Brumby, \"Global land use / land cover with Sentinel 2 and deep learning,\" 2021 *IEEE International Geoscience and Remote Sensing Symposium IGARSS*, 2021, pp. 4704-4707, doi: 10.1109/IGARSS47720.2021.9553499."
msgstr ""

#: 
msgid "Kontgis, C. (2021, June 24). `Mapping the world in unprecedented detail <https://caitlin-kontgis.medium.com/mapping-the-world-in-unprecedented-detail-7c0513205b90>`__"
msgstr ""

#: 
msgid "This data is licensed under a Creative Commons by Attribution (CC BY 4.0) license."
msgstr ""

#: 
msgid "Credits: Impact Observatory, Microsoft, and Esri"
msgstr ""

#: 
msgid "The ESRI/IO Land Cover product ``io_lulc`` is available through the Digital Earth Africa's OWS."
msgstr ""

#: 
msgid "The ESRI/IO Land Cover product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``io_lulc``"
msgstr ""

#: 
msgid "The ``io_lulc`` product has only one specific band of data which can be called by using the default name, ``data``, or by the band’s alternative name, ``classification``, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load the ``data`` band."
msgstr ""

#: 
msgid "**Table 4: ODC product io_lulc band names.**"
msgstr ""

#: 
msgid "Accuracy assessment of the ESRI 2020 Land Cover"
msgstr ""

#: 
msgid "The original Esri 2020 Land Cover collection uses 10 classes and an older version of the underlying deep learning model."
msgstr ""

#: 
msgid "Following best practices for accuracy assessment, Impact Observatory adjusted the acreage estimates for each land cover class in the ESRI 2020 Land Cover product using its respective user’s accuracy as computed from the comparison to the validation set. The deep learning land cover classification model achieved an overall accuracy of 86% on the validation set. This approach also allowed Impact Observatory to produce a 95% confidence interval for each acreage estimate, providing users with a clearer picture of the accuracy and total area for each class. (From the `ESRI release page <https://www.arcgis.com/home/item.html?id=d6642f8a4f6d4685a24ae2dc0c73d4ac>`__)"
msgstr ""

#: 
msgid "**Figure 3: Confusion matrix of pixel counts evaluated against \"three expert strict\" gold standard validation tiles**"
msgstr ""

#: 
msgid "*Image courtesy of ESRI.*"
msgstr ""

#: 
msgid "Landsat Collection 2 Level-2 Surface Reflectance"
msgstr ""

#: 
msgid "**Date modified:** 14 February 2022"
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) provides free and open access to a copy of `Landsat Collection 2 Level-2 <https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-level-2-science-products>`__ products over Africa. These products are produced and provided by the United States Geological Survey (USGS)."
msgstr ""

#: 
msgid "The `Landsat series <https://www.usgs.gov/core-science-systems/nli/landsat>`__ of Earth Observation satellites, jointly led by USGS and NASA, have been continuously acquiring images of the Earth’s land surface since 1972. DE Africa provides data from Landsat 5, 7, 8, and 9 satellites, including historical observations dating back to late 1980s and regularly updated new acquisitions."
msgstr ""

#: 
msgid "New Level-2 Landsat 7, 8, and 9 data are available after approximately 25, 15, and 3 days, respectively, from acquisition. See `Landsat Collection 2 Generation Timeline <https://www.usgs.gov/media/images/landsat-collection-2-generation-timeline>`__ for details."
msgstr ""

#: 
msgid "USGS Landsat Collection 2 was released early 2021 and offers improved processing, geometric accuracy, and radiometric calibration compared to previous Collection 1 products. The Level-2 products are endorsed by the Committee on Earth Observation Satellites (CEOS) to be Analysis Ready Data (`CARD <https://ceos.org/ard/>`__)-compliant. This internationally-recognised certification ensures these products have been processed to a minimum set of requirements and organised into a form that allows immediate analysis with a minimum of additional user effort and interoperability both through time and with other datasets."
msgstr ""

#: 
msgid "USGS Landsat Collection 2 Level-2 includes:"
msgstr ""

#: 
msgid "Surface Reflectance"
msgstr ""

#: 
msgid "Surface Temperature"
msgstr ""

#: 
msgid "This document provides technical specifications for the Surface Reflectance product. Information for the Surface Temperature product can be found in the `Landsat Collection 2 Level-2 Surface Temperature specification <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_ST_specs.html>`__."
msgstr ""

#: 
msgid "Surface reflectance is the fraction of incoming solar radiation that is reflected from Earth's surface. Variations in satellite measured radiance due to atmospheric properties have been corrected for so images acquired over the same area at different times are comparable and can be used readily to detect changes on Earth's surface."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landsat_Surface_Reflectance.ipynb>`__ which demonstrates loading and using Landsat surface reflectance products in the Sandbox is also available."
msgstr ""

#: 
msgid "DE Africa provides Landsat Collection 2 Level-2 from Landsat 5, 7, 8, and 9 as seperate products. Relevant coverage and metadata can be viewed on DE Africa Metadata Exploer:"
msgstr ""

#: 
msgid "`Landsat 5 Collection 2 Level-2 Surface Reflectance <https://explorer.digitalearth.africa/products/ls5_sr>`__"
msgstr ""

#: 
msgid "`Landsat 7 Collection 2 Level-2 Surface Reflectance <https://explorer.digitalearth.africa/products/ls7_sr>`__"
msgstr ""

#: 
msgid "`Landsat 8 Collection 2 Level-2 Surface Reflectance <https://explorer.digitalearth.africa/products/ls8_sr>`__"
msgstr ""

#: 
msgid "`Landsat 9 Collection 2 Level-2 Surface Reflectance <https://explorer.digitalearth.africa/products/ls9_sr>`__"
msgstr ""

#: 
msgid "**Table 1: Landsat Collection 2 Level-2 Surface Reflectance product specifications**"
msgstr ""

#: 
msgid "Landsat 5"
msgstr ""

#: 
msgid "Landsat 7"
msgstr ""

#: 
msgid "Landsat 8"
msgstr ""

#: 
msgid "Landsat 9"
msgstr ""

#: 
msgid "Multispectral Scanner (MSS), Thematic Mapper (TM)"
msgstr ""

#: 
msgid "Enhanced Thematic Mapper (ETM+)"
msgstr ""

#: 
msgid "Operational Land Imager (OLI), Thermal Infrared Sensor (TIRS)"
msgstr ""

#: 
msgid "OLI-2, TIRS-2"
msgstr ""

#: 
msgid "UTM"
msgstr ""

#: 
msgid "Every 16 days"
msgstr ""

#: 
msgid "1999 – present"
msgstr ""

#: 
msgid "2013 – present"
msgstr ""

#: 
msgid "2021 – present"
msgstr ""

#: 
msgid "`Landsat Collection 2 Level-1 <https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-2-level-1-data>`__"
msgstr ""

#: 
msgid "NA (archive)"
msgstr ""

#: 
msgid "**Table 2: Landsat 5 and Landsat 7 Level-2 Surface Reflectance measurements**"
msgstr ""

#: 
msgid "Conversion\\ :math:`^\\ddagger`"
msgstr ""

#: 
msgid "Surface reflectance band 1 (Blue)"
msgstr ""

#: 
msgid "Unitless"
msgstr ""

#: 
msgid "``1-65455``"
msgstr ""

#: 
msgid "2.75e-05 \\* DN - 0.2"
msgstr ""

#: 
msgid "Surface reflectance band 2 (Green)"
msgstr ""

#: 
msgid "Surface reflectance band 3 (Red)"
msgstr ""

#: 
msgid "Surface reflectance band 4 (Near-Infrared (NIR))"
msgstr ""

#: 
msgid "Surface reflectance band 5 (Short Wavelength Infrared (SWIR) 1)"
msgstr ""

#: 
msgid "Surface reflectance band 7 (SWIR 2)"
msgstr ""

#: 
msgid "QA_PIXEL"
msgstr ""

#: 
msgid "Pixel quality"
msgstr ""

#: 
msgid "Bit Index"
msgstr ""

#: 
msgid "``0-65535``"
msgstr ""

#: 
msgid "QA_RADSAT"
msgstr ""

#: 
msgid "Radiometric saturation"
msgstr ""

#: 
msgid "SR_ATMOS \\_OPACITY"
msgstr ""

#: 
msgid "Atmospheric opacity"
msgstr ""

#: 
msgid "``0-32767``"
msgstr ""

#: 
msgid "``-9999``"
msgstr ""

#: 
msgid "0.001 \\* DN"
msgstr ""

#: 
msgid "SR_CLOUD \\_QA"
msgstr ""

#: 
msgid "Cloud mask quality"
msgstr ""

#: 
msgid "``0-255``"
msgstr ""

#: 
msgid ":math:`^\\ddagger` Physical measurement can be derived from the Digital Number (DN) stored in the product using the conversion equation listed."
msgstr ""

#: 
msgid "More inforamtion can be found from the `Landsat 4-7 Collection 2 Science Product Guide <https://www.usgs.gov/media/files/landsat-4-7-collection-2-level-2-science-product-guide>`__."
msgstr ""

#: 
msgid "**Table 3: Landsat 8 and Landsat 9 Level-2 Surface Reflectance measurements**"
msgstr ""

#: 
msgid "Landsat 8 and Landsat 9 Level-2 science products are generated using a different algorithm and have different output measurements compared to Landsat 5 and Landsat 7."
msgstr ""

#: 
msgid "Surface reflectance band 1 (Coastal Aerosol)"
msgstr ""

#: 
msgid "Surface reflectance band 2 (Blue)"
msgstr ""

#: 
msgid "Surface reflectance band 3 (Green)"
msgstr ""

#: 
msgid "Surface reflectance band 4 (Red)"
msgstr ""

#: 
msgid "Surface reflectance band 5 (NIR)"
msgstr ""

#: 
msgid "Surface reflectance band 6 (SWIR 1)"
msgstr ""

#: 
msgid "SR_QA \\_AEROSOL"
msgstr ""

#: 
msgid "Aerosol level"
msgstr ""

#: 
msgid "More inforamtion can be found from `Landsat 8 OLI/TIRS Collection 2 Science Product Guide <https://www.usgs.gov/media/files/landsat-8-collection-2-level-2-science-product-guide>`__ and `Landsat 8-9 OLI/TIRS Collection 2 Level 2 Data Format Control Book <https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book>`__"
msgstr ""

#: 
msgid "Quality assessment bands"
msgstr ""

#: 
msgid "Pixel quality assessment (QA_PIXEL) bands are generated by the CFMask algorithm. Different bit definitions are used because the cirrus band is only available on Landsat 8 and 9. This band is relevant to both Surface Reflectance and Surface Temperature products."
msgstr ""

#: 
msgid "**Table 4: Pixel quality assessment (QA_PIXEL) bit index.**"
msgstr ""

#: 
msgid "Bit"
msgstr ""

#: 
msgid "Landat 5 & 7"
msgstr ""

#: 
msgid "Landsat 8 & 9"
msgstr ""

#: 
msgid "Description Values"
msgstr ""

#: 
msgid "Fill"
msgstr ""

#: 
msgid "0 for image data; 1 for fill data"
msgstr ""

#: 
msgid "Dilated Cloud"
msgstr ""

#: 
msgid "0 for cloud is not dilated or no cloud; 1 for cloud dilation"
msgstr ""

#: 
msgid "2"
msgstr ""

#: 
msgid "Unused"
msgstr ""

#: 
msgid "Cirrus"
msgstr ""

#: 
msgid "0 for cirrus confidence is not; 1 for high confidence cirrus"
msgstr ""

#: 
msgid "3"
msgstr ""

#: 
msgid "Cloud"
msgstr ""

#: 
msgid "0 for cloud confidence is not high; 1 for high confidence cloud"
msgstr ""

#: 
msgid "Cloud Shadow"
msgstr ""

#: 
msgid "0 for Cloud Shadow Confidence is not high; 1 for high confidence cloud shadow"
msgstr ""

#: 
msgid "0 for Snow/Ice Confidence is not high; 1 for high confidence snow cover"
msgstr ""

#: 
msgid "6"
msgstr ""

#: 
msgid "Clear"
msgstr ""

#: 
msgid "0 if Cloud or Dilated Cloud bits are set; 1 if Cloud and Dilated Cloud bits are not set"
msgstr ""

#: 
msgid "7"
msgstr ""

#: 
msgid "Water"
msgstr ""

#: 
msgid "0 for land or cloud; 1 for water"
msgstr ""

#: 
msgid "8-9"
msgstr ""

#: 
msgid "Cloud Confidence"
msgstr ""

#: 
msgid "00 for no confidence level set; 01 Low confidence; 10 Medium confidence; 11 High confidence"
msgstr ""

#: 
msgid "10-11"
msgstr ""

#: 
msgid "Cloud Shadow Confidence"
msgstr ""

#: 
msgid "00 for no confidence level set; 01 Low confidence; 10 Reserved; 11 High confidence"
msgstr ""

#: 
msgid "12-13"
msgstr ""

#: 
msgid "Snow/Ice Confidence"
msgstr ""

#: 
msgid "14-15"
msgstr ""

#: 
msgid "Cirrus Confidence"
msgstr ""

#: 
msgid "Radiometric saturation quality assessment (QA_RADSAT) bands are different for Landsat 5, 7 and 8/9 because the sensors have different spectral bands. This band is relevant to both Surface Reflectance and Surface Temperature products."
msgstr ""

#: 
msgid "**Table 5: Radiometric saturation quality assessment (QA_RADSAT) bit index.**"
msgstr ""

#: 
msgid "Band 1 (Blue)"
msgstr ""

#: 
msgid "Band 1 (Coastal)"
msgstr ""

#: 
msgid "0 no saturation; 1 saturated data"
msgstr ""

#: 
msgid "Band 2 (Green)"
msgstr ""

#: 
msgid "Band 2 (Blue)"
msgstr ""

#: 
msgid "Band 3 (Red)"
msgstr ""

#: 
msgid "Band 3 (Green)"
msgstr ""

#: 
msgid "Band 4 (NIR)"
msgstr ""

#: 
msgid "Band 4 (Red)"
msgstr ""

#: 
msgid "Band 5 (SWIR1)"
msgstr ""

#: 
msgid "Band 5 (NIR)"
msgstr ""

#: 
msgid "Band 6 (TIR)"
msgstr ""

#: 
msgid "Band 6L (TIR)†"
msgstr ""

#: 
msgid "Band 6 (SWIR1)"
msgstr ""

#: 
msgid "Band 7 (SWIR2)"
msgstr ""

#: 
msgid "8"
msgstr ""

#: 
msgid "Band 6H (TIR)‡"
msgstr ""

#: 
msgid "Band 9 (Cirrus)"
msgstr ""

#: 
msgid "9"
msgstr ""

#: 
msgid "Dropped Pixel"
msgstr ""

#: 
msgid "0 Pixel present; 1 detector doesn’t have a value - no data"
msgstr ""

#: 
msgid "11"
msgstr ""

#: 
msgid "Terrain occlusion"
msgstr ""

#: 
msgid "0 no terrain occlusion; 1 terrain occlusion"
msgstr ""

#: 
msgid "12"
msgstr ""

#: 
msgid "13"
msgstr ""

#: 
msgid "15"
msgstr ""

#: 
msgid ":math:`^\\dagger`, :math:`^\\ddagger` For Landsat 7 products, the Band 6 TOA brightness temperature product is generated from ETM+ Band 6 High gain (6H) and Band 6 Low gain (6L) merged together. The merged Band 6 is comprised of pixels that are not saturated in Band 6H. When Band 6H pixels are saturated with a brightness temperature outside of the 6H dynamic range (from 240K to 322K), they will be filled with pixels from the 6L band even if those pixels are saturated."
msgstr ""

#: 
msgid "For Landsat 5 and 7, another cloud mask band (SR_CLOUD_QA) is available but is less accurate than the QA_PIXEL band."
msgstr ""

#: 
msgid "**Table 6: Landsat 5 and Landsat 7 cloud mask (SR_CLOUD_QA) bit index.**"
msgstr ""

#: 
msgid "Dark Dense Vegetation (DDV)"
msgstr ""

#: 
msgid "Cloud shadow"
msgstr ""

#: 
msgid "Adjacent to cloud"
msgstr ""

#: 
msgid "For Landsat 8 and 9, aerosol retrieval information that may have impacted the product is provided in a SR_Aerosol_QA band. The default \"Aerosol Level\" is Climatology (00), which means no aerosol correction was applied. Pixels with an \"Aerosol Level\" classified as high are not recommended for use."
msgstr ""

#: 
msgid "**Table 7: Landsat 8 and Landsat 9 aerosol level (SR_Aerosol_QA) bit index.**"
msgstr ""

#: 
msgid "Flag"
msgstr ""

#: 
msgid "0 Pixel is not fill; 1 Pixel is fill"
msgstr ""

#: 
msgid "Valid aerosol retrieval"
msgstr ""

#: 
msgid "0 Pixel retrieval is not valid; 1 Pixel retrieval is valid"
msgstr ""

#: 
msgid "0 Pixel is not water; 1 Pixel is water"
msgstr ""

#: 
msgid "Interpolated Aerosol"
msgstr ""

#: 
msgid "0 Pixel is not aerosol interpolated; 1 Pixel is aerosol interpolated"
msgstr ""

#: 
msgid "6-7"
msgstr ""

#: 
msgid "Aerosol Level"
msgstr ""

#: 
msgid "00 Climatology; 01 Low; 10 Medium; 11 High"
msgstr ""

#: 
msgid "Landsat Collection 2 Level-2 products are processed by the USGS from Collection 2 Level-1 inputs. Landsat 8-9 OLI surface reflectance products are generated using the Land Surface Reflectance Code (LaSRC) algorithm. Landsat 4-5 TM and Landsat 7 ETM+ surface reflectance products are generated using the Landsat Ecosystem Disturbance Adaptive Processing System (LEDAPS) algorithm."
msgstr ""

#: 
msgid "Landsat composites for Libya"
msgstr ""

#: 
msgid "**Figure 1: Landsat false color composites (highlighting vegetation) over an area in Tripoli District, Libya, showing changes between selected dates from 1984 to 2021.**"
msgstr ""

#: 
msgid "`Water Observations from Space <https://docs.digitalearthafrica.org/en/latest/data_specs/WOfS_specs.html>`__"
msgstr ""

#: 
msgid "`GeoMAD cloud-free composite services <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__"
msgstr ""

#: 
msgid "`Landsat Collection 2 Level-2 Surface Temperature <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_ST_specs.html>`__"
msgstr ""

#: 
msgid "`USGS Collection Level-2 website <https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2>`__"
msgstr ""

#: 
msgid "`Landsat 8-9 OLI/TIRS Collection 2 Level-2 <https://doi.org/10.5066/P9OGBGM6>`__"
msgstr ""

#: 
msgid "`Landsat 7 ETM+ Collection 2 Level-2 <https://doi.org/10.5066/P9C7I13B>`__"
msgstr ""

#: 
msgid "`Landsat 4-5 TM Collection 2 Level-2 <https://doi.org/10.5066/P9IAXOVV>`__"
msgstr ""

#: 
msgid "There are no restrictions on Landsat data downloaded from the USGS; it can be used or redistributed as desired. USGS request that you include a `statement of the data source <https://www.usgs.gov/centers/eros/data-citation?qt-science_support_page_related_con=0#qt-science_support_page_related_con>`__ when citing, copying, or reprinting USGS Landsat data or images."
msgstr ""

#: 
msgid "Landsat Level- 2 Surface Reflectance Science Product courtesy of the U.S. Geological Survey."
msgstr ""

#: 
msgid "Landsat Collection 2 Level-2 is available in AWS S3, sponsored by the `Public Dataset Program <https://registry.opendata.aws/deafrica-landsat/>`__."
msgstr ""

#: 
msgid "**Table 8: AWS data access details.**"
msgstr ""

#: 
msgid "``arn:aws:s3:::deafrica-landsat``"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-landsat/``"
msgstr ""

#: 
msgid "The file paths follow the format ``collection02/level-2/standard/<sensor>/<year>/<path>/<row>/<scene_id>/``."
msgstr ""

#: 
msgid "**Table 9: AWS file path convention.**"
msgstr ""

#: 
msgid "``sensor``"
msgstr ""

#: 
msgid "Landsat sensor name, ``tm``, ``etm`` or ``oli-tirs`` for landsat 5, 7 and 8/9"
msgstr ""

#: 
msgid "``oli-tirs``"
msgstr ""

#: 
msgid "``2021``"
msgstr ""

#: 
msgid "Landsat orbit path id"
msgstr ""

#: 
msgid "``172``"
msgstr ""

#: 
msgid "Landsat orbit row id"
msgstr ""

#: 
msgid "``057``"
msgstr ""

#: 
msgid "``scene_id``"
msgstr ""

#: 
msgid "Landsat scene id"
msgstr ""

#: 
msgid "``LC08_L2SP_172057_20210101_20210308_02_T1``"
msgstr ""

#: 
msgid "**Table 10: OWS data access details.**"
msgstr ""

#: 
msgid "``ls5_sr``, ``ls7_sr``, ``ls8_sr``, ``ls9_sr``"
msgstr ""

#: 
msgid "**ODC product names:** ``ls5_sr``, ``ls7_sr``, ``ls8_sr``, ``ls9_sr``"
msgstr ""

#: 
msgid "**Table 11: Landsat 5 and Landsat 7 Level-2 Surface Reflectance (ODC product ls5_sr and ls7_sr) band names.**"
msgstr ""

#: 
msgid "pq, pixel_quality"
msgstr ""

#: 
msgid "radsat, radiometric_saturation"
msgstr ""

#: 
msgid "SR_ATMOS_OPACITY"
msgstr ""

#: 
msgid "atmos_opacity"
msgstr ""

#: 
msgid "SR_CLOUD_QA"
msgstr ""

#: 
msgid "cloud_qa"
msgstr ""

#: 
msgid "**Table 12: Landsat 8 and Landsat 9 Level-2 Surface Reflectance (ODC product ls8_sr and ls9_sr) band names.**"
msgstr ""

#: 
msgid "band_1, coastal_aerosol"
msgstr ""

#: 
msgid "SR_QA_AEROSOL"
msgstr ""

#: 
msgid "qa_aerosol, aerosol_qa"
msgstr ""

#: 
msgid "The surface reflectance products for Landat 5, 7, 8, and 9 are generated using two different methods."
msgstr ""

#: 
msgid "Landsat 5 TM and Landsat 7 ETM+ Collection 2 Surface Reflectance are generated using the Landsat Ecosystem Disturbance Adaptive Processing System (LEDAPS) algorithm. The software applies Moderate Resolution Imaging Spectroradiometer (MODIS) atmospheric correction routines to Level-1 data products. Water vapor, ozone, atmospheric height, aerosol optical thickness, and digital elevation are input with Landsat data to the Second Simulation of a Satellite Signal in the Solar Spectrum (6S) radiative transfer models to generate top of atmosphere (TOA) reflectance, surface reflectance, TOA brightness temperature, and masks for clouds, cloud shadows, adjacent clouds, land, and water."
msgstr ""

#: 
msgid "Landsat 8 and Landsat 9 OLI Collection 2 Surface Reflectance data are generated using the Land Surface Reflectance Code (LaSRC), which makes use of the coastal aerosol band to perform aerosol inversion tests, uses auxiliary climate data from MODIS, and a unique radiative transfer model."
msgstr ""

#: 
msgid "For more information on the different processing algorithms and caveats of the products, visit the `Landsat Collection 2 Surface Reflectance webpage <https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-surface-reflectance>`__."
msgstr ""

#: 
msgid "Landsat Collection 2 Level-2 Surface Temperature"
msgstr ""

#: 
msgid "This document provides technical specifications for the Surface Temperature product. Information for the Surface Refletance product can be found in the `Landsat Collection 2 Level-2 Surface Reflectance specification <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html>`__."
msgstr ""

#: 
msgid "Surface temperature measures the Earth’s surface temperature and is an important geophysical parameter in global energy balance studies and hydrologic modeling. Surface temperature is also useful for monitoring crop and vegetation health, and extreme heat events such as natural disasters (e.g., volcanic eruptions, wildfires), and urban heat island effects."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landsat_Surface_Temperature.ipynb>`__ which demonstrates loading and using Landsat surface temperature products in the Sandbox is also available."
msgstr ""

#: 
msgid "`Landsat 5 Collection 2 Level-2 Surface Temperature <https://explorer.digitalearth.africa/products/ls5_st>`__"
msgstr ""

#: 
msgid "`Landsat 7 Collection 2 Level-2 Surface Temperature <https://explorer.digitalearth.africa/products/ls7_st>`__"
msgstr ""

#: 
msgid "`Landsat 8 Collection 2 Level-2 Surface Temperature <https://explorer.digitalearth.africa/products/ls8_st>`__"
msgstr ""

#: 
msgid "`Landsat 9 Collection 2 Level-2 Surface Temperature <https://explorer.digitalearth.africa/products/ls9_st>`__"
msgstr ""

#: 
msgid "**Table 1: Landsat Collection 2 Level-2 Surface Temperature product specifications**"
msgstr ""

#: 
msgid "**Table 2: Landsat 5 and Landsat 7 Surface Temperature Level-2 measurements**"
msgstr ""

#: 
msgid "ST_B6"
msgstr ""

#: 
msgid "Surface temperature band 6 (Thermal Infrared (TIR))"
msgstr ""

#: 
msgid "Kelvin"
msgstr ""

#: 
msgid "``1-65535``"
msgstr ""

#: 
msgid "0.00341802 \\* DN + 149.0"
msgstr ""

#: 
msgid "ST_TRAD"
msgstr ""

#: 
msgid "Thermal radiance"
msgstr ""

#: 
msgid "Wm\\ :math:`^{-2}`\\ sr\\ :math:`^{-1}`\\ :math:`\\mu`\\ m\\ :math:`^{-1}`"
msgstr ""

#: 
msgid "``0-22000``"
msgstr ""

#: 
msgid "ST_URAD"
msgstr ""

#: 
msgid "Upwell radiance"
msgstr ""

#: 
msgid "``0-28000``"
msgstr ""

#: 
msgid "ST_DRAD"
msgstr ""

#: 
msgid "Downwell radiance"
msgstr ""

#: 
msgid "ST_ATRAN"
msgstr ""

#: 
msgid "Atmospheric transmittance"
msgstr ""

#: 
msgid "``0-10000``"
msgstr ""

#: 
msgid "0.0001 \\* DN"
msgstr ""

#: 
msgid "ST_EMIS"
msgstr ""

#: 
msgid "Emissivity"
msgstr ""

#: 
msgid "ST_EMSD"
msgstr ""

#: 
msgid "Emissivity standard deviation"
msgstr ""

#: 
msgid "ST_CDIST"
msgstr ""

#: 
msgid "Distance to cloud"
msgstr ""

#: 
msgid "Kilometers"
msgstr ""

#: 
msgid "``0-24000``"
msgstr ""

#: 
msgid "0.01 \\* DN"
msgstr ""

#: 
msgid "ST_QA"
msgstr ""

#: 
msgid "Surface temperature uncertainty"
msgstr ""

#: 
msgid "**Table 3: Landsat 8 and Landsat 9 Level-2 Surface Temperature measurements**"
msgstr ""

#: 
msgid "ST_B10"
msgstr ""

#: 
msgid "Surface temperature band 10 (TIR)"
msgstr ""

#: 
msgid "Landsat Collection 2 Level-2 products are processed by the USGS from Collection 2 Level-1 inputs. Landsat 5, 7, 8, and 9 surface temperature products are generated using the Landsat surface temperature algorithm."
msgstr ""

#: 
msgid "Landsat surface temperature for Libya"
msgstr ""

#: 
msgid "**Figure 1: Landsat false color composites (highlighting vegetation, top row) and corresponding surface temperature measurements (in Kelvin, bottom row) over an area in Tripoli District, Libya.**"
msgstr ""

#: 
msgid "Landsat Level- 2 Surface Temperature Science Product courtesy of the U.S. Geological Survey."
msgstr ""

#: 
msgid "**Table 6: AWS data access details.**"
msgstr ""

#: 
msgid "**Table 7: AWS file path convention.**"
msgstr ""

#: 
msgid "**Table 8: OWS data access details.**"
msgstr ""

#: 
msgid "``ls5_st``, ``ls7_st``, ``ls8_st``, ``ls9_st``"
msgstr ""

#: 
msgid "**ODC product names:** ``ls5_st``, ``ls7_st``, ``ls8_st``, ``ls9_st``"
msgstr ""

#: 
msgid "**Table 9: Landsat 5 and Landsat 7 Level-2 Surface Temperature (ODC product ls5_st and ls7_st) band names.**"
msgstr ""

#: 
msgid "band_6, st, surface_temperature"
msgstr ""

#: 
msgid "trad, thermal_radiance"
msgstr ""

#: 
msgid "urad, upwell_radiance"
msgstr ""

#: 
msgid "drad, downwell_radiance"
msgstr ""

#: 
msgid "atran, atmospheric_transmittance"
msgstr ""

#: 
msgid "emis, emissivity"
msgstr ""

#: 
msgid "emsd, emissivity_stddev"
msgstr ""

#: 
msgid "cdist, cloud_distance"
msgstr ""

#: 
msgid "st_qa, surface_temperature_quality"
msgstr ""

#: 
msgid "**Table 10: Landsat 8 and Landsat 9 Level-2 Surface Temperature (ODC product ls8_st and ls9_st) band names.**"
msgstr ""

#: 
msgid "band_10, st, surface_temperature"
msgstr ""

#: 
msgid "The surface temperature product is generated from the Landsat Collection 2 Level-1 thermal infrared bands, Top of Atmosphere (TOA) reflectance, TOA brightness temperature, Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) Global Emissivity Database (GED) data, ASTER Normalized Difference Vegetation Index (NDVI) data, and atmospheric profiles of geopotential height, specific humidity, and air temperature extracted from Goddard Earth Observing System (GEOS) Model Version 5 Forward Processing Instrument Teams (FP-IT) (for acquisitions from 2000 to present) or Modern Era Retrospective analysis for Research and Applications Version 2 (MERRA-2) (for acquisitions from 1982 to 1999)."
msgstr ""

#: 
msgid "For more information and caveats of the product, visit the `Landsat Collection 2 Surface Temperature webpage <https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-surface-temperature>`__."
msgstr ""

#: 
msgid "The surface temperature product is provided at 30 m spatial sampling, however, the thermal sensors vary in spectral response, sensitivity and resolution."
msgstr ""

#: 
msgid "**Table 11: Landsat thermal sensors specification.**"
msgstr ""

#: 
msgid "Sensor"
msgstr ""

#: 
msgid "Spetral Band"
msgstr ""

#: 
msgid "Wavelength (µm)"
msgstr ""

#: 
msgid "Spatial Resolution (m)"
msgstr ""

#: 
msgid "Landsat 8/9"
msgstr ""

#: 
msgid "Thermal Infrared Sensor (TIRS)/TIRS-2"
msgstr ""

#: 
msgid "10.60 - 11.19"
msgstr ""

#: 
msgid "11.50 - 12.51"
msgstr ""

#: 
msgid "Enhanced Thematic Mapper Plus (ETM+)"
msgstr ""

#: 
msgid "10.31 - 12.36"
msgstr ""

#: 
msgid "60"
msgstr ""

#: 
msgid "Thematic Mapper (TM)"
msgstr ""

#: 
msgid "10.40 - 12.50"
msgstr ""

#: 
msgid "120"
msgstr ""

#: 
msgid "The Level-2 product provides a number of intermediate and quality bands for surface temperature measurement. These bands may help interpret the results."
msgstr ""

#: 
msgid "**Table 12: Surface temperature relevant bands.**"
msgstr ""

#: 
msgid "Explanation"
msgstr ""

#: 
msgid "Surface temperature (ST)"
msgstr ""

#: 
msgid "The temperature of the Earth’s surface in Kelvin (K)."
msgstr ""

#: 
msgid "Thermal radiance (ST_TRAD)"
msgstr ""

#: 
msgid "The values produced when thermal band reflectance is converted to radiance."
msgstr ""

#: 
msgid "Upwell radiance (ST_URAD)"
msgstr ""

#: 
msgid "The amount of electromagnetic radiation reflected upward from the ground’s surface."
msgstr ""

#: 
msgid "Downwellradiance (ST_DRAD)"
msgstr ""

#: 
msgid "The thermal energy radiated onto the ground by all objects in a hemisphere surrounding it."
msgstr ""

#: 
msgid "Atmospheric transmittance (ST_ATRAN)"
msgstr ""

#: 
msgid "The ratio of the transmitted radiation to the total radiation incident upon the medium (atmosphere)."
msgstr ""

#: 
msgid "Emissivity (ST_EMIS)"
msgstr ""

#: 
msgid "The ratio of the energy radiated from a material’s surface to that radiated from a blackbody."
msgstr ""

#: 
msgid "Emissivity_stdev (ST_EMSD)"
msgstr ""

#: 
msgid "The extent of deviation of the emissivity product. This layer is used along with cloud_distance to create the quality assessment product."
msgstr ""

#: 
msgid "Distance to cloud (ST_CDIST)"
msgstr ""

#: 
msgid "The distance, in kilometers, that a pixel is from the nearest cloud pixel. This layer is used along with emissivity_stdev to create the quality assessment product."
msgstr ""

#: 
msgid "Surface temperature uncertainty (ST_QA)"
msgstr ""

#: 
msgid "Provides the Surface Temperature product uncertainty using a combination of uncertainty values and distance to cloud values."
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:86
msgid "Water Observations from Space"
msgstr ""

#: 
msgid "**Date modified:** 02 March 2022"
msgstr ""

#: 
msgid "Water Observations from Space (WOfS) is a service that uses satellite images to provide historical surface water observations across the African continent. WOfS enables users to understand the location and movement of inland and coastal water over time. It shows where water is usually present; where it is seldom observed; and where inundation of the surface has been observed by satellite."
msgstr ""

#: 
msgid "The data are generated using the WOfS classification algorithm applied to Landsat satellite images. There are three WOfS products available in the collection for the African continent, as listed below:"
msgstr ""

#: 
msgid "Product Type"
msgstr ""

#: 
msgid "WOfS Feature Layer (WOFL)"
msgstr ""

#: 
msgid "Water and non-water classification generated per scene"
msgstr ""

#: 
msgid "WOfS Annual Summary"
msgstr ""

#: 
msgid "The ratio of wet to clear observations for each calendar year"
msgstr ""

#: 
msgid "WOfS All-Time Summary"
msgstr ""

#: 
msgid "The ratio of wet to clear observations for the full time period"
msgstr ""

#: 
msgid "**WOfS Feature Layer (WOFL):** Individual water-classified images are called Water Observation Feature Layers (WOFLs), and are created from the input satellite data. There is one WOFL for each satellite image processed showing the occurrence of water."
msgstr ""

#: 
msgid "**WOfS Annual/All-Time Summary:** The frequency of a pixel being classified as wet. This involves:"
msgstr ""

#: 
msgid "Total number of clear observations for each pixel: the number of observations that were clear (no cloud, cloud shadow or terrain shadow) for the selected time period. The classification algorithm then assigns these as either wet, or dry."
msgstr ""

#: 
msgid "Total number of wet observation for each pixel: the number of observations that were clear *and* wet for the selected time period."
msgstr ""

#: 
msgid "The WOfS summaries are calculated as the ratio of clear wet observations to total clear observations."
msgstr ""

#: 
msgid "\\text{WOfS Summary (Frequency) } = \\frac{\\text{Number of Clear and Wet Observations}}{\\text{Number of Clear Observations}}\n"
"\n"
""
msgstr ""

#: 
msgid "Relevant coverage and metadata for each of the three WOfS products can be viewed on DE Africa `Metadata Explorer <https://explorer.digitalearth.africa/products>`__:"
msgstr ""

#: 
msgid "`WOFLs <https://explorer.digitalearth.africa/products/wofs_ls>`__"
msgstr ""

#: 
msgid "`WOfS Annual Summary <https://explorer.digitalearth.africa/products/wofs_ls_summary_annual>`__"
msgstr ""

#: 
msgid "`WOfS All-Time Summary <https://explorer.digitalearth.africa/products/wofs_ls_summary_alltime>`__"
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Water_Observations_from_Space.ipynb>`__ which demonstrates loading and using WOfS products in the Sandbox is also available."
msgstr ""

#: 
msgid "WOfS Feature Layer"
msgstr ""

#: 
msgid "**Table 1: WOfS Feature Layer product specifications**"
msgstr ""

#: 
msgid "**Table 2: WOfS Feature Layer measurements**"
msgstr ""

#: 
msgid "WOFL water"
msgstr ""

#: 
msgid "``0 - 255``"
msgstr ""

#: 
msgid "The WOFL measurement ``water`` uses bit flags to allocate terrain characteristics to each pixel. Bit flags assign a unique decimal value to each characteristic. A pixel can hold multiple characteristics by summing the decimal values of each associated bit flag."
msgstr ""

#: 
msgid "**Table 3: WOfS Feature Layer bit flags**"
msgstr ""

#: 
msgid "Flagging"
msgstr ""

#: 
msgid "Decimal Value"
msgstr ""

#: 
msgid "no data"
msgstr ""

#: 
msgid "1 = pixel masked out due to NO_DATA in source, 0 = valid data"
msgstr ""

#: 
msgid "non-contiguity"
msgstr ""

#: 
msgid "At least one input band is missing or invalid"
msgstr ""

#: 
msgid "low solar angle"
msgstr ""

#: 
msgid "Solar incidence angle is less than 10 degrees"
msgstr ""

#: 
msgid "terrain shadow"
msgstr ""

#: 
msgid "Terrain shadow"
msgstr ""

#: 
msgid "high slope"
msgstr ""

#: 
msgid "16"
msgstr ""

#: 
msgid "Terrain slope (measured from SRTM) is larger than 12 degrees"
msgstr ""

#: 
msgid "cloud shadow"
msgstr ""

#: 
msgid "32"
msgstr ""

#: 
msgid "cloud"
msgstr ""

#: 
msgid "64"
msgstr ""

#: 
msgid "water observed"
msgstr ""

#: 
msgid "128"
msgstr ""

#: 
msgid "Classified as water by the decision tree"
msgstr ""

#: 
msgid "For example, a ``water`` value of ``136`` indicates water (``128``) AND terrain shadow (``8``) were observed for the pixel, whereas a value of ``144`` would indicate water (``128``) AND high slope (``16``)."
msgstr ""

#: 
msgid "WOFLs are useful for identifying the presence of water at a certain point in time, or over short durations (less than one year), and can be best utilised by people with knowledge of water observations with satellites, and their limitations. For annual or historical data, users can access the pre-calculated summary products detailed below."
msgstr ""

#: 
msgid "**Table 4: WOfS Annual Summary product specifications**"
msgstr ""

#: 
msgid "**Table 5: WOfS Annual Summary measurements**"
msgstr ""

#: 
msgid "count_wet"
msgstr ""

#: 
msgid "How many times a pixel was wet"
msgstr ""

#: 
msgid "``-999``"
msgstr ""

#: 
msgid "count_clear"
msgstr ""

#: 
msgid "How many times a pixel was clear"
msgstr ""

#: 
msgid "frequency"
msgstr ""

#: 
msgid "Frequency of water detection at a location"
msgstr ""

#: 
msgid "**Table 6: WOfS All-Time Summary specifications**"
msgstr ""

#: 
msgid "Single summary for the full temporal range"
msgstr ""

#: 
msgid "2 months from end of previous calendar year"
msgstr ""

#: 
msgid "**Table 7: WOfS All-Time Summary measurements**"
msgstr ""

#: 
msgid "All products in the WOfS collection have the same geographic extent. This is shown in Figure 1; data are available for the regions shaded in blue. Specific temporal and geographic extents can be explored as an interactive map on the Digital Earth Africa `Metadata Explorer <https://explorer.digitalearth.africa/products>`__. Different WOfS products can be selected from the horizontal dropdown menu at the top of the page."
msgstr ""

#: 
msgid "**Figure 1: Landsat WOfS colelction geographic extent**"
msgstr ""

#: 
msgid "The `Water Observations from Space Detection Algorithm <https://github.com/GeoscienceAustralia/wofs>`__ as described in `Mueller et al. (2016) <https://doi.org/10.1016/j.rse.2015.11.003>`__, is applied to the Landsat data to create the available WOfS products."
msgstr ""

#: 
msgid "**Image 1: Tagrin Bay, Sierra Leone. WOfS All-Time Summary.**"
msgstr ""

#: 
msgid "Colours indicate the percentage of times water was detected. Red is \"rarely water\", green is \"often water\", and blue is \"always water\"."
msgstr ""

#: 
msgid "Credit: U.S. Geological Survey Landsat data was used in compiling this image."
msgstr ""

#: 
msgid "WOfS All-Time Summary over Tagrin Bay."
msgstr ""

#: 
msgid "**Image 2: Bui Dam inlet, Ghana. Animation of WOfS annual Summary from 2004 to 2021.**"
msgstr ""

#: 
msgid "Intensity of colour indicates the percentage of times water was detected for that year. Dark blue is \"always water\", while light blue is \"rarely water\"."
msgstr ""

#: 
msgid "WOfS Annual Summary over Bui Dam, animated."
msgstr ""

#: 
msgid "**Image 3: Shiroro Reservoir, Nigeria. A WOfS Feature Layer (WOFL) from 13 March 2021.**"
msgstr ""

#: 
msgid "Colours are assigned by bit flag value. For more detail on WOFL bit flags, see Table 3."
msgstr ""

#: 
msgid "Credit: U.S. Geological Survey Landsat data was used in compiling this image. The plotting schema is attributed to the Digital Earth Australia `dea-tools <https://docs.dea.ga.gov.au/>`__ package."
msgstr ""

#: 
msgid "WOFL over Shiroro Reservoir."
msgstr ""

#: 
msgid "Mueller, N., Lewis, A., Roberts, D., Ring, S., Melrose, R., Sixsmith, J., Lymburner, L., McIntyre, A., Tan, P., Curnow, S., & Ip, A. (2016). Water observations from space: Mapping surface water from 25 years of Landsat imagery across Australia. Remote Sensing of Environment, 174, 341-352. `https://doi.org/10.1016/j.rse.2015.11.003 <%5Bhttps://doi.org/10.1016/j.rse.2015.11.003%5D>`__"
msgstr ""

#: 
msgid "The WOfS algorithms incorporated in this product are the work of Norman Mueller, Geoscience Australia, and Dr Dale Roberts, Australian National University."
msgstr ""

#: 
msgid "The Digital Earth Africa WOfS data can be accessed from the associated S3 bucket."
msgstr ""

#: 
msgid "**Table 8: AWS data access details**"
msgstr ""

#: 
msgid "``wofs_ls``, ``wofs_ls_summary_annual``, ``wofs_ls_summary_alltime``"
msgstr ""

#: 
msgid "The following file path convention applies to WOFLs:"
msgstr ""

#: 
msgid "``wofs_ls/<version>/<path>/<row>/<year>/<month>/<day>/``"
msgstr ""

#: 
msgid "Annual Summaries omit ``path``, ``row``, ``month`` and ``day``."
msgstr ""

#: 
msgid "``wofs_ls_summary_annual/<version>/<year>/``"
msgstr ""

#: 
msgid "The All-Time Summary additionally drops ``year``."
msgstr ""

#: 
msgid "``wofs_ls_summary_alltime/<version>/``"
msgstr ""

#: 
msgid "**Table 9: AWS file path convention**"
msgstr ""

#: 
msgid "``wofs_ls``, ``wofs_ls_summary_annual``, or ``wofs_ls_summary_alltime``"
msgstr ""

#: 
msgid "``wofs_ls``"
msgstr ""

#: 
msgid "The WOfS collection can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``wofs_ls``, ``wofs_ls_summary_annual``, ``wofs_ls_summary_alltime``"
msgstr ""

#: 
msgid "**Table 11: WOFL ODC band names**"
msgstr ""

#: 
msgid "The Annual Summary and the All-Time Summary have the same band names in the ODC."
msgstr ""

#: 
msgid "**Table 12: WOfS Annual/All-Time Summary ODC band names**"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:366
msgid "wet"
msgstr ""

#: 
msgid "clear"
msgstr ""

#: 
msgid "freq"
msgstr ""

#: 
msgid "The Water Observations from Space Detection Algorithm uses a decision tree method using both spectral band measurements and derived indices as input datasets. It also utilised several ancillary datasets, including slope."
msgstr ""

#: 
msgid "An illustration of the decision tree is shown in Figure 2."
msgstr ""

#: 
msgid "**Figure 2: WOfS Detection Algorithm decision tree. Tree branches are shown in green with endpoint for water and not-water displayed as blue and red respectively. Each branch indicates the variable used to split and the resulting balance of water and not-water samples created by the split. Source:** `Mueller et al. (2016) <https://doi.org/10.1016/j.rse.2015.11.003>`__."
msgstr ""

#: 
msgid "The decision tree underlying the WOfS algorithm."
msgstr ""

#: 
msgid "The Digital Earth Africa validation task team has many years’ of combined experience validating satellite-derived maps in different regions of Africa, and a long history of collaborating with a wide variety of stakeholders."
msgstr ""

#: 
msgid "To validate WOfS data, the continent was divided into seven Agro-Ecological Zones (AEZ). Analysts from within each regional geospatial organization labelled a large set of sample points using image interpretation of satellite and aerial imagery. Analysts applied their regional and local knowledge to help define class labels and interpret any difficult features, creating a validation dataset that is both accurate and fit for purpose. To ensure WOfS is as accurate as possible, it was validated against a range of data points. 2900 sample points were generated, covering the African continent, including the main islands."
msgstr ""

#: 
msgid "Typically, water classifiers are adept at mapping large, open water bodies - so for this exercise, water features with an area of more than 100 square kilometres were masked out. This ensured that analysis remained focused on areas that are more challenging to map, such as small water bodies with different colours, depths and surrounding environments."
msgstr ""

#: 
msgid "Stratified random sampling was then performed to select locations with different water occurrences and waterbody types. By focusing the sample on the more difficult-to-map areas, this sample scheme allowed the Digital Earth Africa team to understand the limitations of WOfS, and meant that WOfS could be compared to other available datasets. It also resulted in overall accuracy for this exercise appearing lower than expected, since the ‘easy to map’ areas had been removed from the sample design."
msgstr ""

#: 
msgid "Next, analysts labelled each sample point using a visual interpretation of sample points provided by online tool, Collect Earth Online (CEO). CEO allowed multiple analysts to assess points as water or non-water using satellite and aerial images. The labelled sample points were then compared with the WOfS map, determining where the WOfS map service agrees - or disagrees - with the validation dataset."
msgstr ""

#: 
msgid "The sampling design is independent of the WOfS classification, so this validation dataset can be used to provide quantitive comparisons with products such as future versions of WOfS, or other existing surface water maps."
msgstr ""

#: 
msgid "At a continental-scale, WOfS is able to accurately identify about 80% of the labelled water features (Figure 3, right). 94% of its water classifications are correct (Figure 3, left)."
msgstr ""

#: 
msgid "At the AEZ level, WOfS performs outstandingly in Eastern, Sahel and Northern AEZs with more than 85% of reference water features in these zones being correctly identified as water (Figure 3, centre). The reliability of this classification in the Eastern zone is also very high at more than 96%; and the WOfS classification in all seven AEZ proved to be reliable, with more than 84% user accuracy (Figure 3, left). The Western AEZ is a challenging zone with high cloud coverage and a wet climate, 77.5% of reference water features have been correctly identified as water in WOfS product, and 97.3% of these water features are actually water."
msgstr ""

#: 
msgid "**Figure 3: Overall WOfS accuracy, split by Agro-Ecological Zone.**"
msgstr ""

#: 
msgid "WOfS accuracies mapped by Agro-Ecological Zone."
msgstr ""

#: 
msgid "Limitations on Validation"
msgstr ""

#: 
msgid "During the WOfS validation assessment, a number of issues associated with input data, validation method and the WOfS algorithm were recognized. The validation results should be interpreted with the following caveats:"
msgstr ""

#: 
msgid "**Spatial resolution:** The WOfS product is based on 30 m resolution Landsat imagery while the validation data is produced using 10 m resolution Sentinel-2 imagery. WOfS has trouble in areas with mixed pixels (where a pixel covers both water and land). These areas tend to be on edges of lakes and in wetlands where there is a mix of water and vegetation. The Sentinel-2 imagery can identify these edges at a higher resolution than the current Landsat WOfS product."
msgstr ""

#: 
msgid "**Temporal resolution:** Reference locations may have been observed on different dates by the Sentinel-2 and the Landsat satellites. If the water extent has changed between the dates, a mismatch in the classification is expected."
msgstr ""

#: 
msgid "Interpreting WOfS"
msgstr ""

#: 
msgid "The WOfS service should be interpreted with caveats in the following situations:"
msgstr ""

#: 
msgid "**Mixed pixels:** Discretion should be used where a single pixel covers both water and land. These areas tend to occur on the edges of lakes, and in wetlands where there is a mix of water and vegetation."
msgstr ""

#: 
msgid "**Turbid or dark water:** The WOfS algorithm is developed to identify a diverse range of waterbodies. However, the classifier may miss dark water surfaces or water with high concentration of sediments. In some cases, the impact can be mitigated by using a temporal summary of WOfS, such as the Annual Summary or All-Time Summary. A waterbody may be missed in a single observation, but over the course of the year it is mapped as water in other dates and therefore mapped as a waterbody in the summary products."
msgstr ""

#: 
msgid "**Other environmental factors:** Sediment, floating vegetation and similar obstructions change the colour of water and can obfuscate water detection by WOfS."
msgstr ""

#: 
msgid "**Inaccurate input data:** Inaccurate input surface reflectance may lead to false classification in WOfS. To maximize coverage, all pixels within a valid surface reflectance range (0-1) from Landsat Collection 2 are used to generate the WOFLs. When creating WOfS summaries, only WOFLs processed from Landsat Tier 1 data with good geometric accuracy are used."
msgstr ""

#: 
msgid "Note that WOfS is not intended for studying ocean. Validation has been centred around inland and near-coastal waterbodies."
msgstr ""

#: 
msgid "Landsat Collection 2 tiers"
msgstr ""

#: 
msgid "**Date modified:** 22 December 2021"
msgstr ""

#: 
msgid "The Landsat Collection 2 tiers are the inventory structure used to categorise data products based on the data quality and level of processing. The purpose of the tiers is to support easier identification of suitable scenes for time-series pixel-level analysis and data stacking."
msgstr ""

#: 
msgid "The Landsat Collection 2 scenes are evaluated and categorised into 3 tiers:"
msgstr ""

#: 
msgid "Real time - not supported by DE Africa > This tier contains newly acquired imagery as all the scenes go here immediately after acquisition. After the final calibration, the scenes are transitioned to either Tier 1 or Tier 2 and removed from the Real-Time Tier. The radial Root Mean Square Error (RMSE) threshold of 12 meters for the georegestration image-to-image tolerances is used to determine whether the data goes into Tier 1 or Tier 2. Landsat 8 scenes are placed into the final tier within 14 to 16 days after acquisition while Landsat 7 scenes are placed within 26 days after acquisition."
msgstr ""

#: 
msgid "Tier 1 - DE Africa Sandbox Analysis-Ready Data default > Landsat scenes whose RMSE is less than or equal to 12 metres are categorized into Tier 1. This tier contains Landsat scenes with the highest available radiometric and positional data quality and are **considered suitable for time-series analysis**."
msgstr ""

#: 
msgid "Tier 2 - Can be accessed through DE Africa Sandbox > Landsat scenes whose RMSE is greater than 12 metres are categorized into Tier 2. This tier contains all the scenes that fail to meet the Tier 1 criteria during processing. This failure to meet the RMSE 12 meter threshold could be due to less accurate orbital information (specific to older Landsat sensors), significant cloud cover which affects the radiometric calibration and insufficient ground control points within the scenes."
msgstr ""

#: 
msgid "Jupyter notebooks which demonstrate loading and using Landsat surface reflectance and temperature in the Sandbox are also available:"
msgstr ""

#: 
msgid "https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landsat_Surface_Reflectance.ipynb"
msgstr ""

#: 
msgid "https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Landsat_Surface_Temperature.ipynb"
msgstr ""

#: 
msgid "Landsat data tiers in Digital Earth Africa"
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) provides free and open access to Landsat Collection 2 Level-2 products over Africa. The Landsat archive is produced and provided by the United States Geological Survey (USGS)."
msgstr ""

#: 
msgid "Digital Earth Africa Landsat Collection 2 Level-2 includes: \\* `Surface Reflectance <./Landsat_C2_SR_specs.ipynb>`__ \\* `Surface Temperature <./Landsat_C2_ST_specs.ipynb>`__"
msgstr ""

#: 
msgid "Tiers in the Digital Earth Africa Map"
msgstr ""

#: 
msgid "`Access the Digital Earth Africa Map <https://maps.digitalearth.africa/>`__"
msgstr ""

#: 
msgid "All available (Tier 1 and Tier 2) data is displayed when selecting Landsat daily surface reflectance or Landsat daily surface temperature."
msgstr ""

#: 
msgid "Tiers in the Digital Earth Africa Sandbox"
msgstr ""

#: 
msgid "`Access the Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/>`__"
msgstr ""

#: 
msgid "Loading Landsat Analysis-Ready Data using the ``load_ard`` function loads **only Tier 1 data**. Tier 1 data is optimised for time-series analysis."
msgstr ""

#: 
msgid "Tier 2 data can be accessed using the ``datacube.Datacube.load`` function. By default, ``datacube.Datacube.load`` loads all available (Tier 1 and Tier 2) data. The tier can be specified using the optional argument ``collection_category``, which takes strings\\ ``'T1``' or ``'T2'`` ."
msgstr ""

#: 
msgid "*An example of loading only Tier 2 data using* ``datacube.Datacube.load`` with the argument ``collection_category=\"T2\"``."
msgstr ""

#: 
msgid "`USGS Landsat Collections - What are Tiers website <https://www.usgs.gov/media/videos/landsat-collections-what-are-tiers>`__"
msgstr ""

#: 
msgid "`USGS Landsat Collection 2 website <https://www.usgs.gov/landsat-missions/landsat-collection-2>`__"
msgstr ""

#: 
msgid "`Yale Center for Earth Observation Landsat Collection website <https://yceo.yale.edu/landsat-collections>`__"
msgstr ""

#: 
msgid "`datacube.Datacube.load documentation <https://datacube-core.readthedocs.io/en/datacube-1.2.2/dev/generate/datacube.Datacube.load.html>`__"
msgstr ""

#: 
msgid "Monthly Normalised Difference Vegetation Index (NDVI) Anomaly"
msgstr ""

#: 
msgid "Digital Earth Africa's Monthly NDVI Anomaly service provides estimate of vegetation condition, for each caldendar month, against the long-term baseline condition measured for the month from 1984 to 2020 in the `NDVI Climatology <https://docs.digitalearthafrica.org/en/latest/data_specs/NDVI_Climatology_specs.html>`__."
msgstr ""

#: 
msgid "A standardised anomaly is calculated by subtracting the long-term mean from an observation of interest and then dividing the result by the long-term standard deviation. The equation below applies for monthly NDVI anomalies:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{Standardised anomaly }=\\frac{NDVI_{month, year}-NDVI_{month}}{\\sigma} \\end{equation}`"
msgstr ""

#: 
msgid "where :math:`NDVI_{month, year}` is the NDVI measured for a month in a year, :math:`NDVI_{month}` is the long-term mean for this month from 1984 to 2020, and :math:`\\sigma` is the long-term standard deviation. A standarised anomaly therefore measures the direction and significance of vegeation change against normal conditions."
msgstr ""

#: 
msgid "Positive NDVI anomaly values indicate vegetation is greener than average conditions, and are usually due to increased rainfall in a region. Negative values indicate additional plant stress relative to the long-term average. The NDVI anomaly service is therefore effective for understanding the extent, intensity and impact of a drought."
msgstr ""

#: 
msgid "Abrupt and significant negative anomalies may also be caused by fire disturbance."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/NDVI_Anomaly.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "The product is available on `DE Africa Maps <https://maps.digitalearth.africa/#share=s-cWYaj579gpPXmKyRRGSajRTqD19>`__, which loads the product at the continental scale."
msgstr ""

#: 
msgid "**Table 1: NDVI Anomaly specifications**"
msgstr ""

#: 
msgid "``ndvi_anomaly``"
msgstr ""

#: 
msgid "2017 - now"
msgstr ""

#: 
msgid "Landsat 8, 9, Sentinel-2"
msgstr ""

#: 
msgid "From September 2022, the Monthly NDVI Anomaly is generated as a low latency product, i.e. anomaly for a month is generated on the 5th day of the following month. This ensures data is available shortly after the end of a month and all Landat 9 and Sentinel-2 observations are included. Not all landsat 8 observations for the month will be used, because the Landsat 8 Surface Refelectance product from USGS has a latency of over 2 weeks (see `Landsat Collection 2 Generation Timeline <https://www.usgs.gov/media/images/landsat-collection-2-generation-timeline>`__)."
msgstr ""

#: 
msgid "From January 2017 to August 2022, all available Landsat 8, Landsat 9 and Sentinel-2 observations are used in the calculation of the anomalies."
msgstr ""

#: 
msgid "**Table 2: NDVI Anomaly measurements**"
msgstr ""

#: 
msgid "ndvi_mean"
msgstr ""

#: 
msgid "Mean NDVI for a month"
msgstr ""

#: 
msgid "``nan``"
msgstr ""

#: 
msgid "ndvi_std_anomaly"
msgstr ""

#: 
msgid "Standardised NDVI anomaly for a month"
msgstr ""

#: 
msgid "clear_count"
msgstr ""

#: 
msgid "Number of clear observations in a month"
msgstr ""

#: 
msgid "``0 - ~10``"
msgstr ""

#: 
msgid "``int8``"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the `Metadata Explorer <https://explorer.digitalearth.africa/products/ndvi_anomaly>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: The dataset coverage for the NDVI anomaly product**"
msgstr ""

#: 
msgid "**Image 1: Mean NDVI(left image) and Standardised NDVI Anomaly(right image) product at the Continental Level**"
msgstr ""

#: 
msgid "**Image 2: Mean NDVI(left image) and Standardised NDVI Anomaly(right image) product at the Northern part of Egypt**"
msgstr ""

#: 
msgid "**Image 3: Mean NDVI and NDVI anomaly for June 2022 over Uganda**"
msgstr ""

#: 
msgid "The NDVI Anomaly service is available in AWS S3 thanks to the Public Dataset Program."
msgstr ""

#: 
msgid "The bucket is located in the region ``af-south-1`` (Cape Town). Additional region specifications can be applied as follows:"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-services/ndvi_anomaly/``"
msgstr ""

#: 
msgid "Year and month of data collection followed by period of time and time unit in the format ``YYYY-MM--P<period><unit>``. Time units are designated by capitalised letters, ``Y`` for years and ``M`` for months."
msgstr ""

#: 
msgid "``2022-06--P1M``"
msgstr ""

#: 
msgid "The NDVI Anomaly datasets can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``ndvi_anomaly``"
msgstr ""

#: 
msgid "Coverage and reliability of the NDVI Anomaly service depend on the availability and quality of both the NDVI Climatology and observations from the month of interest. Over equatorial Africa, the service is impacted by low quality of the long-term baseline and low number of cloud free images in a given month."
msgstr ""

#: 
msgid "Currently, the NDVI Anomalies are calulated for locations with more than 10 clear historical observations."
msgstr ""

#: 
msgid "Combining Sentinel-2 and Landsat"
msgstr ""

#: 
msgid "The mean NDVI value for a month of interest is calculated combining measurements from Landsat 8, Landsat 9 and Sentinel-2. For Landsat 8 and Landsat 9, NDVI is calculated using Band 5 (NIR) and Band 4 (Red). For Sentinel-2, NDVI is calculated using Band 8A (NIR narrow) and Band 4 (Red)."
msgstr ""

#: 
msgid "The code for reproducing the NDVI anomaly product is publicly availabe `on github <https://github.com/digitalearthafrica/ndvi-anomalies>`__"
msgstr ""

#: 
msgid "Normalised Difference Vegetation Index (NDVI) Climatology"
msgstr ""

#: 
msgid "**Date modified:** February 2022"
msgstr ""

#: 
msgid "Digital Earth Africa's NDVI climatology product represents the long-term average baseline condition of vegetation for every Landsat pixel over the African continent. Both mean and standard deviation NDVI climatologies are available for each calender month."
msgstr ""

#: 
msgid "Some key features of the product are:"
msgstr ""

#: 
msgid "NDVI climatologies were developed using harmonized Landsat 5,7,and 8 satellite imagery."
msgstr ""

#: 
msgid "Mean and standard deviation NDVI climatologies are produced for each calender month, using a temporal baseline period from 1984-2020 (inclusive)"
msgstr ""

#: 
msgid "Datasets have a spatial resolution of 30 metres"
msgstr ""

#: 
msgid "The product contains 36 measurements, across three categories of data (12 measurements within each category, one for each month):"
msgstr ""

#: 
msgid "``mean_<month>``: These measurements show the mean NDVI calculated from all available NDVI data from 1984-2020 for the given month."
msgstr ""

#: 
msgid "``stddev_<month>``: These measurements show the standard deviation of NDVI values of all available NDVI data from 1984-2020 for the given month."
msgstr ""

#: 
msgid "``count_<month>``: These measaurements show the number of clear observations that go into creating the mean and standard deviation measurements."
msgstr ""

#: 
msgid "**Important Note:** Due to the inconsistent data availability of Landsat 5 over equatorial Africa, and due to persistent cloud coverage over these same regions, the quality of the long-term NDVI baseline is poor in equatorial Africa. We recommend not using the product in locations where the clear obervation count is less than ~30 observations. Below this, the standard deviation layers are prone to data artefacts owing to temporal smoothing operations performing poorly on sparse datasets, and residual cloudy pixels not being sufficiently 'averaged out' by a decent volume of input data."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/NDVI_Climatology.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: NDVI Climatology specifications**"
msgstr ""

#: 
msgid "``ndvi_climatology_ls``"
msgstr ""

#: 
msgid "N/A"
msgstr ""

#: 
msgid "1984-2020"
msgstr ""

#: 
msgid "Landsat 5,7,8"
msgstr ""

#: 
msgid "**Table 2: NDVI Climatology measurements**"
msgstr ""

#: 
msgid "mean_jan"
msgstr ""

#: 
msgid "Mean NDVI for January (1984-2020)"
msgstr ""

#: 
msgid "mean_feb"
msgstr ""

#: 
msgid "Mean NDVI for February (1984-2020)"
msgstr ""

#: 
msgid "mean_mar"
msgstr ""

#: 
msgid "Mean NDVI for March (1984-2020)"
msgstr ""

#: 
msgid "mean_apr"
msgstr ""

#: 
msgid "Mean NDVI for April (1984-2020)"
msgstr ""

#: 
msgid "mean_may"
msgstr ""

#: 
msgid "Mean NDVI for May (1984-2020)"
msgstr ""

#: 
msgid "mean_jun"
msgstr ""

#: 
msgid "Mean NDVI for June (1984-2020)"
msgstr ""

#: 
msgid "mean_jul"
msgstr ""

#: 
msgid "Mean NDVI for July (1984-2020)"
msgstr ""

#: 
msgid "mean_aug"
msgstr ""

#: 
msgid "Mean NDVI for August (1984-2020)"
msgstr ""

#: 
msgid "mean_sep"
msgstr ""

#: 
msgid "Mean NDVI for September (1984-2020)"
msgstr ""

#: 
msgid "mean_oct"
msgstr ""

#: 
msgid "Mean NDVI for October (1984-2020)"
msgstr ""

#: 
msgid "mean_nov"
msgstr ""

#: 
msgid "Mean NDVI for November (1984-2020)"
msgstr ""

#: 
msgid "mean_dec"
msgstr ""

#: 
msgid "Mean NDVI for December (1984-2020)"
msgstr ""

#: 
msgid "stddev_jan"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for January (1984-2020)"
msgstr ""

#: 
msgid "stddev_feb"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for February (1984-2020)"
msgstr ""

#: 
msgid "stddev_mar"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for March (1984-2020)"
msgstr ""

#: 
msgid "stddev_apr"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for April (1984-2020)"
msgstr ""

#: 
msgid "stddev_may"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for May (1984-2020)"
msgstr ""

#: 
msgid "stddev_jun"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for June (1984-2020)"
msgstr ""

#: 
msgid "stddev_jul"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for July (1984-2020)"
msgstr ""

#: 
msgid "stddev_aug"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for August (1984-2020)"
msgstr ""

#: 
msgid "stddev_sep"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for September (1984-2020)"
msgstr ""

#: 
msgid "stddev_oct"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for October (1984-2020)"
msgstr ""

#: 
msgid "stddev_nov"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for November (1984-2020)"
msgstr ""

#: 
msgid "stddev_dec"
msgstr ""

#: 
msgid "Standard Deviation of NDVI for December (1984-2020)"
msgstr ""

#: 
msgid "count_jan"
msgstr ""

#: 
msgid "Number of clear obs in January (1984-2020)"
msgstr ""

#: 
msgid "``0 - ~160``"
msgstr ""

#: 
msgid "count_feb"
msgstr ""

#: 
msgid "Number of clear obs in February (1984-2020)"
msgstr ""

#: 
msgid "count_mar"
msgstr ""

#: 
msgid "Number of clear obs in March (1984-2020)"
msgstr ""

#: 
msgid "count_apr"
msgstr ""

#: 
msgid "Number of clear obs in April (1984-2020)"
msgstr ""

#: 
msgid "count_may"
msgstr ""

#: 
msgid "Number of clear obs in May (1984-2020)"
msgstr ""

#: 
msgid "count_jun"
msgstr ""

#: 
msgid "Number of clear obs in June (1984-2020)"
msgstr ""

#: 
msgid "count_jul"
msgstr ""

#: 
msgid "Number of clear obs in July (1984-2020)"
msgstr ""

#: 
msgid "count_aug"
msgstr ""

#: 
msgid "Number of clear obs in August (1984-2020)"
msgstr ""

#: 
msgid "count_sep"
msgstr ""

#: 
msgid "Number of clear obs in September (1984-2020)"
msgstr ""

#: 
msgid "count_oct"
msgstr ""

#: 
msgid "Number of clear obs in October (1984-2020)"
msgstr ""

#: 
msgid "count_nov"
msgstr ""

#: 
msgid "Number of clear obs in November (1984-2020)"
msgstr ""

#: 
msgid "count_dec"
msgstr ""

#: 
msgid "Number of clear obs in December (1984-2020)"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the `Metadata Explorer <https://explorer.digitalearth.africa/products/ndvi_climatology_ls>`__. Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: The dataset coverage for the NDVI Climatology product**"
msgstr ""

#: 
msgid "**Image 1: Animations of the NDVI Climatology layers. Left: Mean NDVI; Right: Std. Dev. NDVI**"
msgstr ""

#: 
msgid "The NDVI Climatology service is available in AWS S3 thanks to the Public Dataset Program."
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-services/ndvi_climatology_ls/``"
msgstr ""

#: 
msgid "Year of data collection followed by period of time and time unit in the format ``YYYY--P<period><unit>``. Time units are designated by capitalised letters, ``Y`` for years and ``M`` for months."
msgstr ""

#: 
msgid "``1984--P37Y``"
msgstr ""

#: 
msgid "The NDVI Climatology datasets can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``ndvi_climatology_ls``"
msgstr ""

#: 
msgid "Landsat Harmonization method"
msgstr ""

#: 
msgid "Landsat satellites have the longest temporal record of Earth Observation data, covering nearly four decades and including landsat 5, 7 and 8 (and now Landsat 9). Ideally, the Landsat data record should be consistent over the Landsat sensor series, but Landsat-8 Operational Land Imager (OLI) has improved calibration over the previous Landsat-7 Enhanced Thematic Mapper (ETM +), and Landsat 5's ETM. The different qualities of the sensors can result in discontinuities when concatenating NDVI time-series across different sensors."
msgstr ""

#: 
msgid "To harmonize the different generations of Landsat sensors, 10,000 60 x 60m polygons were randomly disributed across the continent. At each sample location, a four year time series (2013-2016) of cloud-masked Landsat 7 and Landsat 8 images were loaded, and coincident Landsat 7 and Landsat 8 NDVI observations were retained. Coincident is defined here as acquisitions taken within two days of each other. In total, 35,189 coincident pixel obervations were collected (all pixels within the 60 x 60m polygons were kept)."
msgstr ""

#: 
msgid "**Figure 1: The locations of coincident Landsat 7 and Landsat 8 images used to define the harmonization coefficients in eq 2. Points are coloured by the NDVI value of the Landsat 8 image.**"
msgstr ""

#: 
msgid "Coincident samples were used to linearly regress Landsat 8 NDVI against Landsat 7 NDVI, the results of this are shown in Figure 2a as a density scatter plot. The linear relationship (eq 1.) between the two is expressed as (also represented by the red line in figure 2a):"
msgstr ""

#: 
msgid "To harmonize the datasets, Landsat 7 was transformed to better align with Landsat 8 using eq 2. Figure 2b plots the results after harmonization."
msgstr ""

#: 
msgid "**Figure 2: a) Density scatter plots between Landsat 7 NDVI and Landsat 8 NDVI before harmonization. Red line shows the linear relationship, and the blackline shows the 1:1 line. b) Density scatter plots between Landsat 7 NDVI and Landsat 8 NDVI after harmonization. The red line is directly on top of the 1:1 line**"
msgstr ""

#: 
msgid "We can visualise how the harmonization improves consistency between the sensors by plotting a time-series of NDVI before and after harmonization (figure 3)."
msgstr ""

#: 
msgid "**Figure 3: The impact of Landsat 7 harmonization on an NDVI timeseries. Time-series is from an irrigated cropping region in Egypt.**"
msgstr ""

#: 
msgid "NDVI Climatology Algorithm"
msgstr ""

#: 
msgid "The procedure for calculating the NDVI climatologies is listed step-by-step below. The code for reproducing the NDVI climatology product is publicly availabe `on github <https://github.com/digitalearthafrica/ndvi-anomalies>`__:"
msgstr ""

#: 
msgid "Load a concatenated Landsat 5 and Landsat 7 time series"
msgstr ""

#: 
msgid "Mask pixels in LS5 and LS7 where:"
msgstr ""

#: 
msgid "cloud, and cloud shadows occur, and apply morphological operators opening + dilation (improves the cloud mask)"
msgstr ""

#: 
msgid "Surface reflectance values > 65,455 or < 7272.72"
msgstr ""

#: 
msgid "Blue band surface reflectance is > 20,910 (removes some cloud missed by Fmask)"
msgstr ""

#: 
msgid "Load landsat 8 timeseries"
msgstr ""

#: 
msgid "Mask pixels in LS8 where:"
msgstr ""

#: 
msgid "cloud, cloud shadows, and cirrus clouds occur, and apply morphological operators opening + dilation (improves the cloud mask)"
msgstr ""

#: 
msgid "Blue band surface reflectance is > 20,910 (removes some cloud missed by fmask)"
msgstr ""

#: 
msgid "Calculate NDVI for each sensor"
msgstr ""

#: 
msgid "Adjust Landsat 5-7 using ``eq. 2``."
msgstr ""

#: 
msgid "Merge Landsat 5-7 time series with the Landsat 8 time-series"
msgstr ""

#: 
msgid "Set as nodata pixels where NDVI is not between 0 and 1"
msgstr ""

#: 
msgid "Apply a rolling mean temporal filter (window size = 3) to lesson the influence of noise and missed cloud in the time series"
msgstr ""

#: 
msgid "Calculate monthly mean and standard deviation NDVI climatologies."
msgstr ""

#: 
msgid "Shuttle Radar Topography Mission (SRTM) 1 Arc-Second Global Digital Elevation Model and DEM Derivatives"
msgstr ""

#: 
msgid "The NASA Making Earth System Data Records for Use in Research Environments (MEaSUREs) Shuttle Radar Topography Mission (SRTM) global 1 arc second (~30 metre) DEM is archived and distributed by the Land Processes Distributed Active Archive Center (LP DAAC). This dataset is a result of a collaborative effort by the National Aeronautics and Space Administration (NASA) and the National Geospatial-Intelligence Agency (NGA – previously known as the National Imagery and Mapping Agency, or NIMA), as well as the participation of the German and Italian space agencies. The primary goal of creating this dataset was to eliminate voids that were present in earlier versions of the SRTM elevation data."
msgstr ""

#: 
msgid "Digital Earth Africa provides free and open access to a copy of the NASA Version 3 SRTM DEM product over Africa."
msgstr ""

#: 
msgid "Digital Earth Africa also provides free and open access to the SRTM DEM Derivatives product over Africa. These derivatives include slope, multi-resolution valley bottom flatness and multi-resolution ridge top flatness. This product was generated by Digital Earth Africa from the Shuttle Radar Topography Mission (SRTM) v3.0 1 arc-second Digital Elevation Model."
msgstr ""

#: 
msgid "Relevant metadata for the SRTM DEM and the SRTM DEM derivatives products can be viewed on the DE Africa Metadata Explorer `here <https://explorer.digitalearth.africa/products/dem_srtm>`__ and `here <https://explorer.digitalearth.africa/products/dem_srtm_deriv>`__."
msgstr ""

#: 
msgid "**Table 1: SRTM DEM and SRTM DEM Derivatives product specifications**"
msgstr ""

#: 
msgid "``dem_srtm``"
msgstr ""

#: 
msgid "``dem_srtm_deriv``"
msgstr ""

#: 
msgid "Cell size - X"
msgstr ""

#: 
msgid "0.000278° (~30 m)"
msgstr ""

#: 
msgid "30 m"
msgstr ""

#: 
msgid "Cell size - Y"
msgstr ""

#: 
msgid "EPSG:6933"
msgstr ""

#: 
msgid "Temporal Resolution"
msgstr ""

#: 
msgid "Multi-Day"
msgstr ""

#: 
msgid "2000-02-11 to 2000-02-21"
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the products can be explored as an interactive map on the Metadata Explorer `here <https://explorer.digitalearth.africa/products/dem_srtm>`__ and `here <https://explorer.digitalearth.africa/products/dem_srtm_deriv>`__. Data is available for the regions shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: SRTM DEM geographic extent**"
msgstr ""

#: 
msgid "SRTM DEM Geographic Extent"
msgstr ""

#: 
msgid "**Figure 2: SRTM DEM Derivatives geographic extent**"
msgstr ""

#: 
msgid "SRTM DEM Derivatives Geographic Extent"
msgstr ""

#: 
msgid "**Table 2: SRTM DEM and SRTM DEM Derivatives product measurements**"
msgstr ""

#: 
msgid "Elevation data."
msgstr ""

#: 
msgid "metre"
msgstr ""

#: 
msgid "``-32768.0``"
msgstr ""

#: 
msgid "mrvbf"
msgstr ""

#: 
msgid "**Multi-resolution Valley Bottom Flatness (MrVBF)**: this identifies valley bottoms (areas of deposition). Zero values indicate erosional terrain and values ≥1 and indicate progressively larger areas of deposition."
msgstr ""

#: 
msgid "mrrtf"
msgstr ""

#: 
msgid "**Multi-resolution Ridge Top Flatness (MrRTF)**: complementary to MrVBF, zero values indicate areas that are steep or low, and values ≥1 indicate progressively larger areas of high flat land."
msgstr ""

#: 
msgid "slope"
msgstr ""

#: 
msgid "**Slope (percent)**: this is the rate of elevation change."
msgstr ""

#: 
msgid "The NASA Version 3.0 SRTM DEM is a void filled dataset. The missing data in the National Geospatial-Intelligence Agency (NGA) Version 2.0 SRTM DEM was filled using topographic data from non-SRTM sources. The primary fill elevation data was from the Terra Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) Global Digital Elevation Model Version 2.0 (GDEM2) and the secondary fill elevation data from the USGS Global Multi-resolution Terrain Elevation Data (GMTED2010) elevation model or the USGS National Elevation Dataset (NED). The SRTM Version 3.0 processing steps are detailed in `The Shuttle Radar Topography Mission (SRTM) Collection User Guide <https://lpdaac.usgs.gov/documents/179/SRTM_User_Guide_V3.pdf>`__."
msgstr ""

#: 
msgid "The SRTM DEM Derivatives were generated by Digital Earth Africa from the SRTM v3.0 Digital Elevation Model using `gdaldem <https://gdal.org/programs/gdaldem.html>`__ for the percent slope and `SAGA GIS tool (Version: 2.3.1) <https://saga-gis.sourceforge.io/saga_tool_doc/2.3.0/ta_morphometry_8.html>`__ for the multi-resolution valley bottom flatness (MrVBF) and multi-resolution ridge top flatness (MrRTF). The scripts used to generate the derivatives are available `here <https://github.com/digitalearthafrica/dem-derivative>`__."
msgstr ""

#: 
msgid "**Figure 3: SRTM DEM elevation data for Mt. Kenya**"
msgstr ""

#: 
msgid "**Figure 4: SRTM DEM Derivatives for Mt. Kenya**"
msgstr ""

#: 
msgid "STRM DEM Derivatives Mt. Kenya"
msgstr ""

#: 
msgid "G., Rosen, P. A., Caro, E., Crippen, R., Duren, R., Hensley, S., Kobrick, M., Paller, M., Rodriguez, E., Roth, L., Seal, D., Shaffer, S., Shimada, J., Umland, J., Werner, M., Oskin, M., Burbank, D., & Alsdorf, D. (2007). The Shuttle Radar Topography Mission. In Reviews of Geophysics (Vol. 45, Issue 2). American Geophysical Union (AGU). https://doi.org/10.1029/2005rg000183"
msgstr ""

#: 
msgid "`The Shuttle Radar Topography Mission (SRTM) Collection User Guide <https://lpdaac.usgs.gov/documents/179/SRTM_User_Guide_V3.pdf>`__"
msgstr ""

#: 
msgid "`Shuttle Radar Topography Mission (SRTM) Quick Guide <https://lpdaac.usgs.gov/documents/13/SRTM_Quick_Guide.pdf>`__"
msgstr ""

#: 
msgid "`LPDAAC Data Catalogue <https://lpdaac.usgs.gov/products/srtmagl1v003/>`__"
msgstr ""

#: 
msgid "`DE Africa DEM Derivatives repository <https://github.com/digitalearthafrica/dem-derivative>`__"
msgstr ""

#: 
msgid "The SRTM DEM is available under a `CC-BY-4.0 <https://creativecommons.org/licenses/by/4.0/>`__ license."
msgstr ""

#: 
msgid "The Digital Earth Africa SRTM DEM Derivatives product is provided free of charge, under a `Apache License 2.0 <https://github.com/digitalearthafrica/dem-derivative/blob/main/LICENSE>`__ license."
msgstr ""

#: 
msgid "The SRTM DEM and SRTM DEM Derivatives are available in AWS S3."
msgstr ""

#: 
msgid "**Table 3: SRTM DEM and SRTM DEM Derivatives AWS data access details**"
msgstr ""

#: 
msgid "SRTM DEM"
msgstr ""

#: 
msgid "SRTM DEM Derivatives"
msgstr ""

#: 
msgid "The SRTM DEM file path is: ``strm_dem/dem_srtm``. The SRTM Derivatives file path is: ``srtm_dem/dem_srtm_deriv``."
msgstr ""

#: 
msgid "The SRTM DEM and SRTM DEM Derivatives are available through DE Africa's OWS."
msgstr ""

#: 
msgid "``dem_srtm``, ``dem_srtm_deriv``"
msgstr ""

#: 
msgid "For instructions on how to connect to OWS, see this `tutorial <../web_services/index.ipynb>`__."
msgstr ""

#: 
msgid "The SRTM DEM and SRTM DEM Derivatives can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product names:** ``dem_srtm``, ``dem_srtm_deriv``"
msgstr ""

#: 
msgid "**Table 6: ODC products dem_srtm and dem_srtm_deriv band names**"
msgstr ""

#: 
msgid "The Kinematic Global Positioning System Geodetic field surveying method was used to validate SRTM data. About 70,000 kilometers of survey lines were collected. The data was used to model long-wavelength error sources. In addition, NASA’s JPL deployed corner reflectors during the SRTM mission which were deployed with precisely measured coordinates and served as control points in the SRTM data."
msgstr ""

#: 
msgid "Known issues in the NASA SRTM are described in the following publication:"
msgstr ""

#: 
msgid "Rodriguez, E., C. S. Morris, and J. E. Belz (2006), A global assessment of the SRTM performance, Photogramm. Eng. Remote Sens., 72, 249–260. https://doi.org/10.14358/PERS.72.3.249."
msgstr ""

#: 
msgid "Sentinel-1 Normalised Radar Backscatter"
msgstr ""

#: 
msgid "**Date modified:** 31 May 2022"
msgstr ""

#: 
msgid "The `Sentinel-1 mission <https://sentinel.esa.int/web/sentinel/missions/sentinel-1>`__, composed of a constellation of two C-band Synthetic Aperture Radar (SAR) satellites, are operated by European Space Agency (ESA) as part of the Copernicus Programme. The mission currently collects data every 6 to 12 days over Africa at a spatial resolution of approximately 20 m."
msgstr ""

#: 
msgid "Radar backscatter measures the amount of microwave radiation reflected back to the sensor from the ground surface. This measurement is sensitive to surface roughness, moisture content and viewing geometry. DE Africa provides Sentinel-1 backscatter as Radiometrically Terrain Corrected (RTC) gamma-0 (γ0) where variation due to changing observation geometries has been mitigated."
msgstr ""

#: 
msgid "The dual polarisation backcastter time series can be used in applications for forests, agriculture, wetlands and land cover classification. SAR’s ability to ‘see through’ clouds makes it critical for mapping and monitoring land cover changes in the wet tropics."
msgstr ""

#: 
msgid "CEOS ARD logo"
msgstr ""

#: 
msgid "DE Africa's Sentinel-1 backscatter product is endorsed by the Committee on Earth Observation Satellites (CEOS) to be compliant with the `CEOS Analysis Ready Data (CARD) <https://ceos.org/ard/>`__ specifications. This internationally-recognised certification ensures these products have been processed to a minimum set of requirements and organised into a form that allows immediate analysis with a minimum of additional user effort and interoperability both through time and with other datasets."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Sentinel_1.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "Coverage and metadata for the Sentinel-1 backscatter can be viewed on DE Africa's `Metadata Explorer <https://explorer.digitalearth.africa/products/s1_rtc>`__."
msgstr ""

#: 
msgid "**Table 1: Sentinel-1 product specifications**"
msgstr ""

#: 
msgid "Sentinel-1 Radiometric Terrain Corrected SAR Backscatter"
msgstr ""

#: 
msgid "C-SAR"
msgstr ""

#: 
msgid "C-band (5.405 GHz)"
msgstr ""

#: 
msgid "Acquisition mode"
msgstr ""

#: 
msgid "Interferometric Wide swath (IW)"
msgstr ""

#: 
msgid "VV + VH"
msgstr ""

#: 
msgid "0.0002"
msgstr ""

#: 
msgid "Every 6 to 12 days"
msgstr ""

#: 
msgid "2018-01-01 – present"
msgstr ""

#: 
msgid "`Sentinel-1 GRD <https://registry.opendata.aws/sentinel-1/>`__"
msgstr ""

#: 
msgid "**Table 2: Sentinel-1 measurements**"
msgstr ""

#: 
msgid "vv"
msgstr ""

#: 
msgid "Linear backscatter intensity in VV polarization"
msgstr ""

#: 
msgid "vh"
msgstr ""

#: 
msgid "Linear backscatter intensity in VH polarization"
msgstr ""

#: 
msgid "Data mask"
msgstr ""

#: 
msgid "area"
msgstr ""

#: 
msgid "Normalized scattering area"
msgstr ""

#: 
msgid "angle"
msgstr ""

#: 
msgid "Local incidence angle (degree)"
msgstr ""

#: 
msgid "**Table 3: Sentinel-1 data mask definition**"
msgstr ""

#: 
msgid "Nodata"
msgstr ""

#: 
msgid "Valid"
msgstr ""

#: 
msgid "Invalid (in/near radar shadow)"
msgstr ""

#: 
msgid "DE Africa Sentinel-1 dataset is processed by Sinergise Sentinel Hub using ESA `Sentinel-1 GRD <https://registry.opendata.aws/sentinel-1/>`__ as input. Radiometric terrain correction is applied using `Copernicus DEM <https://registry.opendata.aws/copernicus-dem/>`__, following method developed in `D. Small 2011 <https://doi.org/10.1109/TGRS.2011.2120616>`__."
msgstr ""

#: 
msgid "False color backscatter over Okavango"
msgstr ""

#: 
msgid "**Figure 1: Sentinel-1 false color composite over an area in Okavango Delta, Botswana.**"
msgstr ""

#: 
msgid "TBA"
msgstr ""

#: 
msgid "Small, \"Flattening Gamma: Radiometric Terrain Correction for SAR Imagery,\" in IEEE Transactions on Geoscience and Remote Sensing, vol. 49, no. 8, pp. 3081-3093, Aug. 2011, doi: 10.1109/TGRS.2011.2120616."
msgstr ""

#: 
msgid "Access to Sentinel data is free, full and open for the broad Regional, National, European and International user community. View `Terms and Conditions <https://scihub.copernicus.eu/twiki/do/view/SciHubWebPortal/TermsConditions>`__."
msgstr ""

#: 
msgid "DE Africa Sentinel-1 dataset is available in AWS S3, sponsored by the `Public Dataset Program <https://registry.opendata.aws/deafrica-sentinel-1/>`__."
msgstr ""

#: 
msgid "**Table 4: AWS data access details.**"
msgstr ""

#: 
msgid "``arn:aws:s3:::deafrica-sentinel-1``"
msgstr ""

#: 
msgid "``s1_rtc``"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-sentinel-1/``"
msgstr ""

#: 
msgid "The file paths follow the format ``<product_name>/<tile_id>/<year>/<month>/<day>/<datatake_id>/``."
msgstr ""

#: 
msgid "The filenames follow the format ``<product_name>_<datatake_id>_<tile_id>_<year>_<month>_<day>_<band>.<extension>.``"
msgstr ""

#: 
msgid "**Table 5: AWS file path and name convention.**"
msgstr ""

#: 
msgid "1x1 deg tile labeld by southwest corner coordinates"
msgstr ""

#: 
msgid "``N00E041``"
msgstr ""

#: 
msgid "Observation month"
msgstr ""

#: 
msgid "``02``"
msgstr ""

#: 
msgid "Observation day"
msgstr ""

#: 
msgid "``datatake_id``"
msgstr ""

#: 
msgid "Sentinel-1 mission datatake ID (000001-FFFFFF)"
msgstr ""

#: 
msgid "``0445E6``"
msgstr ""

#: 
msgid "``band``"
msgstr ""

#: 
msgid "band ID, ``VV``, ``VH``, ``MASK``, ``ANGLE``, ``AREA``, ``metadata`` or ``userdata``"
msgstr ""

#: 
msgid "``VV``"
msgstr ""

#: 
msgid "``extension``"
msgstr ""

#: 
msgid "``.tif`` for image files, ``.json`` or ``.xml`` for metadata files"
msgstr ""

#: 
msgid "``.tif``"
msgstr ""

#: 
msgid "For each Sentinel-1 tile, two metadata files are provided:"
msgstr ""

#: 
msgid "``_metadata.json`` is a `STAC <https://stacspec.org/>`__ compliant file."
msgstr ""

#: 
msgid "``_metadata.xml`` is a `CARD4L <https://ceos.org/ard/>`__ compliant file."
msgstr ""

#: 
msgid "s1_rtc"
msgstr ""

#: 
msgid "The Sentinel-1 dataset can be accessed through the DE Africa ODC API, which is available through the `DE Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``s1_rtc``"
msgstr ""

#: 
msgid "**Table 7: Sentinel-1 ODC band names.**"
msgstr ""

#: 
msgid "VV"
msgstr ""

#: 
msgid "VH"
msgstr ""

#: 
msgid "MASK"
msgstr ""

#: 
msgid "AREA, normalised_scattering_area"
msgstr ""

#: 
msgid "ANGLE, local_incidence_angle"
msgstr ""

#: 
msgid "Radar backscatter can be provided as Beta Naught (β0), Sigma Naught (σ0) or Gamma Naught (γ0), depending on the reference area used to normalise the backscatter as shown in Figure 2."
msgstr ""

#: 
msgid "β0 is normalised to an area defined in slant range plane"
msgstr ""

#: 
msgid "σ0 is normalised to ground area"
msgstr ""

#: 
msgid "γ0 is normalised to an area perpendicular to the line of sight"
msgstr ""

#: 
msgid "Normalization areas for SAR backscatter"
msgstr ""

#: 
msgid "**Figure 2: Normalization areas for SAR backscatter.** Source: `Small 2011 <https://doi.org/10.1109/TGRS.2011.2120616>`__."
msgstr ""

#: 
msgid "When local terrain information is not available, an ellipsoidal Earth model can be used to define the reference areas. However, this may lead to significant inaccuracy in the normalised backscatter."
msgstr ""

#: 
msgid "Using knowledge of sensor geometry and a digital elevation model, local scattering (or illuminated) area can be esimated to achieve a radiometric terrain correction and minimise the impact of terrain on the measured backscatter. Such correction allows data collected with different viewing geometry to be combined or compared to detect real change on Earth surface."
msgstr ""

#: 
msgid "Backscatter with and without RTC"
msgstr ""

#: 
msgid "**Figure 3: Beta0 (left) and RTC Gamma0 (right) over an area near Lake Edward, Democratic Republic of the Congo. Backscatter variation due to terrain is minimized in RTC and contrast between different land cover types is increased.**"
msgstr ""

#: 
msgid "Geometric accuracy"
msgstr ""

#: 
msgid "Absolute geometric accuracy of this product has been estimated to be within 6 metres (RMSE), using data processed over Corner Reflectors in Queensland Australia."
msgstr ""

#: 
msgid "Sentinel-2 Level-2A Surface Reflectance"
msgstr ""

#: 
msgid "**Date modified:** 21 April 2021"
msgstr ""

#: 
msgid "The Sentinel-2 mission is part of the European Union Copernicus programme for Earth observations. Sentinel-2 consists of twin satellites, Sentinel-2A (launched 23 June 2015) and Sentinel-2B (launched 7 March 2017). The two satellites have the same orbit, but 180° apart for optimal coverage and data delivery. Their combined data is used in the Digital Earth Africa Sentinel-2 product."
msgstr ""

#: 
msgid "Together, they cover all Earth's land surfaces, large islands, inland and coastal waters every 3-5 days."
msgstr ""

#: 
msgid "Sentinel-2 data is tiered by level of pre-processing. Level-0, Level-1A and Level-1B data contain raw data from the satellites, with little to no pre-processing. Level-1C data is surface reflectance measured at the top of the atmosphere. This is processed using the Sen2Cor algorithm to give Level-2A, the bottom-of-atmosphere reflectance (`Obregón et al, 2019 <https://www.mdpi.com/2072-4292/11/14/1649>`__). Level-2A data is the most ideal for research activities as it allows further analysis without applying additional atmospheric corrections."
msgstr ""

#: 
msgid "The Digital Earth Africa Sentinel-2 dataset contains Level-2A data of the African continent. Digital Earth Africa does not host any lower-level Sentinel-2 data."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Sentinel_2.ipynb>`__ which demonstrates loading and using this dataset in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: Sentinel-2 Level-2A product specifications**"
msgstr ""

#: 
msgid "10, 20, 60 (band-dependent, see Table 2)"
msgstr ""

#: 
msgid "Every 5 days"
msgstr ""

#: 
msgid "2017-01-01 – present"
msgstr ""

#: 
msgid "Sentinel-2 Level-1C (external to DE Africa)"
msgstr ""

#: 
msgid "**Figure 1: Sentinel-2 Level-2A geographic extent**"
msgstr ""

#: 
msgid "Sentinel-2 data extent"
msgstr ""

#: 
msgid "Digital Earth Africa Sentinel-2 data is available for the regions shaded in blue. Specific temporal and geographic extents can be explored as an interactive map on the Digital Earth Africa `Metadata Explorer <https://explorer.digitalearth.africa/products/s2_l2a/extents>`__."
msgstr ""

#: 
msgid "**Table 2: Sentinel-2 Level-2A measurements**"
msgstr ""

#: 
msgid "Spatial resolution (m)"
msgstr ""

#: 
msgid "B01"
msgstr ""

#: 
msgid "Coastal aerosol"
msgstr ""

#: 
msgid "Red edge 1"
msgstr ""

#: 
msgid "20"
msgstr ""

#: 
msgid "Red edge 2"
msgstr ""

#: 
msgid "Red edge 3"
msgstr ""

#: 
msgid "Near infrared (NIR) 1"
msgstr ""

#: 
msgid "NIR 2"
msgstr ""

#: 
msgid "B09"
msgstr ""

#: 
msgid "Water vapour"
msgstr ""

#: 
msgid "Short-wave infrared (SWIR) 1"
msgstr ""

#: 
msgid "SWIR 2"
msgstr ""

#: 
msgid "AOT"
msgstr ""

#: 
msgid "Aerosol optical thickness"
msgstr ""

#: 
msgid "WVP"
msgstr ""

#: 
msgid "Scene average water vapour"
msgstr ""

#: 
msgid "SCL"
msgstr ""

#: 
msgid "Scene classification layer"
msgstr ""

#: 
msgid "The Digital Earth Africa Sentinel-2 Level-2A dataset has fifteen bands of data, which can be grouped into the multispectral bands, and the auxilary quality assurance bands."
msgstr ""

#: 
msgid "**Multispectral observations - 12 bands:** Sentinel-2 satellites carry a multispectral instrument that measures in the visible, near infrared, and short-wave infrared ranges. These are indexed as ``B01 - B12``. The band B10 is not included in the DE Africa Sentinel-2 Level-2A product as it does not contain surface information."
msgstr ""

#: 
msgid "Surface reflectance values are scaled between ``1`` and ``10000``. Note different spectral bands have different native resolutions."
msgstr ""

#: 
msgid "**Quality assurance - 3 bands:** The Sentinel-2 Level-2A product also includes three auxilary data bands which are used to improve the accuracy of surface reflectance-derived products. These corrections were applied as part of the Sen2Cor conversion from Level-1C (top-of-atmosphere) to Level-2A (bottom-of-atmosphere) data."
msgstr ""

#: 
msgid "Scene Classification Layer (``SCL``) distinguishes between cloudy, clear and water pixels. The algorithm identifies areas as clouds, snow, cloud shadows, vegetation, bare soil and water. The resulting SCL is used for cirrus cloud correction in the processing chain. It is also commonly applied in further analysis as a cloud mask, which removes unwanted cloudy pixels from the multispectral observations. SCL bit values are defined in Table 3."
msgstr ""

#: 
msgid "Aerosol Optical Thickness (``AOT``) is a measure of haze, or visibility through the atmosphere. In Sentinel-2 Level-2A data, this is derived using the Dark Dense Vegetation pixel method, which relies on calibrating reflectance against dark vegetation and using the estimated atmospheric thickness to correct the rest of the measurements."
msgstr ""

#: 
msgid "Water Vapour (``WVP``), also referred to in literature as Integrated Water Vapour (IWV) or Water Vapour (WV), is the total water vapour integrated over an atmospheric column. It is calculated using an atmospheric pre-corrected differential absorption algorithm (`Schläpfer et al, 1998 <https://www.sciencedirect.com/science/article/pii/S0034425798000443?via%3Dihub>`__). Like AOT, it is a key component of atmospheric correction."
msgstr ""

#: 
msgid "**Table 3: SCL bit values**"
msgstr ""

#: 
msgid "Bit value"
msgstr ""

#: 
msgid "Classification"
msgstr ""

#: 
msgid "No data"
msgstr ""

#: 
msgid "Saturated or defective"
msgstr ""

#: 
msgid "Dark area pixels"
msgstr ""

#: 
msgid "Cloud shadows"
msgstr ""

#: 
msgid "Vegetation"
msgstr ""

#: 
msgid "Bare soils"
msgstr ""

#: 
msgid "Unclassified"
msgstr ""

#: 
msgid "Cloud medium probability"
msgstr ""

#: 
msgid "Cloud high probability"
msgstr ""

#: 
msgid "Thin cirrus"
msgstr ""

#: 
msgid "Snow or ice"
msgstr ""

#: 
msgid "Sentinel-2 Level-2A metadata can also be viewed on Digital Earth Africa's `Metadata Explorer <https://explorer.digitalearth.africa/products/s2_l2a>`__."
msgstr ""

#: 
msgid "Each observation from the parent dataset, Level-1C, is processed by the European Space Agency (ESA) through the Sen2Cor algorithm. First, cloud detection is performed using SCL, then AOT and WVP are calculated. These are applied to give the resultant bottom-of-atmosphere Level-2A observations."
msgstr ""

#: 
msgid "More details on Sentinel-2 Level-2A processing can be found in `Gascon et al, 2017 <https://www.mdpi.com/2072-4292/9/6/584>`__."
msgstr ""

#: 
msgid "**Image 1: The Eye of Africa, Mauritania. 2021 Sentinel-2, true-colour (RGB).**"
msgstr ""

#: 
msgid "Credit: Contains modified Copernicus Sentinel data 2021, processed by Digital Earth Africa."
msgstr ""

#: 
msgid "Sentinel-2 true-colour image"
msgstr ""

#: 
msgid "**Image 2: Bazaruto Archipelago, Mozambique. 2020 Sentinel-2, true-colour (RGB).**"
msgstr ""

#: 
msgid "Obregón, M.A., Rodrigues, G., Costa, M.J., et al. (2019). Validation of ESA Sentinel-2 L2A aerosol optical thickness and columnar water vapour during 2017-2018. *Remote Sensing*, 11(14), 1649. https://doi.org/10.3390/rs11141649"
msgstr ""

#: 
msgid "Schläpfer, D., Borel, C.C., Keller, J., et al. (1998). Atmospheric precorrected differential absorption technique to retrieve columnar water vapor. *Remote Sensing of Environment*, 65(3), 353-366. https://doi.org/10.1016/S0034-4257(98)00044-3."
msgstr ""

#: 
msgid "Gascon F., Bouzinac C., Thépaut O., et al. (2017). Copernicus Sentinel-2A calibration and products validation status. *Remote Sensing*, 9(6), 584. https://doi.org/10.3390/rs9060584"
msgstr ""

#: 
msgid "The Sentinel-2 Level-2A product is provided by the European Space Agency."
msgstr ""

#: 
msgid "Sentinel-2 Level-2A is available in AWS S3, sponsored by the `Public Dataset Program <https://registry.opendata.aws/deafrica-sentinel-2/>`__."
msgstr ""

#: 
msgid "``arn:aws:s3:::deafrica-sentinel-2``"
msgstr ""

#: 
msgid "``s2_l2a``"
msgstr ""

#: 
msgid "``aws s3 ls --region=af-south-1 s3://deafrica-sentinel-2/``"
msgstr ""

#: 
msgid "The data is organised per tiles using Military Grid Reference System. The file paths follow the format"
msgstr ""

#: 
msgid "``<utm_zone>/<latitude_band>/<grid_square>/<year>/<month>/<scene_ID>``."
msgstr ""

#: 
msgid "``utm_zone``"
msgstr ""

#: 
msgid "Grid zone designator"
msgstr ""

#: 
msgid "``10``"
msgstr ""

#: 
msgid "``latitude band``"
msgstr ""

#: 
msgid "Latitude band are lettered C- X, omitting the letters \"I\" and \"O\""
msgstr ""

#: 
msgid "``S``"
msgstr ""

#: 
msgid "``square``"
msgstr ""

#: 
msgid "Pair of letters designating one of the 100,000-meter side grid squares inside the grid zone"
msgstr ""

#: 
msgid "``DG``"
msgstr ""

#: 
msgid "Year the data was collected, ``YYYY``"
msgstr ""

#: 
msgid "``2018``"
msgstr ""

#: 
msgid "Month of the year the data was collected (without leading zeros)"
msgstr ""

#: 
msgid "``3``"
msgstr ""

#: 
msgid "``scene_ID``"
msgstr ""

#: 
msgid "All files corresponding to a scene"
msgstr ""

#: 
msgid "``ccc27a76-71ab-5da9-9d88-4f2c3e874ef3``"
msgstr ""

#: 
msgid "**Table 6: OWS data access details**"
msgstr ""

#: 
msgid "The Sentinel-2 Level-2A dataset can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``s2_l2a``"
msgstr ""

#: 
msgid "The ODC product name is derived from **S**\\ entinel-\\ **2** **L**\\ evel-\\ **2A**. Some typefaces obscure the fourth character, which is a lowercase L."
msgstr ""

#: 
msgid "Specific bands of data can be called by using either the default names or any of a band's alternative names, as listed in the table below. ODC ``datacube.Datacube.load`` commands without specified bands will load all bands; see `ODC documentation <https://datacube-core.readthedocs.io/en/latest/dev/api/generate/datacube.Datacube.load.html>`__."
msgstr ""

#: 
msgid "**Table 7: Sentinel-2 ODC band names**"
msgstr ""

#: 
msgid "band_01, coastal_aerosol"
msgstr ""

#: 
msgid "band_09, water_vapour"
msgstr ""

#: 
msgid "mask, qa"
msgstr ""

#: 
msgid "aerosol_optical_thickness"
msgstr ""

#: 
msgid "scene_average_water_vapour"
msgstr ""

#: 
msgid "Additional information about the Sentinel-2 instrumentation can be found on the `ESA Sentinel-2 User Guide <https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi>`__."
msgstr ""

#: 
msgid "DE Africa Waterbodies: A Waterbodies Monitoring Service"
msgstr ""

#: 
msgid "**Date modified:** 20 May 2024"
msgstr ""

#: 
msgid "This is a beta product, released for evaluation by all users. The DE Africa team is working actively to validate and improve this product."
msgstr ""

#: 
msgid "The Digital Earth Africa continental Waterbodies Monitoring Service identifies more than 700,000 water bodies from over three decades of satellite observations. This service maps persistent and seasonal water bodies and the change in their water surface area over time. Mapped water bodies may include, but are not limited to, lakes, ponds, man-made reservoirs, wetlands, and segments of some river systems."
msgstr ""

#: 
msgid "On a local, regional, and continental scale, this service helps improve our understanding of surface water dynamics and water availability and can be used for monitoring water bodies such as wetlands, lakes and dams in remote and/or inaccessible locations."
msgstr ""

#: 
msgid "There are several products available as part of the Waterbodies service."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/Waterbodies.html>`__ that demonstrates loading and using the Waterbodies products in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: Waterbodies Service products**"
msgstr ""

#: 
msgid "Waterbodies Historical Extent"
msgstr ""

#: 
msgid "Static water body outlines. The outlines map where water was present in at least 5% of clear satellite acquisitions since 1987."
msgstr ""

#: 
msgid "Vector - polygon"
msgstr ""

#: 
msgid "Waterbodies Surface Area Change"
msgstr ""

#: 
msgid "Dynamic time series of the wet, dry, and unobserved surface area as a proportion of the historical water body extent."
msgstr ""

#: 
msgid "CSV"
msgstr ""

#: 
msgid "**Table 2: Waterbodies Service specifications**"
msgstr ""

#: 
msgid "**Service name**"
msgstr ""

#: 
msgid "DE Africa Waterbodies Service"
msgstr ""

#: 
msgid "**Product name**"
msgstr ""

#: 
msgid "**Coordinate reference system**"
msgstr ""

#: 
msgid "ESPG:4326"
msgstr ""

#: 
msgid "**Temporal resolution**"
msgstr ""

#: 
msgid "Single historical extent derived from the full temporal range"
msgstr ""

#: 
msgid "**Temporal range**"
msgstr ""

#: 
msgid "1987 - 2022"
msgstr ""

#: 
msgid "1984 - present"
msgstr ""

#: 
msgid "**Parent dataset**"
msgstr ""

#: 
msgid "`WOfS All-Time Summary <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-All-Time-Summary>`__"
msgstr ""

#: 
msgid "`WOfS Feature Layer <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-Feature-Layer>`__"
msgstr ""

#: 
msgid "**Update frequency**"
msgstr ""

#: 
msgid "Once every 3-5 years"
msgstr ""

#: 
msgid "Weekly"
msgstr ""

#: 
msgid "**Figure 1: DE Africa Waterbodies Service geographic extent**"
msgstr ""

#: 
msgid "DE Africa Waterbodies is a continental service that includes historical extent of individual water bodies and a time series of the surface area of water within the water body. This service uses the `Water Observations from Space <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ products and has been generated within the bounds of the `HydroSHEDS version 1.1 Land Mask <https://www.hydrosheds.org/hydrosheds-core-downloads>`__."
msgstr ""

#: 
msgid "**Table 3: Waterbodies Historical Extent attribute descriptions**"
msgstr ""

#: 
msgid "*uid*"
msgstr ""

#: 
msgid "A unique identifier determined from the water body's location. Each water body polygon's uid is a geohash, which represents the lat/lon coordinates of the centre of the water body polygon mapped into a shorter character string. A geohash can be converted back into a lat/lon pair."
msgstr ""

#: 
msgid "*wb_id*"
msgstr ""

#: 
msgid "An alternative identifier that assigns an integer value to every water body. Water bodies with similar ``wb_id`` values are located close together."
msgstr ""

#: 
msgid "*area_m2*"
msgstr ""

#: 
msgid "The area of the waterbody, measured in metres squared."
msgstr ""

#: 
msgid "*length_m*"
msgstr ""

#: 
msgid "The length of the longest side of the water body, measured in metres."
msgstr ""

#: 
msgid "*perim_m*"
msgstr ""

#: 
msgid "The perimeter of the water body, measured in metres."
msgstr ""

#: 
msgid "*geometry*"
msgstr ""

#: 
msgid "The geometry of the water body in EPSG:4326."
msgstr ""

#: 
msgid "**Table 4: Waterbodies Surface Area Change attribute descriptions**"
msgstr ""

#: 
msgid "*date*"
msgstr ""

#: 
msgid "The date of the satellite image acquisition used to measure the wet, dry, and invalid surface area of the water body."
msgstr ""

#: 
msgid "*area_wet_m2*"
msgstr ""

#: 
msgid "The total area within the water body's historical extent that has been classified as 'wet', measured in metres squared."
msgstr ""

#: 
msgid "*percent_wet*"
msgstr ""

#: 
msgid "The percentage of water body's historical extent that has been classified as 'wet'."
msgstr ""

#: 
msgid "*area_dry_m2*"
msgstr ""

#: 
msgid "The total area within the water body's historical extent that has been classified as 'dry', measured in metres squared."
msgstr ""

#: 
msgid "*percent_dry*"
msgstr ""

#: 
msgid "The percentage of the water body's historical extent that has been classified as 'dry'."
msgstr ""

#: 
msgid "*area_invalid_m2*"
msgstr ""

#: 
msgid "The total area within the water body's historical extent that has been classified as 'invalid', measured in metres squared."
msgstr ""

#: 
msgid "*percent_invalid*"
msgstr ""

#: 
msgid "The percentage of the water body's historical extent that has been classified as 'invalid'. An area is classified as 'invalid' if it was not clearly observed in the satellite acquisition."
msgstr ""

#: 
msgid "*area_observed_m2*"
msgstr ""

#: 
msgid "The total area within the water body's historical extent that was observed by the satellite on the given date."
msgstr ""

#: 
msgid "*percent_observed*"
msgstr ""

#: 
msgid "The percentage of the water body's historical extent that was observed by the satellite on the given date. This can be less than 100 for large water bodies that cannot be captured by a single scene."
msgstr ""

#: 
msgid "The DE Africa Waterbodies Historical Extent product is a static polygon-based view of the DE Africa Water Observations from Space All-Time Summary product. The historical extent represents where water has appeared in at least 5% of clear observations since 1987. It is not a capture of a water body's true extent in any given year, but a record of where water has appeared since 1987."
msgstr ""

#: 
msgid "Water body historical extent polygons are defined as contiguous sets of pixels that were classified as wet in at least 5% of clear observations since 1987. To be retained, the historical extent polygons must also include a contiguous set of pixels that were classified as wet in at least 10% of clear observations since 1987. This criteria helps to select permanent and seasonal water bodies while ignoring highly-irregular flooding events."
msgstr ""

#: 
msgid "For each water body, the Surface Area Change product provides the percentage of the historical extent that was classified as wet, dry, or invalid, for each Water Observation from Space Feature Layer scene that captured the water body. These measures are also provided as the area in metres squared. The invalid category captures classifications that are neither wet nor dry (e.g. cloud, cloud shadow, or missing). Percentage measurements are only provided when Water Observation from Space Feature Layer scenes clearly capture at least 85% of the historical extent in a single day and the percentage of invalid observations is less than 10%, which is considered enough of the water body to give a reliable percentage measurement of the wet and dry coverage."
msgstr ""

#: 
msgid "The scripts used to produce the DE Africa Waterbodies Historical Extent product and the DE Africa Waterbodies Surface Area Change product are available from the `Digital Earth Africa Waterbodies GitHub repository <https://github.com/digitalearthafrica/waterbodies>`__."
msgstr ""

#: 
msgid "`Water Observations from Space Feature Layer <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-Feature-Layer>`__"
msgstr ""

#: 
msgid "`Water Observations from Space All-Time Summary <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-All-Time-Summary>`__"
msgstr ""

#: 
msgid "Krause, Claire E.; Newey, Vanessa; Alger, Matthew J.; Lymburner, Leo. 2021. \"Mapping and Monitoring the Multi-Decadal Dynamics of Australia’s Open Waterbodies Using Landsat\" Remote Sens. 13, no. 8: 1437. https://doi.org/10.3390/rs13081437"
msgstr ""

#: 
msgid "Mueller, N., Lewis, A., Roberts, D., Ring, S., Melrose, R., Sixsmith, J., Lymburner, L., McIntyre, A., Tan, P., Curnow, S., & Ip, A. (2016). Water observations from space: Mapping surface water from 25 years of Landsat imagery across Australia. Remote Sensing of Environment, 174, 341–352. https://doi.org/10.1016/j.rse.2015.11.003"
msgstr ""

#: 
msgid "CC BY Attribution 4.0 International License."
msgstr ""

#: 
msgid "The DE Africa Waterbodies workflow is adapted from the workflow originally developed by Geoscience Australia. Digital Earth Africa thanks the Digital Earth Africa Product Development task team for the co-design, the co-development and early feedback on the Service."
msgstr ""

#: 
msgid "The Digital Earth Africa Waterbodies products can be accessed from the associated S3 bucket."
msgstr ""

#: 
msgid "**Table 5: AWS data access details**"
msgstr ""

#: 
msgid "``waterbodies``"
msgstr ""

#: 
msgid "Version 0.0.3 (beta) of the DE Africa Waterbodies Historical Extent product can be downloaded from the links below:"
msgstr ""

#: 
msgid "`DE Africa Waterbodies Historical Extent as a Geopackage <https://deafrica-services.s3.af-south-1.amazonaws.com/waterbodies/v0.0.3/historical_extent/waterbodies.gpkg>`__"
msgstr ""

#: 
msgid "`DE Africa Waterbodies Historical Extent as a Shapefile <https://deafrica-services.s3.af-south-1.amazonaws.com/waterbodies/v0.0.3/historical_extent/waterbodies.shp.zip>`__"
msgstr ""

#: 
msgid "``DEAfrica_Waterbodies``"
msgstr ""

#: 
msgid "The Waterbodies Service can be loaded and analysed in the DE Africa Sandbox following the `example Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Waterbodies.ipynb>`__."
msgstr ""

#: 
msgid "For further information regarding the use of DE Africa Water Bodies Service, `visit the Digital Earth Africa Help Desk <https://helpdesk.digitalearthafrica.org/portal/en/kb/search/waterbodies>`__."
msgstr ""

#: 
msgid "The DE Africa Water Bodies Service is comprised of two main products:"
msgstr ""

#: 
msgid "**Waterbodies Historical Extent**: a polygon dataset of static water body outlines. The outlines map where water was observed in at least 5% of clear satellite acquisitions between 1987 and 2002."
msgstr ""

#: 
msgid "**Waterbodies Surface Area Change**: a CSV time series capturing the wet, dry, and invalid surface area and percentage coverage for each individual water body polygon for every available Water Observations from Space Feature Layer scene."
msgstr ""

#: 
msgid "The DE Africa Waterbodies Historical Extent product is currently generated as a one-off product from the DE Africa Water Observations from Space All-Time Summary product."
msgstr ""

#: 
msgid "Inaccuracies and limitations"
msgstr ""

#: 
msgid "Missing water bodies"
msgstr ""

#: 
msgid "There are a few factors why a water body might be missing from this service."
msgstr ""

#: 
msgid "**It might be too small:** the Waterbodies Historical Extent only maps water bodies larger than 4,500m2 (5 Landsat pixels)."
msgstr ""

#: 
msgid "**It might not be wet enough:** the Waterbodies Historical Extent only maps water bodies that have been observed as wet 10% of the time between 1987 to 2022. If a water body fills infrequently, it may not meet this threshold."
msgstr ""

#: 
msgid "**The waterbody might have too much vegetation surrounding it:** the DE Africa Water Observations from Space classifier, which determines where water is observed, does not work well where water is mixed with vegetation. If there is vegetation obscuring the water (like a tree leaning across a river or a wetland), the classifier may not see this as water and the water body may not be mapped."
msgstr ""

#: 
msgid "**The water in the water body does not look like water:** dense sediment-filled water is often misclassified as land."
msgstr ""

#: 
msgid "**The water body might be new:** newly constructed/formed water bodies will not be included in this service as they will not have been observed as wet at least 10% of the time between 1987 to 2022."
msgstr ""

#: 
msgid "Missing river segments"
msgstr ""

#: 
msgid "The DE Africa Water Observations from Space Classifier, which determines where water is observed, does not work well where water is combined with vegetation. If there is vegetation obscuring the water (like a tree leaning across a river), the classifier may not see this as water, and the water body may be truncated, even though the river continues along underneath the vegetation."
msgstr ""

#: 
msgid "Additionally, the Water Observations from Space Feature Layers product (used to produce the Waterbodies Historical Extent product) has a pixel resolution of 30 metres by 30 metres. A pixel will only be classified as water where the pixel is almost entirely made up of water. For example, in areas where rivers narrow or contain large sandbanks, the pixel will include these other signatures and not be classified as water. Both of these factors mean that some rivers are not seen as continuous features in the Waterbodies Historical Extent product."
msgstr ""

#: 
msgid "Incomplete water bodies extent"
msgstr ""

#: 
msgid "Some of the Waterbodies Historical Extent polygons contain holes or are irregularly shaped. This is caused by the DE Africa Water Observations from Space classifier not seeing parts of the water body frequently enough; a pixel must be clearly observed at least 60 times to be included. Additionally the DE Africa Water Observations from Space classifier that determines where water is observed does not work well where water is combined with vegetation. If there is vegetation obscuring the water (like a tree leaning across a river or a wetland), the classifier may not see this as water and the resulting mapped waterbody may contain holes."
msgstr ""

#: 
msgid "Water bodies fused instead of being separate"
msgstr ""

#: 
msgid "Waterbodies Historical Extent polygons are mapped using classified pixels from the Water Observations from Space Feature Layers product. If a pixel is predominantly water, it will be mapped as water. Small levees or roads between adjacent water bodies will not necessarily separate the mapped water bodies if they are not large enough to influence the total make up of their pixel. This means that some separate water bodies are mapped as a single waterbody within the Waterbodies Historical Extent."
msgstr ""

#: 
msgid "Mapping flooded areas"
msgstr ""

#: 
msgid "By design, we have excluded locations where water is seen only during extreme flood events. A wetness threshold of 10% was applied to the data, meaning that only water bodies observed as wet at least 10% of the time between 1987 and 2022 have been included. This threshold was determined to be sensitive enough to capture the locations of persistent water bodies, but not so sensitive as to pick up too many false positives like flood irrigation, flood events or soggy areas in the landscape."
msgstr ""

#: 
msgid "Water Bodies Surface Area Change"
msgstr ""

#: 
msgid "The DE Africa Waterbodies Surface Area Change product will be updated weekly. An individual time series may not be updated with new percentage coverage measurements within the expected 16 day cadence if it was cloudy on the days the relevant data was acquired and processed. Landsat satellites do not observe all of Africa at the same time. The dates of satellite observations are dependent on the date that the satellite observed that water body."
msgstr ""

#: 
msgid "All usable observations for each water body have been included in the Surface Area Change time series for that water body. Short or missing time series can result from frequent cloud cover, misclassification, or other processing issues. If less than 85% of the total water body is observed on any one day, or more than 10% is invalid due to cloud cover or missing data, then the wet and dry percentages are not provided in the Surface Area Change time series. Cloud cover leading to invalid data can be a particular problem in coastal regions."
msgstr ""

#: 
msgid "Dealing with cloud cover"
msgstr ""

#: 
msgid "Data used within DE Africa Waterbodies Surface Area Change product is cloud masked. When a significant fraction of a water body is not observed, due to cloud cover or missing data, estimation of wet area as a percentage of total area is not reliable. Therefore, the wet and dry percentages are not provided when less than 85% of the total water body is observed on any one day."
msgstr ""

#: 
msgid "Spurious measurements and outliers"
msgstr ""

#: 
msgid "The DE Africa Waterbodies Surface Area Change product is derived from the DE Africa Water Observations from Space product. Any innaccuracies in this product will produce spurious measurements and outliers in the Surface Area Change Time Series."
msgstr ""

#: 
msgid "Two examples are shown in Figure 2. On the left, the circled observation in 2017 has a lower wet percentage than the previous two observations. This is because part of the water body is obscured by cloud cover, which can be seen in the corresponding Landsat true-color image and WOfS classification. On the right, the circled observation in 2019 has a much lower wet percentage than the previous two observations. This is because the WOfS algorithm has incorrectly classified much of the water body as dry, rather than wet, which can be seen in the corresponding Landsat true-color image and WOfS classification."
msgstr ""

#: 
msgid "Users should undertake their own analysis to investigate and remove spurious measurements and outliers from the time series as is appropriate to their use case. For example, In Figure 2, a rolling median was calculated using the previous three observations, which produces a smoothed trend that is more robust (but not completely immune) to outliers."
msgstr ""

#: 
msgid "**Figure 2: Spurious measurements and outliers in the Waterbodies Surface Area Change Time Series**"
msgstr ""

#: 
msgid "Spurious measurements and outliers in the Waterbodies Surface Area Change Time Series."
msgstr ""

#: 
msgid "Irregularly spaced time series"
msgstr ""

#: 
msgid "Landsat satellites do not observe all of Africa at the same time. The dates of satellite observations are dependent on the date that a satellite observed that water body. Currently, the Water Observations from Space Feature Layers product has a temporal resolution of 16 days."
msgstr ""

#: 
msgid "No distinction between water sources"
msgstr ""

#: 
msgid "This service does not differentiate between water sources, whether the water is from a natural or artificial water supply"
msgstr ""

#: 
msgid "No measurement of water body volume"
msgstr ""

#: 
msgid "This service does not measure the volume of water in any water body. This tool detects the wet surface area of a water body. The wet surface area does not necessarily correlate to the volume of water in a storage. For example, a water body can be observed as wet with just a shallow covering of water."
msgstr ""

#: 
msgid "World Settlement Footprint"
msgstr ""

#: 
msgid "**Date modified:** 21 November 2023"
msgstr ""

#: 
msgid "According to the UN Department of Economics and Social Affairs, 9.7 billion people will inhabit the planet by the year 2050. 55% of the world's population presently resides in urban areas, and by 2050, that number is projected to increase to 68%. Rapid and haphazard urbanization, when paired with the problems posed by climate change, can increase air pollution, make people more susceptible to catastrophes, and cause problems with the management of resources like water, raw materials, and energy (Mapping Our Human Footprint From Space, 2023)."
msgstr ""

#: 
msgid "To improve the understanding of current trends in global urbanisation, ESA and the German Aerospace Center (DLR), in collaboration with the Google Earth Engine team, are jointly developing the World Settlement Footprint – the world’s most comprehensive dataset on human settlement (G.D. Team, 2023)."
msgstr ""

#: 
msgid "The World Settlement Footprint 2015 is a 10m (0.32 arc sec) resolution binary mask outlining the 2015 global settlement extent derived by jointly exploiting multitemporal Sentinel-1 radar and Landsat-8 optical satellite imagery (Marconcini et al., 2020)."
msgstr ""

#: 
msgid "The World Settlement Footprint 2019 features data from the Copernicus Sentinel-1 and Sentinel-2 missions and provides information on global human settlements with unprecedented detail and precision (Marconcini et al., 2021)."
msgstr ""

#: 
msgid "The World Settlement Footprint Evolution was produced by processing seven million images from the US Landsat satellite collected between 1985 and 2015 and shows the annual growth of human settlements globally (Mapping Our Human Footprint From Space, 2023)."
msgstr ""

#: 
msgid "The World Settlement Footprint 2015, 2019, World Settlement Footprint Evolution data are now indexed in the DE Africa platform."
msgstr ""

#: 
msgid "`World Settlement Footprint <https://doi.org/10.1553/giscience2021_01_s33>`__"
msgstr ""

#: 
msgid "A `Jupyter Notebook for the World Settlement Footprint 2015 and 2019 dataset <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/World_Settlement_Footprint.ipynb>`__ and `Jupyter Notebook for the World Settlement Footprint Evolution <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/World_Settlement_Footprint-Evolution.ipynb>`__ which demonstrates loading and using the datasets in the Sandbox is also available."
msgstr ""

#: 
msgid "The specific temporal and geographic extents for the product can be explored as an interactive map on the metadata for `2015 <https://explorer.digitalearth.africa/products/wsf_2015>`__, `2019 <https://explorer.digitalearth.africa/products/wsf_2019>`__ and `Evolution <https://explorer.digitalearth.africa/products/wsf_evolution>`__."
msgstr ""

#: 
msgid "**Table 1: World Settlement Footprint product specifications**"
msgstr ""

#: 
msgid "``wsf_2015``"
msgstr ""

#: 
msgid "``wsf_2019``"
msgstr ""

#: 
msgid "``wsf_evolution``"
msgstr ""

#: 
msgid "10m"
msgstr ""

#: 
msgid "30m"
msgstr ""

#: 
msgid "2015"
msgstr ""

#: 
msgid "1985 - 2015"
msgstr ""

#: 
msgid "Data is available for the region shaded in blue."
msgstr ""

#: 
msgid "**Figure 1: World Settlement Footprint product geographic extent**"
msgstr ""

#: 
msgid "**Table 2: World Settlement Footprint product measurements**"
msgstr ""

#: 
msgid "wsf_2015"
msgstr ""

#: 
msgid "World Settlement Footprint 2015"
msgstr ""

#: 
msgid "wsf_2019"
msgstr ""

#: 
msgid "World Settlement Footprint 2019"
msgstr ""

#: 
msgid "wsfevolution"
msgstr ""

#: 
msgid "World Settlement Footprint Evolution"
msgstr ""

#: 
msgid "idcscore"
msgstr ""

#: 
msgid "Input Data Consistency score"
msgstr ""

#: 
msgid "The **World Settlement Footprint WSF 2015 version 2** (WSF2015 v2) is a 10m resolution binary mask outlining the extent of human settlements globally for the year 2015. Specifically, the WSF2015 v2 is a pilot product generated by combining multiple datasets.The **World Settlement Footprint (WSF) 2015** derived at 10m spatial resolution by means of 2014-2015 multitemporal Landsat-8 and Sentinel-1 imagery (of which ~217K and ~107K scenes have been processed, respectively). The High Resolution Settlement Layer (HRSL) generated by the Connectivity Lab team at Facebook through the employment of 2016 DigitalGlobe VHR satellite imagery and publicly released at 30m spatial resolution for 214 countries (Marconcini et al., 2020)."
msgstr ""

#: 
msgid "The **World Settlement Footprint (WSF) 2019** is a 10m resolution binary mask outlining the extent of human settlements globally derived by means of 2019 multitemporal Sentinel-1 (S1) and Sentinel-2 (S2) imagery. Based on the hypothesis that settlements generally show a more stable behavior with respect to most land-cover classes, temporal statistics are calculated for both S1- and S2-based indices. In particular, a comprehensive analysis has been performed by exploiting a number of reference building outlines to identify the most suitable set of temporal features (ultimately including 6 from S1 and 25 from S2). Training points for the settlement and non-settlement class are then generated by thresholding specific features, which varies depending on the 30 climate types of the well-established Köppen Geiger scheme. Next, binary classification based on Random Forest is applied and, finally, a dedicated post-processing is performed where ancillary datasets are employed to further reduce omission and commission errors. Here, the whole classification process has been entirely carried out within the Google Earth Engine platform. To assess the high accuracy and reliability of the WSF2019, two independent crowd-sourcing-based validation exercises have been carried out with the support of Google and Mapswipe, respectively, where overall 1M reference labels have been collected based photointerpretation of very high-resolution optical imagery (Marconcini et al., 2021)."
msgstr ""

#: 
msgid "The **World Settlement Footprint (WSF Evolution)** is a 30m resolution dataset outlining the global settlement extent on a yearly basis from 1985 to 2015. Based on the assumption that settlement growth occurred over time, all pixels categorized as non-settlement in the WSF2015 (Marconcini et al., 2020) are excluded a priori from the analysis. Next, for each target year in the past, all available Landsat-5/7 scenes acquired over the given area of interest are gathered and key temporal statistics (i.e., temporal mean, minimum, maximum, etc.) are then extracted for different spectral indices. Among others, these include: the normalized difference built-up index (NDBI), normalized difference vegetation index (NDVI) and modified normalized difference water index (MNDWI). Temporal features proved generally robust if computed over at least 7 clear cloud-/cloud-shadow-free observations; accordingly, if for a given pixel in the target year this constraint is not satisfied, the time frame is enlarged backwards (at 1-year steps) as long as the condition is met."
msgstr ""

#: 
msgid "Starting backwards from the year 2015 - for which the WSF2015 is used as a reference - settlement and non-settlement training samples for the given target year t are iteratively extracted by applying morphological filtering to the settlement mask derived for the year t+1, as well as excluding potentially mislabeled samples by adaptively thresholding the temporal mean NDBI, MNDWI and NDVI. Finally, binary Random Forest classification in performed."
msgstr ""

#: 
msgid "To quantitatively assess the high accuracy and reliability of the dataset, an extensive campaign based on crowdsourcing photointerpretation of very high-resolution airborne and satellite historical imagery has been performed with the support of Google. In particular, for the years 1990, 1995, 2000, 2005, 2010 and 2015, ~200K reference cells of 30x30m size distributed over 100 sites around the world have been labelled, hence summing up to overall ~1.2M validation samples."
msgstr ""

#: 
msgid "It is worth noting that past Landsat-5/7 availability considerably varies across the world and over time. Independently from the implemented approach, this might then result in a lower quality of the final product where few/no scenes have been collected. Accordingly, to provide the users with a suitable and intuitive measure that accounts for the goodness of the Landsat imagery, we conceived the Input Data Consistency (IDC) score, which ranges from 6 to 1 with: 6) very good; 5) good; 4) fair; 3) moderate; 2) low; 1) very low. The IDC score is available on a yearly basis between 1985 and 2015 and supports a proper interpretation of the WSF evolution product."
msgstr ""

#: 
msgid "The WSF evolution and IDC score datasets are organized in 5138 GeoTIFF files (EPSG4326 projection) each one referring to a portion of 2 x 2 degree size (~222 x 222 km) on the ground. WSF evolution values range between 1985 and 2015 corresponding to the estimated year of settlement detection, whereas 0 is no data. A comprehensive publication with all technical details and accuracy figures is currently being finalized. For the time being, please refer to `Marconcini et al,. 2021 <https://austriaca.at/0xc1aa5576%200x003c9b4c.pdf>`__."
msgstr ""

#: 
msgid "**Figure 2: World Settlement Footprint over Kumasi, Ghana**"
msgstr ""

#: 
msgid "wsf 2015 and 2019"
msgstr ""

#: 
msgid "**Figure 3: World Settlement Footprint over Harare, Zimbabwe**"
msgstr ""

#: 
msgid "**Figure 4: World Settlement Footprint Evolution over Mansoura, Egypt with IDC score for the image**"
msgstr ""

#: 
msgid "Mapping our human footprint from space(Accessed on 2023 August). ESA - Mapping Our Human Footprint From Space. https://www.esa.int/Applications/Observing_the_Earth/Mapping_our_human_footprint_from_space"
msgstr ""

#: 
msgid "Marconcini, M., Metz-Marconcini, A., Üreyen, S. et al. Outlining where humans live, the World Settlement Footprint 2015. Sci Data 7, 242 (2020). https://doi.org/10.1038/s41597-020-00580-5"
msgstr ""

#: 
msgid "Mattia Marconcini, Annekatrin Metz-Marconcini, Thomas Esch and Noel Gorelick. Understanding Current Trends in Global Urbanisation - The World Settlement Footprint Suite. GI_Forum 2021, Issue 1, 33-38 (2021) https://austriaca.at/0xc1aa5576%200x003c9b4c.pdf"
msgstr ""

#: 
msgid "G.D.Team (Accessed on 2023 August). EOC Geoservice Map Contexts. EOC Geoservice Map Contexts. https://geoservice.dlr.de/web/maps"
msgstr ""

#: 
msgid "The World Settlement Footprint is provided free of charge, without restriction of use. For the full license information see the `Creative Commons Attribution 4.0 International License <https://creativecommons.org/licenses/by/4.0/>`__."
msgstr ""

#: 
msgid "The World Settlement Footprint 10m 2015 2019, Evolution products are avaliable in AWS S3."
msgstr ""

#: 
msgid "``arn:aws:s3:::wsf_{year}``"
msgstr ""

#: 
msgid "Bucket"
msgstr ""

#: 
msgid "``deafrica-input-datasets``"
msgstr ""

#: 
msgid "The products are hosted on the ``wsf_{year}`` S3 bucket in the AWS ``deafrica-input-datasets``."
msgstr ""

#: 
msgid "The file paths follow the format: ``s3://deafrica-input-datasets/wsf_{year}/``"
msgstr ""

#: 
msgid "The World Settlement Footprint 10m product ``wsf_2015``, ``wsf_2019``, ``wsf_evolution`` are available through the Digital Earth Africa's OWS."
msgstr ""

#: 
msgid "``https://ows.digitalearth.africa/wms``"
msgstr ""

#: 
msgid "``https://ows.digitalearth.africa/wcs``"
msgstr ""

#: 
msgid "``wsf_{year}``"
msgstr ""

#: 
msgid "The World Settlement Footprint product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``wsf_{year}`` and ``wsf_evolution``"
msgstr ""

#: 
msgid "The ``wsf_{year}`` product has only one specific band of data which can be called by using the default name, ``wsf{year}``, as listed in the table below. ODC ``Datacube.load`` commands without specified bands will load the ``wsf_{year}`` band."
msgstr ""

#: 
msgid "**Table 5: ODC product World Settlement Footprint band names.**"
msgstr ""

#: 
msgid "wsf{year}"
msgstr ""

#: 
msgid "iSDA Soil"
msgstr ""

#: 
msgid "**Products used:** `iSDA Soil <https://aws.amazon.com/marketplace/pp/prodview-3bfpv6jsl4tqk?sr=0-4&ref_=beagle&applicationId=AWSMPContessa>`__; `iSDA Soil Bedrock Depth <https://explorer.digitalearth.africa/products/isda_soil_bedrock_depth>`__; `iSDA Soil Bulk Density <https://explorer.digitalearth.africa/products/isda_soil_bulk_density>`__; `iSDA Soil Carbon Total <https://explorer.digitalearth.africa/products/isda_soil_carbon_total>`__; `iSDA Soil Clay Content <https://explorer.digitalearth.africa/products/isda_soil_clay_content>`__; `iSDA Soil Sand Content <https://explorer.digitalearth.africa/products/isda_soil_sand_content>`__; `iSDA Soil Silt Content <https://explorer.digitalearth.africa/products/isda_soil_silt_content>`__;"
msgstr ""

#: 
msgid "**Date modified:** 31 October 2023"
msgstr ""

#: 
msgid "Innovative Solutions for Decision Agriculture `iSDA soil <https://www.isda-africa.com/isdasoil/>`__ is an open access soils data resource for the African continent. The key data products are spatial predictions of soil nutrient concentrations and soil properties, derived from predictive soil mapping (PSM) techniques."
msgstr ""

#: 
msgid "Soils data can be useful for a range of applications including land suitability mapping for agriculture, soil amelioration planning (e.g. liming to address acidic soils or fertiliser to address fertility constraints), and for construction or infrastructure planning."
msgstr ""

#: 
msgid "iSDA variables"
msgstr ""

#: 
msgid "iSDA offers numerous soil variables shown in the table below. Many of the variables have four layers: mean and standard deviation at 0-20cm and 20-50cm depth. Layers are accessible via their Access Names e.g. 'bedrock_depth' in the `Sandbox <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/iSDAsoil.html>`__."
msgstr ""

#: 
msgid "Some variables are indexed in Digital Earth Africa, and others can be brought in directly."
msgstr ""

#: 
msgid "**Table 1: iSDA soil products available on the DE Africa platform.**"
msgstr ""

#: 
msgid "Access Name"
msgstr ""

#: 
msgid "Layers"
msgstr ""

#: 
msgid "Depth to bedrock"
msgstr ""

#: 
msgid "bedrock_depth"
msgstr ""

#: 
msgid "0-200cm depth, predicted mean and standard deviation"
msgstr ""

#: 
msgid "Bulk density, <2mm fraction"
msgstr ""

#: 
msgid "bulk_density"
msgstr ""

#: 
msgid "0-20cm and 20-50cm, predicted mean and standard deviation"
msgstr ""

#: 
msgid "Carbon, total"
msgstr ""

#: 
msgid "carbon_total"
msgstr ""

#: 
msgid "Clay content"
msgstr ""

#: 
msgid "clay_content"
msgstr ""

#: 
msgid "0-20 cm and 20-50 cm, predicted mean and standard deviation"
msgstr ""

#: 
msgid "Sand content"
msgstr ""

#: 
msgid "sand_content"
msgstr ""

#: 
msgid "Silt content"
msgstr ""

#: 
msgid "silt_content"
msgstr ""

#: 
msgid "Relevant metadata for the iSDA soil products, as well as the specific temporal and geographic extents for the product can be explored as an interactive map on the `DE Africa Metadata Explorer <https://explorer.digitalearth.africa/products/isda_soil_bedrock_depth>`__. Data is available for the shaded region. A `Jupyter Notebook <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Datasets/iSDAsoil.html>`__ which demonstrates loading and using iSDA soil products in the Sandbox is also available."
msgstr ""

#: 
msgid "**Figure 1: iSDA soil bedrock depth geographic extent**"
msgstr ""

#: 
msgid "iSDA Soil Geographic Extent"
msgstr ""

#: 
msgid "Spatial prediction of soil properties in the iSDA product suite was undertaken with five regression modelling algorithms. The prediction process utilises field data in combination with covariates such as topographic and surface reflectance data. Further technical information on iSDA products, and links to academic papers describing the methodology, can be found on the `iSDA technical information page <https://www.isda-africa.com/isdasoil/technical-information/>`__."
msgstr ""

#: 
msgid "Miller MAE, Shepherd KD, Kisitu B, Collinson J (2021) iSDAsoil: The first continent-scale soil property map at 30 m resolution provides a soil information revolution for Africa. PLoS Biol 19(11): e3001441. https://doi.org/10.1371/journal.pbio.3001441"
msgstr ""

#: 
msgid "Credits: iSDA"
msgstr ""

#: 
msgid "Product Details"
msgstr ""

#: 
msgid "The specifications for the six products listed above in Table 1 are described in succession below."
msgstr ""

#: 
msgid "1. iSDA Soil Bedrock Depth"
msgstr ""

#: 
msgid "Soil bedrock depth can be useful for development planning, such as agricultural developments or construction."
msgstr ""

#: 
msgid "**Table 2: iSDA soil bedrock depth product specifications**"
msgstr ""

#: 
msgid "``isda_soil_bedrock_depth``"
msgstr ""

#: 
msgid "EPSG:3857"
msgstr ""

#: 
msgid "**Table 3: iSDA soil bedrock depth product measurements**"
msgstr ""

#: 
msgid "mean_0_200"
msgstr ""

#: 
msgid "Soil bedrock depth, mean prediction 0-200cm"
msgstr ""

#: 
msgid "cm"
msgstr ""

#: 
msgid "float32"
msgstr ""

#: 
msgid "stdev_0_200"
msgstr ""

#: 
msgid "Soil bedrock depth, prediction standard deviation 0-200cm"
msgstr ""

#: 
msgid "**Figure 2: iSDA soil bedrock depth (cm) for an area near Cape Town, South Africa.**"
msgstr ""

#: 
msgid "iSDA Bedrock Depth"
msgstr ""

#: 
msgid "iSDA layers are available in `AWS S3 <https://registry.opendata.aws/isdasoil/>`__, details below. iSDA has published `documentation <https://www.isda-africa.com/isdasoil/isdasoil-on-aws/>`__ on accessing data through AWS."
msgstr ""

#: 
msgid "**Table 4: iSDA depth to bedrock access details through AWS.**"
msgstr ""

#: 
msgid "``arn:aws:s3:::isdasoil``"
msgstr ""

#: 
msgid "``us-west-2``"
msgstr ""

#: 
msgid "The iSDA soil depth to bedrock product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_bedrock_depth``"
msgstr ""

#: 
msgid "The ``isda_soil_bedrock_depth`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 5: iSDA depth to bedrock band names.**"
msgstr ""

#: 
msgid "MEAN_0_200"
msgstr ""

#: 
msgid "STDEV_0_200"
msgstr ""

#: 
msgid "2. iSDA Soil Bulk Density"
msgstr ""

#: 
msgid "Soil bulk density is a useful variable for understanding soil's capacity to support ecosystem functions and other uses. It is also a useful input for planning soil additive rates."
msgstr ""

#: 
msgid "**Table 6: iSDA soil bulk density product specifications**"
msgstr ""

#: 
msgid "``isda_soil_bulk_density``"
msgstr ""

#: 
msgid "**Table 7: iSDA soil bulk density product measurements**"
msgstr ""

#: 
msgid "mean_0_20"
msgstr ""

#: 
msgid "Soil bulk density, mean prediction 0-20cm"
msgstr ""

#: 
msgid "g/cm\\ :math:`^3`"
msgstr ""

#: 
msgid "mean_20_50"
msgstr ""

#: 
msgid "Soil bulk density, mean prediction 20-50cm"
msgstr ""

#: 
msgid "stdev_0_20"
msgstr ""

#: 
msgid "Soil bulk density, prediction standard deviation 0-20cm"
msgstr ""

#: 
msgid "stdev_20_50"
msgstr ""

#: 
msgid "Soil bulk density, prediction standard deviation 20-50cm"
msgstr ""

#: 
msgid "**Figure 3: iSDA soil bulk density (g/cm3) for an area near Cape Town, South Africa.**"
msgstr ""

#: 
msgid "iSDA Bulk Density"
msgstr ""

#: 
msgid "**Table 8: iSDA soil bulk density access details through AWS.**"
msgstr ""

#: 
msgid "The iSDA soil bulk density product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_bulk_density``"
msgstr ""

#: 
msgid "The ``isda_soil_bulk_density`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 9: iSDA soil bulk density band names.**"
msgstr ""

#: 
msgid "MEAN_0_20"
msgstr ""

#: 
msgid "MEAN_20_50"
msgstr ""

#: 
msgid "STDEV_0_20"
msgstr ""

#: 
msgid "STDEV_20_50"
msgstr ""

#: 
msgid "3. iSDA Soil Carbon Total"
msgstr ""

#: 
msgid "Total soil carbon is critical to a range of application such as Carbon cycle and Land Degradation Neutrality (LDN) monitoring."
msgstr ""

#: 
msgid "**Table 10: iSDA soil carbon total product specifications**"
msgstr ""

#: 
msgid "``isda_soil_carbon_total``"
msgstr ""

#: 
msgid "**Table 11: iSDA soil carbon total product measurements**"
msgstr ""

#: 
msgid "Soil carbon total, mean prediction 0-20cm"
msgstr ""

#: 
msgid "g/kg"
msgstr ""

#: 
msgid "Soil carbon total, mean prediction 20-50cm"
msgstr ""

#: 
msgid "Soil carbon total, prediction standard deviation 0-20cm"
msgstr ""

#: 
msgid "Soil carbon total, prediction standard deviation 20-50cm"
msgstr ""

#: 
msgid "Back Transformation"
msgstr ""

#: 
msgid "Soil carbon total values must be transformed, in Python the transformation can be written as ``np.expm1(x/10)``."
msgstr ""

#: 
msgid "**Figure 4: iSDA soil carbon total (g/kg) for an area near Lake Tana, Ethiopia.**"
msgstr ""

#: 
msgid "iSDA Soil Carbon Total"
msgstr ""

#: 
msgid "**Table 12: iSDA soil carbon total access details through AWS.**"
msgstr ""

#: 
msgid "The iSDA soil carbon total product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_carbon_total``"
msgstr ""

#: 
msgid "The ``isda_soil_carbon_total`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 13: iSDA soil carbon total band names.**"
msgstr ""

#: 
msgid "4. iSDA Soil Clay Content"
msgstr ""

#: 
msgid "Soil clay content is one of three (sand, silt, clay) soil texture layers. Soil texture determines many other soil attributes, such as water and nutrient holding capacity."
msgstr ""

#: 
msgid "**Table 14: iSDA soil clay content product specifications**"
msgstr ""

#: 
msgid "``isda_soil_clay_content``"
msgstr ""

#: 
msgid "**Table 15: iSDA soil clay content total product measurements**"
msgstr ""

#: 
msgid "Soil clay content, mean prediction 0-20cm"
msgstr ""

#: 
msgid "Soil clay content, mean prediction 20-50cm"
msgstr ""

#: 
msgid "Soil clay content, prediction standard deviation 0-20cm"
msgstr ""

#: 
msgid "Soil clay content, prediction standard deviation 20-50cm"
msgstr ""

#: 
msgid "**Figure 5: iSDA soil clay content (%) in the Okavango Delta, Botswana.**"
msgstr ""

#: 
msgid "iSDA Soil Clay Content"
msgstr ""

#: 
msgid "**Table 16: iSDA soil clay content access details through AWS.**"
msgstr ""

#: 
msgid "The iSDA soil clay content product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_clay_content``"
msgstr ""

#: 
msgid "The ``isda_soil_clay_content`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 17: iSDA soil clay content band names.**"
msgstr ""

#: 
msgid "5. iSDA Soil Sand Content"
msgstr ""

#: 
msgid "Soil sand content is one of three (sand, silt, clay) soil texture layers. Soil texture determines many other soil attributes, such as water and nutrient holding capacity."
msgstr ""

#: 
msgid "**Table 18: iSDA soil sand content product specifications**"
msgstr ""

#: 
msgid "``isda_soil_sand_content``"
msgstr ""

#: 
msgid "**Table 19: iSDA soil sand content total product measurements**"
msgstr ""

#: 
msgid "Soil sand content, mean prediction 0-20cm"
msgstr ""

#: 
msgid "Soil sand content, mean prediction 20-50cm"
msgstr ""

#: 
msgid "Soil sand content, prediction standard deviation 0-20cm"
msgstr ""

#: 
msgid "Soil sand content, prediction standard deviation 20-50cm"
msgstr ""

#: 
msgid "**Figure 6: iSDA soil sand content (%) in the Okavango Delta, Botswana.**"
msgstr ""

#: 
msgid "iSDA Soil Sand Content"
msgstr ""

#: 
msgid "**Table 20: iSDA soil sand content access details through AWS.**"
msgstr ""

#: 
msgid "The iSDA soil sand content product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_sand_content``"
msgstr ""

#: 
msgid "The ``isda_soil_sand_content`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 21: iSDA soil sand content band names.**"
msgstr ""

#: 
msgid "6. iSDA Soil Silt Content"
msgstr ""

#: 
msgid "Soil silt content is one of three (sand, silt, clay) soil texture layers. Soil texture determines many other soil attributes, such as water and nutrient holding capacity."
msgstr ""

#: 
msgid "**Table 22: iSDA soil silt content product specifications**"
msgstr ""

#: 
msgid "``isda_soil_silt_content``"
msgstr ""

#: 
msgid "**Table 23: iSDA soil silt content total product measurements**"
msgstr ""

#: 
msgid "Soil silt content, mean prediction 0-20cm"
msgstr ""

#: 
msgid "Soil silt content, mean prediction 20-50cm"
msgstr ""

#: 
msgid "Soil silt content, prediction standard deviation 0-20cm"
msgstr ""

#: 
msgid "Soil silt content, prediction standard deviation 20-50cm"
msgstr ""

#: 
msgid "**Figure 7: iSDA soil silt content (%) in the Okavango Delta, Botswana.**"
msgstr ""

#: 
msgid "iSDA Soil Silt Content"
msgstr ""

#: 
msgid "**Table 24: iSDA soil silt content access details through AWS.**"
msgstr ""

#: 
msgid "The iSDA soil silt content product can be accessed through the Digital Earth Africa ODC API, which is available through the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/hub/login>`__."
msgstr ""

#: 
msgid "**ODC product name:** ``isda_soil_silt_content``"
msgstr ""

#: 
msgid "The ``isda_soil_silt_content`` has two layers: the estimate itself and standard deviation as a measure of prediction uncertainty. They can be called by using the default name or by the band’s alternative name as listed in the table below."
msgstr ""

#: 
msgid "**Table 4: iSDA soil silt content band names.**"
msgstr ""

#: 
msgid "Keyword Index"
msgstr ""

#: 
msgid "This is a placeholder to use the generated index in the Table of Contents. Only the heading will be used."
msgstr ""

#: 
msgid "Home"
msgstr ""

#: 
msgid "Data"
msgstr ""

#: 
msgid "Platforms"
msgstr ""

#: 
msgid "About"
msgstr ""

#: 
msgid "Digital Earth Africa User Guide"
msgstr ""

#: 
msgid "The `Digital Earth Africa <https://www.digitalearthafrica.org/>`_ platform consists of a repository of Earth Observation data and a set of tools to view and analyse that data."
msgstr ""

#: 
msgid ":doc:`data_specs/index`"
msgstr ""

#: 
msgid "Access up-to-date technical specifications of all Digital Earth Africa datasets"
msgstr ""

#: 
msgid ":doc:`More <data_specs/index>`"
msgstr ""

#: 
msgid ":doc:`maps/deafrica_map`"
msgstr ""

#: 
msgid "Our user friendly map-based access to DE Africa data and products"
msgstr ""

#: 
msgid ":doc:`More <maps/deafrica_map>`"
msgstr ""

#: 
msgid ":doc:`maps/external_web_services`"
msgstr ""

#: 
msgid "Intergrating external web services into the DE Africa platform."
msgstr ""

#: 
msgid ":doc:`More <maps/external_web_services>`"
msgstr ""

#: 
msgid ":doc:`sandbox/index`"
msgstr ""

#: 
msgid "Our JupyterLab Analysis Platform for exploring the data with access to analysis tools"
msgstr ""

#: 
msgid ":doc:`More <sandbox/index>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/explorer`"
msgstr ""

#: 
msgid "The Metadata Explorer allows you to see where and when you can find data"
msgstr ""

#: 
msgid ":doc:`More <platform_tools/explorer>`"
msgstr ""

#: 
msgid ":doc:`maps/geoportal`"
msgstr ""

#: 
msgid "Imagery from DE Africa is available in Esri’s Africa GeoPortal, providing geospatial tools, data and training"
msgstr ""

#: 
msgid ":doc:`More <maps/geoportal>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/web_services_gis`"
msgstr ""

#: 
msgid "Access to DE Africa data from QGIS or ArcGIS using Web Map Service and Web Coverage Service"
msgstr ""

#: 
msgid ":doc:`More <platform_tools/web_services_gis>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/cube-in-a-box`"
msgstr ""

#: 
msgid "The Cube in a Box is a simple way to run the Open Data Cube."
msgstr ""

#: 
msgid ":doc:`More <platform_tools/cube-in-a-box>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/direct_access`"
msgstr ""

#: 
msgid "Directly access the data and metadata from cloud data storage"
msgstr ""

#: 
msgid ":doc:`More <platform_tools/direct_access>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/odc_stac`"
msgstr ""

#: 
msgid "Load STAC compliant earth observation data as an `xarray.Dataset` from the python environment of your choice."
msgstr ""

#: 
msgid ":doc:`More <platform_tools/odc_stac>`"
msgstr ""

#: 
msgid ":doc:`platform_tools/googledrive_access`"
msgstr ""

#: 
msgid "Connecting Google Drive Folder to DE Africa Sandbox"
msgstr ""

#: 
msgid ":doc:`More <platform_tools/googledrive_access>`"
msgstr ""

#: 
msgid "DE Africa Map"
msgstr ""

#: 
msgid "This guide provides detailed instructions on how to use the different features of the `Digital Earth Africa Map <https://maps.digitalearth.africa/>`__."
msgstr ""

#: 
msgid "Get Started"
msgstr ""

#: 
msgid "To launch the DE Africa Map and display some basic data follow these steps."
msgstr ""

#: 
msgid "Launch the DE Africa Map at `maps.digitalearth.africa <https://maps.digitalearth.africa/>`__."
msgstr ""

#: 
msgid "In the left panel click the **Add Data** button to open the data catalogue (see image below)."
msgstr ""

#: 
msgid "Find a dataset of interest such as water."
msgstr ""

#: 
msgid "Select the dataset to see a preview of that data and description."
msgstr ""

#: 
msgid "To view your selected dataset on the map, click the **Add to the map** button."
msgstr ""

#: 
msgid "DE Africa maps image"
msgstr ""

#: 
msgid "Visualise and analyse your dataset:"
msgstr ""

#: 
msgid "The spatial data will be displayed in the map view, and a visual legend will appear in the Data workbench, on the left side of the page."
msgstr ""

#: 
msgid "It may not be immediately obvious where your selected spatial data has loaded on the map if it does not cover a large part of Africa. To locate loaded data on the map, go to the workbench, and select **Zoom to extent**."
msgstr ""

#: 
msgid "The dataset should now be visible in the map view."
msgstr ""

#: 
msgid "To add additional datasets to the map, repeat the above steps."
msgstr ""

#: 
msgid "Zoom manually by moving your mouse pointer over the map and using your mouse wheel to zoom in or out further."
msgstr ""

#: 
msgid "Click and drag the map to further show the region in which you are interested."
msgstr ""

#: 
msgid "Explore the workbench"
msgstr ""

#: 
msgid "When a dataset is added to the map via the data catalogue, a legend for that dataset will appear in the workbench. From the workbench you can:"
msgstr ""

#: 
msgid "Set the order data is shown on the map. To do this, click the title of a dataset and drag it to a new position in your workbench."
msgstr ""

#: 
msgid "Toggle the visibility of added datasets by selecting the checkbox opposite your prefered dataset title"
msgstr ""

#: 
msgid "Zoom to the geographical extent of an added data set"
msgstr ""

#: 
msgid "Set the opacity of individual data sets"
msgstr ""

#: 
msgid "Remove data sets from the map. Note: they can be re-added via the data catalogue."
msgstr ""

#: 
msgid "Navigate the Map"
msgstr ""

#: 
msgid "There are multiple ways to navigate DE Africa Map's map view:"
msgstr ""

#: 
msgid "Zooming"
msgstr ""

#: 
msgid "Move your mouse pointer over the map and use the scroll wheel to zoom in or out. The location at the centre of the map display is the centre of the zooming. Right-click and drag upwards or downwards over the map to zoom about the centre point. Select the zoom control to zoom in or out quickly by a set amount."
msgstr ""

#: 
msgid "Panning"
msgstr ""

#: 
msgid "Click anywhere on the map and drag it to the required location."
msgstr ""

#: 
msgid "Rotate the map"
msgstr ""

#: 
msgid "Use the compass control to rotate the map so North is no longer at the top. Select the “gyroscope” in the centre of the compass control and drag slowly to the left or right to rotate the map clockwise or anti-clockwise respectively. The further you drag, the faster it rotates. Release the mouse button when you reach the desired rotation."
msgstr ""

#: 
msgid "Select the North Point or outer ring of the Compass Control and drag it around to set the desired rotation directly."
msgstr ""

#: 
msgid "Control + left-click and drag left or right over the map to rotate the view about the centre."
msgstr ""

#: 
msgid "Perspective view"
msgstr ""

#: 
msgid "Select the “gyroscope” in the centre of the compass control and drag slowly upwards to tilt the view into a perspective view. Drag downwards to tilt the view back to vertical. The further you drag, the faster it tilts. Release the mouse button when you reach the desired view."
msgstr ""

#: 
msgid "Control + left-click and drag upwards or downwards over the map to enter or adjust the perspective view."
msgstr ""

#: 
msgid "When you are in perspective view, control + left-click and drag left or right over the map to “orbit” around the centre of the view. You can also click and drag left or right over the “gyroscope” at the centre of the Compass Control to orbit about the centre of the view."
msgstr ""

#: 
msgid "Double-click the “gyroscope” in the centre of the Compass Control to return the view quickly to a vertical view with North to the top at the current location and scale."
msgstr ""

#: 
msgid "Dragging to pan and using the mouse wheel to zoom still work while showing a perspective view."
msgstr ""

#: 
msgid "Use the splitter functionality"
msgstr ""

#: 
msgid "The splitter functionality allows you to compare a dataset for different time periods. To use it:"
msgstr ""

#: 
msgid "Select an area/location"
msgstr ""

#: 
msgid "Select a dataset from the catalogue to add it to the workbench"
msgstr ""

#: 
msgid "Select the **Split** link in the workbench to create a copy of the data already selected. Note that you can use the splitter with two different datasets, not just with copies of the same data"
msgstr ""

#: 
msgid "Select different times (using the date picker) for the “left” and “right” sections of the screen"
msgstr ""

#: 
msgid "Use the back and forward arrows to explore imagery and select cloud-free views"
msgstr ""

#: 
msgid "Drag the splitter on the screen to observe the differences"
msgstr ""

#: 
msgid "This video shows an example of the splitter used over a map of Australia, but the functionality is the same."
msgstr ""

#: 
msgid "`Split functionality video <http://www.youtube.com/watch?v=H3htpdYAE7w>`__"
msgstr ""

#: 
msgid "Upload Data to the Map"
msgstr ""

#: 
msgid "There are two ways to load your data:"
msgstr ""

#: 
msgid "Drag your data file onto the DE Africa Map map view. The format of the data file will be auto-detected."
msgstr ""

#: 
msgid "Select **Add Data** in the left panel. This will launch the data catalogue. Select the **My Data** tab at the top of the modal window and follow the provided instructions."
msgstr ""

#: 
msgid "As for DE Africa Map data sets, you can select regions or points to see the data available for that location. If the file is a CSV file, the data from all columns will be shown in the feature information dialogue."
msgstr ""

#: 
msgid "You can also use all of the features of the workbench on the data you have loaded as well."
msgstr ""

#: 
msgid "To share a view of your data with others, you must first publish it to the web somewhere with a URL, and then load it from there."
msgstr ""

#: 
msgid "DE Africa Map can display two kinds of spreadsheets:"
msgstr ""

#: 
msgid "Spreadsheets with a point location (latitude and longitude) for each row, expressed as two columns: lat and lon. These will be displayed as points (circles)."
msgstr ""

#: 
msgid "Spreadsheets where each row refers to a country using ISO 3166 2-letter or 3-letter code. Columns must be named cnt2, iso2, cnt3 or iso3 according to the `CSV-geo-au standard <https://github.com/TerriaJS/nationalmap/wiki/csv-geo-au#country-boundaries>`__. These will be displayed as regions, highlighting the actual shape of each area."
msgstr ""

#: 
msgid "Spreadsheets must be saved as CSV (comma-separated values)."
msgstr ""

#: 
msgid "Other standard spatial data types such as GeoJSON and KML are also supported."
msgstr ""

#: 
msgid "`Upload Location <http://www.youtube.com/watch?v=XKP90TcBq6A>`__"
msgstr ""

#: 
msgid "Integrating External Web Services"
msgstr ""

#: 
msgid "The DE Africa platform is built on top of open standards and can integrate with a range of external web services. Some examples of external services are included on this page."
msgstr ""

#: 
msgid "Norway's International Climate and Forests Initiative Data program (NICFI)"
msgstr ""

#: 
msgid "NICFI has arranged for non-commercial users to be able to access high-resolution, analysis-ready mosaics over the world's tropics. It's possible to integrate the visual layers into DE Africa's Maps application or to download the data to use in the DE Africa Sandbox. For more information, see `Planet's NICFI page <https://www.planet.com/nicfi/>`__."
msgstr ""

#: 
msgid "Steps to load NICFI visual layers in Maps"
msgstr ""

#: 
msgid "Sign up for the program on the `NICFI home page <https://www.planet.com/nicfi/#sign-up>`__"
msgstr ""

#: 
msgid "Once you have access, copy your ``API_KEY`` from your `\"My Settings\" <https://www.planet.com/account/#/user-settings>`__ page on the Planet website"
msgstr ""

#: 
msgid "Copy this URL, and add your ``API_KEY`` to the end: ``https://api.planet.com/basemaps/v1/mosaics/wmts?api_key=YOURKEYGOESHERE``"
msgstr ""

#: 
msgid "Go to `DE Africa Maps <https://maps.digitalearth.africa/>`__ and do the following:"
msgstr ""

#: 
msgid "Click \"Explore map data\""
msgstr ""

#: 
msgid "Click \"My Data\""
msgstr ""

#: 
msgid "Click \"Web Data\""
msgstr ""

#: 
msgid "Pasted the above URL into the \"Step 2\" section, and click \"Add\""
msgstr ""

#: 
msgid "NICFI in DE Africa Maps."
msgstr ""

#: 
msgid "When you've added one of the mosaics, you can visualise it across Africa in context with DE Africa data, such as the Sentinel-2 GeoMAD."
msgstr ""

#: 
msgid "Africa GeoPortal"
msgstr ""

#: 
msgid "Esri provides geographic information system software, web GIS and geodatabase management applications. They have developed the `Africa GeoPortal <https://deafrica.africageoportal.com/>`_, which uses imagery from DE Africa to provide location for geospatial tools data and training free for users working on Africa geospatial challenges."
msgstr ""

#: 
msgid "Sign up to the geoportal at:"
msgstr ""

#: 
msgid "`deafrica.africageoportal.com <https://deafrica.africageoportal.com/>`_"
msgstr ""

#: 
msgid "Training material and courses for the Africa Geoportal are available on the `Learning Resources <https://deafrica.africageoportal.com/pages/Learning%20Resources>`_ page."
msgstr ""

#: 
msgid "Cube in a Box (CiaB)"
msgstr ""

#: 
msgid "Why use the Cube in a Box?"
msgstr ""

#: 
msgid "The Cube in a Box and the Digital Earth Africa Analysis Sandbox are both deployments of the Open Data Cube."
msgstr ""

#: 
msgid "The Digital Earth Africa Analysis Sandbox is a cloud deployment of the Open Data Cube. This environment is externally hosted and managed by Digital Earth Africa and consists of :"
msgstr ""

#: 
msgid "An Amazon Web Service instance of cloud computing"
msgstr ""

#: 
msgid "A JupyterLab platform for conducting analysis"
msgstr ""

#: 
msgid "Direct access to an Open Data Cube instance containing all of Digital Earth Africa's earth observation data."
msgstr ""

#: 
msgid "Pre-loaded Jupyter notebooks demonstrating how to use the Open Data Cube to conduct earth observation analysis"
msgstr ""

#: 
msgid "The Sandbox is the simplest way to getting started with the Open Data Cube. It provides a limited, but free compute resource to explore Digital Earth Africa's earth observation data and analysis tools for ad-hoc report generation and rapid development of new algorithms. Being an externally managed environment, the Sandbox only allows access to products indexed by Digital Earth Africa into the Open Data Cube instance."
msgstr ""

#: 
msgid "If you are looking to install the Open Data Cube on your own resources, whether locally or on a cloud service such as Amazon Web Services (AWS) then the Cube in a Box is a great option. The Cube in a Box (CIAB) is a distributable, ready to run reference install of an independent Open Data Cube. It allows you to create your own Open Data Cube environment, similar to the Sandbox. This Open Data Cube instance is specifically maintained and customized by the user. You can index Digital Earth Africa earth observation data and index (add) your own data, be it commercial, in-situ, or derived products into your self managed Open Data Cube instance."
msgstr ""

#: 
msgid "Getting started with Cube in a Box"
msgstr ""

#: 
msgid "Installing the Cube in a Box requires you to have Docker and Docker-Compose installed. To install the Digital Earth Africa's Cube in a Box, clone the the Github repository `digitalearthafrica/cube-in-a-box <https://github.com/digitalearthafrica/cube-in-a-box>`__ and follow the `detailed install instructions <https://github.com/digitalearthafrica/cube-in-a-box/blob/main/docs/Detailed_Install.md>`__."
msgstr ""

#: 
msgid "You can deploy the Cube in a Box to AWS using this `magic link <https://console.aws.amazon.com/cloudformation/home?#/stacks/new?stackName=cube-in-a-box&templateURL=https://deafrica-dev-cfn.s3.af-south-1.amazonaws.com/cube-in-a-box/cube-in-a-box-cloudformation.yml>`__. You need to be logged in to the AWS Console to deploy using this URL. Once logged in, click the link, and follow the prompts including settings a bounding box region of interest, EC2 instance type and password for Jupyter."
msgstr ""

#: 
msgid "There is a notebook provided in the `Cube in a Box Github repository <https://github.com/digitalearthafrica/cube-in-a-box/blob/main/notebooks/Indexing_More_Data.ipynb>`__ that shows how to index more data into the Cube in a Box."
msgstr ""

#: 
msgid "The Open Data Cube is a collection of software that is designed to:"
msgstr ""

#: 
msgid "Catalogue large amounts of Earth Observation data"
msgstr ""

#: 
msgid "Provide a Python based API for high performance querying and data access"
msgstr ""

#: 
msgid "Give scientists and other users easy ability to perform Exploratory Data Analysis"
msgstr ""

#: 
msgid "Allow scalable continent scale processing of the stored data"
msgstr ""

#: 
msgid "Track the provenance of all the contained data to allow for quality control and updates"
msgstr ""

#: 
msgid "The Open Data Cube is composed of the following:"
msgstr ""

#: 
msgid "Data: The data can be stored on a file system, either in local directories of GeoTIFFs or NetCDF files, or stored on an object store like AWS’ S3 as Cloud Optimised GeoTIFFs."
msgstr ""

#: 
msgid "An index: This is a PostgreSQL database that contains an index pointing to where the actual data is stored. The index enables a user to ask for data at a time and location, without needing to know specifically where the required files are stored and how to access them."
msgstr ""

#: 
msgid "Software : The Open Data Cube python library is the core of the ODC. Other Software include Jupyter Notebooks built on the ODC python library which one can use to explore the data indexed."
msgstr ""

#: 
msgid "**Figure 1: Technical Components of the Open Data Cube**"
msgstr ""

#: 
msgid "ODC technical components"
msgstr ""

#: 
msgid "*Image from the What is the Open Data Cube? by Alex Leith.*"
msgstr ""

#: 
msgid "The ODC can be deployed on various computing platforms. Possible deployments include:"
msgstr ""

#: 
msgid "Local deployment (e.g., high-end workstation)"
msgstr ""

#: 
msgid "Cloud (e.g., Amazon Web Services)"
msgstr ""

#: 
msgid "High Performance Computing infrastructure (e.g., NCI)"
msgstr ""

#: 
msgid "`The Open Data Cube website <https://www.opendatacube.org/installation>`__"
msgstr ""

#: 
msgid "`The Open Data Cube Manual <https://datacube-core.readthedocs.io/en/latest/>`__"
msgstr ""

#: 
msgid "`What is the Open Data Cube? <https://medium.com/opendatacube/what-is-open-data-cube-805af60820d7>`__"
msgstr ""

#: 
msgid "`Cube in a Box Github repositry <https://github.com/digitalearthafrica/cube-in-a-box>`__"
msgstr ""

#: 
msgid "Direct access"
msgstr ""

#: 
msgid "Amazon Web Services (AWS) S3 Bucket"
msgstr ""

#: 
msgid "Digital Earth Africa data is stored on Amazon Web Services in several publicly accessible S3 buckets."
msgstr ""

#: 
msgid "These buckets are:"
msgstr ""

#: 
msgid "``deafrica-landsat``"
msgstr ""

#: 
msgid "``deafrica-sentinel-1``"
msgstr ""

#: 
msgid "``deafrica-sentinel-2``"
msgstr ""

#: 
msgid "``deafrica-services``"
msgstr ""

#: 
msgid "For information on where products can be found, see :ref:`data_specs`."
msgstr ""

#: 
msgid "More information on inventory and notification services for some of the buckets can be found on their respective datasets pages on the `Digital Earth Africa Registry of Open Data on AWS <https://registry.opendata.aws/collab/deafrica/>`_"
msgstr ""

#: 
msgid "These buckets are in the AWS region ``af-south-1`` (Capetown)."
msgstr ""

#: 
msgid "To list the contents of a bucket using the `AWS Command Line <https://docs.aws.amazon.com/cli/latest/userguide/>`_::"
msgstr ""

#: 
msgid "Note that you will need to export the environment variable ``export AWS_S3_ENDPOINT=s3.af-south-1.amazonaws.com`` to be able to use some tools such as GDAL to access the data."
msgstr ""

#: 
msgid "Cloud Optimized GeoTIFFs (COG)"
msgstr ""

#: 
msgid "Most of the products in Digital Earth Africa are available as Cloud Optimized GeoTIFF (:term:`COG`) files."
msgstr ""

#: 
msgid "For more information on using these files, see the `Cloud Optimized GeoTIFF <https://www.cogeo.org/>`_ site."
msgstr ""

#: 
msgid "For using COGs on S3 with QGIS, see the tutorial `How to read a Cloud Optimized GeoTIFF with QGIS <https://www.cogeo.org/qgis-tutorial.html>`_."
msgstr ""

#: 
msgid "To convert an S3 path to a direct HTTPS link that you can use in many applications, use the following format: ``https://<bucket>.s3.<region>.amazonaws.com/<key>`` where bucket is the name of the bucket, the region is ``af-south-1` and key is the path to the file."
msgstr ""

#: 
msgid "Spatio-Temporal Asset Catalog (STAC)"
msgstr ""

#: 
msgid "The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A **'spatiotemporal asset'** is any file that represents information about Earth captured in a certain space and time."
msgstr ""

#: 
msgid "The DE Africa STAC endpoint is:"
msgstr ""

#: 
msgid "https://explorer.digitalearth.africa/stac/"
msgstr ""

#: 
msgid "For more information, see the `SpatioTemporal Asset Catalog <https://stacspec.org/>`_ site and the `DE Africa odc-stac example <odc_stac.ipynb>`_."
msgstr ""

#: 
msgid "Metadata Explorer"
msgstr ""

#: 
msgid "The `Digital Earth Metadata Explorer <https://explorer.digitalearth.africa/products>`_ shows the products available on the Digital Earth Africa platform."
msgstr ""

#: 
msgid "It can be found at `explorer.digitalearth.africa <https://explorer.digitalearth.africa/>`_"
msgstr ""

#: 
msgid "The explorer allows you to see where and when you can find data."
msgstr ""

#: 
msgid "For more on how to use the Metadata Explorer, see the guide on :doc:`explorer_guide`."
msgstr ""

#: 
msgid "Using the Metadata Explorer"
msgstr ""

#: 
msgid "How do we know specifically **where** and **when** data is available? Before we start any analysis, we can answer this question by verifying existing data on the `Digital Earth Africa Metadata Explorer <https://explorer.digitalearth.africa/>`__. The Metadata Explorer can be found at https://explorer.digitalearth.africa/."
msgstr ""

#: 
msgid "Map or Explorer?"
msgstr ""

#: 
msgid "The `Digital Earth Africa Metadata Explorer <https://explorer.digitalearth.africa/>`__ and `Digital Earth Africa Map <https://maps.digitalearth.africa/>`__ look similar, but they are designed for different purposes."
msgstr ""

#: 
msgid "Use the `Digital Earth Africa Map <https://maps.digitalearth.africa/>`__ if you:"
msgstr ""

#: 
msgid "Want to see what the product or dataset looks like"
msgstr ""

#: 
msgid "Use the `Digital Earth Africa Metadata Explorer <https://explorer.digitalearth.africa/>`__ if you:"
msgstr ""

#: 
msgid "Want to know exactly where and when you can find data"
msgstr ""

#: 
msgid "Open the Digital Earth Africa Metadata Explorer"
msgstr ""

#: 
msgid "Open https://explorer.digitalearth.africa/. This will display the Metadata Explorer user interface."
msgstr ""

#: 
msgid "The DE Africa Metadata Explorer."
msgstr ""

#: 
msgid "The Digital Earth Africa Metadata Explorer has four main sections."
msgstr ""

#: 
msgid "**Product selection:** This shows the currently-selected product. Click the selected product name to open the products dropdown menu."
msgstr ""

#: 
msgid "**Time period:** This shows the time period for which the selected product is being displayed. Click the selected time period to open the time selection dropdown menu."
msgstr ""

#: 
msgid "**Map display:** This shows where data is available, for the selected time and product. Blue shaded tiles indicate the presence of data."
msgstr ""

#: 
msgid "**Product information:** The sidebar shows more information about the data for the selected time and product. For example, this includes how many datasets are selected, the name of the datasets in the product, and its coordinate reference system."
msgstr ""

#: 
msgid "Select the Landsat 8 product"
msgstr ""

#: 
msgid "Click the **product selection** bar to open the dropdown menu. Select **ls8_sr**. This selects the Landsat 8 product."
msgstr ""

#: 
msgid "Metadata Explorer Landsat 8."
msgstr ""

#: 
msgid "Click the **time** bar to open the dropdown menu. Select **2018**. This will show all Landsat 8 datasets for 2018."
msgstr ""

#: 
msgid "Metadata Explorer Landsat 8 2018."
msgstr ""

#: 
msgid "Click the **all months** bar to open the dropdown menu. Select **August**. This will show all the Landsat 8 datasets for August 2018."
msgstr ""

#: 
msgid "Click the **all days** bar to open the dropdown menu. Select **11th**. This will show all the Landsat 8 datasets for 11 August 2018."
msgstr ""

#: 
msgid "The **map display** will now show all the Landsat 8 datasets for 11 August 2018 as blue shaded boxes. Use the **+** button on the map to zoom in, and click and drag to pan the map."
msgstr ""

#: 
msgid "We can see that there is only data available for some African countries. Let's take a closer look at Tanzania."
msgstr ""

#: 
msgid "Zoom in on Tanzania"
msgstr ""

#: 
msgid "Use the map's **+** button to zoom in on Africa. Click and drag to see Tanzania."
msgstr ""

#: 
msgid "We can see the data for 11 August 2018 (blue shaded boxes) covers certain parts of Tanzania, which means areas within Tanzania are a suitable location to choose for data analysis for that day. For example, for that day (11 August 2018) we would not be able to do any Landsat 8 analysis over the city of Dodoma in Tanzania, as it does not have any data available for that time."
msgstr ""

#: 
msgid "Google Drive Access"
msgstr ""

#: 
msgid "Google Drive API enables developers to integrate Google Drive functionality into applications, offering access to file storage, sharing, and synchronization capabilities. It allows users to manage files, folders, and permissions programmatically, facilitating seamless integration of cloud storage features into various software solutions. The API supports multiple programming languages and provides robust documentation, making it versatile for a wide range of applications from document management to collaborative platforms. More information can be found `here <https://developers.google.com/drive/api/guides/about-sdk>`__."
msgstr ""

#: 
msgid "To connect DE Africa notebooks and other files with Google Drive API using a service account, a ``service account`` is created in the Google Cloud Console. Users must then download its JSON key file, and configure permissions on both Google Drive and the service account. This approach bypasses user authentication and allows server-to-server interactions, making it suitable for automated tasks or applications where user interaction is not required. The service account JSON key is securely stored and used by Python code within Jupyter notebooks to authenticate and authorize API requests, enabling seamless integration of Google Drive functionalities directly into data science workflows without user intervention."
msgstr ""

#: 
msgid "The tutorials below cover:"
msgstr ""

#: 
msgid "Setting up a Service Account"
msgstr ""

#: 
msgid "Enabling Google API"
msgstr ""

#: 
msgid "Connecting a Google Drive folder to the DE Africa sandbox"
msgstr ""

#: 
msgid "Setting up Google Service Account"
msgstr ""

#: 
msgid "A `Google service account <https://cloud.google.com/iam/docs/service-account-overview>`__ is a special type of Google account that belongs to your application or a virtual machine (VM), instead of to an individual end-user. It is typically used when your application needs to access Google Cloud services programmatically, without requiring human intervention."
msgstr ""

#: 
msgid "Follow the steps below create one service"
msgstr ""

#: 
msgid "Go to `Google Cloud <https://console.cloud.google.com/>`__"
msgstr ""

#: 
msgid "On the top left click on the ``select a project``"
msgstr ""

#: 
msgid "A dialogue box will open. On the top right of the dialogue box, click on ``NEW PROJECT``."
msgstr ""

#: 
msgid "A new page will open, on the page either keep the default name or provide your own details, afterwards click on the ``CREATE`` button."
msgstr ""

#: 
msgid "A new page will open for you. In the top left, click on 3 horizontal line and choose ``APIs AND Service``.Click on the ``APIs and Service`` choose ``Credentials`` on the left."
msgstr ""

#: 
msgid "At the ``Credentials`` page, click on ``Create Credentials`` and select ``Service account``"
msgstr ""

#: 
msgid "Fill in the details provided below, for this example, the ``deafricaconnection`` name was used, but you can use any name of your choice. Click on the ``create and continue``"
msgstr ""

#: 
msgid "The next step is to choose the role, ``Grant this service account access to project``, under select role go to ``Basic`` and choose ``Onwer``. After that click on ``continue`` and then click on ``Done`` buttton."
msgstr ""

#: 
msgid "The image below will show up, under the service account click on the edit button, and it will open the account created."
msgstr ""

#: 
msgid "On the detail page ``copy the service account email`` and keep it, as it will be used later on"
msgstr ""

#: 
msgid "Click on the ``KEYS``, at this section click on ``ADD KEY`` and choose ``JSON``, click on ``CREATE`` button. A json file will be downloaded unto your machine and rename it to ``credentials.json``"
msgstr ""

#: 
msgid "Visit https://console.cloud.google.com/apis/library/drive.googleapis.com"
msgstr ""

#: 
msgid "Make sure the project you created is shown in the dropdown beside Google Cloud"
msgstr ""

#: 
msgid "Click on the ``ENABLE`` button to enable the Google API"
msgstr ""

#: 
msgid "Setting up Google Drive Folder"
msgstr ""

#: 
msgid "Open the Google Drive, and ``Create`` a folder, give it any name of your choice."
msgstr ""

#: 
msgid "Once the folder is created, right click on the folder and click on share."
msgstr ""

#: 
msgid "Share the folder with the service account email that was copied earlier, and set permission to ``editor``. Click on ``Done``."
msgstr ""

#: 
msgid "Open the created folder and copy the highlighed text in the url as shown in the image below as it will be used later on."
msgstr ""

#: 
msgid "Connecting Folder to DE Africa sandbox"
msgstr ""

#: 
msgid "Log into your DE Africa Sandbox account."
msgstr ""

#: 
msgid "Locate the ``Supplementary_data`` Folder, open it and look for ``DriveCredentials`` folder."
msgstr ""

#: 
msgid "Upload the ``credential.json`` file in the ``DriveCredentials`` folder."
msgstr ""

#: 
msgid "Now we are good to go and tryout the function."
msgstr ""

#: 
msgid "odc-stac"
msgstr ""

#: 
msgid "Why use odc-stac?"
msgstr ""

#: 
msgid "``odc-stac`` allows you to load datasets from Digital Earth Africa in your own computing environment. While Digital Earth Africa provides users with a managed Jupyter Lab environment with limited computing resources, i.e. the Analysis Sandbox, for interacting with and analyzing Digital Earth Africa's earth observation data, this computing environment has these drawbacks:"
msgstr ""

#: 
msgid "Being a managed environment, the user is limited in how much they can customize the Analysis Sandbox to suit their needs. If you wish to use modules/packages outside the pre-loaded packages in the default Analysis Sandbox, you will need to reinstall them everytime you start up your Analysis Sandbox environment as they do not persist."
msgstr ""

#: 
msgid "Carrying out an analysis over a large area like an entire country can be challenging even with the larger 32GB environment provided."
msgstr ""

#: 
msgid "Accessing datasets from sources other than Digital Earth Africa requires downloading the data onto your local machine, then uploading the data into the Analysis Sandbox."
msgstr ""

#: 
msgid "The ``odc-stac`` is a suitable alternative to using the Analyis Sandbox, because it is a set of tools that converts `STAC <https://stacspec.org/en>`__ metadata to the `Open Data Cube <https://www.opendatacube.org/>`__ data model. ``odc-stac`` allows you to load STAC items into ``xarray.Datasets``, and process them locally or disribute data loading and computation with `Dask <https://dask.org/>`__."
msgstr ""

#: 
msgid "**Table 1: Comparison between ODC and STAC concepts.**"
msgstr ""

#: 
msgid "`Collection <https://pystac.readthedocs.io/en/latest/api/pystac.html#pystac.Collection>`__"
msgstr ""

#: 
msgid "`Product <https://opendatacube.readthedocs.io/en/latest/about-core-concepts/products.html>`__ or `DatasetType <https://datacube-core.readthedocs.io/en/latest/api/core-classes/datasetType.html#datacube.model.DatasetType>`__"
msgstr ""

#: 
msgid "Collection of observations across space and time"
msgstr ""

#: 
msgid "`Item <https://pystac.readthedocs.io/en/latest/api/pystac.html#pystac.Item>`__"
msgstr ""

#: 
msgid "`Dataset <https://datacube-core.readthedocs.io/en/latest/api/core-classes/dataset.html#datacube.model.Dataset>`__"
msgstr ""

#: 
msgid "Single observation (specific time and place), multi-channel"
msgstr ""

#: 
msgid "`Asset <https://pystac.readthedocs.io/en/latest/api/pystac.html#pystac.Asset>`__"
msgstr ""

#: 
msgid "`Measurement <https://datacube-core.readthedocs.io/en/latest/api/core-classes/measurement.html#datacube.model.Measurement>`__"
msgstr ""

#: 
msgid "Component of a single observation"
msgstr ""

#: 
msgid "`Band <https://github.com/stac-extensions/eo#band-object>`__"
msgstr ""

#: 
msgid "Pixel plane within a multi-plane asset"
msgstr ""

#: 
msgid "`Common Name <https://github.com/stac-extensions/eo#common-band-names>`__"
msgstr ""

#: 
msgid "Alias"
msgstr ""

#: 
msgid "Refer to the same band by different"
msgstr ""

#: 
msgid "Digital Earth Africa stores a range of data products on Amazon Web Service's Simple Cloud Storage (S3) with free public access. Digital Earth Africa also provides a SpatioTemporal Asset Catalog (STAC) endpoint for listing or searching the metadata, e.g. bounding box (area of interest coordinates), collection and date and time, for this archive here: https://explorer.digitalearth.africa/stac. Using the STAC endpoint provided, the ``odc-stac`` module gives you the ability to access Digital Earth Africa's earth observation data outside of the Analysis Sandbox, on your own resources, whether locally or on a cloud service such as Amazon Web Services (AWS), from the python environment of your choice, in the same format (as an ``xarray.Dataset``) as you would in the Analysis Sandbox. You can also use ``odc-stac`` to load other STAC compliant earth observation data as an ``xarray.Dataset``."
msgstr ""

#: 
msgid "Getting started with odc-stac"
msgstr ""

#: 
msgid "Instructions on how to install the ``odc-stac`` module into your Python environment are provided `here <https://odc-stac.readthedocs.io/en/latest/intro.html#installation>`__."
msgstr ""

#: 
msgid "Example notebooks on how you can use ``odc-stac`` can be viewed here:"
msgstr ""

#: 
msgid "`Access Sentinel 2 Analysis Ready Data from Digital Earth Africa <https://odc-stac.readthedocs.io/en/latest/notebooks/stac-load-S2-deafrica.html>`__"
msgstr ""

#: 
msgid "`Access Sentinel 2 Data from AWS <https://odc-stac.readthedocs.io/en/latest/notebooks/stac-load-e84-aws.html#>`__"
msgstr ""

#: 
msgid "`Access Sentinel 2 Data on Planetary Computer <https://odc-stac.readthedocs.io/en/latest/notebooks/stac-load-S2-ms.html>`__"
msgstr ""

#: 
msgid "To download and run these notebooks, visit the `odc-stac Github repository <https://github.com/opendatacube/odc-stac/tree/develop/notebooks>`__."
msgstr ""

#: 
msgid "For more on the ``odc-stac`` see the `odc-stac documentation <https://odc-stac.readthedocs.io/en/latest>`__ and the `odc-stac Github repository <https://github.com/opendatacube/odc-stac>`__."
msgstr ""

#: 
msgid "Complete example for Digital Earth Africa"
msgstr ""

#: 
msgid "This example demonstrates a simple analysis workflow based on the Digital Earth Africa Annual Landsat-8 and Landsat-9 GeoMAD product. In this example, we will load the Annual Landsat-8 and Landsat-9 GeoMAD data using the ``odc.stac`` ``stac_load`` function then calculate the Modified Normalized Difference Water Index (MNDWI). We will then plot the results of the water classification of the MNDWI index."
msgstr ""

#: 
msgid "**Note:** To run this example outside the Digital Earth Africa Analysis Sandbox, download this example as a `Jupyter notebook <https://github.com/digitalearthafrica/deafrica-docs/blob/main/platform_tools/odc_stac.ipynb>`__ and the `get_product_config.py <https://github.com/digitalearthafrica/deafrica-docs/blob/main/platform_tools/get_product_config.py>`__ Python script."
msgstr ""

#: 
msgid "Load Packages"
msgstr ""

#: 
msgid "Set Collection Configuration"
msgstr ""

#: 
msgid "The purpose of the configuration dictionary is to supply some optional STAC extensions that a data source might be missing. This missing information includes, pixel data type, nodata value, unit attribute and band aliases. The configuration dictionary is passed to the ``odc.stac.load`` ``stac_cfg=`` parameter in order to supply the missing information at load time."
msgstr ""

#: 
msgid "The configuration is per collection per asset and is determined from the product's definition. The Annual Landsat-8 and Landsat-9 GeoMAD product definition is available at https://explorer.digitalearth.africa/products/gm_ls8_ls9_annual."
msgstr ""

#: 
msgid "Set AWS Configuration"
msgstr ""

#: 
msgid "Digital Earth Africa data is stored on S3 in Cape Town, Africa. To load the data, we must configure rasterio with the appropriate AWS S3 endpoint. This can be done with the ``odc.stac.configure_rio`` function. Documentation for this function is available at https://odc-stac.readthedocs.io/en/latest/_api/odc.stac.configure_rio.html#odc.stac.configure_rio."
msgstr ""

#: 
msgid "The configuration below must be used when loading any Digital Earth Africa data through the STAC API."
msgstr ""

#: 
msgid "Connect to the Digital Earth Africa STAC Catalog"
msgstr ""

#: 
msgid "Find STAC Items to Load"
msgstr ""

#: 
msgid "Define query parameters"
msgstr ""

#: 
msgid "**Note**: The Annual Landsat-8 and Landsat-9 GeoMAD composite is available for the years **2021** - **present**."
msgstr ""

#: 
msgid "One way to set the study area/bounding box is to set a central latitude and longitude coordinate pair, ``(central_lat, central_lon)``, then specify how many degrees to include either side of the central latitude and longitude, known as the ``buffer``. Together, these parameters specify a square study area, as shown below:"
msgstr ""

#: 
msgid "Construct a query and get items from the Digital Earth Africa STAC Catalog"
msgstr ""

#: 
msgid "Load the GeoMAD data"
msgstr ""

#: 
msgid "In this step, we specify the desired coordinate system, resolution (here 30m), and bands to load. We will load 2 spectral satellite bands: ``green`` and ``swir_1``. Since the band aliases are contained in the ``config`` dictionary, bands can be loaded using these aliases instead of the band number e.g. ``\"swir_1\"`` instead of ``\"SR_B6\"``."
msgstr ""

#: 
msgid "We also pass the bounding box to the ``stac_load`` function to only load the requested data. The data will be lazy-loaded with dask, meaning that is won't be loaded into memory until necessary, such as when it is displayed."
msgstr ""

#: 
msgid "Compute the MNDWI index"
msgstr ""

#: 
msgid "After loading the data, you can perform standard ``xarray`` operations, such as calculating the Modified Normalized Difference Water Index (MNDWI)."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{MNDWI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "**Note:** The ``.compute()`` method triggers Dask to load the data into memory."
msgstr ""

#: 
msgid "If a pixel's ``MNDWI`` value is greater than ``0``, i.e. ``MNDWI``>\\ ``0`` then the pixel is classified as water."
msgstr ""

#: 
msgid "Plot the MNDWI and MNDWI water extents"
msgstr ""

#: 
msgid "Web Services for GIS"
msgstr ""

#: 
msgid "Web Map Service / Web Coverage Service"
msgstr ""

#: 
msgid "A Web Map Service (WMS) is an Open Geospatial Consortium (OGC) standard that allows users to remotely access georeferenced map images via secure hypertext transfer protocol (HTTPS) requests."
msgstr ""

#: 
msgid "DE Africa provides two types of maps services:"
msgstr ""

#: 
msgid "Web Map Service (WMS) - A standard protocol for serving georeferenced map images over the internet that are generated from a map server using data from a GIS database. It is important to note that with a WMS, you are essentially getting an image of geospatial data (i.e. JPG, GIF, PNG file). While this has its uses, it is an image only, and therefore does not contain any of the underlying geospatial data that was used to create the image."
msgstr ""

#: 
msgid "Web Coverage Service (WCS) - A standard protocol for serving coverage data which returns data with its original semantics (instead of just pictures) which may be interpreted, extrapolated, etc., and not just portrayed. Essentially, a WCS can be thought of as the raw geospatial raster data behind an image. Using a WCS, you can pull the raw raster information you need to perform further analysis."
msgstr ""

#: 
msgid "Web Map Tile Service (WMTS) - A standard protocol for serving pre-rendered georeferenced map tiles over the internet, comparable to WMS. The primary distinction between WMS and WMTS is how data is supplied to the client; WMS delivers map data as a single image, whereas WMTS serves map data as a series of tiles pre-rendered on the server side at different scales and cached on the client-side resulting in faster delivery and less bandwidth."
msgstr ""

#: 
msgid "So, to give a quick summarisation, a WMS is simply an image of a map. You can almost think of this like taking a screenshot of Google Maps. A WMTS is identical to a WMS, except that the images are pre-generated and saved as small map tiles that span the whole map area and at several scales. A WCS is the raw raster data, so for example, if you are working with a WCS containing Landsat imagery, you can effectively chunk off the piece you are interested in and download the full multispectral image at the spatial resolution of the original image. The beauty of these services is that you can grab only the information you need. So, rather than retrieving a file that contains the data you are seeking and possibly much more, you can confine your download to only your area of interest, allowing you to get what you need and no more."
msgstr ""

#: 
msgid "For more information, see this article on the `difference between GIS web services <https://www.l3harrisgeospatial.com/Learn/Blogs/Blog-Details/ArtMID/10198/ArticleID/16289/Web-Mapping-Service-Web-Coverage-Service-or-Web-Feature-Service-%E2%80%93-What%E2%80%99s-the-Difference>`__."
msgstr ""

#: 
msgid "Setting up WMS"
msgstr ""

#: 
msgid "Adding WMS-T (time-supported) layers"
msgstr ""

#: 
msgid "Connecting to WCS"
msgstr ""

#: 
msgid "Connecting to WMTS"
msgstr ""

#: 
msgid "The tutorials have been created with QGIS3 and ArcGIS Pro 3.0.3. The same processes can be used to connect other Desktop GIS applications. `QGIS <https://qgis.org/en/site/>`__ is a free and open-source desktop GIS application. You can download it from https://qgis.org/en/site/."
msgstr ""

#: 
msgid "QGIS"
msgstr ""

#: 
msgid "This tutorial shows how to set up the Web Map Services in QGIS and use it with other data on your computer such as drone imagery, vector or raster data. This may be useful for you if you cannot upload the data to the DE Africa Map or the DE Africa Sandbox due to uploading due to size or internet bandwidth. It may also be useful if you feel more comfortable doing analysis in a GIS application."
msgstr ""

#: 
msgid "Launch QGIS."
msgstr ""

#: 
msgid "On the Menu Bar click on **Layer**."
msgstr ""

#: 
msgid "A sub-menu tab will show below Layer; click on **Add Layer**, choose **Add WMS/WMTS Layer**."
msgstr ""

#: 
msgid "QGIS - Add Layer"
msgstr ""

#: 
msgid "A dialogue will open as shown below. Click on the **New** button."
msgstr ""

#: 
msgid "QGIS - New Layer"
msgstr ""

#: 
msgid "A dialogue will open, as shown below: Provide the following details, these can be found at the URL https://ows.digitalearth.africa/."
msgstr ""

#: 
msgid "``Name: DE Africa Services``"
msgstr ""

#: 
msgid "``URL:  https://ows.digitalearth.africa/wms?version=1.3.0``"
msgstr ""

#: 
msgid "QGIS - Create New Connection"
msgstr ""

#: 
msgid "After providing the details above, click on **OK**."
msgstr ""

#: 
msgid "The previous dialogue will show up, in the dropdown above the **New** button, you will see DE Africa Services. If it is not there click the dropdown button below and select it."
msgstr ""

#: 
msgid "The **Connect** button will be activated, click on it to load the layers. Anytime this page is open, because the connection has already been established, click on **Connect** to load the data."
msgstr ""

#: 
msgid "QGIS - View Connection"
msgstr ""

#: 
msgid "The layer will be loaded as shown below in the dialogue."
msgstr ""

#: 
msgid "Navigate through layers and choose the layer you will need to display on the Map Page."
msgstr ""

#: 
msgid "After selecting the layer, click on **Add** button at the bottom of the dialogue."
msgstr ""

#: 
msgid "Close the dialogue, the selected layer will be loaded onto the Map Page."
msgstr ""

#: 
msgid "**For web developers**"
msgstr ""

#: 
msgid "The sites below provide instructions on how to load these map services onto your platform."
msgstr ""

#: 
msgid "https://leafletjs.com/examples/wms/wms.html"
msgstr ""

#: 
msgid "https://openlayers.org/en/latest/examples/wms-tiled.html"
msgstr ""

#: 
msgid "https://docs.microsoft.com/en-us/bingmaps/v8-web-control/map-control-concepts/layers/wms-tile-layer-example"
msgstr ""

#: 
msgid "Add WMS-T (time-supported) layers"
msgstr ""

#: 
msgid "Digital Earth Africa web services support WMS-T (WMS with time). WMS-T layers allow users to navigate different time periods."
msgstr ""

#: 
msgid "**How to add WMS-T layers using QGIS**"
msgstr ""

#: 
msgid "Connect to the Web Map Service in QGIS by following the instructions in `Setting up WMS tutorial <#Tutorial:-Setting-up-WMS>`__."
msgstr ""

#: 
msgid "In the QGIS **Browser Panel** navigate to the **WMS/WMTS** provider item and expand it to show the **DE Africa Services** connection."
msgstr ""

#: 
msgid "Select a WMS-T layer from the **DE Africa Services** connection layers by either double clicking on the layer item in the **Browser Panel** or right clicking on it and selecting **Add Layer to Project** to add the layer onto the map canvas."
msgstr ""

#: 
msgid "QGIS - Add Temporal Layer to Project"
msgstr ""

#: 
msgid "The layer will be loaded in the **Layers Panel** with a clock symbol |temporal indicator| next it to indicate that it is a temporal layer."
msgstr ""

#: 
msgid "temporal indicator"
msgstr ""

#: 
msgid "QGIS - View Temporal Layer in Layer Panel"
msgstr ""

#: 
msgid "**How to use the QGIS Temporal Controller with WMS-T layers**"
msgstr ""

#: 
msgid "To use the **Temporal Controller** for WMS-T layers, ensure that in the Temporal section of the layer's **Layer Properties**, the **Dynamic Temporal Control** is selected. You can select the time range to be **Automatic** or **Fixed time range**."
msgstr ""

#: 
msgid "For the **Automatic** setting, the temporal handling is delegated to the data provider and time based filtering is applied to the features of the layer such that the features will be visualized for the animation range set by the **Temporal Controller**."
msgstr ""

#: 
msgid "QGIS - Dynamic Temporal Control - Automatic"
msgstr ""

#: 
msgid "For the **Fixed time range** setting the user manually sets the temporal range in which all the features of the layer will be visualised only if the animation range from the **Temporal Controller** is within this temporal range."
msgstr ""

#: 
msgid "QGIS - Dynamic Temporal Control - Fixed time range"
msgstr ""

#: 
msgid "On the **Map Navigation Toolbar** select the clock symbol for the **Temporal Controller Panel** to activate the **Temporal Controller** dock widget."
msgstr ""

#: 
msgid "QGIS - Activate Temporal Controller Dock Widget"
msgstr ""

#: 
msgid "**Temporal controller** dock widget activated after click on the **Temporal Controller** toolbar icon."
msgstr ""

#: 
msgid "QGIS - Temporal Controller Dock Widget"
msgstr ""

#: 
msgid "To turn on the Fixed range temporal navigation, select the **Fixed range temporal navigation** icon |Temporal Navigation Fixed Range| on the **Temporal Controller Panel** and set the time range for the layer features to be visualized."
msgstr ""

#: 
msgid "Temporal Navigation Fixed Range"
msgstr ""

#: 
msgid "QGIS - Fixed Range Temporal Navigation"
msgstr ""

#: 
msgid "To turn on the Animated temporal navigation, select the **Animated temporal navigation** icon |Temporal Navigation Animated| on the **Temporal Controller Panel**, and set animation range and the time step for the animation."
msgstr ""

#: 
msgid "Temporal Navigation Animated"
msgstr ""

#: 
msgid "QGIS - Animated Temporal Navigation - Animation Range"
msgstr ""

#: 
msgid "⁣"
msgstr ""

#: 
msgid "QGIS - Animated Temporal Navigation - Time Step"
msgstr ""

#: 
msgid "Click on the **Play** icon |play| to view the animation."
msgstr ""

#: 
msgid "play"
msgstr ""

#: 
msgid "QGIS - Play Animation"
msgstr ""

#: 
msgid "To rewind the animation to the beginning i.e. the start of the animation range, click on the **Rewind to start** icon |rewindToStart|."
msgstr ""

#: 
msgid "rewindToStart"
msgstr ""

#: 
msgid "QGIS - Rewind Animation to Start"
msgstr ""

#: 
msgid "To go back to the previous frame of the animation, click on the **Go to previous frame** icon |previous|. The time difference (time step) between consecutive frames is determined by the **Step** defined by the user."
msgstr ""

#: 
msgid "previous"
msgstr ""

#: 
msgid "QGIS - Rewind Animation to Previous Frame"
msgstr ""

#: 
msgid "To rewind the animation, click on the **Reverse** icon |back|."
msgstr ""

#: 
msgid "back"
msgstr ""

#: 
msgid "QGIS - Rewind Animation"
msgstr ""

#: 
msgid "To go to the next frame of the animation, click on the **Go to next frame** icon |next|. The time difference (time step) between consecutive frames is determined by the **Step** defined by the user."
msgstr ""

#: 
msgid "next"
msgstr ""

#: 
msgid "QGIS - Forward Animation to Next Frame"
msgstr ""

#: 
msgid "To fast forward the animation to the end i.e. skip to the end of the animation range, click on the **Fast forward to end** icon |skipToEnd|."
msgstr ""

#: 
msgid "skipToEnd"
msgstr ""

#: 
msgid "QGIS - Forward Animation to End"
msgstr ""

#: 
msgid "**How to export the animation from QGIS Temporal Controller**"
msgstr ""

#: 
msgid "The animation can be exported from the QGIS temporal controller as a series of images. To export the animation click on the **Export animation** icon |save| on the **Temporal Controller Panel**."
msgstr ""

#: 
msgid "save"
msgstr ""

#: 
msgid "QGIS - Export Animation"
msgstr ""

#: 
msgid "In the **Export Map animation** dialogue, specify:"
msgstr ""

#: 
msgid "The naming template to be used for labelling the images."
msgstr ""

#: 
msgid "The output directory where the images will be saved."
msgstr ""

#: 
msgid "The map extent to be covered by the images."
msgstr ""

#: 
msgid "The width and height of the images."
msgstr ""

#: 
msgid "The temporal range and time step for the animation."
msgstr ""

#: 
msgid "QGIS - Export Animation Options"
msgstr ""

#: 
msgid "The exported images will be saved in the specified ouput directory. Using your preferred software, you can use the images to create an animation."
msgstr ""

#: 
msgid "QGIS - Exported Animation as Images"
msgstr ""

#: 
msgid "GIF from Exported Animation Images"
msgstr ""

#: 
msgid "**How to use the WMS-T layers in QGIS without the Temporal Controller**"
msgstr ""

#: 
msgid "To use the WMS-T layers in QGIS without the Temporal Controller, first disable the **Dynamic Temporal Control** in the layer's **Layer Properties** to enable the **Static WMS-T Temporal Range** settings. The default setting is the **Server default** temporal range for visualizing the layer features. This is a predefined temporal range set by the data service provider."
msgstr ""

#: 
msgid "You will notice after disabling **Dynamic Temporal Control** that the layer no longer has the temporal indicator symbol |temporal indicator| next to the layer name in the **Layers Panel**, this means that the layer is no longer considered a temporal layer by QGIS, hence can't be used by the **Temporal Controller**."
msgstr ""

#: 
msgid "QGIS - Disable Dynamic Temporal Control"
msgstr ""

#: 
msgid "QGIS - Static WMS-T Layer"
msgstr ""

#: 
msgid "Using the **Predefined range** you can set the temporal range for the layer features to be visualized using the **Start date** and **End date**. A time-based filter will be applied to the layer and the fetched features will be the features within the predefined temporal range."
msgstr ""

#: 
msgid "QGIS - Static WMS-T Temporal Range - Predefined Range"
msgstr ""

#: 
msgid "To use the **Follow project's temporal range** setting, the project temporal range in the **Temporal** section (Project > Properties> Temporal) of the **Project Properties** must be set. After setting the project temporal range, applying this setting will result in fetching the WMS layer features that are within the projects temporal range."
msgstr ""

#: 
msgid "QGIS - Set Project Temporal Range"
msgstr ""

#: 
msgid "QGIS - Static WMS-T Temporal Range - Follow Project's Temporal Range"
msgstr ""

#: 
msgid "QGIS - View Static WMS-T Layer Features in Project Temporal Range"
msgstr ""

#: 
msgid "**WMS-T Settings**"
msgstr ""

#: 
msgid "You can also specify the time slice mode used for both the **Dynamic Temporal Control** and the **Static WMS-T Temporal Range**. There are four options available for the time slice mode:"
msgstr ""

#: 
msgid "**Use Whole Temporal Range**: Allows the user to set the temporal range for the layer features to be visualized/plotted."
msgstr ""

#: 
msgid "**Match to Start of Range**: The layer features visualized will be features that match the start of the layer's time range."
msgstr ""

#: 
msgid "**Match to End of Range**: The layer features visualized will be features that match the end of the layer's time range."
msgstr ""

#: 
msgid "**Closest Match to Start of Range**: Visualizes the layer features whose date and time stamp are the closest to the start of the defined temporal range."
msgstr ""

#: 
msgid "**Closet Match to End of Range**: Visualizes the layer features whose date and time stamp are the closest to the end of the defined temporal range."
msgstr ""

#: 
msgid "You can also enable the option for **Ignoring time components** which allows QGIS to only consider the dates when applying a time based filter to the layer features based on a defined temporal range, without considering the time component."
msgstr ""

#: 
msgid "QGIS - WMS-T Settings"
msgstr ""

#: 
msgid "How to connect WCS"
msgstr ""

#: 
msgid "A sub-menu tab will show below Layer; click on **Add Layer**, choose **Add WCS Layer**."
msgstr ""

#: 
msgid "QGIS - Add WCS"
msgstr ""

#: 
msgid "Click on the **New** button."
msgstr ""

#: 
msgid "A dialogue will open, as shown below: Provide the following details, these can be found at the URL https://ows.digitalearth.africa/"
msgstr ""

#: 
msgid "``URL:  https://ows.digitalearth.africa/wcs?version=2.1.0``"
msgstr ""

#: 
msgid "QGIS - WCS Connection"
msgstr ""

#: 
msgid "The previous dialogue will show up, in the dropdown above the New button, you will see DE Africa Services, if it is not there click the dropdown button below and select it."
msgstr ""

#: 
msgid "The **Connect** button will be activated, click on it to load the layers. Anytime this page is open, because the connection has already been established, click on the **Connect** button to load the data."
msgstr ""

#: 
msgid "QGIS - Loaded WCS"
msgstr ""

#: 
msgid "Navigate through layers and choose the layer you will need to display on the Map Page. With WCS you can select Time and Format of Image."
msgstr ""

#: 
msgid "After selecting the layer click on the **Add** button at the bottom of the dialogue."
msgstr ""

#: 
msgid "ArcGIS Pro"
msgstr ""

#: 
msgid "This tutorial shows how to set up the Web Map Services in ArcGIS Pro, and use it with other data on your computer such as drone imagery, vector or raster data. This may be useful for you if you cannot upload the data to the DE Africa Map or the DE Africa Sandbox due to uploading due to size or internet bandwidth. It may also be useful if you feel more comfortable doing analysis in a GIS application."
msgstr ""

#: 
msgid "Launch ArcGIS Pro."
msgstr ""

#: 
msgid "On the Menu Bar click on **Insert**."
msgstr ""

#: 
msgid "In the **Project** group, click on **Connections** and a dropdown menu will appear below **Connections**; click on **Server** and choose **Add WMS Server**."
msgstr ""

#: 
msgid "ArcGIS - Add WMS server"
msgstr ""

#: 
msgid "A dialogue will open, as shown below: Provide the server URL, which can be found at the URL https://ows.digitalearth.africa/."
msgstr ""

#: 
msgid "ArcGIS - Create New WMS Connection"
msgstr ""

#: 
msgid "After providing the server URL above, click on **OK**."
msgstr ""

#: 
msgid "This will add the Digital Earth Africa WMS Server to the **Catalog** pane, under **Servers**."
msgstr ""

#: 
msgid "ArcGIS - WMS to catalog"
msgstr ""

#: 
msgid "Navigate through layers and choose the layer you will need to display on the Map view."
msgstr ""

#: 
msgid "After selecting the layer, right click on the layer and select **Add to Current Map** (alternatively, you can drag and drop the layer onto the Map view)."
msgstr ""

#: 
msgid "The selected layer will be loaded onto the Map view."
msgstr ""

#: 
msgid "**How to add WMS-T layers using ArcGIS Pro**"
msgstr ""

#: 
msgid "Connect to the Web Map Service in ArcGIS by following the instructions in `Setting up WMS tutorial <#Tutorial:-Setting-up-WMS>`__."
msgstr ""

#: 
msgid "In the **Catalog** pane, navigate to **Servers** and expand it to show the **Digital Earth Africa - OGC Web Services on ows.digitalearth.africa.wms** connection."
msgstr ""

#: 
msgid "Select a WMS-T layer from the **Digital Earth Africa - OGC Web Services on ows.digitalearth.africa.wms** connection layers. To add the layer to the map view, right click on the layer and select **Add to Current Map** (alternatively, you can drag and drop the layer onto the Map view)."
msgstr ""

#: 
msgid "ArcGIS - Add Temporal layer to Project"
msgstr ""

#: 
msgid "The layer will be loaded onto the Map view with a contextual **Time** tab added to the **Menu** bar and a **Time Slider** ay the top of the map view, indicating that it is a temporal layer."
msgstr ""

#: 
msgid "**How to use the ArcGIS Pro Time Slider with WMS-T layers**"
msgstr ""

#: 
msgid "To use the **Time Slider** for WMS-T layers, hover over the **Time Slider** to see its controls.On the left side of the **Time Slider** icon, click on **Time disabled** |time disabled| to change it to **Time enabled** |time enabled|."
msgstr ""

#: 
msgid "time disabled"
msgstr ""

#: 
msgid "time enabled"
msgstr ""

#: 
msgid "ArcGIS - Enable Time"
msgstr ""

#: 
msgid "You can configure the time settings on your layer. Click on the **Time** tab in the **Menu** bar. In the **Snapping** group, check the **Time Snapping** check box."
msgstr ""

#: 
msgid "Under the **Time Snapping** check box, click on the **Time Snap Interval** dropdown and select **Years**."
msgstr ""

#: 
msgid "*This corresponds to the yearly intervals of the data.*"
msgstr ""

#: 
msgid "In the **Current Time** group, change the **Span** setting to 0 and press the **Enter** key."
msgstr ""

#: 
msgid "*This ensures that only one year's woth of data displays at a time.*"
msgstr ""

#: 
msgid "ArcGIS - Time slider configuration"
msgstr ""

#: 
msgid "In the **Playback** group, click **Play all steps** |play all steps|."
msgstr ""

#: 
msgid "play all steps"
msgstr ""

#: 
msgid "ArcGIS - play all steps"
msgstr ""

#: 
msgid "To set the time slider controls backwards according to the step setting (i.e., move back one time step), click on the **Step Back** icon |step back|."
msgstr ""

#: 
msgid "step back"
msgstr ""

#: 
msgid "ArcGIS - step back"
msgstr ""

#: 
msgid "To set the time slider controls forward according to the step setting (i.e., move forward one time step), click on the **Step Forward** icon |step forward|."
msgstr ""

#: 
msgid "step forward"
msgstr ""

#: 
msgid "ArcGIS - step forward"
msgstr ""

#: 
msgid "To set the relative speed of the visualisation by adjusting the amount of pause between steps, use the **Adjust Playback Speed** icon |adjust playback speed|."
msgstr ""

#: 
msgid "adjust playback speed"
msgstr ""

#: 
msgid "ArcGIS - adjust playback speed"
msgstr ""

#: 
msgid "To set whether the playback of all steps begins by moving forward or backward in time through the data, click on the **Direction** icon |direction|."
msgstr ""

#: 
msgid "direction"
msgstr ""

#: 
msgid "ArcGIS - direction"
msgstr ""

#: 
msgid "To set the playback to continue to loop in the same direction after it has reached the last step at the end of the time slider, click on the **Repeat** icon |repeat|."
msgstr ""

#: 
msgid "repeat"
msgstr ""

#: 
msgid "ArcGIS - repeat"
msgstr ""

#: 
msgid "To set the playback to continue to loop in the opposite direction after it has reached the last step at the end of the time slider, click on the **Reverse** icon |reverse|."
msgstr ""

#: 
msgid "reverse"
msgstr ""

#: 
msgid "ArcGIS - reverse"
msgstr ""

#: 
msgid "**How to export the animation from ArcGIS Time Slider** 1. To export the animation, click on the **View** tab. In the **Animation** group, click **Add**. 2. An empty **Animation Timeline** pane appers undeer the Map view. On the **Menu** bar, a contextual **Animation** tab appears."
msgstr ""

#: 
msgid "ArcGIS - Empty Animation Timeline"
msgstr ""

#: 
msgid "Before you create keyframes for the animation, you will zoom to the correct map extent. In the **Contents** pane, right click on the layer and **Zoom To layer**."
msgstr ""

#: 
msgid "On the **Menu** bar, click the **Animation** tab. In the **Create** group, click **Impoer Animation** and click **Time Slider Steps**."
msgstr ""

#: 
msgid "ArcGIS - Time slider Steps"
msgstr ""

#: 
msgid "The **Animation Timeline** pane populates with keyframes (It takes a few moments for the images to display in the keyframes). The first keyframe represents the animation at zero seconds (00:00.0000). Each subsequent keyframe corresponds to the data for one year."
msgstr ""

#: 
msgid "ArcGIS - Animation timeline population"
msgstr ""

#: 
msgid "On the **Animation tab**, in the **Playback** group, the **Duration** setting tells you the length of the the animatiton. You can replace the duration value (e.g., 00:30 - which will make the duration of the animation 30 seconds)."
msgstr ""

#: 
msgid "As the animation plays, you may want to show which year the data represents. To do so, yo will add dynamic text - information that updates during the playback."
msgstr ""

#: 
msgid "In the **Animation Timeline** pane, under **keyframe Gallery**, click on the first keyframe to select it and scroll to the end of the gallery, press and hold the **Shift** key, then click the last keyframe. This will select all the key frames in your animation."
msgstr ""

#: 
msgid "*The dynamic text you add in the next step will be applied to all the selected keyframes - in other words, thoughout the animation.*"
msgstr ""

#: 
msgid "ArcGIS - keyframe gallery selection"
msgstr ""

#: 
msgid "On the **Menu** bar, on the **Animation** tab, in the **Overlay** group, expand the **Overlay** gallery."
msgstr ""

#: 
msgid "ArcGIS - Overlay gallery"
msgstr ""

#: 
msgid "In the dynamic text box that appears on the Map view, replace the default two-line expression with ``<dyn type=\"animation\" property=\"startTime\" format=\"yyyy\"/>``"
msgstr ""

#: 
msgid "In the **Playback** group of the **Animation** tab, click on **Play** (*Do not click*\\ **Play**\\ *on the*\\ **Time Slider**\\ *as the changes you have made to the animation are not reflected in the*\\ **Time Sllider**\\ *playback*."
msgstr ""

#: 
msgid "ArcGIS - play animation"
msgstr ""

#: 
msgid "On the **Animation** tab, in the **Export** group, click **Movie Export** |movie export|"
msgstr ""

#: 
msgid "movie export"
msgstr ""

#: 
msgid "In the **Export Movie** pane, in the **File Name** box, give your animation an appropriate name."
msgstr ""

#: 
msgid "Optionally, click **Browse** |browse| and browse to a different folder to save the video."
msgstr ""

#: 
msgid "browse"
msgstr ""

#: 
msgid "ArcGIS - Export movie"
msgstr ""

#: 
msgid "In the **Project** group, click on **Connections** and a dropdown menu will appear below **Connections**; click on **Server** and choose **Add WCS Server**."
msgstr ""

#: 
msgid "ArcGIS - Add WCS server"
msgstr ""

#: 
msgid "``URL:  https://ows.digitalearth.africa/wcs?version=1.3.0``"
msgstr ""

#: 
msgid "ArcGIS - Create New WCS Connection"
msgstr ""

#: 
msgid "This will add the Digital Earth Africa WCS Server to the **Catalog** pane, under **Servers**."
msgstr ""

#: 
msgid "ArcGIS - WCS to catalog"
msgstr ""

#: 
msgid "How to connect WMTS"
msgstr ""

#: 
msgid "In the **Project** group, click on **Connections** and a dropdown menu will appear below **Connections**; click on **Server** and choose **Add WMTS Server**."
msgstr ""

#: 
msgid "ArcGIS - Add WMTS server"
msgstr ""

#: 
msgid "``URL:  https://ows.digitalearth.africa/wmts?version=1.0.0``"
msgstr ""

#: 
msgid "This will add the Digital Earth Africa WMTS Server to the **Catalog** pane, under **Servers**."
msgstr ""

#: 
msgid "Getting Started"
msgstr ""

#: 
msgid "The Sandbox is free to use. Visit `sandbox.digitalearth.africa <https://sandbox.digitalearth.africa/>`__ to sign up for a new account, or sign in if you have an existing account."
msgstr ""

#: 
msgid "Register"
msgstr ""

#: 
msgid "Visit `sandbox.digitalearth.africa <https://sandbox.digitalearth.africa>`__ and click **Login or Sign up**."
msgstr ""

#: 
msgid "Click **Sign up**."
msgstr ""

#: 
msgid "Fill in the **Username**, **Name**, **Email** and **Password** fields. Passwords must be at least 8 characters, and contain at minimum a lower case letter, an upper case letter and a number. Record your username securely as it will be required to reset your password should you forget it."
msgstr ""

#: 
msgid "The DE Africa Sandbox new user registration page."
msgstr ""

#: 
msgid "A verification code will have been sent to your nominated email address. Enter the verification code and click **Confirm Account**. This will automatically log you in."
msgstr ""

#: 
msgid "The DE Africa Sandbox new user confirm account page."
msgstr ""

#: 
msgid "If you have not received the verification code email, please check your spam or junk mail folders."
msgstr ""

#: 
msgid "Access"
msgstr ""

#: 
msgid "Sign in at: `sandbox.digitalearth.africa <https://sandbox.digitalearth.africa>`__"
msgstr ""

#: 
msgid "After signing in, you will be given a option of sandbox types to choose from:"
msgstr ""

#: 
msgid "**Default:**  2 Cores, 16G Memory"
msgstr ""

#: 
msgid "You may see other options as well. For regular users, the default environment should be enough for most of your needs."
msgstr ""

#: 
msgid "The DE Africa Sandbox start server page."
msgstr ""

#: 
msgid "Select **Default environment** and click **Start**."
msgstr ""

#: 
msgid "The Sandbox will then prepare a JupyterLab environment for you; this can take a few minutes.  You will automatically be redirected to the Sandbox environment."
msgstr ""

#: 
msgid "The Sandbox runs completely in-browser and all necessary software is provided as part of this environment, so no additional installation or configuration is required."
msgstr ""

#: 
msgid "Navigate"
msgstr ""

#: 
msgid "The JupyterLab interface consists of the main work area (right-hand panel), the left sidebar (containing a file browser and other useful features), and a menu bar along the top."
msgstr ""

#: 
msgid "JupyterLab Start Up"
msgstr ""

#: 
msgid "The main work area is where Jupyter notebooks will be displayed once opened. By default, the Launcher is displayed, which allows you to open new files."
msgstr ""

#: 
msgid "To open an existing Jupyter notebook, double-click through the folders to find a notebook you're interested in, then double-click the notebook to open it in the main work area. Notebooks are indicated by the ``.ipynb`` file extension. The JupyterLab interface also supports plain text and Markdown files."
msgstr ""

#: 
msgid "To learn more about JupyterLab, visit the `JupyterLab Documentation`_."
msgstr ""

#: 
msgid "Lazy-loading Data"
msgstr ""

#: 
msgid "By default the ``datacube`` library does not use Dask when loading data, meaning that when ``dc.load()`` is used the data being queried will loaded into memory. Lazy-loading data refers to data only being loaded into memory when necessary for analysis. In order to lazy-load data, we pass the ``dask_chunks`` parameter into the ``dc.load()`` statement."
msgstr ""

#: 
msgid "In this section we will lazy-load data by passing the ``dask_chunks`` parameter into the ``.load()`` function, and explore the data structure of lazy-loaded data."
msgstr ""

#: 
msgid "Connecting to the datacube"
msgstr ""

#: 
msgid "Standard load function"
msgstr ""

#: 
msgid "The ``dc.load()`` command specifies the product, measurements (bands), x, y coordinates and the time range."
msgstr ""

#: 
msgid "Lazy-loading the same data"
msgstr ""

#: 
msgid "Passing ``dask_chunks`` into the load query initialises lazy loading the data, whereby ``dask.array`` objects are returned instead of individual values until called upon."
msgstr ""

#: 
msgid "Plotting RGB image of the study area"
msgstr ""

#: 
msgid "In this section you have ‘lazy-loaded’ data by passing the ``dask_chunks`` parameter into the load statement."
msgstr ""

#: 
msgid "Key Concepts"
msgstr ""

#: 
msgid "Until now, the ``.load()`` function has been used to load data straight into memory"
msgstr ""

#: 
msgid "Dask is a tool used to break data into manageable chunks, ideal for data management"
msgstr ""

#: 
msgid "Adding the ``dask_chunks`` parameter to the standard ``.load()`` function calls for data to be **lazy-loaded**"
msgstr ""

#: 
msgid "Lazy-loading results in data only being loaded when necessary to complete a computation, until specific data is required the xarray.dataset is comprised of dask.array objects which act as placeholders, not specific values"
msgstr ""

#: 
msgid "To break a dataset into chunks using Dask, we pass ``dask_chunks`` into the load query and specify ``‘time’``, ``‘x’``, and ``‘y’`` parameters (e.g., ``dask_chunks = {'time': 1, 'x': 500, 'y': 500}``)"
msgstr ""

#: 
msgid "Further information"
msgstr ""

#: 
msgid "**Dask** is a tool used for data management, this process breaks data down into manageable chunks stored in memory. In short, Dask enables you to"
msgstr ""

#: 
msgid "analyse larger-than-memory datasets"
msgstr ""

#: 
msgid "efficiently run computations"
msgstr ""

#: 
msgid "Dask compatible operations are not executed until computation or visualisation of the final results are called upon."
msgstr ""

#: 
msgid "Standard Load"
msgstr ""

#: 
msgid "In this section we used the standard ``dc.load()`` function to load data straight into memory. Until now, we have used this method of loading data from the Datacube into Jupyter notebooks. However, loading data across large areas or over prolonged timespans can cause Jupyter notebooks to crash. To load larger datasets, we can use Dask functionalities to manage computation within a limited memory limit."
msgstr ""

#: 
msgid "Lazy-loading data"
msgstr ""

#: 
msgid "Lazy-loading data refers to loading data only when it is required to complete a calculation. To lazy-load data we add the ``dask_chunks = {‘time’:, ‘x’:, ‘y’:}`` parameter into the ``dc.load()`` statement. When we lazy-load a dataset, the returned ``xarray.dataset`` is comprised of ``dask.array`` objects."
msgstr ""

#: 
msgid "Lazy-loading data saves both time and memory which would otherwise be spent storing the data within your computer’s local memory."
msgstr ""

#: 
msgid "**Note**: The ``.load()`` command with ``dask_chunks`` parameter returns much faster as it is not loading any data into memory. The comparison below shows returned data using the standard load function, and then returned ``dask.array`` objects when lazy-loading the same ``data.datacube``."
msgstr ""

#: 
msgid "Comparison between loaded and lazy-loaded objects."
msgstr ""

#: 
msgid "Factoring Dask array shape for chunking"
msgstr ""

#: 
msgid "When chunking data, we need to factor in the shape of the data, type of computation, and the memory available. Below is an example showing an excess number of chunks containing small amounts of data (480 chunks with each chunk storing 500 kilobytes of data). Applying the same chunking parameters from earlier in this exercise (x: 500, y: 500) is inefficient for the dataset. Rechunking the data and factoring chunk size which can reduce the number of times data must be read from file (fewer tasks and chunks) is more time effective."
msgstr ""

#: 
msgid "Comparison between different chunk sizes."
msgstr ""

#: 
msgid "Advanced explanation"
msgstr ""

#: 
msgid "**Larger-than-memory** refers to datasets which require more storage beyond available memory, for example:"
msgstr ""

#: 
msgid "**Example:** To load three bands (red, green, blue), each bands datatype will be stored as an unsigned integer (uint16). This means that each pixel you wish to load is 16 bits which is equivalent to 2 bytes. To load an area which is 100 pixels by 100 pixels, you will need to load 10,000 pixels per band, which for three bands this will require 30,000 pixels to be loaded. At 2 bytes per pixel, this totals 60,000 bytes (60 Kilobytes or 0.06 Gigabytes). This example requires a small amount of memory which easily fits into the memory available in your Sandbox. However, if you wanted to load 12 bands over a larger area that spanned 100,000 pixels by 100,000 pixels (10,000km by 10,000km for 10m Sentinel-2 resolution), that would require 240 Gigabytes (100,000 pixels x 100,000 pixels x 12 bands x 2 bytes = 240 Gigabytes). As the default Sandbox environment offers 16G Memory, this hypothetical dataset would require additional storage beyond what is available and therefore considered to be larger-than-memory."
msgstr ""

#: 
msgid "Lazy Operations"
msgstr ""

#: 
msgid "In this section, you will lazy-load data, visualise the task graph while loading data, and use ``.compute()`` to calculate the a new NDVI band using red and nir bands."
msgstr ""

#: 
msgid "Viewing the task graph"
msgstr ""

#: 
msgid "By requesting a small portion of the red band, we can use .visualize() to show us where in the dataset the data comes from."
msgstr ""

#: 
msgid "The new task ‘getitem’ has been added to the task graph, Dask has traced the operation through the graph to find only the relevant small portion of the red band we requested."
msgstr ""

#: 
msgid "Multiple tasks using .compute()"
msgstr ""

#: 
msgid "In this section, you will chain multiple steps together to calculate a new band for the data array. Using the red and nir bands, we will calculate the Normalised Difference Vegetation Index (NDVI)."
msgstr ""

#: 
msgid "From viewing the task graph, we can now see the NDVI equation taking place using the red and nir bands."
msgstr ""

#: 
msgid "Plotting the NDVI"
msgstr ""

#: 
msgid "Dask only loads data that is required/used by the final operation in the chain, task graphs are used to visualise where required data stems from"
msgstr ""

#: 
msgid "Task graphs are a visual representation of the series of steps taken to execute a loading operation"
msgstr ""

#: 
msgid "**Rectangles** at the bottom of the graph are database entries which represent the chunks that need to be read to load the data"
msgstr ""

#: 
msgid "**Circles** above the rectangles are individual operation that will do the reading, there is one for each chunk"
msgstr ""

#: 
msgid "**Indexes** are located at the very top of the chunks which make up the final array"
msgstr ""

#: 
msgid "In this tutorial we used ``.compute()`` to calculate the NDVI and specifically keep the ndvi data variable as a Dask array in lazy_load xarray.dataset"
msgstr ""

#: 
msgid "``ndvi_compute`` = ``lazy_data.compute()`` will load data into memory for ``ndvi_compute``, but ``lazy_data`` will remain lazy"
msgstr ""

#: 
msgid "Lazy operations"
msgstr ""

#: 
msgid "In addition to breaking data into smaller chunks that fit into memory, Dask has another advantage in that it can track how you want to work with the data, and from that only perform the necessary operations later."
msgstr ""

#: 
msgid "Task graphs"
msgstr ""

#: 
msgid "Task graphs visually represent the series of steps taken to execute a loading operation. Task graphs are read from bottom-to-top (see below) whereby:"
msgstr ""

#: 
msgid "**Rectangles** at the bottom of the graph are database entries which represent the files that need to be read to load the data"
msgstr ""

#: 
msgid "**Circles** above the rectangles are individual load commands that will do the reading, there is one for each chunk"
msgstr ""

#: 
msgid "**Arrows** represent which files need to be read for each operation"
msgstr ""

#: 
msgid "Adding tasks"
msgstr ""

#: 
msgid "Before we request data to be loaded using Dask, tasks can be chained together prior to loading. This is an advantageous method as only data that is required by the final operation is loaded."
msgstr ""

#: 
msgid "Interpreting the task graph"
msgstr ""

#: 
msgid "In the above example we returned task graphs at two different points of loading data."
msgstr ""

#: 
msgid "Requesting a small portion of the red band: resulting in the new task ‘getitem’ to be added, as that is where the small portion of the red band we requested resides"
msgstr ""

#: 
msgid "Dask task graph get item."
msgstr ""

#: 
msgid "Chaining operations together for calculating the NDVI: resulted in ‘add’ and ‘sub’ being performed on each band before being divided ‘truediv’"
msgstr ""

#: 
msgid "Dask task graph operations chain."
msgstr ""

#: 
msgid "We can see how each output chunk is independent from one another. This allows for each chunk to be calculated without having to load all the bands into memory at the same time."
msgstr ""

#: 
msgid "Dask Client for Larger Datasets"
msgstr ""

#: 
msgid "In this section, we will analyse a larger dataset over multiple time-steps. We will use the Dask Client Dashboard to view the status of our computations."
msgstr ""

#: 
msgid "This section draws upon skills from the previous two sections including lazy-loading data, adding multiple tasks using ``.compute()``, and visualise the task graph using ``.visualise()``."
msgstr ""

#: 
msgid "Create a Dask Cluster"
msgstr ""

#: 
msgid "Returning this will show information about the Client and Cluster. For this exercise we will use the hyperlink to the Dashboard. This link will allow you to view the progress of your computations as they are running."
msgstr ""

#: 
msgid "To view the Dask dashboard and your active notebook at the same time, follow the hyperlink and open in a new window."
msgstr ""

#: 
msgid "From viewing the task graph, we can now see the NDVI equation taking place across all four time-steps within our two-year time range. Each time-step is signified by a separate database entry at the bottom of the task graph (see single highlighted time-step below)."
msgstr ""

#: 
msgid "Viewing the Dashboard while computing"
msgstr ""

#: 
msgid "Ensure your new window with the Dask Dashboard is visible and run the following cell:"
msgstr ""

#: 
msgid "Plotting the NDVI timeseries"
msgstr ""

#: 
msgid "The ``create_local_dask_cluster()`` function takes advantage of multiple CPU cores to speed up computations, known as distributed computing"
msgstr ""

#: 
msgid "Dask dashboard allows us to view the progress of computations as they run in real-time"
msgstr ""

#: 
msgid "Dask Client"
msgstr ""

#: 
msgid "Dask can use multiple computing cores (CPUs) in parallel to speed up computations, known as distributed computing."
msgstr ""

#: 
msgid "The deafrica_tools package provides us with access to support functions within the Dask module, including the ``create_local_dask_cluster()`` function, which allows us to take advantage of the multiple CPUs available in the Sandbox."
msgstr ""

#: 
msgid "Dask Dashboard"
msgstr ""

#: 
msgid "The status tab in the scheduler provides information on the following:"
msgstr ""

#: 
msgid "Bytes Stored: cluster memory and memory per worker"
msgstr ""

#: 
msgid "Task Processing: tasks being processed by each worker"
msgstr ""

#: 
msgid "Task Stream: shows the progress of each individual task across every thread, with each line corresponding to a thread. Each colour corresponds to a type of operation."
msgstr ""

#: 
msgid "Progress: progress of individual computations"
msgstr ""

#: 
msgid "The image below shows the task stream and progress bar progressing as the computations run."
msgstr ""

#: 
msgid "Dask dashboard progress comparison."
msgstr ""

#: 
msgid "Understanding Dask"
msgstr ""

#: 
msgid "This documentation builds upon DE Africa’s existing Parallel Processing with Dask notebook. Each of these isolated examples builds on from the previous, with the aim of introducing a new Dask related concept as each example progresses."
msgstr ""

#: 
msgid "Dask is a tool used for data management, whereby data is broken down into manageable chunks to allow for scaling up analyses and time efficiency. Breaking data into chunks can allow for easier storage in memory and can draw upon multiple computing cores to speed up computations."
msgstr ""

#: 
msgid "To find out more, click **Next**, or select `Lazy-loading Data <./01_lazy_loading_dask.ipynb>`_ below."
msgstr ""

#: 
msgid "What is Git?"
msgstr ""

#: 
msgid "Introduction to Git and GitHub"
msgstr ""

#: 
msgid "The DE Africa Sandbox can be used with the version control software **Git**. Git is free and open-source, and is an industry standard for maintaining code bases used by multiple users. It keeps track of:"
msgstr ""

#: 
msgid "Files"
msgstr ""

#: 
msgid "Changes to file contents"
msgstr ""

#: 
msgid "Who added the changes"
msgstr ""

#: 
msgid "Who approved the changes"
msgstr ""

#: 
msgid "When these changes were made"
msgstr ""

#: 
msgid "It also allows files to be copied, so changes can be made away from the original files, and has rollback features to remove unwanted changes."
msgstr ""

#: 
msgid "One of the Git service providers is a website called **GitHub**. GitHub allows Git users to better manage their files and projects."
msgstr ""

#: 
msgid "The DE Africa Analysis Sandbox has integrated compatibility with Git and GitHub. Connecting your Sandbox to Git via a GitHub account is an excellent way of accessing the DE Africa analysis code, which uses Python in Jupyter Notebooks. It allows you to make your own changes and develop new analyses, without affecting existing code. It is also important for collaboration, as you can publish your changes so they can be viewed, reviewed, and edited by your co-workers."
msgstr ""

#: 
msgid "Why should I use it?"
msgstr ""

#: 
msgid "Benefits of using Git:"
msgstr ""

#: 
msgid "Become familiar with a free version control software used worldwide"
msgstr ""

#: 
msgid "Experiment with DE Africa code without worrying about breaking it"
msgstr ""

#: 
msgid "Back up your DE Africa analysis work to GitHub"
msgstr ""

#: 
msgid "Easily share your code via its GitHub URL"
msgstr ""

#: 
msgid "Gain basic command-line interface experience"
msgstr ""

#: 
msgid "Git concepts"
msgstr ""

#: 
msgid "In each section of this guide on Git, new Git terminology will be introduced in a section called **Git concepts**."
msgstr ""

#: 
msgid "**Repository:** Often shortened to 'repo'. A Git repository is like a folder that lives on GitHub. It contains all the files related to your project. For example, all of the DE Africa Sandbox documentation has been added to a repository called ``deafrica-docs``. Even if you don't have a GitHub account, you can view the files on the repo's `GitHub website <https://github.com/digitalearthafrica/deafrica-docs>`__. To edit or suggest contributions to them, you will need to log in to GitHub. You can do this with most public repos."
msgstr ""

#: 
msgid "Create a GitHub account"
msgstr ""

#: 
msgid "You will need a GitHub account to access files in GitHub repositories. There is a free account option which is suitable for DE Africa purposes."
msgstr ""

#: 
msgid "Sign up at https://github.com/join."
msgstr ""

#: 
msgid "Click **Next** to learn how to connect your GitHub account to the DE Africa Sandbox."
msgstr ""

#: 
msgid "Connect to Git"
msgstr ""

#: 
msgid "Now you have a GitHub account, we will link it to your Sandbox. This allows you to access GitHub repositories directly from the Sandbox."
msgstr ""

#: 
msgid "As we saw in the previous section, you can view files from the GitHub website. However, accessing them directly from the Sandbox allows files to be copied and edited. This is particularly useful for working on coding and analysis."
msgstr ""

#: 
msgid "To do this, we will set Git settings using the Terminal console in the DE Africa Sandbox. You will need both a GitHub account and a DE Africa Sandbox account. Make sure you activate GitHub two-factor authentication, as you will need it to authorise Git actions from inside the Sandbox."
msgstr ""

#: 
msgid "For more information on GitHub security mechanisms, see this article on `configuring two-factor authentication <https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication>`__ or read about `how to create a personal account token <https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token>`__."
msgstr ""

#: 
msgid "Log in to Git on the Sandbox"
msgstr ""

#: 
msgid "Log in to the Digital Earth Africa Sandbox at https://sandbox.digitalearth.africa/hub/login."
msgstr ""

#: 
msgid "Open a Terminal window from the Launcher by clicking on the Terminal icon."
msgstr ""

#: 
msgid "The DE Africa Sandbox Jupyterlab launcher."
msgstr ""

#: 
msgid "Terminal will open to show a blinking cursor. This is the command line. We will use it to set your Git login."
msgstr ""

#: 
msgid "The DE Africa Sandbox Jupyterlab terminal."
msgstr ""

#: 
msgid "Type the following text, replacing ``your-github-username`` with your GitHub username. Make sure to put it inside the quotation marks."
msgstr ""

#: 
msgid "Press ``Enter``. The command line will go to the next line."
msgstr ""

#: 
msgid "Set your Git username."
msgstr ""

#: 
msgid "Now set your email. Your email address has to match the email registered to your GitHub username."
msgstr ""

#: 
msgid "Press ``Enter``."
msgstr ""

#: 
msgid "Congratulations! You have successfully linked your GitHub account to your DE Africa Sandbox. You can now track changes and make your own code copies to edit. The next steps on **forking** and **cloning** show you how to do that."
msgstr ""

#: 
msgid "Fork the DE Africa Sandbox Notebooks repository"
msgstr ""

#: 
msgid "Forking a repository allows you to make a personal copy of a project. This way, you do not need to be an admin or member of an open-source project to experiment on or contribute to the code."
msgstr ""

#: 
msgid "Visit the home page of the `DE Africa Sandbox Notebooks repository <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__."
msgstr ""

#: 
msgid "Click the **Fork** button in the top-right corner of the page."
msgstr ""

#: 
msgid "Fork a repo from the GitHub website."
msgstr ""

#: 
msgid "When the fork is complete, you'll be taken to your forked copy of the repository. The header for the repository should now be ``<username>/deafrica-sandbox-notebooks``, rather than ``digitalearthafrica/deafrica-sandbox-notebooks``. We will refer to this repo as **your fork**."
msgstr ""

#: 
msgid "A forked repo."
msgstr ""

#: 
msgid "This is all on the GitHub website. You can see all the files are there, but you cannot edit them from the website. We will now make a copy of your fork, or **clone**, inside the DE Africa Sandbox, so you can edit files there. First, we will introduce some relevant Git concepts."
msgstr ""

#: 
msgid "**Local:** Your computer, device, or account you are working on. In this case, your local machine is your DE Africa Sandbox. This is because no one else can see or access any files in your Sandbox account (including changes you have made) unless you publish them. This makes it \"local\" to you. Repositories you have copied to your local machine are called \"local repositories\"."
msgstr ""

#: 
msgid "**Remote:** Mostly used to describe repositories hosted online, such as on the GitHub website. A remote repository is often accessible by multiple team members, and may even be public-facing. In most cases, such as in our examples here, the remote repo should contain the most up-to-date version of the files."
msgstr ""

#: 
msgid "**Fork:** \"A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.\" as defined by `GitHub Docs <https://docs.github.com/en/get-started/quickstart/fork-a-repo>`__. At time of forking, the original repo and your fork are exactly the same."
msgstr ""

#: 
msgid "**Clone:** Copying a remote repository to your local machine. Cloning a remote repo makes a local repo. At the timing of cloning, the remote repo and local repo are exactly the same. Any changes made to either repo after this point are not automatically synced. We will cover pushing and pulling changes between repos in the next section."
msgstr ""

#: 
msgid "Difference between a fork and a clone: When you fork a remote repository, like when you press the **Fork** button, you have a *remote* copy of the *remote* repository. Cloning then allows you to make a *local* copy of the *remote* repo. This is generally done to allow editing."
msgstr ""

#: 
msgid "Clone your Sandbox Notebooks fork"
msgstr ""

#: 
msgid "Log in to the Digital Earth Africa Sandbox."
msgstr ""

#: 
msgid "Create a new folder to store your copied repos in. By convention we will call it ``dev``, although you can name it something else. Click the **New Folder** button and name your folder ``dev``, then double-click the folder to navigate inside it. It is currently empty."
msgstr ""

#: 
msgid "New folder."
msgstr ""

#: 
msgid "dev folder."
msgstr ""

#: 
msgid "Inside dev folder."
msgstr ""

#: 
msgid "Click the last symbol on the Folder menu bar. This opens the Clone Repository option."
msgstr ""

#: 
msgid "Clone button."
msgstr ""

#: 
msgid "The Clone URI can be found on each repository's GitHub webpage. We want to clone your fork, so we will go to your fork page. If you cannot find it you can access it from **User > Your repositories** in the top right corner of the GitHub website."
msgstr ""

#: 
msgid "Near the top of the page, it should say \"This branch is even with digitalearthafrica:master.\" This means your fork is the same as the original Sandbox Notebooks repo."
msgstr ""

#: 
msgid "If it does not say that, don't worry. We will fix any inconsistencies between repos in the next part of this guide. You can continue to follow all the steps on this page."
msgstr ""

#: 
msgid "Click the **Code** button to open the dropdown, and click the clipboard icon to copy the URI. It should begin with ``https:// ...``."
msgstr ""

#: 
msgid "Clone on GitHub."
msgstr ""

#: 
msgid "Come back to your Sandbox page and paste the URI into the box. Click **Clone**."
msgstr ""

#: 
msgid "Paste and clone."
msgstr ""

#: 
msgid "After a few moments, a folder will appear in your ``/dev`` folder. This is a clone of your fork of the DE Africa Sandbox Notebooks repo. Well done!"
msgstr ""

#: 
msgid "Clone successful."
msgstr ""

#: 
msgid "If you open the folder and explore its contents, you will see they should look exactly the same as your fork, which is the same as the remote repo on https://github.com/digitalearthafrica/deafrica-sandbox-notebooks."
msgstr ""

#: 
msgid "Why do I have to fork then clone? Can I clone straight from ``digitalearthafrica/deafrica-sandbox-notebooks``? The answer is you can clone the original repo without forking, but you cannot contribute any edits from that direct clone unless you have been added as a member of the Digital Earth Africa Sandbox Notebooks repo. Forking and cloning is best practice for contributing to open-source projects as described in `this article <https://opensource.com/article/19/11/first-open-source-contribution-fork-clone>`__."
msgstr ""

#: 
msgid "Find out more about cloning from remote to local in this `git clone tutorial <https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone>`__."
msgstr ""

#: 
msgid "Terminal version: Clone the DE Africa Sandbox Notebooks repository"
msgstr ""

#: 
msgid "**Skip this section if you have already completed the steps above.**"
msgstr ""

#: 
msgid "This is an alternative method of cloning the repo. It is intended for users already familiar with Terminal command line; this is properly introduced to new users in the later section *Git with Terminal*. Steps roughly correspond to the interface version above."
msgstr ""

#: 
msgid "Log in to the Digital Earth Africa Sandbox and open a Terminal window."
msgstr ""

#: 
msgid "``mkdir dev``"
msgstr ""

#: 
msgid "``cd dev``"
msgstr ""

#: 
msgid "Copy the repo URI from your fork page"
msgstr ""

#: 
msgid "``git clone <URI>``"
msgstr ""

#: 
msgid "I need more Git help!"
msgstr ""

#: 
msgid "Git can be confusing at the start. It can look intimidating to set up, especially if you are not familiar with command-line interfaces. Take your time to read and follow this guide carefully. If you are having trouble:"
msgstr ""

#: 
msgid "Check for typos. Command-line commands are sensitive to spelling errors, whitespaces, punctuation and upper/lower case."
msgstr ""

#: 
msgid "Look up any error messages. Git is very widely used; the Internet has plenty of resources on how to fix different error messages."
msgstr ""

#: 
msgid "Ask a question. DE Africa is part of the Open Data Cube initiative, which has an active Slack community at http://slack.opendatacube.org/ and is a great place to ask for help."
msgstr ""

#: 
msgid "Next steps"
msgstr ""

#: 
msgid "We defined above that *at the timing of cloning, the remote repo and local repo are exactly the same. Any changes made to either repo after this point are not automatically synced*. So what happens if someone else makes a change (such as a code improvement, bug fix, or new examples) to the remote repo? Your copy of the content in your Sandbox account will be out of date. The next section is about how we grab those new changes from the remote repo and download them to our local repo."
msgstr ""

#: 
msgid "Oppositely, we can also make changes on our local repo and contribute them to the remote repo. Then, everyone who uses that code can download your improvements and additions. We will show you how to apply these changes in a way which allows everyone to see who made the changes, what the changes are, and confirm whether these changes should be added to the main repository — the version control abilities of Git."
msgstr ""

#: 
msgid "To do both these things, we will first need to understand how to use Git to track file changes through the graphical user interface on the Sandbox. This is a great option for new Git users as an alternative to the command-line interface. Select **Next** to continue."
msgstr ""

#: 
msgid "Git with the Git menu"
msgstr ""

#: 
msgid "Now we've connected to Git, we can use it to version control. How does Git do this?"
msgstr ""

#: 
msgid "To make file or code changes without impacting working code already on the repository, we make separate \"copies\" of the repository code, called **branches**."
msgstr ""

#: 
msgid "The ``main`` branch is the main branch that contains all the most up-to-date and tested code"
msgstr ""

#: 
msgid "Every time you want to add a new feature or test code, you make a new branch"
msgstr ""

#: 
msgid "The new branch contains all of the code from ``main``, but any changes made to that branch do not affect ``main``"
msgstr ""

#: 
msgid "Once you are confident your changes are working, you can request to add your changes back to ``main`` in a Pull Request (covered in a later section of the guide)"
msgstr ""

#: 
msgid "Creating new branches to work from follows one of the key principles of code contributing. It is considered good practice to keep any new work separate so it can be tested and reviewed before it is published."
msgstr ""

#: 
msgid "Pull and push mechanisms in Git"
msgstr ""

#: 
msgid "*This section covers how we make and get changes on the repository. A simplified diagram of our current remote and local entities are shown in the diagram above.*"
msgstr ""

#: 
msgid "Check your fork is up to date"
msgstr ""

#: 
msgid "The quickest way to check your fork is the latest version of the original repo is by going to your GitHub account and looking at your forks. The fork URL might have a similar structure to:"
msgstr ""

#: 
msgid "If your fork is behind, there will be a banner at the top of the page saying \"This branch is XYZ commits behind digitalearthafrica:main.\" An example is shown in the image below."
msgstr ""

#: 
msgid "This branch is behind by 12 commits."
msgstr ""

#: 
msgid "In this example, 12 changes, or commits, have been made by other people since the fork was last synced with the original."
msgstr ""

#: 
msgid "To make them even again, click **Fetch upstream**, then select **Fetch and merge**. You can \"pull\" those new updates to your Sandbox clone using the Git menu in the Sandbox."
msgstr ""

#: 
msgid "Access the Git menu"
msgstr ""

#: 
msgid "Open up the Sandbox and navigate to the folder of the ``deafrica-sandbox-notebooks`` clone, in your ``dev`` folder. If you have not set up the ``dev`` folder and repository clone yet, please follow the instructions in the previous section on `connecting to Git <./02_connect_git.ipynb>`__."
msgstr ""

#: 
msgid "Check the file path at the top of the folder sidebar is ``/dev/deafrica-sandbox-notebooks/``."
msgstr ""

#: 
msgid "Select the Git menu."
msgstr ""

#: 
msgid "Click the **Git** icon on the sidebar menu. It is a grey diamond shape with two lines running through it. This will take you to the Git menu."
msgstr ""

#: 
msgid "Git menu."
msgstr ""

#: 
msgid "Git menu: a breakdown"
msgstr ""

#: 
msgid "The Git menu tells you about what repository you are editing and lets you access the most common Git version control functions. We will go through some of the buttons on the menu, and then show how they are used through a demo example you can try yourself."
msgstr ""

#: 
msgid "Don't be concerned if you are confused by all the menu items. Try the example exercise below: the concepts will make more sense when you use them."
msgstr ""

#: 
msgid "Parts of the Git menu."
msgstr ""

#: 
msgid "**Current Repository:** This tells me I am currently in my clone of ``deafrica-sandbox-notebooks``. By default (and convention) your clone will have the same name as its parent repository. The Current Repository is selected by whichever folder your File Browser is navigated to, which is why it was important to check your file path earlier."
msgstr ""

#: 
msgid "**Current Branch:** This tells me I am on the ``main`` branch. Click the dropdown arrow to create a new branch, or view and select other branches."
msgstr ""

#: 
msgid "**Pull latest changes:** This performs a Git Pull. Changes to the remote version of this fork (for example, if you synced with the main through **Fetch upstream** earlier) will be pulled down to this clone on the Sandbox. > If you are not sure if you have pulled all recent changes to your clone, you should click this button now."
msgstr ""

#: 
msgid "**Push committed changes:** When you have made changes to the local clone of the repository, you can send them to the remote version by \"committing the change\", then \"pushing\". The following example tutorial will demonstrate both those actions."
msgstr ""

#: 
msgid "**Refresh the repository to detect local and remote changes:** Use this to check your menu is displaying the latest information."
msgstr ""

#: 
msgid "**Staged:** Files listed here have been changed, and these changes are ready for confirmation, or *commit*. Committing will allow these changes to be pushed to the remote repo."
msgstr ""

#: 
msgid "**Changed:** Files which are being version-tracked, and have been modified, will show up here. These changes are not yet committed, so they will not be pushed to the remote repo."
msgstr ""

#: 
msgid "**Untracked:** These files are not being version controlled. They will not be part of the GitHub repo on any branch. Generally, new files are listed here. This is because Git doesn't know yet whether the files are related to any of your branches."
msgstr ""

#: 
msgid "*Untracked files are only stored on your Sandbox memory. This memory is subject to upgrades and changes by Digital Earth Africa as per the Sandbox Terms and Conditions, which could affect your files. Important files should be backed up to at least one other location.*"
msgstr ""

#: 
msgid "**Branch:** A copy of the repository. It contains all the code of the main branch, but can be edited without impacting the repo."
msgstr ""

#: 
msgid "**Commit:** A \"save\" of your changes. It confirms these are the changes you want to make. Only committed changes can be pushed or pulled from repos."
msgstr ""

#: 
msgid "**Pull:** Retrieves changes (commits) from the remote branch and copies them to the corresponding local branch."
msgstr ""

#: 
msgid "**Push:** Sends commits made on the local branch to its corresponding remote branch. Push and pulls make sure local and remote versions of the same repo are up-to-date with each other."
msgstr ""

#: 
msgid "**Upstream:** The term used to indicate the repo being tracked by your fork or clone. For instance, the original ``deafrica-sandbox-notebooks`` repo is *upstream* of your fork of that repo. Not every repo has an upstream entity. In the example tutorial below, we will make a branch in your repo clone, and set its upstream branch to one on your fork."
msgstr ""

#: 
msgid "Tutorial: Use the Git menu to create a new branch and make changes"
msgstr ""

#: 
msgid "All the menu items and new concepts can be best understood by following this tutorial. We will use the sidebar Git menu to:"
msgstr ""

#: 
msgid "make a new branch;"
msgstr ""

#: 
msgid "add a file;"
msgstr ""

#: 
msgid "commit the changes; and"
msgstr ""

#: 
msgid "push the changes to the remote repo (your fork on the GitHub website)."
msgstr ""

#: 
msgid "Make a new branch"
msgstr ""

#: 
msgid "In the Git menu, select **New Branch**."
msgstr ""

#: 
msgid "Name your new branch (here we will call it ``git-test``). For \"Create branch based on...\", select ``main``. This will create a branch which is an exact copy of ``main``. Select **Create Branch** to create the branch."
msgstr ""

#: 
msgid "We will automatically be moved onto the branch. \"Current Branch\" should now say ``git-test``."
msgstr ""

#: 
msgid "Add a new file"
msgstr ""

#: 
msgid "Select the folder icon to return to the Folder view. The files and folders will look exactly like they did before, because you just created a copy of the ``main`` branch. Now we are going to change something. Click on the **Notebook > Python 3** icon in the Launcher to make a new Jupyter Notebook file."
msgstr ""

#: 
msgid "Return to the folder view"
msgstr ""

#: 
msgid "The file will automatically open."
msgstr ""

#: 
msgid "Make a new file"
msgstr ""

#: 
msgid "Type something in the first cell of the file. It's okay if you don't know any Python. In this example, we will enter ``print(\"This is a change to the git-test branch\")``. Ensure the dropdown menu at the top of the file says \"Code\". Press ``Shift + Enter`` on your keyboard to execute the cell. This will print the text you entered underneath the code cell."
msgstr ""

#: 
msgid "Type something in the file."
msgstr ""

#: 
msgid "Let's rename the file. Right-click on the file in the file browser and select **Rename**."
msgstr ""

#: 
msgid "Rename the file"
msgstr ""

#: 
msgid "Type your new file name. Here we have called it ``my-change``. It has the file extension ``.ipynb``."
msgstr ""

#: 
msgid "File is renamed."
msgstr ""

#: 
msgid "Commit changes: track new files"
msgstr ""

#: 
msgid "Go back to the Git menu. Now it will show one \"Untracked\" file - your new Jupyter Notebook file!"
msgstr ""

#: 
msgid "Hover over the file name with your mouse. A **+** symbol will appear on the right-hand side. Click **+**. This adds ``my-change.ipynb`` to the \"Staged\" file list. This means this file is now *tracked*; all changes will be monitored. This is in preparation for changes to be added back to the repo."
msgstr ""

#: 
msgid "While the file is staged but the changes are *not yet committed*, you can still make edits to it. Go back to ``my-change.ipynb`` and add another line, like ``print(\"I am changing a staged file\")``. Now, the letter next to the staged file name has changed from ``A`` (added) to ``M`` (modified)."
msgstr ""

#: 
msgid "Change a staged file."
msgstr ""

#: 
msgid "Let's finalise all these changes (the original added file plus any modifications) by committing. Committing finalises any changes staged files so you can push the changes to your fork. Type a short summary of the changes made to staged files. For example, \"Added my-change file.\" Click **Commit**."
msgstr ""

#: 
msgid "Committed changes are removed from the menu."
msgstr ""

#: 
msgid "Staged changes have been removed."
msgstr ""

#: 
msgid "Commit changes: set upstream"
msgstr ""

#: 
msgid "We are almost there! Now we just need to tell our branch to push the commit to our fork. Remember, your changes are on your local clone of the repo, while the fork is remote on your GitHub account. We will first link our branch to a corresponding remote branch on the fork. They will track each other. When we push our locally commited change, it will go to its equivalent remote branch. If this is too confusing, don't overthink it, just follow the steps."
msgstr ""

#: 
msgid "Github local remote branch diagram."
msgstr ""

#: 
msgid "Open a Terminal from the File Browser. Type in ``git push --set-upstream origin git-test`` and press ``Enter`` on your keyboard. It will ask you for your Git credentials, enter them as prompted. **In Terminal, when you are typing your password or Personal Access Token, the text cursor does not move but characters are being entered. For security reasons you must have set up GitHub multi-factor authentication; see the Connect to Git page for more information.**"
msgstr ""

#: 
msgid "Set upstream remote branch."
msgstr ""

#: 
msgid "Success! You will see the message ``Branch 'git-test' set up to track remote branch 'git-test' from 'origin'``. Return to the Git menu."
msgstr ""

#: 
msgid "Successfully linked remote branch."
msgstr ""

#: 
msgid "Push committed changes"
msgstr ""

#: 
msgid "Return to the Git menu. Hit the icon **Push committed changes**. It looks like a little cloud with an up arrow inside. Enter your Git credentials as prompted and click **OK**."
msgstr ""

#: 
msgid "Authenticate to push changes."
msgstr ""

#: 
msgid "Finally, we can check whether the changes went through. Go to your GitHub ``deafrica-sandbox-notebooks`` fork page, which will have a URL similar to ``https://github.com/<your_username>/deafrica-sandbox-notebooks``. Click the branch dropdown menu near the top of the page. Now, apart from just ``main``, you should also be able to see and select ``git-test``."
msgstr ""

#: 
msgid "The new branch has the changes."
msgstr ""

#: 
msgid "Notice that your new file ``my-change.ipynb`` is *not* listed on the ``main`` branch, but when you switch your view to the ``git-test`` branch, it appears. We have successfully made a change. Congratulations for making it through all of these steps."
msgstr ""

#: 
msgid "Git checklist"
msgstr ""

#: 
msgid "Things to check when you log into the Sandbox and start working on your open-source code project:"
msgstr ""

#: 
msgid "Have you fetched and merged upstream so **your fork is up-to-date** with the original repository?"
msgstr ""

#: 
msgid "Which **branch** are you on? Is that the correct branch to be working from?"
msgstr ""

#: 
msgid "Have you **pulled** and merged the latest changes to your clone from your fork of the repository?"
msgstr ""

#: 
msgid "You can check the first item from your fork URL, and the second two by accessing the Git menu and looking at **Current Repository** and **Current Branch**."
msgstr ""

#: 
msgid "Common issues"
msgstr ""

#: 
msgid "**Unable to detect a Git repository.** This can happen if you have not logged into Git on the Sandbox. Follow the instructions on `connecting to Git <./02_connect_git.ipynb>`__. Secondly, check your File Browser is navigated to your clone folder. If it is in the Home page or just in the ``dev`` folder, those aren't GitHub repositories."
msgstr ""

#: 
msgid "**I can't find my file, but I know I made a new file.** Are you on the correct branch? If you switch to a different branch, your new file may not appear if it has been tracked in a different branch. For example, ``my-change.ipynb`` should not be visible on the ``main`` branch."
msgstr ""

#: 
msgid "**I pushed my changes to my fork but I can't see them on the GitHub website.** Did you add and commit the files which were changed? Are you looking at the ``main`` branch of your fork when your changes were actually on a different branch? ``main`` is displayed by default on the website. Click the branch dropdown to see different branches on your fork."
msgstr ""

#: 
msgid "**I am \"XYZ number of commits behind ``digitalearthafrica:main``\".** You have not fetched and merged the latest changes from the original repository. Click the **Fetch upstream** button on the fork's GitHub webpage to fetch and merge the latest updates. Then, click the **Pull** button in the Sandbox to update your local clone. For minimum conflicts, this should be done before committing the changes and pushing to your fork."
msgstr ""

#: 
msgid "**Git is not accepting my Git password when credentials are requested.** For security reasons, the Sandbox requires a Personal Access Token separate to your password, or another form of multi-factor authentication. They are simple to set up. See the official GitHub article and guide linked on the *Connect to Git* page."
msgstr ""

#: 
msgid "Experiment with making changes using the Git menu and become more familiar with how the file tracking works. Alternatively, continue on with the next part of the tutorial."
msgstr ""

#: 
msgid "The Git menu gives users access to some of the more common Git functions. However, for full flexibility it is ideal to use the Git from the Sandbox Terminal. We already used the Terminal for some commands that could not be done through the menu. As it happens, *all* Git commands can be run through Terminal instead of clicking back and forth in the menu."
msgstr ""

#: 
msgid "The benefits of Terminal include:"
msgstr ""

#: 
msgid "Access to the complete repertoire of Git commands"
msgstr ""

#: 
msgid "Better Git monitoring with the ``git status`` command"
msgstr ""

#: 
msgid "More control over file versioning, including reverting commits"
msgstr ""

#: 
msgid "Familiarity with command-line-like interfaces, which is useful for other non-Git administrative tasks in the Sandbox, and also applicable outside of the Sandbox"
msgstr ""

#: 
msgid "Less clicking around: everything you need can be done from Terminal"
msgstr ""

#: 
msgid "For coders or anyone with previous Terminal or command-line experience, this is the natural platform for you to use. If these concepts are new to you, don't worry! They are uncomplicated to learn and we recommend trying it."
msgstr ""

#: 
msgid "Click **Next** to continue."
msgstr ""

#: 
msgid "Git with Terminal"
msgstr ""

#: 
msgid "The ultimate tool for file versioning with Git in the DE Africa Sandbox is the Terminal. You can open a Terminal window from the Launcher tab by clicking on the Terminal icon."
msgstr ""

#: 
msgid "In this section, we will show how to use Terminal to create a branch and push changes to your fork. This involves typing commands into the Terminal command line."
msgstr ""

#: 
msgid "It is assumed you have forked and cloned the ``deafrica-sandbox-notebooks`` repo as described in the *Connect to Git* section. Familiarity with the section *Git with the Git menu*, including concepts such as **push**, **pull**, **branch** and **commit** will be useful. If you are new to Git, you are encouraged to try both tutorials."
msgstr ""

#: 
msgid "Please ensure you have also updated your fork to match ``digitalearthafrica:master`` by selecting **Fetch upstream** and **Fetch and merge** from your fork's GitHub page."
msgstr ""

#: 
msgid "A recap on why we create a branch to make changes:"
msgstr ""

#: 
msgid "The ``master`` branch is the main branch that contains all the most up-to-date and tested code"
msgstr ""

#: 
msgid "The new branch contains all of the code from ``master``, but any changes made to that branch do not affect ``master``"
msgstr ""

#: 
msgid "Once you are confident your changes are working, you can request to add your changes back to ``master`` in a Pull Request (covered in a later section of the guide)"
msgstr ""

#: 
msgid "Terminal: a breakdown"
msgstr ""

#: 
msgid "The Terminal interface has two main components:"
msgstr ""

#: 
msgid "The current directory you are in"
msgstr ""

#: 
msgid "The command line, where you can type commands"
msgstr ""

#: 
msgid "Terminal interface screenshot."
msgstr ""

#: 
msgid "Check your clone is up to date"
msgstr ""

#: 
msgid "Open a Terminal window from a Launcher tab. You can open a new Launcher tab by pressing the **+** button at the top of the File Browser menu."
msgstr ""

#: 
msgid "Terminals automatically start in your home directory. Type ``ls`` and press ``Enter`` on your keyboard to show all files and folders in your home directory."
msgstr ""

#: 
msgid "Files in your home directory."
msgstr ""

#: 
msgid "Change the directory of your Terminal to your clone of the ``deafrica-sandbox-notebooks`` repo. This can be done by using ``cd``, the \"change directory\" command. The syntax is ``cd <folder name>/``."
msgstr ""

#: 
msgid "In Terminal, type:"
msgstr ""

#: 
msgid "and hit ``Enter``. Notice your directory has now changed: the ``$`` is now *after* ``/dev/deafrica-sandbox-notebooks``."
msgstr ""

#: 
msgid "Change your Terminal directory."
msgstr ""

#: 
msgid "Check your clone is up to date by running:"
msgstr ""

#: 
msgid "This will pull any changes between your fork and this local clone."
msgstr ""

#: 
msgid "Terminal tips"
msgstr ""

#: 
msgid "Press the **Tab** key on your keyboard to auto-complete file paths and file names. This is *much* faster and generally more accurate than typing manually."
msgstr ""

#: 
msgid "Press the **Up** arrow key on your keyboard to access Terminal commands you have previously executed. Great for repeating a command."
msgstr ""

#: 
msgid "The File Browser does *not* show which directory your Terminal is in. Terminal directory location and File Browser folder location are completely independent."
msgstr ""

#: 
msgid "The File Browser *does* show the content of the branch you are in. This means files in one branch but not another will appear or disappear when you switch branches. Therefore, it is always good to know which branch you are on."
msgstr ""

#: 
msgid "Terminal commands are case-sensitive."
msgstr ""

#: 
msgid "By convention, Terminal code is often identified with a ``!`` at the start of the line, but for clarity will not be used in this tutorial as ``!`` is not required in Terminal itself. (Jupyter Notebooks allow Terminal commands to be run inside ``.ipynb`` files by using code cells starting with ``!``; this is not covered here.)"
msgstr ""

#: 
msgid "Tutorial: Use Terminal to create a new branch and make changes"
msgstr ""

#: 
msgid "We will use the Terminal in the Sandbox to:"
msgstr ""

#: 
msgid "add a file (this will be done using File Browser, although it can be done by Terminal);"
msgstr ""

#: 
msgid "push the changes to the remote repo."
msgstr ""

#: 
msgid "Your Terminal commands may be different if you have named your repositories or branches differently from the examples provided here or in the *Connect to Git* tutorial, or if they are located in a different folder arrangement."
msgstr ""

#: 
msgid "In the Terminal, navigate to your ``deafrica-sandbox-notebooks`` directory if you aren't there already."
msgstr ""

#: 
msgid "Make a new branch using the ``git checkout -b`` command. ``git checkout`` moves between branches, and the ``-b`` creates a new branch."
msgstr ""

#: 
msgid "You will see the message ``Switched to a new branch 'git-terminal'``."
msgstr ""

#: 
msgid "Open the File Browser. Navigate. Click on the **Notebook > Python 3** icon in the Launcher to make a new Jupyter Notebook file."
msgstr ""

#: 
msgid "Type something in the first cell of the file, for example ``print(\"This is a change to the git-terminal branch\")``. Ensure the dropdown menu at the top of the file says \"Code\". Press ``Shift + Enter`` on your keyboard to execute the cell. This will print the text you entered underneath the code cell."
msgstr ""

#: 
msgid "Go back to your Terminal tab and run"
msgstr ""

#: 
msgid "This will show output indicating current branch and untracked files, such as the new file you just created."
msgstr ""

#: 
msgid "New files are untracked."
msgstr ""

#: 
msgid "As suggested in the Terminal output, we use ``git add <filename>`` to start tracking the file."
msgstr ""

#: 
msgid "Run ``git status`` again to see the file name has changed to a green colour and it no longer says ``untracked``."
msgstr ""

#: 
msgid "Add new file to track it."
msgstr ""

#: 
msgid "Go back to ``my-change.ipynb`` and add some text or code. Save the file."
msgstr ""

#: 
msgid "Switch back to the Terminal tab and run ``git status`` again. The modifications show up as unstaged changes."
msgstr ""

#: 
msgid "Unstaged changes."
msgstr ""

#: 
msgid "Run ``git add my-change.ipynb`` again to include the new modifications in your commit."
msgstr ""

#: 
msgid "When all the changes you want to make in that commit are staged, run the command"
msgstr ""

#: 
msgid "The text in the quotation marks should be replaced with a brief description of the commit."
msgstr ""

#: 
msgid "Run ``git status`` again, and your committed changes have disappeared. The output will say ``nothing to commit, working tree clean``."
msgstr ""

#: 
msgid "The easiest way to set upstream is as follows:"
msgstr ""

#: 
msgid "Run:"
msgstr ""

#: 
msgid "This will give you the error message ``fatal: The current branch git-terminal has no upstream branch.``. It will suggest to you a command that looks like:"
msgstr ""

#: 
msgid "The suggested code is usually correct. Use your mouse to copy the suggested line of code. Copy by pressing ``Ctrl+C`` then click back to your command line text cursor. Paste using ``Ctrl+V`` and press ``Enter`` to run."
msgstr ""

#: 
msgid "Enter your GitHub username and Personal Access Token or similar, as prompted."
msgstr ""

#: 
msgid "Return to your Terminal tab. Run:"
msgstr ""

#: 
msgid "Enter Git credentials as prompted."
msgstr ""

#: 
msgid "Congratulations, you're all done. As suggested in the previous section, you can now go to your fork on the GitHub website and check for your new branch, ``git-terminal``, as well as the new file only visible there."
msgstr ""

#: 
msgid "Git checklist with ``git status``"
msgstr ""

#: 
msgid "The ``git status`` command will help you identify which branch you are currently on, as well as list any staged or unstaged changes, and any untracked files."
msgstr ""

#: 
msgid "Terminal command summary"
msgstr ""

#: 
msgid "``cd <folder path>`` Changes directory to the new folder path"
msgstr ""

#: 
msgid "``cd ..`` Goes up one on the folder path (back one folder)"
msgstr ""

#: 
msgid "``cd`` Resets directory to home"
msgstr ""

#: 
msgid "``ls`` Shows files and folders in the current directory"
msgstr ""

#: 
msgid "``git status`` Summary of your Git repository"
msgstr ""

#: 
msgid "``git pull`` Pulls commits from the remote to local"
msgstr ""

#: 
msgid "``git checkout -b <new branch name>`` Creates new branch based off current branch and checks out the new branch"
msgstr ""

#: 
msgid "``git checkout <branch name>`` Checks out existing branch"
msgstr ""

#: 
msgid "``git add <file or folder>`` Stages all changes in the file or folder"
msgstr ""

#: 
msgid "``git commit -m \"description\"`` Commits staged changes to a commit described by the description"
msgstr ""

#: 
msgid "``git push`` Pushes commits to the remote repo"
msgstr ""

#: 
msgid "With a bit of practice, Terminal commands are faster than using the Git menu interface, and can provide a greater level of control and flexibility."
msgstr ""

#: 
msgid "**Terminal error \"fatal: not a git repository\".** This occurs when your Terminal directory location is not a folder linked to a Git repo. Your home directory is not linked to Git, and your ``dev`` folder is not linked to Git."
msgstr ""

#: 
msgid "**One of my files has disappeared but I did not delete it.** You could be on the wrong branch. Run a ``git status`` to check your current branch. Use ``git checkout <branch name>`` to move between branches."
msgstr ""

#: 
msgid "As Git is well-documented online, it is recommended you Google search any issues when troubleshooting."
msgstr ""

#: 
msgid "GitHub wiki tutorial"
msgstr ""

#: 
msgid "A concise version of this tutorial can be found on the `deafrica-sandbox-notebooks wiki <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/wiki/Guide-to-working-with-your-own-copy-of-the-DE-Africa-Notebooks>`__. It also contains useful Terminal commands not described here."
msgstr ""

#: 
msgid "One way or another, you have made changes to your fork of the repository. You've branched, committed, pulled and pushed, and your code is ready to be seen by the masses."
msgstr ""

#: 
msgid "The only problem — it's on *your* GitHub repository and no one else knows it's there. Time to fix that: the next section shows you how to make a *pull request*. Pull requests allow users to propose code mergers between repositories and branches through a documented review system."
msgstr ""

#: 
msgid "Make a pull request (PR)"
msgstr ""

#: 
msgid "A pull request, often shortened to PR, is the process by which code is contributed back to the central repository. It merges the changes from one branch into another. Often, the changes are being merged into the ``main`` or ``master`` branch, but PRs can be used to merge a branch with any other branch, both within the central repository and from a fork to the central repository."
msgstr ""

#: 
msgid "Here you will have made a fork of the ``deafrica-sandbox-notebooks`` repository, so the PR consists of the following steps:"
msgstr ""

#: 
msgid "Ensure your changes are on a branch that is up to date with ``digitalearthafrica:master``"
msgstr ""

#: 
msgid "Open a PR between your fork's branch and ``digitalearthafrica/deafrica-sandbox-notebooks``"
msgstr ""

#: 
msgid "Describe the changes made in your branch"
msgstr ""

#: 
msgid "Submit the PR for review"
msgstr ""

#: 
msgid "Since we have not made any substantial contribution to the repository in the previous example tutorials, this demonstration PR will *not* be submitted."
msgstr ""

#: 
msgid "Check your remote branch is up to date"
msgstr ""

#: 
msgid "On your GitHub fork of the repository, use the branch dropdown to select the branch with the changes you want to propose. The header should say"
msgstr ""

#: 
msgid "Those commits are your proposed changes. If the branch is behind, perform a fetch upstream and merge."
msgstr ""

#: 
msgid "Open a pull request"
msgstr ""

#: 
msgid "Click **Contribute** and select **Open pull request**."
msgstr ""

#: 
msgid "Contribute button."
msgstr ""

#: 
msgid "Describe your changes"
msgstr ""

#: 
msgid "This is an important step to communicate why you want to make changes to the repository. The ``deafrica-sandbox-notebooks`` has a default PR template: proposed changes should be summarised and the code quality checklist reviewed."
msgstr ""

#: 
msgid "Open PR template."
msgstr ""

#: 
msgid "Change the title to something more informative, and fill in the description."
msgstr ""

#: 
msgid "At the top of the page, we can see the PR will request a merge from the user's fork, from a branch called ``git-test``, to the base repository ``digitalearthafrica/deafrica-sandbox-notebooks`` branch of ``master``."
msgstr ""

#: 
msgid "When the PR submission has been filled out, select **Create pull request**."
msgstr ""

#: 
msgid "What happens next?"
msgstr ""

#: 
msgid "The PR becomes publicly visible. Depending on the repository settings, one or more contributors will need to review and approve the PR before it can be merged. This may involve editing your changes, or leaving comments or suggestions for improvement before merging can occur."
msgstr ""

#: 
msgid "When should I make a PR?"
msgstr ""

#: 
msgid "PRs should do at least one of the following:"
msgstr ""

#: 
msgid "Fix an open issue on the repo"
msgstr ""

#: 
msgid "Improve existing code by removing typos or increasing efficiency"
msgstr ""

#: 
msgid "Expand on existing code"
msgstr ""

#: 
msgid "It is good practice to have a working familiarity with the repository before proposing large changes. If in doubt, get in contact with the repository owners."
msgstr ""

#: 
msgid "GitHub wiki tutorial and other resources"
msgstr ""

#: 
msgid "A concise version of steps to open a PR can be found on the `deafrica-sandbox-notebooks wiki <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/wiki/Guide-to-working-with-your-own-copy-of-the-DE-Africa-Notebooks#creating-a-pull-request>`__."
msgstr ""

#: 
msgid "Additionally, you may find this summary tutorial from `dataschool.io <https://www.dataschool.io/how-to-contribute-on-github/>`__ useful."
msgstr ""

#: 
msgid "Read error messages carefully and use Google (or your preferred search engine)! Forums such as Stackexchange have the answers to many Git problems."
msgstr ""

#: 
msgid "Bonus: Make this tutorial better!"
msgstr ""

#: 
msgid "Contributions to this tutorial can be made through a pull request to the Digital Earth Africa Read the Docs repository at https://github.com/digitalearthafrica/deafrica-docs. It will then undergo the collaborative review process described above."
msgstr ""

#: 
msgid "*Digital Earth Africa Read the Docs content is mostly written in Markdown in Jupyter Notebooks with some formatting in ReStructuredText (RST).*"
msgstr ""

#: 
msgid "Conclusion"
msgstr ""

#: 
msgid "Thanks for joining us on the journey towards Git literacy. We hope you found it useful!"
msgstr ""

#: 
msgid "Version Control with Git"
msgstr ""

#: 
msgid "The DE Africa Sandbox can be used with the version control software **Git**. Git is free and open-source, and is an industry standard for maintaining code bases used by multiple users."
msgstr ""

#: 
msgid "The DE Africa Analysis Sandbox has integrated compatibility with Git. Connecting your Sandbox to Git via a GitHub account is an excellent way of accessing the DE Africa analysis code, which uses Python in Jupyter Notebooks. It allows you to make your own changes and develop new analyses, without affecting existing code. It is also important for collaboration, as you can publish your changes so they can be viewed, reviewed, and edited by your co-workers."
msgstr ""

#: 
msgid "To find out more, click **Next**, or select `What is Git? <./01_what_is_git.ipynb>`_ below."
msgstr ""

#: 
msgid "To see the extensive code available in the Sandbox for spatial analysis, see the `Notebook Gallery <../index.rst>`_."
msgstr ""

#: 
msgid "When you create a DE Africa Sandbox account or use the DE Africa Sandbox, you agree to the `Sandbox Terms and Conditions <../termsconditions.rst>`_."
msgstr ""

#: 
msgid "Getting Help with the Sandbox"
msgstr ""

#: 
msgid "Having issues with the Sandbox? Check the Help Desk Knowledgebase for more issues:"
msgstr ""

#: 
msgid "`Digital Earth Africa Help Desk <https://helpdesk.digitalearthafrica.org/portal/en/kb/sandbox>`_"
msgstr ""

#: 
msgid "If you can't find what you are looing for, you can ask a question at:"
msgstr ""

#: 
msgid "`Submit a ticket <https://helpdesk.digitalearthafrica.org/portal/newticket>`_"
msgstr ""

#: 
msgid "Analysis Sandbox"
msgstr ""

#: 
msgid "The DE Africa Analysis Sandbox is a cloud-based user computational platform that operates through a Jupyter Lab environment. It provides users with access to data and analysis tools, democratising access to remote-sensing data to allow for ad-hoc report generation and rapid development of new algorithms."
msgstr ""

#: 
msgid "When you create a DE Africa Sandbox account or use the DE Africa Sandbox, you agree to the `Sandbox Terms and Conditions <termsconditions.rst>`_."
msgstr ""

#: 
msgid ":doc:`access`"
msgstr ""

#: 
msgid "Creating an account on the sandbox"
msgstr ""

#: 
msgid ":doc:`More <access>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Beginners_guide/index`"
msgstr ""

#: 
msgid "An introduction to using the sandbox"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Beginners_guide/index>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Datasets/index`"
msgstr ""

#: 
msgid "Examples on using the each of the datasets"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Datasets/index>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Frequently_used_code/index`"
msgstr ""

#: 
msgid "Simple code examples demonstrating how to perform common tasks"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Frequently_used_code/index>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Real_world_examples/index`"
msgstr ""

#: 
msgid "Complex workflows on how to address real-world problems"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Real_world_examples/index>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Use_cases/index`"
msgstr ""

#: 
msgid "Advanced examples looking at specific use-cases"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Use_cases/index>`"
msgstr ""

#: 
msgid "Additional Guides"
msgstr ""

#: 
msgid ":doc:`notebooks/SDGs/DEAfrica_Notebooks_and_SDG_Indicators`"
msgstr ""

#: 
msgid "How DE Africa data and services can be used to support the Sustainable Development Goals."
msgstr ""

#: 
msgid ":doc:`More <notebooks/SDGs/DEAfrica_Notebooks_and_SDG_Indicators>`"
msgstr ""

#: 
msgid ":doc:`notebooks/Tools/index`"
msgstr ""

#: 
msgid "Reference guide for ``deafrica_tools`` functions and algorithms"
msgstr ""

#: 
msgid ":doc:`More <notebooks/Tools/index>`"
msgstr ""

#: 
msgid ":doc:`help`"
msgstr ""

#: 
msgid "How to get help using the Sandbox"
msgstr ""

#: 
msgid ":doc:`More <help>`"
msgstr ""

#: 
msgid ":doc:`git-howto/index`"
msgstr ""

#: 
msgid "Guide to using notebooks with ``git`` version control"
msgstr ""

#: 
msgid ":doc:`More <git-howto/index>`"
msgstr ""

#: 
msgid ":doc:`dask-howto/index`"
msgstr ""

#: 
msgid "Guide to using Dask capabilities within the Sandbox"
msgstr ""

#: 
msgid ":doc:`More <dask-howto/index>`"
msgstr ""

#: 
msgid "Introduction to Jupyter notebooks"
msgstr ""

#: 
msgid "**Prerequisites**:"
msgstr ""

#: 
msgid "There is no prerequisite learning required, as this document is designed for a novice user of the Jupyter environment"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; jupyter notebook`, :index:`jupyter notebook; beginner's guide`, :index:`jupyter notebook; markdown cell`, :index:`jupyter notebook; raw cell`, :index:`jupyter notebook; code cell`"
msgstr ""

#: 
msgid "Access to implementations of the `Open Data Cube <https://www.opendatacube.org/>`__ such as `Digital Earth Africa <https://www.digitalearthafrica.org/>`__ and `Digital Earth Australia <https://www.ga.gov.au/dea>`__ is achieved through the use of Python code and `Jupyter Notebooks <https://jupyterlab.readthedocs.io/en/stable/user/notebook.html>`__. The Jupyter Notebook (also termed notebook from here onwards) is an interactive web application that allows for the viewing, creation and documentation of live code. Notebook applications include data transformation, visualisation, modelling and machine learning. The default web interface to access notebooks when using Digital Earth Africa is `JupyterLab <https://jupyterlab.readthedocs.io/en/stable/>`__."
msgstr ""

#: 
msgid "This notebook is designed to introduce users to the basics of using Python code in Jupyter Notebooks via JupyterLab."
msgstr ""

#: 
msgid "Topics covered include:"
msgstr ""

#: 
msgid "How to run (execute) a Jupyter Notebook cell"
msgstr ""

#: 
msgid "The different types of Jupyter Notebook cells"
msgstr ""

#: 
msgid "Stopping a process or restarting a Jupyter Notebook"
msgstr ""

#: 
msgid "Saving and exporting your work"
msgstr ""

#: 
msgid "Starting a new Jupyter Notebook"
msgstr ""

#: 
msgid "Getting started"
msgstr ""

#: 
msgid "Running (executing) a cell"
msgstr ""

#: 
msgid "Jupyter Notebooks allow code to be separated into sections that can be executed independent of one another. These sections are called \"cells\"."
msgstr ""

#: 
msgid "Python code is written into individual cells that can be executed by placing the cursor in the cell and typing ``Shift-Enter`` on the keyboard or selecting the ► \"run\" button in the ribbon at the top of the notebook. These options will run a single cell at a time."
msgstr ""

#: 
msgid "If you wish to auto-run all cells in a notebook, navigate to the \"Run\" tab of the menu bar at the top of JupyterLab and select \"Run All Cells\" (or the option that best suits your needs). When you run a cell, you are executing that cell's content. Any output produced from running the cell will appear directly below it."
msgstr ""

#: 
msgid "Run the cell below:"
msgstr ""

#: 
msgid "Cell status"
msgstr ""

#: 
msgid "The ``[ ]:`` symbol to the left of each Code cell describes the state of the cell:"
msgstr ""

#: 
msgid "``[ ]:`` means that the cell has not been run yet."
msgstr ""

#: 
msgid "``[*]:`` means that the cell is currently running."
msgstr ""

#: 
msgid "``[1]:`` means that the cell has finished running and was the first cell run."
msgstr ""

#: 
msgid "The number indicates the order that the cells were run in."
msgstr ""

#: 
msgid "**Note:** You can also tell whether a cell is currently executing in a Jupyter notebook by inspecting the small circle in the top-right of the window. The circle will turn grey (\"Kernel busy\") when the cell is running, and return to empty (\"Kernel idle\") when the process is complete."
msgstr ""

#: 
msgid "Jupyter notebook cell types"
msgstr ""

#: 
msgid "Cells are identified as either Code, Markdown, or Raw. This designation can be changed using the ribbon at the top of the notebook."
msgstr ""

#: 
msgid "Code cells"
msgstr ""

#: 
msgid "All code operations are performed in Code cells. Code cells can be used to edit and write new code, and perform tasks like loading data, plotting data and running analyses."
msgstr ""

#: 
msgid "Click on the cell below. Note that the ribbon at the top of the notebook describes it as a Code cell."
msgstr ""

#: 
msgid "Markdown cells"
msgstr ""

#: 
msgid "Place the cursor in this cell by double clicking."
msgstr ""

#: 
msgid "The cell format has changed to allow for editing. Note that the ribbon at the top of the notebook describes this as a Markdown cell."
msgstr ""

#: 
msgid "Run this cell to return the formatted version."
msgstr ""

#: 
msgid "Markdown cells provide the narrative to a notebook. They are used for text and are useful to describe the code operations in the following cells. To see some of the formatting options for text in a Markdown cell, navigate to the \"Help\" tab of the menu bar at the top of JupyterLab and select \"Markdown Reference\". Here you will see a wide range of text formatting options including headings, dot points, italics, hyperlinking and creating tables."
msgstr ""

#: 
msgid "Raw cells"
msgstr ""

#: 
msgid "Information in Raw cells is stored in the notebook metadata and can be used to render different code formats into HTML or :math:`\\LaTeX`. There are a range of available Raw cell formats that differ depending on how they are to be rendered. For the purposes of this beginner's guide, raw cells are rarely used by the authors and not required for most notebook users."
msgstr ""

#: 
msgid "Sometimes it can be useful to stop a cell execution before it finishes (e.g. if a process is taking too long to complete, or if you realise you need to modify some code before running the cell). To interrupt a cell execution, you can click the ■ \"stop\" button in the ribbon above the notebook, or select \"Interrupt Kernel\" from the Kernel menue."
msgstr ""

#: 
msgid "To test this, run the following code cell. This will run a piece of code that will take 20 seconds to complete. To interrupt this code, press the ■ \"stop\" button. The notebook should stop executing the cell."
msgstr ""

#: 
msgid "If the approach above does not work (e.g. if the notebook has frozen or refuses to respond), you can also try restarting the entire notebook. To do this, navigate to the \"Kernel\" tab of the menu bar, then select \"Restart Kernel\". Alternatively, click the ↻ \"Restart the kernel\" button in the ribbon above the notebook."
msgstr ""

#: 
msgid "Restarting a notebook can also be useful for testing whether your code will work correctly the first time a new user tries to run the notebook. To restart and then run every cell in a notebook, navigate to the \"Kernel\" tab, then select \"Restart and Run All Cells\"."
msgstr ""

#: 
msgid "Modifications to Jupyter Notebooks are automatically saved every few minutes. However, you can force a notebook to save by navigating to \"File\" in the menu bar, then selecting \"Save Notebook\". Alternatively, click the 💾 \"save\" icon on the left of the ribbon above the notebook."
msgstr ""

#: 
msgid "Exporting Jupyter Notebooks to Python scripts"
msgstr ""

#: 
msgid "The standard file extension for a Jupyter Notebook is ``.ipynb``."
msgstr ""

#: 
msgid "There are a range of export options that allow you to save your work for access outside of the Jupyter environment. Python code for example can easily be saved as ``.py`` Python scripts by navigating to the \"File\" tab of the menu bar in JupyterLab and selecting \"Export Notebook As\" followed by \"Export Notebook To Executable Script\"."
msgstr ""

#: 
msgid "Starting a new notebook"
msgstr ""

#: 
msgid "To create a new notebook of your own, first use JupyterLab's file browser to navigate to the directory you would like the notebook to be created in (if the file browser is not visible, re-open it by clicking on the 📁 \"File browser\" icon at the top-left of the screen)."
msgstr ""

#: 
msgid "Once you have navigated to your desired location, press the ✚ \"New Launcher\" button above the browser. This will bring up JupyterLab's \"Launcher\" page which allows you to launch a range of new files or utilities. Below the heading \"Notebook\", click the large \"Python 3\" button. This will create a new notebook entitled \"Untitled.ipynb\" in your directory."
msgstr ""

#: 
msgid "To rename this notebook to something more useful, right-click on it in the file browser and select \"Rename\"."
msgstr ""

#: 
msgid "Recommended next steps"
msgstr ""

#: 
msgid "For more advanced information about working with Jupyter Notebooks or JupyterLab, you can explore `JupyterLab documentation page <https://jupyterlab.readthedocs.io/en/stable/user/notebook.html>`__."
msgstr ""

#: 
msgid "To continue working through the notebooks in this beginner's guide, the following notebooks are designed to be worked through in the following order:"
msgstr ""

#: 
msgid "**Jupyter Notebooks (this notebook)**"
msgstr ""

#: 
msgid "`Products and Measurements <02_Products_and_measurements.ipynb>`__"
msgstr ""

#: 
msgid "`Loading data <03_Loading_data.ipynb>`__"
msgstr ""

#: 
msgid "`Plotting <04_Plotting.ipynb>`__"
msgstr ""

#: 
msgid "`Performing a basic analysis <05_Basic_analysis.ipynb>`__"
msgstr ""

#: 
msgid "`Introduction to numpy <06_Intro_to_numpy.ipynb>`__"
msgstr ""

#: 
msgid "`Introduction to xarray <07_Intro_to_xarray.ipynb>`__"
msgstr ""

#: 
msgid "`Parallel processing with Dask <08_Parallel_processing_with_dask.ipynb>`__"
msgstr ""

#: 
msgid "Once you have you have completed the above six tutorials, join advanced users in exploring:"
msgstr ""

#: 
msgid "The \"Datasets\" directory in the repository, where you can explore DE Africa products in depth."
msgstr ""

#: 
msgid "The \"Frequently used code\" directory, which contains a recipe book of common techniques and methods for analysing DE Africa data."
msgstr ""

#: 
msgid "The \"Real-world examples\" directory, which provides more complex workflows and analysis case studies."
msgstr ""

#: 
msgid "Additional information"
msgstr ""

#: 
msgid "**License:** The code in this notebook is licensed under the `Apache License, Version 2.0 <https://www.apache.org/licenses/LICENSE-2.0>`__. Digital Earth Africa data is licensed under the `Creative Commons by Attribution 4.0 <https://creativecommons.org/licenses/by/4.0/>`__ license."
msgstr ""

#: 
msgid "**Contact:** If you need assistance, please post a question on the `Open Data Cube Slack channel <http://slack.opendatacube.org/>`__ or on the `GIS Stack Exchange <https://gis.stackexchange.com/questions/ask?tags=open-data-cube>`__ using the ``open-data-cube`` tag (you can view previously asked questions `here <https://gis.stackexchange.com/questions/tagged/open-data-cube>`__). If you would like to report an issue with this notebook, you can file one on `Github <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__."
msgstr ""

#: 
msgid "**Last Tested:**"
msgstr ""

#: 
msgid "Introduction to products and measurements"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr/extents>`__"
msgstr ""

#: 
msgid "**Prerequisites:** Users of this notebook should have a basic understanding of:"
msgstr ""

#: 
msgid "How to run a `Jupyter notebook <01_Jupyter_notebooks.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; products`, :index:`beginner's guide; measurements`, :index:`products; beginner's guide`, :index:`measurements; beginner's guide`, :index:`data used; landsat 8`"
msgstr ""

#: 
msgid "A \"datacube\" is a digital information architecture that specialises in hosting and cataloguing spatial information. `Digital Earth Africa (DE Africa) <https://www.digitalearthafrica.org/>`__ is based on the `Open Data Cube <https://www.opendatacube.org/>`__ infrastructure, and specialises in storing remotely sensed data, particularly from Earth Observation satellites such as `Landsat <https://landsat.gsfc.nasa.gov/>`__ and `Sentinel <https://www.esa.int/Applications/Observing_the_Earth/Copernicus/The_Sentinel_missions>`__."
msgstr ""

#: 
msgid "The Digital Earth Africa datacube contains both raw satellite data and derivative data \"products\". These data products are often composed of a range of \"measurements\" such as the suite of remote sensing band values or statistical product summaries. Before running a query to load data from the datacube, it is useful to know what it contains. This notebook demonstrates several straightforward ways to inspect the product and measurement contents of a datacube."
msgstr ""

#: 
msgid "This notebook demonstrates how to connect to the Digital Earth Africa datacube and interrogate the available products and measurements stored within. Topics covered include:"
msgstr ""

#: 
msgid "How to connect to a datacube"
msgstr ""

#: 
msgid "How to list all the products"
msgstr ""

#: 
msgid "How to list a selected product's measurements"
msgstr ""

#: 
msgid "How to interactively visualise data in the datacube"
msgstr ""

#: 
msgid "To run this introduction to products and measurements, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "Load packages"
msgstr ""

#: 
msgid "The ``datacube`` package is required to access and work with available data. The ``pandas`` package is required to format tables. The ``DcViewer`` utility will allow us to interactively explore the products available in the datacube."
msgstr ""

#: 
msgid "Connect to the datacube"
msgstr ""

#: 
msgid "After importing the ``datacube`` package, users need to specify a name for their session, known as the app name."
msgstr ""

#: 
msgid "This name is generated by the user and is used to track down issues with database queries. It does not have any effect on the analysis. Use a short name that is consistent with the purpose of your notebook such as the way ``02_Products_and_measurements`` has been used as the app name in this notebook."
msgstr ""

#: 
msgid "The resulting ``dc`` object is what we use to access all the data contained within the Digital Earth Africa datacube."
msgstr ""

#: 
msgid "List products"
msgstr ""

#: 
msgid "Once a datacube instance has been created, users can explore the products and measurements stored within."
msgstr ""

#: 
msgid "The following cell lists all product attributes currently available in the Digital Earth Africa datacube by using the ``dc.list_products().columns`` function."
msgstr ""

#: 
msgid "Any of these can be used to customise the product information returned by the ``dc.list_products()`` function, as shown in the next cell."
msgstr ""

#: 
msgid "Additionally, the next cell lists all products that are currently available in the Digital Earth Africa datacube by using the ``dc.list_products()`` function."
msgstr ""

#: 
msgid "Products listed under **name** in the following table represent the product options available when querying the datacube. The table below provides some useful information about each product, including a brief product **description**, the **instrument** and **platform** the data originated from (e.g. Landsat 8 OLI), and the product's default **crs** (coordinate reference system) and **resolution** if applicable."
msgstr ""

#: 
msgid "List measurements"
msgstr ""

#: 
msgid "Most products are associated with a range of available measurements. These can be individual satellite bands (e.g. Landsat's near-infrared band) or statistical product summaries."
msgstr ""

#: 
msgid "Using the **name** column of products listed above, let's interrogate the measurements associated with the ``ls8_usgs_sr_scene`` product using the ``dc.list_measurements()`` function. This product name refers to the US Geological Survey's Landsat 8 Analysis-ready data product."
msgstr ""

#: 
msgid "The table below includes a range of technical information about each band in the dataset, including any **aliases** which can be used to load the data, the data type or **dtype**, any **flags_definition** that are associated with the measurement (this information is used for tasks like cloud masking), and the measurement's **nodata** value."
msgstr ""

#: 
msgid "Change the ``product`` name below and re-run the following cell to explore available measurements associated with other products."
msgstr ""

#: 
msgid "Visualising available data"
msgstr ""

#: 
msgid "For a more visual way of exploring the data that is available within the Digital Earth Africa datacube, we can use the interactive ``DcViewer`` utility or the online `DE Africa Explorer <https://explorer.digitalearth.africa/products/ls8_sr>`__ website. We will use the ``DcViewer`` utility in this exiercise. Select a product from the drop-down menu on the top-left of the map to show the areas data is available for in blue. You can also use the back and forward buttons above the map to toggle through time."
msgstr ""

#: 
msgid "The utility is only able to visualise a limited number of datasets at one time. If the available data footprints do not appear, either press the \"show\" button on the top right, or zoom further in on the map."
msgstr ""

#: 
msgid "`Jupyter Notebooks <01_Jupyter_notebooks.ipynb>`__"
msgstr ""

#: 
msgid "**Products and measurements (this notebook)**"
msgstr ""

#: 
msgid "**Compatible datacube version:**"
msgstr ""

#: 
msgid "Loading data from Digital Earth Africa"
msgstr ""

#: 
msgid "**Products used:** `gm_s2_annual <https://explorer.digitalearth.africa/gm_s2_annual>`__, `ga_ls8c_wofs_2_annual_summary <https://explorer.digitalearth.africa/ga_ls8c_wofs_2_annual_summary>`__"
msgstr ""

#: 
msgid "Inspecting available `DE Africa products and measurements <02_Products_and_measurements.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; loading data`, :index:`loading data; beginner's guide`, :index:`data used; landsat 8 geomedian`, :index:`data used; WOfS`, :index:`data methods; resampling` :index:`data methods; reprojecting`, :index:`data attributes; coordinate reference system`"
msgstr ""

#: 
msgid "Loading data from the `Digital Earth Africa (DE Africa) <https://www.digitalearthafrica.org/>`__ instance of the `Open Data Cube <https://www.opendatacube.org/>`__ requires the construction of a data query that specifies the what, where, and when of the data request. Each query returns a `multi-dimensional xarray object <http://xarray.pydata.org/en/stable/>`__ containing the contents of your query. It is essential to understand the ``xarray`` data structures as they are fundamental to the structure of data loaded from the datacube. Manipulations, transformations and visualisation of ``xarray`` objects provide datacube users with the ability to explore and analyse DE Africa datasets, as well as pose and answer scientific questions."
msgstr ""

#: 
msgid "This notebook will introduce how to load data from the Digital Earth Africa datacube through the construction of a query and use of the ``dc.load()`` function. Topics covered include:"
msgstr ""

#: 
msgid "Loading data using ``dc.load()``"
msgstr ""

#: 
msgid "Interpreting the resulting ``xarray.Dataset`` object"
msgstr ""

#: 
msgid "Inspecting an individual ``xarray.DataArray``"
msgstr ""

#: 
msgid "Customising parameters passed to the ``dc.load()`` function"
msgstr ""

#: 
msgid "Loading specific measurements"
msgstr ""

#: 
msgid "Loading data for coordinates in a custom coordinate reference system (CRS)"
msgstr ""

#: 
msgid "Projecting data to a new CRS and spatial resolution"
msgstr ""

#: 
msgid "Specifying a specific spatial resampling method"
msgstr ""

#: 
msgid "Loading data using a reusable dictionary query"
msgstr ""

#: 
msgid "Loading matching data from multiple products using ``like``"
msgstr ""

#: 
msgid "Adding a progress bar to the data load"
msgstr ""

#: 
msgid "To run this introduction to loading data from DE Africa, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "First we need to load the ``datacube`` package. This will allow us to query the datacube database and load some data. The ``with_ui_cbk`` function from ``odc.ui`` will allow us to show a progress bar when loading large amounts of data."
msgstr ""

#: 
msgid "We then need to connect to the datacube database. We will then be able to use the ``dc`` datacube object to load data. The ``app`` parameter is a unique name used to identify the notebook that does not have any effect on the analysis."
msgstr ""

#: 
msgid "Loading data from the datacube uses the `dc.load() <https://datacube-core.readthedocs.io/en/latest/api/indexed-data/generate/datacube.Datacube.load.html>`__ function."
msgstr ""

#: 
msgid "The function requires the following minimum arguments:"
msgstr ""

#: 
msgid "``product``: A specific product to load (to revise DE Africa products, see the `Products and measurements <02_Products_and_measurements.ipynb>`__ notebook)."
msgstr ""

#: 
msgid "``x``: Defines the spatial region in the *x* dimension. By default, the *x* and *y* arguments accept queries in a geographical co-ordinate system WGS84, identified by the EPSG code *4326*."
msgstr ""

#: 
msgid "``y``: Defines the spatial region in the *y* dimension. The dimensions ``longitude``/``latitude`` and ``x``/``y`` can be used interchangeably."
msgstr ""

#: 
msgid "``time``: Defines the temporal extent. The time dimension can be specified using a tuple of datetime objects or strings in the \"YYYY\", \"YYYY-MM\" or \"YYYY-MM-DD\" format."
msgstr ""

#: 
msgid "An optional arguement which provides ease of use and ease of identification of the measurements to load is:"
msgstr ""

#: 
msgid "``measurements:`` This argument is used to provide a list of measurement names to load, as listed in ``dc.list_measurements()``. For satellite datasets, measurements contain data for each individual satellite band (e.g. near infrared). If not provided, all measurements for the product will be returned, and they will have the default names from the satellite data."
msgstr ""

#: 
msgid "Let's run a query to load 2018 data from the `Sentinel 2 annual geomedian product <https://explorer.digitalearth.africa/gm_s2_annual>`__ for part of Nxai Pan National park in Botswana. For this example, we can use the following parameters:"
msgstr ""

#: 
msgid "``product``: ``gm_s2_annual``"
msgstr ""

#: 
msgid "``x``: ``(24.60, 24.80)``"
msgstr ""

#: 
msgid "``y``: ``(-20.05, -20.25)``"
msgstr ""

#: 
msgid "``time``: ``(\"2018-01-01\", \"2018-12-31\")``"
msgstr ""

#: 
msgid "``measurements``: ``['blue', 'green', 'red', 'nir', 'swir_1', 'swir_2', 'emad', 'bcmad', 'smad', 'red_edge_1']``"
msgstr ""

#: 
msgid "Run the following cell to load all datasets from the ``gm_s2_annual`` product that match this spatial and temporal extent:"
msgstr ""

#: 
msgid "Interpreting the resulting ``xarray.Dataset``"
msgstr ""

#: 
msgid "The variable ``ds`` has returned an ``xarray.Dataset`` containing all data that matched the spatial and temporal query parameters inputted into ``dc.load``."
msgstr ""

#: 
msgid "*Dimensions*"
msgstr ""

#: 
msgid "Identifies the number of timesteps returned in the search (``time: 1``) as well as the number of pixels in the ``x`` and ``y`` directions of the data query."
msgstr ""

#: 
msgid "*Coordinates*"
msgstr ""

#: 
msgid "``time`` identifies the date attributed to each returned timestep."
msgstr ""

#: 
msgid "``x`` and ``y`` are the coordinates for each pixel within the spatial bounds of your query."
msgstr ""

#: 
msgid "*Data variables*"
msgstr ""

#: 
msgid "These are the measurements available for the nominated product. For every date (``time``) returned by the query, the measured value at each pixel (``y``, ``x``) is returned as an array for each measurement. Each data variable is itself an ``xarray.DataArray`` object (`see below <#Inspecting-an-individual-xarray.DataArray>`__)."
msgstr ""

#: 
msgid "*Attributes*"
msgstr ""

#: 
msgid "``crs`` identifies the coordinate reference system (CRS) of the loaded data."
msgstr ""

#: 
msgid "The ``xarray.Dataset`` we loaded above is itself a collection of individual ``xarray.DataArray`` objects that hold the actual data for each data variable/measurement. For example, all measurements listed under *Data variables* above (e.g. ``blue``, ``green``, ``red``, ``nir``, ``swir_1``, ``swir_2``) are ``xarray.DataArray`` objects."
msgstr ""

#: 
msgid "We can inspect the data in these ``xarray.DataArray`` objects using either of the following syntaxes:"
msgstr ""

#: 
msgid "or:"
msgstr ""

#: 
msgid "Being able to access data from individual data variables/measurements allows us to manipulate and analyse data from individual satellite bands or specific layers in a dataset. For example, we can access data from the near infra-red satellite band (i.e. ``nir``):"
msgstr ""

#: 
msgid "Note that the object header informs us that it is an ``xarray.DataArray`` containing data for the ``nir`` satellite band."
msgstr ""

#: 
msgid "Like an ``xarray.Dataset``, the array also includes information about the data's **dimensions** (i.e. ``(time: 1, y: 801, x: 644)``), **coordinates** and **attributes**. This particular data variable/measurement contains some additional information that is specific to the ``nir`` band, including details of array's nodata value (i.e. ``nodata: -999``)."
msgstr ""

#: 
msgid "**Note**: For a more in-depth introduction to ``xarray`` data structures, refer to the `official xarray documentation <http://xarray.pydata.org/en/stable/data-structures.html>`__"
msgstr ""

#: 
msgid "Customising the ``dc.load()`` function"
msgstr ""

#: 
msgid "The ``dc.load()`` function can be tailored to refine a query."
msgstr ""

#: 
msgid "Customisation options include:"
msgstr ""

#: 
msgid "``measurements:`` This argument is used to provide a list of measurement names to load, as listed in ``dc.list_measurements()``. For satellite datasets, measurements contain data for each individual satellite band (e.g. near infrared). If not provided, all measurements for the product will be returned."
msgstr ""

#: 
msgid "``crs:`` The coordinate reference system (CRS) of the query's ``x`` and ``y`` coordinates is assumed to be ``WGS84``/``EPSG:4326`` unless the ``crs`` field is supplied, even if the stored data is in another projection or the ``output_crs`` is specified. The ``crs`` parameter is required if your query's coordinates are in any other CRS."
msgstr ""

#: 
msgid "``group_by:`` Satellite datasets based around scenes can have multiple observations per day with slightly different time stamps as the satellite collects data along its path. These observations can be combined by reducing the ``time`` dimension to the day level using ``group_by=solar_day``."
msgstr ""

#: 
msgid "``output_crs`` and ``resolution``: To reproject or change the resolution the data, supply the ``output_crs`` and ``resolution`` fields."
msgstr ""

#: 
msgid "``resampling``: This argument allows you to specify a custom spatial resampling method to use when data is reprojected into a different CRS."
msgstr ""

#: 
msgid "Example syntax on the use of these options follows in the cells below."
msgstr ""

#: 
msgid "For help or more customisation options, run ``help(dc.load)`` in an empty cell or visit the function's `documentation page <https://datacube-core.readthedocs.io/en/latest/api/indexed-data/generate/datacube.Datacube.load.html>`__"
msgstr ""

#: 
msgid "Specifying measurements"
msgstr ""

#: 
msgid "By default, ``dc.load()`` will load *all* measurements in a product."
msgstr ""

#: 
msgid "To load data from the ``red``, ``green`` and ``blue`` satellite bands only, we can add ``measurements=[\"red\", \"green\", \"blue\"]`` to our query:"
msgstr ""

#: 
msgid "Note that the *Data variables* component of the ``xarray.Dataset`` now includes only the measurements specified in the query (i.e. the ``red``, ``green`` and ``blue`` satellite bands)."
msgstr ""

#: 
msgid "Loading data for coordinates in any CRS"
msgstr ""

#: 
msgid "By default, ``dc.load()`` assumes that your query ``x`` and ``y`` coordinates are provided in degrees in the ``WGS84/EPSG:4326`` CRS. If your coordinates are in a different coordinate system, you need to specify this using the ``crs`` parameter."
msgstr ""

#: 
msgid "In the example below, we load data for a set of ``x`` and ``y`` coordinates defined in Africa Albers Equal Area Conic (``EPSG:6933``), and ensure that the ``dc.load()`` function accounts for this by including ``crs=\"EPSG:6933\"``:"
msgstr ""

#: 
msgid "CRS reprojection"
msgstr ""

#: 
msgid "Certain applications may require that you output your data into a specific CRS. You can reproject your output data by specifying the new ``output_crs`` and identifying the ``resolution`` required."
msgstr ""

#: 
msgid "In this example, we will reproject our data to a new CRS (UTM Zone 34S, ``EPSG:32734``) and resolution (250 x 250 m). Note that for most CRSs, the first resolution value is negative (e.g. ``(-250, 250)``):"
msgstr ""

#: 
msgid "Note that the ``crs`` attribute in the *Attributes* section has changed to ``EPSG:32734``. Due to the larger 250 m resolution, there are also now less pixels on the ``x`` and ``y`` dimensions (e.g. ``x: 87, y: 91`` compared to ``x: 1930, y: 2100`` in earlier examples)."
msgstr ""

#: 
msgid "Spatial resampling methods"
msgstr ""

#: 
msgid "When a product is re-projected to a different CRS and/or resolution, the new pixel grid may differ from the original input pixels by size, number and alignment. It is therefore necessary to apply a spatial \"resampling\" rule that allocates input pixel values into the new pixel grid."
msgstr ""

#: 
msgid "By default, ``dc.load()`` resamples pixel values using \"nearest neighbour\" resampling, which allocates each new pixel with the value of the closest input pixel. Depending on the type of data and the analysis being run, this may not be the most appropriate choice (e.g. for continuous data)."
msgstr ""

#: 
msgid "The ``resampling`` parameter in ``dc.load()`` allows you to choose a custom resampling method from the following options:"
msgstr ""

#: 
msgid "For example, we can request that all loaded data is resampled using \"average\" resampling:"
msgstr ""

#: 
msgid "You can also provide a Python dictionary to request a different sampling method for different measurements. This can be particularly useful when some measurements contain contain categorical data which require resampling methods such as \"nearest\" or \"mode\" that do not modify the input pixel values."
msgstr ""

#: 
msgid "In the example below, we specify ``resampling={\"red\": \"nearest\", \"*\": \"average\"}``, which will use \"nearest\" neighbour resampling for the ``red`` satellite band only. ``\"*\": \"average\"`` will apply \"average\" resampling for all other satellite bands:"
msgstr ""

#: 
msgid "**Note**: For more information about spatial resampling methods, see the `following guide <https://rasterio.readthedocs.io/en/stable/topics/resampling.html>`__"
msgstr ""

#: 
msgid "Loading data using the query dictionary syntax"
msgstr ""

#: 
msgid "It is often useful to re-use a set of query parameters to load data from multiple products. To achieve this, we can load data using the \"query dictionary\" syntax. This involves placing the query parameters we used to load data above inside a Python dictionary object which we can re-use for multiple data loads:"
msgstr ""

#: 
msgid "We can then use this query dictionary object as an input to ``dc.load()``."
msgstr ""

#: 
msgid "The ``**`` syntax below is Python's \"keyword argument unpacking\" operator. This operator takes the named query parameters listed in the dictionary we created (e.g. ``\"x\": (153.3, 153.4)``), and \"unpacks\" them into the ``dc.load()`` function as new arguments. For more information about unpacking operators, refer to the `Python documentation <https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists>`__"
msgstr ""

#: 
msgid "Query dictionaries can contain any set of parameters that would usually be provided to ``dc.load()``:"
msgstr ""

#: 
msgid "Now we have a reusable query, we can easily use it to load data from a different product. For example, we can load Water Observations from Space (WOfS) Annual Summary data for the same extent, time, output CRS and resolution that we just loaded Landsat 8 Geomedian data for:"
msgstr ""

#: 
msgid "Other helpful tricks"
msgstr ""

#: 
msgid "Loading data \"like\" another dataset"
msgstr ""

#: 
msgid "Another option for loading matching data from multiple products is to use ``dc.load()``'s ``like`` parameter. This will copy the spatial and temporal extent and the CRS/resolution from an existing dataset, and use these parameters to load a new data from a new product."
msgstr ""

#: 
msgid "In the example below, we load another WOfS dataset that exactly matches the ``ds_s2`` dataset we loaded earlier:"
msgstr ""

#: 
msgid "Adding a progress bar"
msgstr ""

#: 
msgid "When loading large amounts of data, it can be useful to view the progress of the data load. The ``progress_cbk`` parameter in ``dc.load()`` allows us to add a progress bar which will indicate how the load is progressing. In this example, we will load 5 years of data (2013, 2014, 2015, 2016 and 2017) from the ``ga_ls8c_wofs_2_annual_summary`` product with a progress bar:"
msgstr ""

#: 
msgid "**Loading data (this notebook)**"
msgstr ""

#: 
msgid "Introduction to plotting"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__"
msgstr ""

#: 
msgid "How to `load data from DE Africa <03_Loading_data.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; visualisation`, :index:`visualisation; beginner's guide`, :index:`data used; landsat 8`, :index:`visualisation; measurements`, :index:`visualisation; timesteps`, :index:`visualisation; colour maps`, :index:`python package; matplotlib`"
msgstr ""

#: 
msgid "Data visualisation is an important component of working with Earth Observation data. The ``xarray`` Python package provides a range of straightforward data plotting options which allow users to quickly generate simple plots from multi-dimensional datasets. To generate more complex and informative plots from data loaded from Digital Earth Africa (DE Africa), the DE Africa Notebooks repository also provides a custom plotting module with additional easy-to-use functionality."
msgstr ""

#: 
msgid "This introductory notebook demonstrates how to visualise Digital Earth Africa satellite data returned from running a datacube query. The notebook demonstrates commonly-used ``xarray`` plotting methods, as well as custom functions provided in ``deafrica_tools.plotting``."
msgstr ""

#: 
msgid "Topics covered in this notebook include:"
msgstr ""

#: 
msgid "View your area of interest prior to querying the datacube"
msgstr ""

#: 
msgid "Querying the datacube and loading data"
msgstr ""

#: 
msgid "Plotting single band data (e.g. a single satellite band)"
msgstr ""

#: 
msgid "Selecting and plotting individual timesteps"
msgstr ""

#: 
msgid "Plotting multiple timesteps"
msgstr ""

#: 
msgid "Customising plot appearance"
msgstr ""

#: 
msgid "Plotting three-band true or false colour imagery"
msgstr ""

#: 
msgid "Plotting single timesteps"
msgstr ""

#: 
msgid "To run this introduction to plotting data loaded from the datacube, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "First we run ``%matplotlib inline``, which ensures figures plot correctly in the Jupyter notebook."
msgstr ""

#: 
msgid "We then need to load the ``datacube`` package, which allows us to load data."
msgstr ""

#: 
msgid "Plotting the data requires functions which we can import from ``deafrica_tools.plotting``. For this notebook, we need ``rgb`` and ``display_map``. We can import both in one line by separating the names with a comma."
msgstr ""

#: 
msgid "We then connect to the datacube database so we can load DE Africa data."
msgstr ""

#: 
msgid "Analysis parameters"
msgstr ""

#: 
msgid "The following variables are required to establish a query for this notebook: - ``lat_range``: The latitude range to analyse (e.g. ``(11.72, 11.52)``). For reasonable load times, keep this to a range of ~0.1 degrees or less. - ``lon_range``: The longitude range to analyse (e.g. ``(-15.63, -15.43)``). For reasonable load times, keep this to a range of ~0.1 degrees or less. - ``time_range``: The date range to analyse (e.g. ``(\"2018-01-01\", \"2018-03-30\")``)."
msgstr ""

#: 
msgid "View the queried location"
msgstr ""

#: 
msgid "Before running a query and extracting and analysing data, it is useful to double-check that your location is correct. The ``display_map()`` function shows your selected area as a red rectangle on an interactive map. Clicking on any point of the map will reveal the latitude and longitude coordinates of that point."
msgstr ""

#: 
msgid "Query and view data"
msgstr ""

#: 
msgid "The variables determined above are used here to query the DE Africa datacube using the ``dc.load()`` function and load data introduced in the `Loading data notebook <03_Loading_data.ipynb>`__. This notebook uses Landsat 8 Surface reflectance ``ls8_sr``."
msgstr ""

#: 
msgid "Plotting single band images"
msgstr ""

#: 
msgid "The ``xarray`` package provides built-in methods for plotting individual data variables or measurements. For example, we might want to make a plot for a single measurement like the ``swir_1`` satellite band in the data we loaded above."
msgstr ""

#: 
msgid "To do this, we first need to access the band we are after as an ``xarray.DataArray`` (to revise the difference between ``xarray.Dataset`` and ``xarray.DataArray`` objects, refer back to the `Loading data <03_Loading_data.ipynb>`__ notebook):"
msgstr ""

#: 
msgid "Selecting and plotting a single timestep"
msgstr ""

#: 
msgid "You can see in the object header that this ``xarray.DataArray`` has data for six timesteps (i.e. ``<xarray.DataArray 'swir_1' (time: 6, y: 834, x: 644)>``). To make a plot for a single timestep only, we need to select it using one of the following options:"
msgstr ""

#: 
msgid "``.isel()``: This stands for \"index selection\", and lets us easily select individual timesteps from a dataset by providing the number of the observation we want. Counting in Python begins at 0, so to select the first timestep in the ``xarray.DataArray`` we can specify ``.isel(time=0)``:"
msgstr ""

#: 
msgid "``.sel()``: This allows us to select data using real-world coordinate labels like ``time``. For example, from the *Coordinates* section, we can select the first timestep (i.e. The observation for January 6th 2017) from the ``xarray.DataArray`` by specifying ``.sel(time='2017-01-06')``:"
msgstr ""

#: 
msgid "We can now use the ``.plot()`` method to plot ``swir1`` data for our selected timestep:"
msgstr ""

#: 
msgid "It is often useful to produce plots for a single measurement across time, for example to compare change between satellite observations or summary datasets. To plot multiple images, we can skip the ``isel()`` step above and plot the entire ``xarray.DataArray`` directly."
msgstr ""

#: 
msgid "To plot multiple timesteps in one figure, we need to tell the ``.plot()`` function to put each timestep in a different column. We can do this by specifying ``.plot(col=\"time\")``:"
msgstr ""

#: 
msgid "**Note**: This kind of plotting is called \"facetted plotting\". For more information, refer to the `xarray documentation <http://xarray.pydata.org/en/stable/plotting.html#faceting>`__"
msgstr ""

#: 
msgid "You may notice that the plots above are dark and difficult to see clearly. To improve the appearance of ``xarray`` plots, you can use the ``robust=True`` argument to optimise the plot colours by clipping extreme values or outliers. This will use the 2nd and 98th percentiles of the data to compute the color limits:"
msgstr ""

#: 
msgid "We can also easily use custom colour maps/styles to visualise our data using the ``cmap`` parameter."
msgstr ""

#: 
msgid "When choosing a colour map for a plot, it is important to choose a set of colours that are perceived logically by the human eye. The best colour maps are \"perceptually uniform\": these colour maps increase logically from dark to light colours, where equal increases in lightness/darkness correspond to equal changes in data values. Some best-practice perceptually uniform colour maps include:"
msgstr ""

#: 
msgid "**Note**: For further reading about perceptually uniform colour maps in data visualisation, refer to the `matplotlib documentation <https://matplotlib.org/stable/tutorials/colors/colormaps.html>`__."
msgstr ""

#: 
msgid "It is also important to consider colour blindness when selecting a colour map. ``xarray`` supports many colour maps from the \"colorbrewer\" family of colour maps which are optimised for colour blindness. You can use the interactive `online tool <http://colorbrewer2.org>`__ to browse all available colour maps, or choose from one of the following commonly used options:"
msgstr ""

#: 
msgid "For a full list of available colour maps you can refer to `this list <https://matplotlib.org/stable/tutorials/colors/colormaps.html>`__."
msgstr ""

#: 
msgid "For example, to plot our data with the perceptually uniform ``magma`` colour map:"
msgstr ""

#: 
msgid "Plotting true or false colour RGB images"
msgstr ""

#: 
msgid "Although ``xarray`` makes it easy to plot single band images, plotting a three band colour photo-like image is less straightforward."
msgstr ""

#: 
msgid "To make this easier, the ``deafrica-sandbox-notebooks`` repository provides a custom ``rgb()`` function that is designed for plotting three band images. The ``rgb()`` function maps three data variables/measurements from the loaded dataset to the red, green and blue channels that are used to make a three-colour image."
msgstr ""

#: 
msgid "Providing the ``red``, ``green`` and ``blue`` measurements from a dataset will produce a true colour image (akin to how humans view the landscape). Providing ``nir``, ``red`` and ``green`` measurements or any other set of three satellite bands from a dataset will produce a false colour image. You can learn more about colour rendering `here <https://en.wikipedia.org/wiki/False_color#True_color>`__."
msgstr ""

#: 
msgid "Hence, the ``rgb()`` function can be used to visualise the data returned by a query. It requires the minimum input of:"
msgstr ""

#: 
msgid "``ds:`` The ``xarray.Dataset`` object"
msgstr ""

#: 
msgid "``bands:`` Three bands for display (these must be measurements found in the dataset)"
msgstr ""

#: 
msgid "``index:`` The timestep to view, default is ``0``"
msgstr ""

#: 
msgid "Plotting a single timestep"
msgstr ""

#: 
msgid "The time dimension of your ``xarray.Dataset`` describes how many timesteps exist for your location during your nominated time period. In the ``rgb()`` function, the ``index`` variable is asking for which timestep you want to view (similar to the ``isel()`` example above). Remember: counting in Python begins at 0 so to view the earliest timestep set ``index=0``:"
msgstr ""

#: 
msgid "By changing the input bands, we can plot a false colour image which can provide different insights in a landscape. This band combination (``swir_1``, ``nir``, ``green``) emphasises growing vegetation in green, and water in deep blue:"
msgstr ""

#: 
msgid "As discussed in the `single band example above <#Plotting-multiple-timesteps>`__, it can be useful to visualise multiple timesteps in a single plot (e.g. to compare change over time)."
msgstr ""

#: 
msgid "The ``rgb()`` function allows you to do this by providing a list of multiple images to plot using ``index=[X, X, ...]``. For example, we can plot the first and fifth image in our dataset using ``index=[0, 4]`` (remembering that counting in Python starts at 0):"
msgstr ""

#: 
msgid "It is also possible to use ``rgb()`` to plot all timesteps in a dataset using the ``col=\"time\"`` syntax we demonstrate in the `single band example above <#Plotting-multiple-timesteps>`__:"
msgstr ""

#: 
msgid "By default, ``rgb()`` generates plots with ``robust=True`` to improve the appearance of the images by clipping out the darkest and brightest 2% of pixels, using the 2nd and 98th percentiles of the data to compute the color limits."
msgstr ""

#: 
msgid "If this default provides poor results, the plot's colour stretch can be customised using the ``percentile_stretch`` parameter. This allows you to clip the most extreme minimum and maximum values in the dataset, to improve the contrast and appearance of the plot."
msgstr ""

#: 
msgid "For example, specifying ``percentile_stretch=[0.05, 0.95]`` will clip out the darkest and brightest 5% of pixels, focusing the colour stretch on the remaining 90% of less extreme values:"
msgstr ""

#: 
msgid "`Loading data (this notebook) <03_Loading_data.ipynb>`__"
msgstr ""

#: 
msgid "**Plotting (this notebook)**"
msgstr ""

#: 
msgid "Once you have you have completed the above tutorials, join advanced users in exploring:"
msgstr ""

#: 
msgid "Performing a basic analysis"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__"
msgstr ""

#: 
msgid "**Prerequisites**: Users of this notebook should have a basic understanding of:"
msgstr ""

#: 
msgid "How to `plot loaded data <04_Plotting.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`beginner's guide; analysis`, :index:`analysis; beginner's guide`, :index:`data used; landsat 8`, :index:`band index; NDVI`, :index:`data methods; exporting`"
msgstr ""

#: 
msgid "To understand the world around us, it's important to combine the key steps of loading, visualising, analysing, and interpreting satellite data. To perform an analysis, we begin with a question and use these steps to reach an answer."
msgstr ""

#: 
msgid "This notebook demonstrates how to conduct a basic analysis with DE Africa data and the Open Data Cube. It will combine many of the steps that have been covered in the other beginner's notebooks."
msgstr ""

#: 
msgid "In this notebook, the analysis question is *\"How is the health of vegetation changing over time in a given area?\"*"
msgstr ""

#: 
msgid "This could be related to a number of broader questions:"
msgstr ""

#: 
msgid "What is the effect of a new land use practice on a field of crops?"
msgstr ""

#: 
msgid "How has a patch of forest changed after a fire?"
msgstr ""

#: 
msgid "How does proximity to water affect vegetation throughout the year?"
msgstr ""

#: 
msgid "For this notebook, the analysis question will be kept simple, without much real-world context. For more examples of notebooks that demonstrate how to use DE Africa to answer specific analysis questions, see the notebooks in the \"Real world examples\" folder."
msgstr ""

#: 
msgid "Choosing a study area."
msgstr ""

#: 
msgid "Loading data for the study area."
msgstr ""

#: 
msgid "Plotting the chosen data and exploring how it changes with time."
msgstr ""

#: 
msgid "Calculating a measure of vegetation health from the loaded data."
msgstr ""

#: 
msgid "Exporting the data for further analysis."
msgstr ""

#: 
msgid "To run this introduction to performing basic analysis with DE Africa data and the datacube, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "The cell below imports Python packages that are used for the analysis. The first command is ``%matplotlib inline``, which ensures figures plot correctly in the Jupyter notebook. The following commands import various functionality:"
msgstr ""

#: 
msgid "``deafrica_tools`` contains helpful support functions, including those in the ``deafrica_plotting`` module which we are using in this notebook."
msgstr ""

#: 
msgid "``datacube`` provides the ability to query and load data."
msgstr ""

#: 
msgid "``matplotlib`` provides the ability to format and manipulate plots."
msgstr ""

#: 
msgid "The next step is to connect to the datacube database. The resulting ``dc`` datacube object can then be used to load data. The ``app`` parameter is a unique name used to identify the notebook that does not have any effect on the analysis."
msgstr ""

#: 
msgid "Step 1: Choose a study area"
msgstr ""

#: 
msgid "When working with the Open Data Cube, it's important to load only as much data as needed. This helps keep an analysis running quickly and avoids the notebook crashing due to insufficient memory."
msgstr ""

#: 
msgid "One way to set the study area is to set a central latitude and longitude coordinate pair, ``(central_lat, central_lon)``, then specify how many degrees to include either side of the central latitude and longitude, known as the ``buffer``. Together, these parameters specify a square study area, as shown below:"
msgstr ""

#: 
msgid "Location"
msgstr ""

#: 
msgid "Below, we have set the study area covering an agricultural area in South Africa. To load a different area, you can provide your own ``central_lat`` and ``central_lon`` values. One way to source these is to Google a location, or click directly on the map in `Google Maps <https://www.google.com/maps/place/21%C2%B007'25.4%22N+11%C2%B023'51.1%22W/@21.0925851,-11.555448,82035m/data=!3m1!1e3!4m14!1m7!3m6!1s0x10a06c0a948cf5d5:0x108270c99e90f0b3!2sAfrica!3b1!8m2!3d-8.783195!4d34.508523!3m5!1s0x0:0x0!7e2!8m2!3d21.1237127!4d-11.3975263>`__. Other options are:"
msgstr ""

#: 
msgid "**Mount Kenya, Kenya**"
msgstr ""

#: 
msgid "**Bobiri Forest Reserve, Ghana**"
msgstr ""

#: 
msgid "**Note**: If you change the study area latitude and longitude, you'll need to re-run all of the cells after to apply that change to the whole analysis."
msgstr ""

#: 
msgid "Buffer"
msgstr ""

#: 
msgid "Feel free to experiment with the ``buffer`` value to load different sized areas. We recommend that you keep the ``buffer`` relatively small, no higher than ``buffer=0.1`` degrees. This will help keep the loading times reasonable and prevent the notebook from crashing."
msgstr ""

#: 
msgid "**Extension**: Can you modify the code to use a different ``buffer`` value for latitude and longitude?"
msgstr ""

#: 
msgid "*Hint*: You may want two variables, ``buffer_lat`` and ``buffer_lon`` that you can set independently. You'll then need to update the definitions of ``study_area_lat`` and ``study_area_lon`` with their corresponding buffer value."
msgstr ""

#: 
msgid "After choosing the study area, it can be useful to visualise it on an interactive map. This provides a sense of scale. > **Note**: The interactive map also returns latitude and longitude values when clicked. You can use this to generate new latitude and longitude values to try without leaving the notebook."
msgstr ""

#: 
msgid "Step 2: Loading data"
msgstr ""

#: 
msgid "When asking analysis questions about vegetation, it's useful to work with optical imagery, such as Sentinel-2 or Landsat. The Sentinel-2 satellites have 10 metre resolution and go back to 2017."
msgstr ""

#: 
msgid "The code below sets up the required information to load the data."
msgstr ""

#: 
msgid "After setting all of the necessary parameters, the ``dc.load()`` command is used to load the data:"
msgstr ""

#: 
msgid "Following the load step, printing the ``dataset`` object will give you insight into all of the data that was loaded. Do this by running the next cell."
msgstr ""

#: 
msgid "There's a lot of information to unpack, which is represented by the following aspects of the data: - ``Dimensions``: the names of data dimensions, frequently ``time``, ``x`` and ``y``, and number of entries in each - ``Coordinates``: the coordinate values for each point in the data cube - ``Data variables``: the observations loaded, frequently different spectral bands from a satellite - ``Attributes``: any useful information for the data, such as the ``crs`` (coordinate reference system)"
msgstr ""

#: 
msgid "Step 3: Plotting data"
msgstr ""

#: 
msgid "After loading the data, it is useful to view it to understand the resolution, which observations are impacted by cloud cover, and whether there are any obvious differences between time steps."
msgstr ""

#: 
msgid "We use the ``rgb()`` function to plot the data loaded in the previous step. The ``rgb()`` function maps three data variables/measurements from the loaded dataset to the red, green and blue channels that are used to make a three-colour image. There are several parameters you can experiment with:"
msgstr ""

#: 
msgid "``time_step=n``"
msgstr ""

#: 
msgid "This sets the time step you want to view. ``n`` can be any number from ``0`` to one fewer than the number of time steps you loaded. The number of time steps loaded is given in the print-out of the data, under the ``Dimensions`` heading. As an example, if under ``Dimensions:`` you see ``time: 6``, then there are 6 time steps, and ``time_step`` can be any number between ``0`` and ``5``."
msgstr ""

#: 
msgid "``bands=[red_channel, green_channel, blue_channel]`` This sets the measurements that you want to use to make the image. Any measurements can be mapped to the three channels, and different combinations highlight different features. Two common combinations are"
msgstr ""

#: 
msgid "true colour: ``bands = [\"red\", \"green\", \"blue\"]``"
msgstr ""

#: 
msgid "false colour: ``bands = [\"nir\", \"red\", \"green\"]``"
msgstr ""

#: 
msgid "For more detail about customising plots, see the `Introduction to plotting <04_Plotting.ipynb>`__ notebook."
msgstr ""

#: 
msgid "**Extension**: If ``time_step`` is set to an array of values, e.g. ``time_step=[time_1, time_2]``, it will plot all provided time steps. See if you can modify the code to plot the first and last images. If you do, what changes do you notice?"
msgstr ""

#: 
msgid "*Hint*: To get the last image, you can use a time step value of ``-1``"
msgstr ""

#: 
msgid "Step 4: Calculate vegetation health"
msgstr ""

#: 
msgid "While it's possible to identify vegetation in the RGB image, it can be helpful to have a quantitative index to describe the health of vegetation directly."
msgstr ""

#: 
msgid "In this case, the `Normalised Difference Vegetation Index <https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index>`__ (NDVI) can help identify areas of healthy vegetation. For remote sensing data such as satellite imagery, it is defined as"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDVI} & = \\frac{(\\text{NIR} - \\text{Red})}{(\\text{NIR} + \\text{Red})}, \\\\\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "where :math:`\\text{NIR}` is the near-infrared band of the data, and :math:`\\text{Red}` is the red band. NDVI can take on values from -1 to 1; high values indicate healthy vegetation and negative values indicate non-vegetation (such as water)."
msgstr ""

#: 
msgid "The following code calculates the top and bottom of the fraction separately, then computes the NDVI value directly from these components. The calculated NDVI values are stored as their own data array."
msgstr ""

#: 
msgid "Note: Before we calculate NDVI, we need to convert the data type to ``float32``, this will convert the nodata values in the original ``uint16`` dataset to ``NaN``, and therefore ignore those values in the NDVI calculation."
msgstr ""

#: 
msgid "After calculating the NDVI values, it is possible to plot them by adding the ``.plot()`` method to ``ndvi`` (the variable that the values are stored in). The code below will plot a single image, based on the time selected with the ``ndvi_time_step`` variable. Try changing this value to plot the NDVI map at different time steps. Do you notice any differences?"
msgstr ""

#: 
msgid "**Extension 1**: Sometimes, it is valuable to change the colour scale to something that helps with intuitively understanding the image. For example, the \"viridis\" colour map shows high values in greens/yellows (mapping to vegetation), and low values in blue (mapping to water). Try modifying the ``.plot(cmap=\"RdYlGn\")`` command below to use ``cmap=\"viridis\"`` instead."
msgstr ""

#: 
msgid "**Extension 2**: For the cell above, a single time step was selected using the ``.isel()`` method. It is possible to plot all time steps by removing the ``.isel()`` method, and modifying the ``.plot()`` method to be ``.plot(col='time', col_wrap=3)`` where ``time`` is the timesteps for the images. Plotting all of the time steps at once may make it easier to notice differences in vegetation over time."
msgstr ""

#: 
msgid "Step 5: Exporting data"
msgstr ""

#: 
msgid "Sometimes, you will want to analyse satellite imagery in a GIS program, such as QGIS. The ``write_cog()`` command from the Open Data Cube library allows loaded data to be exported to GeoTIFF, a commonly used file format for geospatial data. This example export an image based on the time_step provided. for more information on exporting multiple images check `Exporting GeoTIFFS notebook <../Frequently_used_code/Exporting_GeoTIFFs.ipynb>`__ > **Note**: the saved file will appear in the same directory as this notebook, and it can be downloaded from here for later use."
msgstr ""

#: 
msgid "For this notebook"
msgstr ""

#: 
msgid "Many of the variables used in this analysis are configurable. We recommend returning to the beginning of the notebook and re-running the analysis with a different location, dates, measurements, and so on. This will help give you more understanding for running your own analysis. If you didn't try the extension activities the first time, try and work on these when you run through the notebook again."
msgstr ""

#: 
msgid "For other notebooks"
msgstr ""

#: 
msgid "This is the fifth notebook in the beginner's guide; if anything was unclear, we recommend revising the relevant notebook:"
msgstr ""

#: 
msgid "**Performing a basic analysis (this notebook)**"
msgstr ""

#: 
msgid "Once you have completed the above tutorials, join advanced users in exploring:"
msgstr ""

#: 
msgid "Introduction to Numpy"
msgstr ""

#: 
msgid "How to run a `Jupyter notebook <01_jupyter_notebooks.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; numpy`, :index:`python package; numpy`, :index:`python package; matplotlib`"
msgstr ""

#: 
msgid "Numpy is a Python library which adds support for large, multi-dimension arrays and metrics, along with a large collection of high-level mathematical functions to operate on these arrays. More information about Numpy arrays can be found `here <https://en.wikipedia.org/wiki/NumPy>`__."
msgstr ""

#: 
msgid "This notebook is designed to introduce users to Numpy arrays of using Python code in Jupyter Notebooks via JupyterLab."
msgstr ""

#: 
msgid "How to use Numpy functions in a Jupyter Notebook cell"
msgstr ""

#: 
msgid "Using indexing to explore multi-dimensional Numpy array data"
msgstr ""

#: 
msgid "Numpy data types, broadcasting and booleans"
msgstr ""

#: 
msgid "Using Matplotlib to plot Numpy data"
msgstr ""

#: 
msgid "To run this notebook, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "In order to be able to use numpy we need to import the library using the special word ``import``. Also, to avoid typing ``numpy`` every time we want to use one if its functions we can provide an alias using the special word ``as``:"
msgstr ""

#: 
msgid "Now, we have access to all the functions available in ``numpy`` by typing ``np.name_of_function``. For example, the equivalent of ``1 + 1`` in Python can be done in ``numpy``:"
msgstr ""

#: 
msgid "Although this might not at first seem very useful, even simple operations like this one can be much quicker in ``numpy`` than in standard Python when using lots of numbers (large arrays)."
msgstr ""

#: 
msgid "To access the documentation explaining how a function is used, its input parameters and output format we can press ``Shift+Tab`` after the function name. Try this in the cell below"
msgstr ""

#: 
msgid "By default the result of a function or operation is shown underneath the cell containing the code. If we want to reuse this result for a later operation we can assign it to a variable:"
msgstr ""

#: 
msgid "The contents of this variable can be displayed at any moment by typing the variable name in a new cell:"
msgstr ""

#: 
msgid "Numpy arrays"
msgstr ""

#: 
msgid "The core concept in numpy is the ``array`` which is equivalent to lists of numbers but can be multidimensional. To declare a numpy array we do:"
msgstr ""

#: 
msgid "Most of the functions and operations defined in numpy can be applied to arrays. For example, with the previous operation:"
msgstr ""

#: 
msgid "But a more simple and convenient notation can also be used:"
msgstr ""

#: 
msgid "Indexing"
msgstr ""

#: 
msgid "Arrays can be sliced and diced. We can get subsets of the arrays using the indexing notation which is ``[start:end:stride]``. Let's see what this means:"
msgstr ""

#: 
msgid "Try experimenting with the indices to understand the meaning of ``start``, ``end`` and ``stride``. What happens if you don't specify a start? What value does numpy uses instead? Note that numpy indexes start on ``0``, the same convention used in Python lists."
msgstr ""

#: 
msgid "Indexes can also be negative, meaning that you start counting from the end. For example, to select the last 2 elements in an array we can do:"
msgstr ""

#: 
msgid "Multi-dimensional arrays"
msgstr ""

#: 
msgid "Numpy arrays can have multiple dimensions. For example, we define a 2-dimensional ``(1,9)`` array using nested square bracket:"
msgstr ""

#: 
msgid "drawing"
msgstr ""

#: 
msgid "To visualise the shape or dimensions of a numpy array we can add the suffix ``.shape``"
msgstr ""

#: 
msgid "Any array can be reshaped into different shapes using the function ``reshape``:"
msgstr ""

#: 
msgid "If you are concerned about having to type so many squared brackets, there are more simple and convenient ways of doing the same:"
msgstr ""

#: 
msgid "Also there are shortcuts for declaring common arrays without having to type all their elements:"
msgstr ""

#: 
msgid "Arithmetic operations"
msgstr ""

#: 
msgid "Numpy has many useful arithmetic functions. Below we demonstrate a few of these, such as mean, standard deviation and sum of the elements of an array. These operation can be performed either across the entire array, or across a specified dimension."
msgstr ""

#: 
msgid "Numpy data types"
msgstr ""

#: 
msgid "Numpy arrays can contain numerical values of different types. These types can be divided in these groups:"
msgstr ""

#: 
msgid "Integers"
msgstr ""

#: 
msgid "Unsigned"
msgstr ""

#: 
msgid "8 bits: ``uint8``"
msgstr ""

#: 
msgid "16 bits: ``uint16``"
msgstr ""

#: 
msgid "32 bits: ``uint32``"
msgstr ""

#: 
msgid "64 bits: ``uint64``"
msgstr ""

#: 
msgid "Signed"
msgstr ""

#: 
msgid "8 bits: ``int8``"
msgstr ""

#: 
msgid "16 bits: ``int16``"
msgstr ""

#: 
msgid "32 bits: ``int32``"
msgstr ""

#: 
msgid "64 bits: ``int64``"
msgstr ""

#: 
msgid "Floats"
msgstr ""

#: 
msgid "32 bits: ``float32``"
msgstr ""

#: 
msgid "64 bits: ``float64``"
msgstr ""

#: 
msgid "We can specify the type of an array when we declare it, or change the data type of an existing one with the following expressions:"
msgstr ""

#: 
msgid "Broadcasting"
msgstr ""

#: 
msgid "The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. This can make operations very fast."
msgstr ""

#: 
msgid "Booleans"
msgstr ""

#: 
msgid "There is a binary type in numpy called boolean which encodes ``True`` and ``False`` values. For example:"
msgstr ""

#: 
msgid "Boolean types are quite handy for indexing and selecting parts of images as we will see later. Many numpy functions also work with Boolean types."
msgstr ""

#: 
msgid "Introduction to Matplotlib"
msgstr ""

#: 
msgid "This second part introduces matplotlib, a Python library for plotting numpy arrays as images. For the purposes of this tutorial we are going to use a part of matplotlib called pyplot. We import it by doing:"
msgstr ""

#: 
msgid "An image can be seen as a 2-dimensional array. To visualise the contents of a numpy array:"
msgstr ""

#: 
msgid "We can use the Pyplot library to load an image using the function ``imread``:"
msgstr ""

#: 
msgid "Let's display this image using the ``imshow`` function."
msgstr ""

#: 
msgid "This is a `free stock photo <https://depositphotos.com/42725091/stock-photo-kilimanjaro.html>`__ of Mount Kilimanjaro, Tanzania. A colour image is normally composed of three layers containing the values of the red, green and blue pixels. When we display an image we see all three colours combined."
msgstr ""

#: 
msgid "Let's use the indexing functionality of numpy to select a slice of this image. For example to select the top right corner:"
msgstr ""

#: 
msgid "We can also replace values in the 'red' layer with the value 255, making the image 'reddish'. Give it a try:"
msgstr ""

#: 
msgid "**Introduction to numpy (this notebook)**"
msgstr ""

#: 
msgid "Once you have you have completed the above eight tutorials, join advanced users in exploring:"
msgstr ""

#: 
msgid "Introduction to xarray"
msgstr ""

#: 
msgid "How to work with `numpy <06_Intro_to_numpy.ipynb>`__"
msgstr ""

#: 
msgid "``Xarray`` is a python library which simplifies working with labelled multi-dimension arrays. ``Xarray`` introduces labels in the forms of dimensions, coordinates and attributes on top of raw ``numpy`` arrays, allowing for more intitutive and concise development. More information about ``xarray`` data structures and functions can be found `here <http://xarray.pydata.org/en/stable/>`__."
msgstr ""

#: 
msgid "Once you've completed this notebook, you may be interested in advancing your xarray skills further, this `external notebook <https://rabernat.github.io/research_computing/xarray.html>`__ introduces more uses of xarray and may help you advance your skills further."
msgstr ""

#: 
msgid "This notebook is designed to introduce users to ``xarray`` using Python code in Jupyter Notebooks via JupyterLab."
msgstr ""

#: 
msgid "How to use xarray functions in a Jupyter Notebook cell"
msgstr ""

#: 
msgid "How to access xarray dimensions and metadata"
msgstr ""

#: 
msgid "Using indexing to explore multi-dimensional xarray data"
msgstr ""

#: 
msgid "Appliction of built-in xarray functions such as sum, std and mean"
msgstr ""

#: 
msgid "DE Africa uses xarray as its core data model. To better understand what it is, let first do a simple experiment using a combination of plain numpy arrays and Python dictionaries."
msgstr ""

#: 
msgid "Suppose we have a satellite image with three bands: ``Red``, ``NIR`` and ``SWIR``. These bands are represented as 2-dimensional numpy arrays and the latitude and longitude coordinates for each dimension are represented using 1-dimensional arrays. Finally, we also have some metadata that comes with this image. The code below creates fake satellite data and structures the data as a ``dictionary``."
msgstr ""

#: 
msgid "All our data is conveniently packed in a dictionary. Now we can use this dictionary to work with the data it contains:"
msgstr ""

#: 
msgid "Still, to select data we have to use numpy indexes. Wouldn't it be convenient to be able to select data from the images using the coordinates of the pixels instead of their relative positions? This is exactly what ``xarray`` solves! Let's see how it works:"
msgstr ""

#: 
msgid "To explore xarray we have a file containing some surface reflectance data extracted from the DE Africa platform. The object that we get ``ds`` is a xarray ``Dataset``, which in some ways is very similar to the dictionary that we created before, but with lots of convenient functionality available."
msgstr ""

#: 
msgid "Xarray dataset structure"
msgstr ""

#: 
msgid "A ``Dataset`` can be seen as a dictionary structure packing up the data, dimensions and attributes. Variables in a ``Dataset`` object are called ``DataArrays`` and they share dimensions with the higher level ``Dataset``. The figure below provides an illustrative example:"
msgstr ""

#: 
msgid "To access a variable we can access as if it were a Python dictionary, or using the ``.`` notation, which is more convenient."
msgstr ""

#: 
msgid "Dimensions are also stored as numeric arrays that we can easily access"
msgstr ""

#: 
msgid "Metadata is referred to as attributes and is internally stored under ``.attrs``, but the same convenient ``.`` notation applies to them."
msgstr ""

#: 
msgid "DataArrays store their data internally as multidimensional numpy arrays. But these arrays contain dimensions or labels that make it easier to handle the data. To access the underlaying numpy array of a ``DataArray`` we can use the ``.values`` notation."
msgstr ""

#: 
msgid "Xarray offers two different ways of selecting data. This includes the ``isel()`` approach, where data can be selected based on its index (like numpy)."
msgstr ""

#: 
msgid "Or the ``sel()`` approach, used for selecting data based on its dimension of label value."
msgstr ""

#: 
msgid "Slicing data is also used to select a subset of data."
msgstr ""

#: 
msgid "Xarray exposes lots of functions to easily transform and analyse ``Datasets`` and ``DataArrays``. For example, to calculate the spatial mean, standard deviation or sum of the green band:"
msgstr ""

#: 
msgid "Plotting data with Matplotlib"
msgstr ""

#: 
msgid "Plotting is also conveniently integrated in the library."
msgstr ""

#: 
msgid "but we still can do things manually using numpy and matplotlib if you choose:"
msgstr ""

#: 
msgid "But compare the above to elegantly chaining operations within xarray:"
msgstr ""

#: 
msgid "**Introduction to xarray (this notebook)**"
msgstr ""

#: 
msgid "Parallel processing with Dask"
msgstr ""

#: 
msgid "**Products used:** `gm_s2_annual <https://explorer.digitalearth.africa/gm_s2_annual>`__"
msgstr ""

#: 
msgid "How to `run a basic analysis <05_Basic_analysis.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`beginner's guide; parallel processing`, :index:`parallel processing; dask`, :index:`parallel processing; beginner's guide`, :index:`data used; landsat 8 geomedian`, :index:`python package; dask`"
msgstr ""

#: 
msgid "`Dask <https://dask.org/>`__ is a useful tool when working with large analyses (either in space or time) as it breaks data into manageable chunks that can be easily stored in memory. It can also use multiple computing cores to speed up computations. This has numerous benefits for analyses, which will be covered in this notebook."
msgstr ""

#: 
msgid "This notebook covers how to enable Dask as part of loading data, which can allow you to analyse larger areas and longer time-spans without crashing the DE Africa Environment, as well as potentially speeding up your calculations."
msgstr ""

#: 
msgid "The difference between the standard load command and loading with Dask."
msgstr ""

#: 
msgid "Enabling Dask and the Dask Dashboard."
msgstr ""

#: 
msgid "Setting chunk sizes for data loading."
msgstr ""

#: 
msgid "Loading data with Dask."
msgstr ""

#: 
msgid "Chaining operations together before loading any data and understanding task graphs."
msgstr ""

#: 
msgid "To run this introduction to Dask, run all the cells in the notebook starting with the \"Load packages\" cell. For help with running notebook cells, refer back to the `Jupyter Notebooks notebook <01_Jupyter_notebooks.ipynb>`__."
msgstr ""

#: 
msgid "The cell below imports the ``datacube`` package, which already includes Dask functionality. The ``deafrica_tools`` package provides access to helpful support functions in the ``dask`` module, specifically the ``create_local_dask_cluster`` function."
msgstr ""

#: 
msgid "Standard load"
msgstr ""

#: 
msgid "By default, the ``datacube`` library will **not** use Dask when loading data. This means that when ``dc.load()`` is used, all data relating to the load query will be requested and loaded into memory."
msgstr ""

#: 
msgid "For very large areas or long time spans, this can cause the Jupyter notebook to crash."
msgstr ""

#: 
msgid "For more information on how to use ``dc.load()``, see the `Loading data from DE Africa notebook <03_Loading_data.ipynb>`__. Below, we show a standard load example:"
msgstr ""

#: 
msgid "Enabling Dask"
msgstr ""

#: 
msgid "One of the major features of Dask is that it can take advantage of multiple CPU cores to speed up computations, which is known as distributed computing. This is good for situations where you need to do a lot of calculations on large datasets."
msgstr ""

#: 
msgid "To set up distributed computing with Dask, you need to first set up a Dask client using the function below:"
msgstr ""

#: 
msgid "A print out should appear, displaying information about the ``Client`` and the ``Cluster``. For now, we're most interested in the hyperlink after the **Dashboard:** heading, which should look something like `/user/<email>/proxy/8787/status <#>`__, where `<email> <#>`__ is your email for the DE Africa Sandbox."
msgstr ""

#: 
msgid "This link provides a way for you to view how any computations you run are progressing. There are two ways to view the dashboard: 1. Click the link, which will open a new tab in your browser 2. Set up the dashboard inside the DE Africa Environment."
msgstr ""

#: 
msgid "We'll now cover how to do the second option."
msgstr ""

#: 
msgid "Dask dashboard in DE Africa"
msgstr ""

#: 
msgid "On the left-hand menu bar, click the Dask icon, as shown below:"
msgstr ""

#: 
msgid "|Image|"
msgstr ""

#: 
msgid "Image"
msgstr ""

#: 
msgid "Copy and paste the **Dashboard** link from the Client print out in the DASK DASHBOARD URL text box:"
msgstr ""

#: 
msgid "If the url is valid, the buttons should go from grey to orange. Click the orange **PROGRESS** button on the dask panel, which will open a new tab inside the DE Africa Environment."
msgstr ""

#: 
msgid "To view the Dask window and your active notebook at the same time, drag the new Dask Progress tab to the bottom of the screen."
msgstr ""

#: 
msgid "Now, when you do computations with Dask, you'll see the progress of the computations in this new Dask window."
msgstr ""

#: 
msgid "Lazy load"
msgstr ""

#: 
msgid "When using Dask, the ``dc.load()`` function will switch from immediately loading the data to \"lazy-loading\" the data. This means the data is only loaded when it is going to be used for a calculation, potentially saving time and memory."
msgstr ""

#: 
msgid "Lazy-loading changes the data structure returned from the ``dc.load()`` command: the returned ``xarray.Dataset`` will be comprised of ``dask.array`` objects."
msgstr ""

#: 
msgid "To request lazy-loaded data, add a ``dask_chunks`` parameter to your ``dc.load()`` call:"
msgstr ""

#: 
msgid "The function should return much faster, as it is not reading any data from disk."
msgstr ""

#: 
msgid "Dask chunks"
msgstr ""

#: 
msgid "After adding the ``dask_chunks`` parameter to ``dc.load()``, the lazy-loaded data contains ``dask.array`` objects with the ``chunksize`` listed. The ``chunksize`` should match the ``dask_chunks`` parameter originally passed to ``dc.load()``."
msgstr ""

#: 
msgid "Dask works by breaking up large datasets into chunks, which can be read individually. You may specify the number of pixels in each chunk for each dataset dimension."
msgstr ""

#: 
msgid "For example, we passed the following chunk definition to ``dc.load()``:"
msgstr ""

#: 
msgid "This definition tells Dask to cut the data into chunks containing 3000 pixels in the ``x`` and ``y`` dimensions and one measurement in the ``time`` dimension. For DE Africa, we always set ``'time': 1`` in the ``dask_chunk`` definition, since the data files only span a single time."
msgstr ""

#: 
msgid "If a chunk size is not provided for a given dimension, or if it set to -1, then the chunk will be set to the size of the array in that dimension. This means all the data in that dimension will be loaded at once, rather than being broken into smaller chunks."
msgstr ""

#: 
msgid "Viewing Dask chunks"
msgstr ""

#: 
msgid "To get a visual intuition for how the data has been broken into chunks, we can use the ``.data`` attribute provided by ``xarray``. This attribute can be used on individual measurements from the lazy-loaded data. When used in a Jupyter Notebook, it provides a table summarising the size of individual chunks and the number of chunks needed."
msgstr ""

#: 
msgid "An example is shown below, using the ``red`` measurement from the lazy-loaded data:"
msgstr ""

#: 
msgid "From the Chunk column of the table, we can see that the data has been broken into 4 chunks, with each chunk having a shape of ``(1 time, 3000 pixels, 3000 pixels)`` and taking up 18.00MB of memory. Comparing this with the Array column, using Dask means that we can load 4 lots of 18.00MB. rather than one lot of 57.67MB."
msgstr ""

#: 
msgid "This is valuable when it comes to working with large areas or time-spans, as the entire array may not always fit into the memory available. Breaking large datasets into chunks and loading chunks one at a time means that you can do computations over large areas without crashing the DE Africa environment."
msgstr ""

#: 
msgid "Loading lazy data"
msgstr ""

#: 
msgid "When working with lazy-loaded data, you have to specifically ask Dask to read and load data when you want to use it. Until you do this, the lazy-loaded dataset only knows where the data is, not its values."
msgstr ""

#: 
msgid "To load the data from disk, call ``.load()`` on the ``DataArray`` or ``Dataset``. If you opened the Dask progress window, you should see the computation proceed there."
msgstr ""

#: 
msgid "The Dask arrays constructed by the lazy load"
msgstr ""

#: 
msgid "have now been replaced with actual numbers:"
msgstr ""

#: 
msgid "After applying the ``.load()`` command, the lazy-loaded data is the same as the data loaded from the first query."
msgstr ""

#: 
msgid "In addition to breaking data into smaller chunks that fit in memory, Dask has another advantage in that it can track how you want to work with the data, then only perform the necessary operations later."
msgstr ""

#: 
msgid "We'll now explore how to do this by calculating the normalised difference vegetation index (NDVI) for our data. To do this, we'll perform the lazy-load operation again, this time adding the near-infrared band (``nir``) to the ``dc.load()`` command:"
msgstr ""

#: 
msgid "When using lazy-loading, Dask breaks up the loading operation into a series of steps. A useful way to visualise the steps is the task graph, which can be accessed by adding the ``.visualize()`` method to a ``.data`` call:"
msgstr ""

#: 
msgid "**The task graph is read from bottom to top.**"
msgstr ""

#: 
msgid "The four rectangles at the bottom of the graph are the database entries representing the files that need to be read to load the data."
msgstr ""

#: 
msgid "Above the rectangles are individual load commands (in the circles) that will do the reading. There is one for each chunk. The arrows describe which files need to be read for each operation: the chunk on the left needs data from all four database entries, whereas the chunk on the right only needs data from one."
msgstr ""

#: 
msgid "At the very top are the indexes of the chunks that will make up the final array."
msgstr ""

#: 
msgid "Adding more tasks"
msgstr ""

#: 
msgid "The power of this method comes from chaining tasks together before loading the data. This is because Dask will only load the data that is required by the final operation in the chain."
msgstr ""

#: 
msgid "We can demonstrate this by requesting only a small portion of the red band. If we do this for the lazy-loaded data, we can view the new task graph:"
msgstr ""

#: 
msgid "Notice that the new task ``getitem`` has been added, and that it only applies to the left-most chunk. If we call ``.load()`` on the ``extract_from_red`` Dask array, Dask trace the operation back through the graph to find only the relevant data. This can save both memory and time."
msgstr ""

#: 
msgid "We can establish that the above operation yields the same result as loading the data without Dask and subsetting it by running the command below:"
msgstr ""

#: 
msgid "Since the arrays are the same, it is worth using lazy-loading to chain operations together, then calling ``.load()`` when you're ready to get the answer. This saves time and memory, since Dask will only load the input data that is required to get the final output. In this example, the lazy-load only needed to load a small section of the ``red`` band, whereas the original load to get ``data`` had to load the ``red``, ``green`` and ``blue`` bands, then subset the ``red`` band, meaning time was spent loading data that wasn't used."
msgstr ""

#: 
msgid "Multiple tasks"
msgstr ""

#: 
msgid "The power of using lazy-loading in Dask is that you can continue to chain operations together until you are ready to get the answer."
msgstr ""

#: 
msgid "Here, we chain multiple steps together to calculate a new band for our array. Specifically, we use the ``red`` and ``nir`` bands to calculate the normalized difference vegetation index:"
msgstr ""

#: 
msgid "Doing this adds the new ``ndvi`` Dask array to the ``lazy_data`` dataset:"
msgstr ""

#: 
msgid "Now that the operation is defined, we can view its task graph:"
msgstr ""

#: 
msgid "Reading the graph bottom-to-top, we can see the equation taking place. The ``add`` and ``sub`` are performed on each band before being divided."
msgstr ""

#: 
msgid "We can see how each output chunk is independent from the others. This means we could calculate each chunk without ever having to load all of the bands into memory at the same time."
msgstr ""

#: 
msgid "Finally, we can calculate the NDVI values by calling the ``.load()`` command. We'll store the result in the ``ndvi_load`` variable:"
msgstr ""

#: 
msgid "Note that running the ``.load()`` command also modifies the ``ndvi`` entry in the ``lazy_load`` dataset:"
msgstr ""

#: 
msgid "You can see that ``ndvi`` is a number, whereas all the other variables are Dask arrays."
msgstr ""

#: 
msgid "Keeping variables as Dask arrays"
msgstr ""

#: 
msgid "If you wanted to calculate the NDVI values, but leave ``ndvi`` as a dask array in ``lazy_load``, you can use the ``.compute()`` command instead."
msgstr ""

#: 
msgid "To demonstrate this, we first redefine the ``ndvi`` variable so that it becomes a Dask array again"
msgstr ""

#: 
msgid "Now, we perform the same steps as before to calculate NDVI, but use ``.compute()`` instead of ``.load():``"
msgstr ""

#: 
msgid "You can see that the values have been calculated, but as shown below, the ``ndvi`` variable is kept as a Dask array."
msgstr ""

#: 
msgid "Using ``.compute()`` can allow you to calculate in-between steps and store the results, without modifying the original Dask dataset or array. However, be careful when using ``.compute()``, as it may lead to confusion about what you have and have not modified, as well as multiple computations of the same quantity."
msgstr ""

#: 
msgid "Further Resources"
msgstr ""

#: 
msgid "For further reading on how Dask works, and how it is used by xarray, see these resources:"
msgstr ""

#: 
msgid "http://xarray.pydata.org/en/stable/dask.html"
msgstr ""

#: 
msgid "https://dask.readthedocs.io/en/latest/"
msgstr ""

#: 
msgid "http://stephanhoyer.com/2015/06/11/xray-dask-out-of-core-labeled-arrays/"
msgstr ""

#: 
msgid "Other notebooks"
msgstr ""

#: 
msgid "This is the last notebook in the beginner's guide; if anything was unclear, we recommend revising the relevant notebook:"
msgstr ""

#: 
msgid "**Parallel processing with Dask (this notebook)**"
msgstr ""

#: 
msgid "Once you have completed the above eight tutorials, join advanced users in exploring:"
msgstr ""

#: 
msgid "Beginner's Guide"
msgstr ""

#: 
msgid "Introductory notebooks aimed at introducing Jupyter Notebooks and how to load, plot and interact with DE Africa data."
msgstr ""

#: 
msgid "These notebooks can also be found in your home folder on the sandbox, or accessed from GitHub at:"
msgstr ""

#: 
msgid "https://github.com/digitalearthafrica/deafrica-sandbox-notebooks"
msgstr ""

#: 
msgid "Important Updates"
msgstr ""

#: 
msgid "August 2023"
msgstr ""

#: 
msgid "Python Package updates"
msgstr ""

#: 
msgid "Package"
msgstr ""

#: 
msgid "Old"
msgstr ""

#: 
msgid "New"
msgstr ""

#: 
msgid "datacube"
msgstr ""

#: 
msgid "1.8.13"
msgstr ""

#: 
msgid "1.8.15"
msgstr ""

#: 
msgid "jupyterhub"
msgstr ""

#: 
msgid "1.5.0"
msgstr ""

#: 
msgid "3.0.0"
msgstr ""

#: 
msgid "numpy"
msgstr ""

#: 
msgid "1.23.5"
msgstr ""

#: 
msgid "1.24.3"
msgstr ""

#: 
msgid "We have also added new python packages. These include ``poetry``, ``pytest``,\\ ``pytest-reportlog`` and ``pytest-xdist``."
msgstr ""

#: 
msgid "For more information on the Analysis Sandbox image upgrade see the `deafrica-sandbox 0.0.7 release <https://github.com/digitalearthafrica/deafrica-sandbox/releases/tag/0.0.7>`__."
msgstr ""

#: 
msgid "Breaking changes"
msgstr ""

#: 
msgid "With the update to the ``numpy`` package, the numpy aliases ``np.object``, ``np.bool``, ``np.float``, ``np.complex``, ``np.str``, and ``np.int`` can no longer be used in the Analysis Sandbox and have been replaced with the appropriate builtin type in the Jupyter notebooks and Python scripts. For example ``np.int`` has been an alias of the builtin ``int`` and has been replaced with ``int``. The aliases were deprecated in ``numpy`` 1.20.0 and removed in 1.24. For a full list of deprecated aliases, along with their exact meaning see the `numpy version 1.20.0 release notes <https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations>`__."
msgstr ""

#: 
msgid "June 2023"
msgstr ""

#: 
msgid "python"
msgstr ""

#: 
msgid "3.8.10"
msgstr ""

#: 
msgid "3.10.6"
msgstr ""

#: 
msgid "1.8.8"
msgstr ""

#: 
msgid "0.12.2"
msgstr ""

#: 
msgid "2023.5.0"
msgstr ""

#: 
msgid "geopandas"
msgstr ""

#: 
msgid "0.11.1"
msgstr ""

#: 
msgid "0.13.2"
msgstr ""

#: 
msgid "shapely"
msgstr ""

#: 
msgid "1.8.5.post1"
msgstr ""

#: 
msgid "2.0.1"
msgstr ""

#: 
msgid "matplotlib"
msgstr ""

#: 
msgid "3.6.0"
msgstr ""

#: 
msgid "3.7.1"
msgstr ""

#: 
msgid "pyproj"
msgstr ""

#: 
msgid "3.4.0"
msgstr ""

#: 
msgid "3.5.0"
msgstr ""

#: 
msgid "For more information on the Analysis Sandbox image upgrade see the `deafrica-sandbox 0.0.6 release <https://github.com/digitalearthafrica/deafrica-sandbox/releases/tag/0.0.6>`__."
msgstr ""

#: 
msgid "With the **xarray package** update, xarray’s ufuncs can no longer be used in the Analysis Sandbox and have been replaced in the notebooks and scripts with `numpy's ufuncs <https://numpy.org/doc/stable/reference/ufuncs.html>`__ instead. E.g. ``xarray.ufuncs.1og10`` has been replaced with ``np.log10``."
msgstr ""

#: 
msgid "*Code cell from the old version of the Real_world_examples/Radar_water_detection.ipynb notebook*"
msgstr ""

#: 
msgid "*Code cell from the new version of the Real_world_examples/Radar_water_detection.ipynb notebook*"
msgstr ""

#: 
msgid "With the **xarray package** update, using a ``tuple`` as a sequence in the xarray ```.sel`` <https://docs.xarray.dev/en/stable/generated/xarray.DataArray.sel.html#xarray.DataArray.sel>`__ method, e.g. ``data_array.sel(coordinate=(val1, val2))`` is no longer supported. Use a ``list`` or ``range`` instead of a tuple e.g. ``data_array.sel(coordinate=[val1, val2])``. For more details see `xarray issue #6835 <https://github.com/pydata/xarray/issues/6835>`__."
msgstr ""

#: 
msgid "With the **matplotlib package** update, some of the plotting functionality has been updated within the notebooks. E.g.:"
msgstr ""

#: 
msgid "``matplotlib.cm.get_cmap(cmap_name)`` has been deprecated, use ``matplotlib.colormaps[cmap_name]`` instead."
msgstr ""

#: 
msgid "All parameters of ``imshow`` starting from aspect are keyword-only."
msgstr ""

#: 
msgid "For more details see the `Matplotlib API changes for 3.7.0 <https://matplotlib.org/stable/api/prev_api_changes/api_changes_3.7.0.html#api-changes-for-3-7-0>`__."
msgstr ""

#: 
msgid "*Code cell from the old version of the Datasets/NDVI_Anomaly.ipynb notebook*"
msgstr ""

#: 
msgid "*Code cell from the new version of the Datasets/NDVI_Anomaly.ipynb notebook*"
msgstr ""

#: 
msgid "With the **shapely package** update, iteration over multi-part geometries is deprecated. For alternatives see `Multi-part geometries will no longer be “sequences” (length, iterable, indexable) <https://shapely.readthedocs.io/en/stable/migration.html#multi-part-geometries-will-no-longer-be-sequences-length-iterable-indexable>`__ or `this GIS Stack Exchange answer <https://gis.stackexchange.com/a/378895>`__ applied to the ``contours_to_arrays`` function of the `deafrica_tools.spatial module <Tools/deafrica_tools/spatial.py>`__."
msgstr ""

#: 
msgid "Support for python ``3.8`` has been dropped for the ``deafrica-tools``. ``deafrica-tools`` version ``2.0.0`` requires Python version ``>=3.9,<3.12``. Minimum versions of some dependencies were also changed. See the ``deafrica-tools`` `pyproject.toml <Tools/pyproject.toml>`__ for the updated versions of the package dependencies."
msgstr ""

#: 
msgid "Changed"
msgstr ""

#: 
msgid "The ``esa_world_cover`` product has been archived. All notebooks that use the ``esa_world_cover`` product have been updated to use the ```esa_world_cover_2020`` <https://explorer.digitalearth.africa/products/esa_worldcover_2020>`__ product to load ESA World Cover, global 10 m land use/land cover data from 2020. To load data for 2021 please use the ```esa_world_cover_2021`` <https://explorer.digitalearth.africa/products/esa_worldcover_2021>`__ product."
msgstr ""

#: 
msgid "*Code cell from the old version of the Real_world_examples/Cropland_extent.ipynb notebook*"
msgstr ""

#: 
msgid "*Code cell from the new version of the Real_world_examples/Cropland_extent.ipynb notebook*"
msgstr ""

#: 
msgid "The ``load_soil_moisture`` function previously defined in the `Global Root-zone moisture Analysis & Forecasting System (GRAFS) Dataset notebook <Datasets/Soil_Moisture.ipynb>`__ is now part of the `load_soil_moisture module <Tools/deafrica_tools/load_soil_moisture.py>`__ in the ``deafrica-tools`` package."
msgstr ""

#: 
msgid "With the xarray package update, notebooks using ``xr.DataArray.resample()`` and ``xr.Dataset.resample()`` with the ``loffset`` parameter have been updated to use time offset arithmetic to replace the ``loffset`` parameter. For more details see the `xarray v2023.03.0 release notes <https://docs.xarray.dev/en/stable/whats-new.html#id36>`__."
msgstr ""

#: 
msgid "*Code cell from the old version of the Use_cases/Lake_baringo_grazing/Vegetation_phenology_1D.ipynb notebook*"
msgstr ""

#: 
msgid "*Code cell from the new version of the Use_cases/Lake_baringo_grazing/Vegetation_phenology_1D.ipynb notebook*"
msgstr ""

#: 
msgid "Other notable changes include:"
msgstr ""

#: 
msgid "``pyproj.Proj`` and ``pyproj.transformer.transform()`` have been replaced in the notebooks and scripts with ``pyproj.transformer.Transformer`` and ``pyproj.crs.CRS``. For more details see `Upgrading to pyproj 2 from pyproj 1 <https://pyproj4.github.io/pyproj/stable/gotchas.html#upgrading-to-pyproj-2-from-pyproj-1>`__."
msgstr ""

#: 
msgid "Added"
msgstr ""

#: 
msgid "The notebooks and scripts in the Analysis Sandbox, that use the geopandas package have been updated to set an environment variable (``USE_PYGEOS=0``) before importing geopandas. This is because in future, GeoPandas will deprecate support of the PyGEOS backend and will go forward with Shapely 2.0 as the only geometry engine exposing GEOS functionality. For more details see `Migration from PyGEOS geometry backend to Shapely 2.0 <https://geopandas.org/en/stable/docs/user_guide/pygeos_to_shapely.html>`__."
msgstr ""

#: 
msgid "*Code cell from new version of the Datasets/Coastlines.ipynb notebook*"
msgstr ""

#: 
msgid "May 2023"
msgstr ""

#: 
msgid "The monthly `NDVI Mean and Anomalies <https://www.digitalearthafrica.org/platform-resources/services/mean-ndvi-and-anomalies>`__ service has been released."
msgstr ""

#: 
msgid "Information </h2"
msgstr ""

#: 
msgid "Notebooks"
msgstr ""

#: 
msgid "This Sandbox environment hosts many Jupyter Notebooks which you are free to experiment with. The Digital Earth Africa notebook repository is often updated and latest updates can be seen in the Sandbox and inspected on `GitHub <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__."
msgstr ""

#: 
msgid "The Digital Earth Africa Notebooks repository (```deafrica-sandbox-notebooks`` <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__) hosts Jupyter Notebooks, Python scripts and workflows for analysing `Digital Earth Africa (DE Africa) <https://www.digitalearthafrica.org/>`__ satellite data and derived products. This documentation is designed to provide a guide to getting started with DE Africa, and to showcase the wide range of geospatial analyses that can be achieved using DE Africa data and open-source software including `Open Data Cube <https://www.opendatacube.org/>`__ and `xarray <http://xarray.pydata.org/en/stable/>`__."
msgstr ""

#: 
msgid "For guidance on the Sandbox and integrating Git for version control, please see the `Digital Earth Africa documentation <https://docs.digitalearthafrica.org/en/latest/sandbox>`__."
msgstr ""

#: 
msgid "Datasets"
msgstr ""

#: 
msgid "The Sandbox enables access to Digital Earth Africa's datasets which can be explored in the Datasets folder. The list of datasets can also be found in the `metadata explorer <https://explorer.digitalearth.africa/products>`__."
msgstr ""

#: 
msgid "Support"
msgstr ""

#: 
msgid "The `Training and Help <https://www.digitalearthafrica.org/platform-resources/training-and-help>`__ page can be consulted for guidance on using the Helpdesk and accessing training and the user guide."
msgstr ""

#: 
msgid "**Products used:** `alos_palsar_mosaic <https://explorer.digitalearth.africa/products/alos_palsar_mosaic>`__, `jers_sar_mosaic <https://explorer.digitalearth.africa/products/jers_sar_mosaic>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; ALOS PALSAR`, :index:`data used; ALOS-2 PALSAR-2`, :index:`datasets; ALOS/ALOS-2 PALSAR/PALSAR-2`, :index:`data used; JERS SAR`, :index:`datasets; JERS SAR`, index:`SAR`"
msgstr ""

#: 
msgid "The ALOS/ALOS2 PALSAR Annual Mosaic is a global 25 m resolution dataset that combines data from many images captured by JAXA’s PALSAR and PALSAR-2 sensors on ALOS-1 and ALOS-2 satellites respectively. This product contains radar measurement in L-band and in HH and HV polarizations. It has a spatial resolution of 25m and is available annually for 2007 to 2010 (ALOS/PALSAR) and 2015 to 2022 (ALOS-2/PALSAR-2). ALOS/ALOS2 PALSAR mosaic data is part of a global `dataset <https://www.eorc.jaxa.jp/ALOS/en/palsar_fnf/fnf_index.htm>`__ provided by the Japan Aerospace Exploration Agency (JAXA) Earth Observation Research Center. Historically, the JERS annual mosaic is generated from images acquired by the SAR sensor on the Japanese Earth Resources Satellite-1 (JERS-1) satellite."
msgstr ""

#: 
msgid "DE Africa's ALOS/ALOS-2 PALSAR/PALSAR-2 and JERS annual mosaic are Normalized Radar Backscatter data, for which Radiometric Terrain Correction (RTC) has been applied to data acquired with different imaging geometries over the same region.The relevant coverage and metadata of ALOS/ALOS2 PALSAR dataset can be viewed on `DE Africa Metadata Explorer <https://explorer.digitalearth.africa/products/alos_palsar_mosaic>`__ while JERS dataset coverage can be access via this `link <https://explorer.digitalearth.africa/products/jers_sar_mosaic>`__ that forms a single, cohesive Analysis Ready Data (ARD) package, which allows you to analyse radar backscatter data as-is without the need to apply additional corrections."
msgstr ""

#: 
msgid "**Important details:**"
msgstr ""

#: 
msgid "ALOS/ALOS2 PALSAR annual mosaic product specifications"
msgstr ""

#: 
msgid "Number of bands: ``5``"
msgstr ""

#: 
msgid "To achieve backscatter in decibel unit, convert backscatter values in Digital Number (DN) using $ 10 \\* log10(DN^2) - 83.0 $"
msgstr ""

#: 
msgid "Mask specification includes ``0`` for ``no-data``, ``50`` for water, ``100`` for lay_over, ``150`` for shadowing and ``255`` for land"
msgstr ""

#: 
msgid "Observation date is expressed as days after launch, which are Jan. 24, 2006 and May. 24, 2014 for PALSAR and PALSAR-2 respectively."
msgstr ""

#: 
msgid "Native pixel alignment is ``centre``"
msgstr ""

#: 
msgid "Date-range: selected years from 2007 to 2022"
msgstr ""

#: 
msgid "Spatial resolution: 25 x 25 m"
msgstr ""

#: 
msgid "JERS annual mosaic product specifications"
msgstr ""

#: 
msgid "Number of bands: ``4``"
msgstr ""

#: 
msgid "To achieve backscatter in decibel unit, convert backscatter values in Digital Number (DN) using $ 10 \\* log10(DN^2) - 84.66 $"
msgstr ""

#: 
msgid "Observation date is expressed as days after launch, which is Feb. 11, 1992 for JERS-1."
msgstr ""

#: 
msgid "Date-range: 1996"
msgstr ""

#: 
msgid "For a detailed description of DE Africa's ALOS/ALOS2 PALSAR archive, see the DE Africa's `ALOS/ALOS2 technical specifications documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/ALOS_PALSAR_annual_mosaic_specs.html>`__."
msgstr ""

#: 
msgid "In this notebook we will load **ALOS PALSAR** data using `dc.load() <../Beginners_guide/03_Loading_data.ipynb>`__ to return a time series of satellite images from a single sensor."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the ALOS PALSAR products and measurements available in the datacube 2. Using the native ``dc.load()`` function to load in dual polarization ALOS PALSAR data and visualize 3. Using ``dc.load()`` function to load single polarization JERS mosaic and visualize"
msgstr ""

#: 
msgid "To run this analysis, run all the cells in the notebook, starting with the \"Load packages\" cell."
msgstr ""

#: 
msgid "Available products and measurements"
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect DE Africa's SAR products that are available in the datacube. The table below shows the product names that we will use to load the data, a brief description of the data, and the satellite instrument that acquired the data."
msgstr ""

#: 
msgid "We can further inspect the data available for each SAR product using datacube's ``list_measurements`` functionality. The table below lists each of the measurements available in the data."
msgstr ""

#: 
msgid "Load ALOS PALSAR Annual Mosaic dataset using ``dc.load()``"
msgstr ""

#: 
msgid "Now that we know what products and measurements are available for the products, we can load data from the datacube using ``dc.load``."
msgstr ""

#: 
msgid "In the example below, we will load ALOS PALSAR for Cairo and its surrounding in Egypt between 2007 and 2022."
msgstr ""

#: 
msgid "We will load data from two polarizations, as well as the data mask (``'mask'``) and observation date. The data is loaded in native EPSG:4326 coordinate reference system (CRS). It can be reprojected if ``output_crs`` and ``resolution`` are defined in the query."
msgstr ""

#: 
msgid "Note: For a more general discussion of how to load data using the datacube, refer to the `Introduction to loading data <../Beginners_guide/03_Loading_data.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Visualise the selected area"
msgstr ""

#: 
msgid "Inspection of observation date"
msgstr ""

#: 
msgid "Each annual mosaic is created from multiple oberservations from a year. This may result in discontinuity across images as seen above. It also means mosaics from different years may come from different seasons."
msgstr ""

#: 
msgid "The observation date should be considered when evaluating change detected from year to year. In this example, we find the earliest, latest and median observation dates for each mosaic loaded."
msgstr ""

#: 
msgid "The date ranges below show that the observations can span a few months. Occasionally data used may be from another year."
msgstr ""

#: 
msgid "Coverting DN Values to Decibel Units"
msgstr ""

#: 
msgid "Since Backscatter data is provided as digital number(DN), it can be converted to backscatter in decibel unit to enhance contrast using the provided conversion equation. Before converting to decibel, we also apply the data mask to exclude pixels in radar shadow or with layerover."
msgstr ""

#: 
msgid "Histogram Analysis for ALOS/ALOS-2 PALSAR Dataset"
msgstr ""

#: 
msgid "Use histograms to inspect the distribution of backscatter values."
msgstr ""

#: 
msgid "Load JERS dataset using ``dc.load()``"
msgstr ""

#: 
msgid "In the example below, we will load JERS annual mosaic for Cairo and its surrounding in Egypt in 1996."
msgstr ""

#: 
msgid "We will load data from HH polarization, as well as the data mask (``mask``). The data is loaded in native EPSG:4326 coordinate reference system (CRS). It can be reprojected if ``output_crs`` and ``resolution`` are defined in the query."
msgstr ""

#: 
msgid "Histogram Analysis for JERS HH Polarization"
msgstr ""

#: 
msgid "Inspect backscatter distribution in this area"
msgstr ""

#: 
msgid "**Products used:** `ERA5 <https://registry.opendata.aws/ecmwf-era5/>`__"
msgstr ""

#: 
msgid "This dataset is external to the Digital Earth Africa platform."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ERA5`, :index:`datasets; ERA5`, :index:`climate`, :index:`temperature`, :index:`precipitation`, :index:`wind`"
msgstr ""

#: 
msgid "This notebook demonstrates how to access and use the European Centre for Medium Range Weather Forecasts (ECMWF) global climate reanalysis product called, ERA5, from the `AWS Public Dataset Program <https://registry.opendata.aws/ecmwf-era5/>`__ or `Google Cloud Storage <https://cloud.google.com/storage/docs/public-datasets/era5>`__."
msgstr ""

#: 
msgid "This 5th generation operational service utilizes the best available observation data from satellites and in-situ stations, which are assimilated and processed using ECMWF's Integrated Forecast System. The dataset provides essential atmospheric meteorological parameters such as air temperature, pressure and wind at different altitudes, along with surface parameters like rainfall, and sea parameters like sea-surface temperature and wave height. Spatial resolution is 0.25 degrees (latitude and longitude) which equates to about 31 km. Data is available from 1979 to present and is updated operationally."
msgstr ""

#: 
msgid "For offical information on this dataset, see `ERA5 data documentation from ECMWF <https://confluence.ecmwf.int/display/CKB/ERA5%3A+data+documentation>`__."
msgstr ""

#: 
msgid "**Currently, the AWS ERA 5 dataset is deprecated.** The ERA5 dataset used in the notebook is from Google Cloud Storage and spans the years 1959 to 2022."
msgstr ""

#: 
msgid "We recommend use of ERA5 data in Zarr format which allows cloud native access without the need to download data."
msgstr ""

#: 
msgid "15 surface or single level variables are accessible using the ``load_era5()`` wrapper function."
msgstr ""

#: 
msgid "6 hour precipitation"
msgstr ""

#: 
msgid "total_precipitation_6hr"
msgstr ""

#: 
msgid "12 hour precipitation"
msgstr ""

#: 
msgid "total_precipitation_12hr"
msgstr ""

#: 
msgid "24 hour precipitation"
msgstr ""

#: 
msgid "total_precipitation_24hr"
msgstr ""

#: 
msgid "surface_pressure"
msgstr ""

#: 
msgid "This notebook covers examples for accessing and working with the following variables: 1. Daily total precipitation 2. Daily minimum and maximum air temperature at 2 metres height 3. Hourly wind speed at 10 metres height 4. Monthly maximum air temperature at 2 metres height for the continent"
msgstr ""

#: 
msgid "Import Python packages that are used for the analysis."
msgstr ""

#: 
msgid "Define location and time period of interest. For an initial test, use a time period of no more than a few months to limit data access."
msgstr ""

#: 
msgid "``lat`` & ``lon``: The latitude and longitude range for the area of interest."
msgstr ""

#: 
msgid "``time``: The time range you wish to extract data for. Times can be provided as year, month or date strings or datetime objects."
msgstr ""

#: 
msgid "Daily total precipitation"
msgstr ""

#: 
msgid "Total precipitation is the accumulated liquid and frozen water, comprising rain and snow, that falls to the Earth's surface. It does not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth. The units of this parameter are depth in metres of water equivalent. It is the depth the water would have if it were spread evenly over the grid box. Care should be taken when comparing model parameters with observations, because observations are often local to a particular point in space and time, rather than representing averages over a model grid box."
msgstr ""

#: 
msgid "In this example, total precipitation is aggregated at daily intervals."
msgstr ""

#: 
msgid "Noting that output spatial grid is snapped to the nearest input grid points."
msgstr ""

#: 
msgid "Daily minimum and maximum air temperature at 2 metres height"
msgstr ""

#: 
msgid "Air temperature estimate is provided in kelvin (K) and can be converted to degrees Celsius (°C) by subtracting 273.15."
msgstr ""

#: 
msgid "In this example, highest and lowerest daily temperatures are extracted."
msgstr ""

#: 
msgid "Optional parameters used to load data:"
msgstr ""

#: 
msgid "``reduce_func``: function to aggregate input hourly data, set to np.max and np.min to calculate maximum and minimum temperature."
msgstr ""

#: 
msgid "``resample``: temporal resampling frequency, '1D' (as default) for daily aggregation."
msgstr ""

#: 
msgid "Maximum hourly wind speed at 10 metres height"
msgstr ""

#: 
msgid "Wind causes changes in surface characteristic of some land cover types, e.g. surface roughness of water. Increased surface roughness leads to an increase in measured radar backscatter. Although typically stronger than wind at surface, wind at 10 metres height may be used to flag windy conditions."
msgstr ""

#: 
msgid "In ERA5, horizontal wind estimate is provided in metres per second and is represented by an eastward component and a northward component. A negative sign indicates air moving in the opposite direction, e.g. towards the west for the eastward component. The two components can be combined to give the speed and direction of the horizontal wind."
msgstr ""

#: 
msgid "Wind speed is highly variable throughout a day, so sampling is kept at hourly."
msgstr ""

#: 
msgid "``resample``: temporal resampling frequency, '1h' so that output data is at same frequency as input."
msgstr ""

#: 
msgid "Combine the two wind components to get wind speed"
msgstr ""

#: 
msgid "Magnitude of the wind speed is calculated from U and V components as :math:`sqrt(U^2 + V^2)`."
msgstr ""

#: 
msgid "Monthly maximum air temperature at 2 metres height"
msgstr ""

#: 
msgid "In this example, maximum air temperature at 2 metres height is retrieved monthly for the African continent."
msgstr ""

#: 
msgid "Latitude and Longitude ranges are set to cover the continent. Time range is set from Janurary to March 2021."
msgstr ""

#: 
msgid "``reduce_func``: function to aggregate input hourly data, set to np.max to calculate maximum temperature."
msgstr ""

#: 
msgid "Coastlines"
msgstr ""

#: 
msgid "**Products used:** `DE Africa Coastlines <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; coastlines`"
msgstr ""

#: 
msgid "Africa's long and dynamic coastline is subject to a wide range of pressures, including extreme weather and climate, sea level rise and human development. Understanding how the coastline responds to these pressures is crucial to managing this region, from social, environmental and economic perspectives."
msgstr ""

#: 
msgid "The `Digital Earth Africa Coastlines <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__ is a continental dataset that includes annual shorelines and rates of coastal change along the entire African coastline from 2000 to 2021."
msgstr ""

#: 
msgid "The product combines satellite data from the Digital Earth Africa program with tidal modelling to map the typical location of the coastline at mean sea level for each year. The product enables trends of coastal erosion and growth to be examined annually at both a local and continental scale, and for patterns of coastal change to be mapped historically and updated regularly as data continues to be acquired. This allows current rates of coastal change to be compared with that observed in previous years or decades."
msgstr ""

#: 
msgid "The ability to map shoreline positions for each year provides valuable insights into whether changes to the coastline are the result of particular events or actions, or a process of more gradual change over time. This information can enable scientists, managers and policy makers to assess impacts from the range of drivers impacting the coastlines and potentially assist planning and forecasting for future scenarios."
msgstr ""

#: 
msgid "Applications"
msgstr ""

#: 
msgid "Monitoring and mapping rates of coastal erosion along the African coastline"
msgstr ""

#: 
msgid "Prioritise and evaluate the impacts of local and regional coastal management based on historical coastline change"
msgstr ""

#: 
msgid "Modelling how coastlines respond to drivers of change, including extreme weather events, sea level rise or human development"
msgstr ""

#: 
msgid "Supporting geomorphological studies of how and why coastlines have changed across time"
msgstr ""

#: 
msgid "For a full description of the product specifications, validation results, and methods used to develop the products, see the `DE Africa Coastlines specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__ document."
msgstr ""

#: 
msgid "This notebook will demonstrate how to load, plot, and conduct a simple analysis using the `Digital Earth Africa Coastlines <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__ product."
msgstr ""

#: 
msgid "Loading DE Africa Coastlines annual shoreline data using the ``get_coastlines`` function."
msgstr ""

#: 
msgid "Loading DE Africa Coastlines rates of change statistics data using the ``get_coastlines`` function."
msgstr ""

#: 
msgid "Extracting shoreline data for one or multiple coastal transects using an interactive DE Africa Coastlines application."
msgstr ""

#: 
msgid "This section defines the analysis parameters, including:"
msgstr ""

#: 
msgid "``central_lat, central_lon, buffer``: center lat/lon and analysis window size for the area of interest"
msgstr ""

#: 
msgid "The default location is an area on Nyali Beach along the Kenyan Coast."
msgstr ""

#: 
msgid "View the selected location"
msgstr ""

#: 
msgid "The next cell will display the selected area on an interactive map. Feel free to zoom in and out to get a better understanding of the area you'll be analysing. Clicking on any point of the map will reveal the latitude and longitude coordinates of that point."
msgstr ""

#: 
msgid "Loading DE Africa Coastlines data"
msgstr ""

#: 
msgid "Annual shorelines"
msgstr ""

#: 
msgid "DE Africa Coastlines data can be loaded directly in a Python script or Jupyter Notebook using the ``get_coastlines`` function. This function makes use of the DE Africa Coastlines Web Feature Service (WFS) and ``geopandas``\\ to load the DE Africa Coastlines data for a provided bounding box."
msgstr ""

#: 
msgid "We can now plot the DE Africa Coastlines annual shoreline data using ``geopandas``. Zoom in to **Nyali Beach** in Kenya on the interactive map to view the shoreline data."
msgstr ""

#: 
msgid "Annual shorelines represent the median or 'most representative' position of the shoreline at approximately mean sea level tide (0 m Above Mean Sea Level) for each year from 2000 onward. Light-coloured lines (e.g. yellow) in the plot below represent recent shorelines (e.g. 2020), while dark-coloured lines represent older shorelines (e.g. 2000)."
msgstr ""

#: 
msgid "**Note:** For more detail about DE Africa Coastlines annual shoreline data, refer to the official `Digital Earth Africa Coastlines product description <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__."
msgstr ""

#: 
msgid "Rates of change statistics points"
msgstr ""

#: 
msgid "We can also load and plot the DE Africa Coastlines rates of change statistics points. These points provide robust rates of annual coastal change (in metres per year) for every 30 m along Africa's non-rocky (e.g. sandy and muddy) coastlines. These rates are calculated by linearly regressing annual shoreline positions against time, using the most recent shoreline as a baseline."
msgstr ""

#: 
msgid "**Note:** For more detail about DE Africa Coastlines rates of change statistics data, refer to the official `Digital Earth Africa Coastlines product description <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__."
msgstr ""

#: 
msgid "The DE Africa Coastlines rates of change statistics points data also provides many additional statistics that give insights into coastal change in Africa. For a full description of each of these statistics, refer to the Rates of change statistics section of the official `Digital Earth Africa Coastlines product description <https://docs.digitalearthafrica.org/en/latest/data_specs/Coastlines_specs.html>`__."
msgstr ""

#: 
msgid "Exporting DE Africa Coastlines data as vector files"
msgstr ""

#: 
msgid "We can easily export the loaded data as spatial vector files (e.g. ESRI Shapefiles or GeoJSON) so that they can be analysed further in GIS software:"
msgstr ""

#: 
msgid "DE Africa Coastlines analysis tools"
msgstr ""

#: 
msgid "The following sections provide useful tools for analysing DE Africa Coastlines data directly within a Jupyter Notebook without needing to load the data into GIS software. All outputs from the tools below will be saved to a new folder in this directory called ``deacoastlines_outputs``."
msgstr ""

#: 
msgid "Extract shoreline data by coastal transect"
msgstr ""

#: 
msgid "The ``deacoastlines.transect_app`` tool allows you to interactively draw a transect over DE Africa Coastlines annual shoreline data, and get back a graph showing how shoreline positions have changed over time. To use the tool:"
msgstr ""

#: 
msgid "Run the cell below; an interactive application will appear"
msgstr ""

#: 
msgid "Zoom in on the map and use the ``Draw a polyline`` tool on the left to draw a transect so that it crosses through a set of shorelines (see example below). Transects should be drawn in a consistent direction, e.g. starting on land and finishing over water. This ensures that results can be compared between transects."
msgstr ""

#: 
msgid "|Transect example|"
msgstr ""

#: 
msgid "Transect example"
msgstr ""

#: 
msgid "Press ``Finish`` when you are happy with the line, then click on the ``Extract shoreline data`` button on the bottom left."
msgstr ""

#: 
msgid "A graph will appear below the map showing distances along the transect to each annual shoreline (distances will be measured from the start of the transect line you drew above)"
msgstr ""

#: 
msgid "**Optional:** Set transaction extraction mode to ``'width'`` and re-run the cell below to measure the width between two adjacent sets of coastlines (e.g. across the neck of a tombolo or sandbar)."
msgstr ""

#: 
msgid "**Optional:** Upload a GeoJSON or ESRI Shapefile containing transects using the ``Upload`` button to automatically extract shoreline positions from multiple coastal transects (uploaded files should be less than 5 megabytes in size)."
msgstr ""

#: 
msgid "The resulting figure shows how shorelines at this location have changed over time."
msgstr ""

#: 
msgid "In ``distance`` mode, the y-axis shows the distance from the start of the transect to the location at which the transect intersects with each annual shoreline (shown on the x-axis). If transects were drawn with a starting point on land, decreasing distances over time indicate the coastline at this location was retreating or eroding since 2000. Conversely, increasing distances over time indicate the coastline was growing."
msgstr ""

#: 
msgid "In ``width`` mode, the y-axis shows the distance (i.e. width) between the first and last time the transect intersects each annual shoreline. Increasing widths indicate that a sandbar, spit or peninsular was growing wider over time; decreasing widths indicate that it was eroding or growing narrower."
msgstr ""

#: 
msgid "Next steps: coastline erosion notebook"
msgstr ""

#: 
msgid "The `Coastal erosion notebook <../Real_world_examples/Coastal_erosion.ipynb>`__ in this repository provides a simplified example of the method used to extract DE Africa Coastlines annual shoreline data. Run this notebook if you would like to generate more customised coastlines for a specific location, time period, epoch (e.g. annual or biennial coastlines) or tidal range (e.g. the position of the coastline at low, mid or high tide)."
msgstr ""

#: 
msgid "**Note:** This notebook currently supports extracting coastline data only, not generating rates of change statistics like those included in the DE Africa Coastlines product."
msgstr ""

#: 
msgid "**Contact:** If you need assistance, please post a question on the `Open Data Cube Slack channel <http://slack.opendatacube.org/>`__ or on the `GIS Stack Exchange <https://gis.stackexchange.com/questions/ask?tags=open-data-cube>`__ using the ``open-data-cube`` tag (you can view previously asked questions `here <https://gis.stackexchange.com/questions/tagged/open-data-cube>`__). If you would like to repoart an issue with this notebook, you can file one on `Github <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__."
msgstr ""

#: 
msgid "**Products used:** `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`datasets; crop_mask`, :index:`analysis; agriculture`, :index:`cropland extent`"
msgstr ""

#: 
msgid "Digital Earth Africa's cropland extent maps for Africa show the estimated location of croplands for the period of January to Decemeber 2019."
msgstr ""

#: 
msgid "For a full description of the product specifications, validation results, and methods used to develop the products, see the `Cropland_extent_specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/Cropland_extent_specs.html>`__ document."
msgstr ""

#: 
msgid "This notebook will show you how to load, plot, and conduct a simple analysis using the cropland extent product. The steps are as follows:"
msgstr ""

#: 
msgid "List the available cropland extent products"
msgstr ""

#: 
msgid "Load the ``crop_mask`` product"
msgstr ""

#: 
msgid "Plotting the different measurements of the crop-mask"
msgstr ""

#: 
msgid "Example analysis 1: Identifying crop trends with NDVI"
msgstr ""

#: 
msgid "Example analysis 2: Comparison of cropped area with global land cover datasets"
msgstr ""

#: 
msgid "Inspect different regions of the crop mask."
msgstr ""

#: 
msgid "For a more detailed example of using the cropland extent product, see the following notebooks:"
msgstr ""

#: 
msgid "`Cropland vegetation anomalies <../Real_world_examples/Vegetation_anomalies_monthly.ipynb>`__"
msgstr ""

#: 
msgid "`Phenology_optical <../Real_world_examples/Phenology_optical.ipynb>`__"
msgstr ""

#: 
msgid "`Phenology_radar <../Real_world_examples/Phenology_radar.ipynb>`__"
msgstr ""

#: 
msgid "Connect to the datacube so we can access DE Africa data."
msgstr ""

#: 
msgid "``lat, lon, buffer``: center lat/lon and analysis window size for the area of interest"
msgstr ""

#: 
msgid "``time_period``: time period to load for the crop mask. Currently, only a map for 2019 is available"
msgstr ""

#: 
msgid "``resolution``: the pixel resolution to use for loading the ``crop_mask_<region>``. The native resolution of the product is 10 metres i.e. ``(-10,10)``"
msgstr ""

#: 
msgid "The default location is in a extensivley cultivated valley north of Addis Ababa, Ethiopia"
msgstr ""

#: 
msgid "List cropland extent products available in Digital Earth Africa"
msgstr ""

#: 
msgid "We can use datacube's ``list_measurements`` functionality to inspect the cropland extent products available in the datacube. The table below shows the product names you can use to load data, and the measurements available for each product. The cropland extent masks come with three measurements: ``mask``, ``filtered``, and ``prob``."
msgstr ""

#: 
msgid "We can see in the table below that there is a single ``crop_mask`` product which covers the entire continent. It is comprised of numerous ``crop_mask_<region>`` products stitched together. We can use the continental ``crop_mask`` products for most applications, though we should be aware of the boundaries of the regional products that comprise it. We will explore this further below."
msgstr ""

#: 
msgid "Loading the cropland extent product"
msgstr ""

#: 
msgid "In this example, we will load the ``'crop_mask'`` product."
msgstr ""

#: 
msgid "Plotting the cropland extent"
msgstr ""

#: 
msgid "Above, we can see the ``crop_mask`` products contains three measurements:"
msgstr ""

#: 
msgid "Below, we will plot the three measurements side-by-side:"
msgstr ""

#: 
msgid "Example application: Identifying crop trends with NDVI"
msgstr ""

#: 
msgid "The Normalised Difference Vegetation Index (NDVI) can be used to track the health and growth of crops as they mature. Here will load an annual time series of Sentinel-2 satellite data, calculate the NDVI, and mask the region with DE Africa's cropland extent product. With only the cropping pixels remaining, we can summarise the growth cycle of the crops within the region."
msgstr ""

#: 
msgid "Calculate NDVI"
msgstr ""

#: 
msgid "Resample the dataset to monthly time-steps"
msgstr ""

#: 
msgid "Mask with the cropland extent map"
msgstr ""

#: 
msgid "Using the measurement ``filtered``, we can mask the dataset with the ``crop_mask`` product."
msgstr ""

#: 
msgid "Summarise the trends in NDVI for the croppping regions with a line plot"
msgstr ""

#: 
msgid "Below, the plot shows the cropping schedule starts in April, with the peak of the growing season occuring towards the end of the year in October/November."
msgstr ""

#: 
msgid "Example Analysis 2: Comparison with global landcover datasets"
msgstr ""

#: 
msgid "Indexed within the DE Africa's datacube are two global 10m resolution landcover datasets that each contain a cropping class. These landcover datasets were both produced using Senitnel-2 images, the same as DE Afric's cropland extent product. Below, we will load the landcover datasets over the same region as the cropland extent map and compare the area classified as croppping. You can use the interactive map plotted below to determine the areas where each datasets does well (or poorly) at classifying crops."
msgstr ""

#: 
msgid "To learn more about the landcover datasets see the `Landcover Classification <Landcover_Classification.ipynb>`__ notebook."
msgstr ""

#: 
msgid "First, we need to re-enter some analysis parameters. You'll notice below we've set the resolution to 60m to allow us to load a large region quickly, though all datasets are natively stored at 10m resolution."
msgstr ""

#: 
msgid "The default region is a bounding box over Lake Kyoga, Uganda. This region is extensively cropped."
msgstr ""

#: 
msgid "Plot an interactive map"
msgstr ""

#: 
msgid "If you zoom in you can examine the dominant land cover classes in the region (hint, there's a lot of agriculture!)"
msgstr ""

#: 
msgid "Load the cropland extent, ESRI's Landcover product, and ESA's WorldCover product"
msgstr ""

#: 
msgid "Reclassify the landcover datasets to a binary crop/non-crop image to allow a straightforward comparison with DE Africa's cropland extent map"
msgstr ""

#: 
msgid "Filter out the no-data pixels (255) from the crop-mask ``mask`` band."
msgstr ""

#: 
msgid "Plot the cropping extent of the three datasets"
msgstr ""

#: 
msgid "Calculate the cropped area in each product"
msgstr ""

#: 
msgid "In this example, you'll see that DE Africa's cropland product maps a lot more cropping than the two global landcover products. In this example, the DE Africa product is more accurate than the landcover datasets. However, over wetlands in the south-west of Lake Kyoga DE Afria's product incorrectly maps some of the wetlands as cropping, while the landcover datasets do not. While there are regions where DE AFrica's cropland extent maps have errors, in general they are much more accurate than any of the currently existing landcover datasets over Africa."
msgstr ""

#: 
msgid "Regional crop mask boundaries"
msgstr ""

#: 
msgid "As we saw in the datasets table, the ``crop_mask`` is comprised of numerous regional products stitched together. We can load and use the continental ``crop_mask`` product for most applications. However, we may observe some unusual artefacts at the boundaries of regional crop masks which are worth being aware of. We will investigate this below."
msgstr ""

#: 
msgid "First, we will define and inspect an area on the borders of Uganda, Rwanda, and DR Congo. This also forms the border the ``crop_mask_central`` and ``crop_mask_eastern``. We can inspect the extent of each regional product on the `Digital Earth Africa Maps Platform <https://maps.digitalearth.africa/>`__."
msgstr ""

#: 
msgid "Load regional crop masks"
msgstr ""

#: 
msgid "Below, we load the continental product in addtion to both the central and eastern crop masks. We do this by using the ``region`` argument in ``dc.load``."
msgstr ""

#: 
msgid "Plot regional products"
msgstr ""

#: 
msgid "Digital Elevation Models"
msgstr ""

#: 
msgid "**Products used:** `dem_cop_30 <https://explorer.digitalearth.africa/products/dem_cop_30>`__, `dem_cop_90 <https://explorer.digitalearth.africa/products/dem_cop_90>`__, `dem_srtm <https://explorer.digitalearth.africa/products/dem_srtm>`__, `dem_srtm_deriv <https://explorer.digitalearth.africa/products/dem_srtm_deriv>`__"
msgstr ""

#: 
msgid "**Keywords**: :index: 'data used; Copernicus DEM 30 m', :index: 'data used; Copernicus DEM 90 m', :index: 'data used; 1 second elevation model', :index: 'data used; 1 second elevation model derivatives', :index:`data used; ERA5`, :index: 'datasets; dem_cop_30', :index: 'datasets; dem_cop_90', :index: 'datasets; dem_srtm', :index: 'datasets; dem_srtm_deriv'"
msgstr ""

#: 
msgid "**D**\\ igital **E**\\ levation **M**\\ odels (DEMs) provide information on bare ground topography, that is, elevation irrespective of land cover such as buildings/trees. DEMs are often derived from Light Detection and Ranging (LiDAR) data sources. DEMs are used in several applications such as understanding how climatic variables change with topography."
msgstr ""

#: 
msgid "There are four DEM products available from the Open Data Cube. The `Copernicus products <https://spacedata.copernicus.eu/web/cscda/dataset-details?articleId=394198>`__ come from the European Space Agency (ESA) and the `Shuttle Radar Topography Mission (SRTM) <https://www.usgs.gov/centers/eros/science/usgs-eros-archive-digital-elevation-shuttle-radar-topography-mission-srtm-1-arc?qt-science_center_objects=0#qt-science_center_objects>`__ products are from the United States Geological Survey (USGS):"
msgstr ""

#: 
msgid "Copernicus DEM 30 m: ``dem_cop_30``, elevation data at 30 m resolution"
msgstr ""

#: 
msgid "Copernicus DEM 90 m: ``dem_cop_90``, elevation data at 90 m resolution"
msgstr ""

#: 
msgid "DEM SRTM: ``dem_srtm``, elevation data at 1-arc second (~30 m)"
msgstr ""

#: 
msgid "DEM SRTM Derivatives: ``dem_srtm_deriv``, derivatives of the 1-arc second DEM which include:"
msgstr ""

#: 
msgid "**Slope (percent)**; this is the rate of elevation change, so mathematically speaking it is the first/primary derivative of elevation."
msgstr ""

#: 
msgid "**Multi-resolution Valley Bottom Flatness (MrVBF)**; this identifies valley bottoms (areas of deposition). Zero values indicate erosional terrain and values ≥1 and indicate progressively larger areas of deposition."
msgstr ""

#: 
msgid "**Multi-resolution Ridge Top Flatness (MrRTF)**; complementary to MrVBF, zero values indicate areas that are steep or low, and values ≥1 indicate progressively larger areas of high flat land."
msgstr ""

#: 
msgid "For further details on how these measurements were calculated see the `DEM derivatives repository <https://github.com/digitalearthafrica/dem-derivative>`__"
msgstr ""

#: 
msgid "In this notebook we will load the Copernicus 30 m DEM and the DEM derivatives using ``dc.load()``. Then we run through a short example analysis."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the DEM product available in the datacube 2. Using the ``dc.load()`` function to load in DEM data 3. Plotting DEM and derivatives 4. An example analysis which compares temperature at high and low elevation"
msgstr ""

#: 
msgid "The table below lists the products and measurements available for the DEM datasets indexed within DE Africa's datacube. We can see that the first three products contain a single measure for elevation, expressed in metres above sea level. The derivatives product comprises percent slope, multi-resolution valley bottom flatness (mrvbf), and multi-resolution ridge top flatness (mrrtf)."
msgstr ""

#: 
msgid "``lat``, ``lon``: The central latitude and longitude to analyse (e.g. -3.0674, 37.355)."
msgstr ""

#: 
msgid "``buffer``: The number of square degrees to load around the central latitude and longitude. For reasonable loading times, set this as 0.1 or lower."
msgstr ""

#: 
msgid "``resolution``: We use 30 m here for the ``dem_cop_30`` product."
msgstr ""

#: 
msgid "Load the Copernicus 30 m DEM data"
msgstr ""

#: 
msgid "Plot elevation"
msgstr ""

#: 
msgid "We can generate a basic plot of elevation below. The summit of Mt Kilimanjaro is 5,895m."
msgstr ""

#: 
msgid "Load DEM deriviatives"
msgstr ""

#: 
msgid "Now we can load the derivative dataset with the same parameters, except measurements."
msgstr ""

#: 
msgid "Plot derivatives"
msgstr ""

#: 
msgid "Plotting the three derivative measurements below shows areas of greater steepness around Mt Kilimanjaro. Most of the mountain has a 0 value for valley bottom and ridge tip flatness, whereas surrounding areas are identified as valleys and flat ridge tops."
msgstr ""

#: 
msgid "Analysis example: masking based on elevation"
msgstr ""

#: 
msgid "We can use elevation information to select or mask areas for analysis. In this example, we will compare climatic information between higher and lower elevation at the Virunga Mountains, a chain of volcanoes along the border of Rwanda, the Democratic Republic of the Congo, and Uganda."
msgstr ""

#: 
msgid "Below we set up some new analysis parameters:"
msgstr ""

#: 
msgid "``lat``, ``lon``: The central latitude and longitude to analyse for the Virunga Mountains (-1.4310, 29.5262)."
msgstr ""

#: 
msgid "``buffer``: The number of square degrees to load around the central latitude and longitude."
msgstr ""

#: 
msgid "``resolution``: We use 90 m here with the ``dem_cop_90`` product for faster loading and computation times."
msgstr ""

#: 
msgid "Load the Copernicus 90m DEM"
msgstr ""

#: 
msgid "Mask analysis to high and low elevation"
msgstr ""

#: 
msgid "For this analysis, we will split the dataset into areas above and below 2,000m in elevation. In the plot below we can see that this separates the chain of volcanoes from surrounding lowland."
msgstr ""

#: 
msgid "Load temperature data and compare between high and low elevation"
msgstr ""

#: 
msgid "We will use the ``load_era5`` function to load temperature data. More information on loading and using climate data can be found in the `Climate_Data_ERA5_AWS Datasets <Climate_Data_ERA5_AWS.ipynb>`__ notebook."
msgstr ""

#: 
msgid "To make our calculation we will need to reproject the climate data so it matches the elevation data. We use the ``xr_reproject`` function to do this. More information on reprojecting datacube data is available `here <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Frequently_used_code/Reprojecting_data.html>`__."
msgstr ""

#: 
msgid "We can see that average daily temperature tends to be lower at the altitudes >2,000m for our analysis area, according to the ERA5 reanalysis product."
msgstr ""

#: 
msgid "**Last tested:**"
msgstr ""

#: 
msgid "**Products used:** `fc_ls <https://explorer.digitalearth.africa/fc_ls>`__, `fc_ls_summary_annual <https://explorer.digitalearth.africa/fc_ls_summary_annual>`__, `wofs_ls <https://explorer.digitalearth.africa/wofs_ls>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`datasets; fractional_cover`, :index:`data used; fc_ls`, :index:`data used; fc_ls_summary_annual`, :index:`data used; wofs_ls`"
msgstr ""

#: 
msgid "The Fractional Cover (FC) product provides estimates of the proportions of green vegetation, non-green vegetation (including deciduous trees during autumn, dry grass, etc.), and bare soils for every Landsat pixel. Fractional cover provides valuable information for a range of environmental and agricultural applications, including:"
msgstr ""

#: 
msgid "The algorithm is developed by the `Joint Remote Sensing Research Program <https://www.jrsrp.org.au/>`__ (JRSRP) and is described in Scarth et al. (2010). Field data collected across Australia have been used to calibrate and validate the unmixing model. More information on the product can be found `here <http://data.auscover.org.au/xwiki/bin/view/Product+pages/Landsat+Seasonal+Fractional+Cover>`__."
msgstr ""

#: 
msgid "While the scened based Fractional Cover can be used to study dynamic processes, the annual summaries make it easier to analyse year to year changes. The percentiles provide robust estimates of the low, median and high proportion values observed for each cover type in a year, which can be used to characterise the land cover. Before the percentile calculation, areas of water and cloud cover, as mapped in the Water Observations from Space (WOfS) Feature Layer, are exluded."
msgstr ""

#: 
msgid "**Reference**"
msgstr ""

#: 
msgid "Scarth, P, Roder, A and Schmidt, M 2010, 'Tracking grazing pressure and climate interaction - the role of Landsat fractional cover in time series analysis', Proceedings of the 15th Australasian Remote Sensing & Photogrammetry Conference (ARSPC), 13-17 September, Alice Springs, Australia. Alice Springs, NT."
msgstr ""

#: 
msgid "This notebook will cover following topics:"
msgstr ""

#: 
msgid "Inspecting the products and measurements available in the datacube"
msgstr ""

#: 
msgid "Loading pre-generated FC data."
msgstr ""

#: 
msgid "Cloud and water masking FC with Water Observations from Space (WOfS) Feature Layers"
msgstr ""

#: 
msgid "Plotting FC and the FC annual summary"
msgstr ""

#: 
msgid "Inspecting unmixing error outputs"
msgstr ""

#: 
msgid "Conducting a simple analysis workflow with FC"
msgstr ""

#: 
msgid "Understand and load the FC annual summary data."
msgstr ""

#: 
msgid "Interpreting the annual summary percentiles"
msgstr ""

#: 
msgid "This section defines the analysis parameters, including"
msgstr ""

#: 
msgid "``time_period``: time period to be investigated"
msgstr ""

#: 
msgid "``output_crs``: projection for loading data; output resolution is not defined so different resolutions can be used for Landsat and Sentinel-2"
msgstr ""

#: 
msgid "The default location is an area along Olifants River, South Africa."
msgstr ""

#: 
msgid "Default resolution, spatial and temporal extents are chosen to limit the time required for calculating FC from Sentinel-2 surface reflectance."
msgstr ""

#: 
msgid "List products available in Digital Earth Africa"
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect the Fractional Cover products that are available. The table below shows the product names that we will use to load data."
msgstr ""

#: 
msgid "Note that there are two separate products. The ``fc_ls`` product gives fractional cover percentages at daily timesteps corresponding to Landsat overpass dates, whereas the ``fc_ls_summary_annual`` gives the 10th, 50th, and 90th percentile values, expressed as a percentage, for each of the bare soil, photosynthetic vegetation, and non-photosynthetic vegetation fractions. We'll explore this idea further in cells below."
msgstr ""

#: 
msgid "Loading pre-generated fractional cover data"
msgstr ""

#: 
msgid "FC has been calculated from Landsat Collection 2 surface reflectance, at 30 m spatial resolution. FC is generated from Landsat satellites 5, 7 and 8. Their data is combined into one product called ``'fc_ls'``."
msgstr ""

#: 
msgid "The unmixing algorithm breaks down when water or cloud is present. The ``Water Observations Feature Layer`` can be used to exclude these problematic pixels. For more information on bitmasking, see the `Applying WOfS bitmasking notebook <../Frequently_used_code/Applying_WOfS_bitmasking.ipynb>`__."
msgstr ""

#: 
msgid "Make a clear (no-cloud) and dry (no-water) pixel mask"
msgstr ""

#: 
msgid "If we like, we can keep mostly clear scenes by calculating the number of good pixels per scene and applying a threshold"
msgstr ""

#: 
msgid "``min_gooddata``: minimum fraction of good data required for a (FC or surface reflectance) scene to be kept"
msgstr ""

#: 
msgid "Now we can apply the \"clear mask\" and filter to just the scenes that are mostly free of cloud and water"
msgstr ""

#: 
msgid "Plotting fractional cover"
msgstr ""

#: 
msgid "We can plot each FC variable in our dataset (i.e. ``['bs', 'pv', 'npv']``) using the ``rgb`` function. This will create a false colour view of the data where shades of green, blue and red represent varying proportions of vegetation and bare soil cover:"
msgstr ""

#: 
msgid "Green: photosynthetic (green) vegetation (``'pv'``)"
msgstr ""

#: 
msgid "Blue: non-photosynthetic (i.e. 'non-green') vegetation (``'npv'``)"
msgstr ""

#: 
msgid "Red: bare soil (``'bs'``)"
msgstr ""

#: 
msgid "The chart on the right indicates how the RGB colour composition can be interpreted."
msgstr ""

#: 
msgid "In the area of interest used here, the resulting images show agricultural fields containing high proportions of green vegetation cover, surrounded by areas dominated by brown vegetation and bare soil."
msgstr ""

#: 
msgid "Inspecting unmixing error"
msgstr ""

#: 
msgid "Fractional cover values range between 0 and 100 %, but due to model uncertainties and the limitations of the training data, some areas may show cover values in excess of 100%. These areas can either be excluded or treated as equivalent to 100%."
msgstr ""

#: 
msgid "We can also visualise the 'unmixing error' (ue) for each of our Fractional Cover observations. High unmixing error values (bright colours below) represent areas of higher model uncertainty (e.g. areas of water, cloud we missed masking, or soil types/colours that were not included in the model training data). This data can be useful for removing uncertain pixels from an analysis."
msgstr ""

#: 
msgid "In this example, wet pixels associated with the river and the irrigated paddocks have relatively high unmixing errors. Additional filtering can be done by requiring the sum of the three fractions to be close to 100 % and/or the unxming error to be small. However, these constraints alone are not sufficient to exclude all problematic FC results."
msgstr ""

#: 
msgid "Example application: tracking changes in vegetation cover and bare soil over time"
msgstr ""

#: 
msgid "The following section will demonstrate a simple analysis workflow based on Fractional Cover. In this example, we will process our loaded FC data so that we can consistently track the changing proportions of green vegetation, brown vegetation and bare soil over time."
msgstr ""

#: 
msgid "The first step is to load FC, and then mask water and clouds, and then filter to images that are mostly clear. Fortunately, we have already done this above. We will print our data ``fc_clear`` again to remind ourselves of the datasets contents"
msgstr ""

#: 
msgid "Calculating average fractional cover over time"
msgstr ""

#: 
msgid "Now that our FC data has had nodata values and cloud, shadow and water pixels set to NaN, we can reliably track how average proportions of green and brown vegetation and bare soil have changed over time across our entire study area. We can then plot this as a line chart, showing that green vegetation (``pv``) has consistently decreased over time at this location, while bare soil (``bs``) has increased, and non-photosynthetic (``npv``) vegetation has been relatively stable."
msgstr ""

#: 
msgid "Understanding the FC annual summary"
msgstr ""

#: 
msgid "The fractional cover annual summary product gives annual percentile values for each of the three fractions (pv, bs, npv)."
msgstr ""

#: 
msgid "This idea is shown below where we plot a histogram of pv values for the area loaded above, with the pv % on the x-axis and density on the y-axis. We can see the distribution is positively skewed as most values are between 0% and 20%. The 10th, 50th, and 90th percentiles are plotted to demonstrate the information available in the annual summary product. In this case, the 10th percentile for pv is close to 0%, the 50th percentile is about 11% and the 90th percentile is about 47%."
msgstr ""

#: 
msgid "Omit missing values from dataset"
msgstr ""

#: 
msgid "Load the annual summary"
msgstr ""

#: 
msgid "The annual summary can be used to monitor changes from year to year."
msgstr ""

#: 
msgid "Plot and interpret the annual summary percentiles"
msgstr ""

#: 
msgid "For each cover type, 10th, 50th and 90th percentiles are estimated from all the clear and valid fraction measurements from a calendar year. As shown above, these percentiles provide estimates of the low, median and high values in a distribution that are robust against outliers."
msgstr ""

#: 
msgid "The example below shows the three percentiles for the green cover fraction, which can serve as proxies for the minimum, typical and maximum green cover for a given year."
msgstr ""

#: 
msgid "Because the percentiles are estimated independently for the three cover types, the 10th percentiles represent the low end of the measurements for the three covers, which may have been observed at different times of a year. Simiarly, the 90th percentiles respresent the high end of the measurements for the three covers, which may have occured at different times. These percentile values can be used separately or combined to understand the land cover dynamics."
msgstr ""

#: 
msgid "For example, using the 90th percentile PV as proxy for maximum green cover fraction that is observed within a year, irrigated fields are shown below to have achieved highest maximum green cover in all years."
msgstr ""

#: 
msgid "The 10th percentile BS can be used as proxy for lowest bare soil fraction observed in a year."
msgstr ""

#: 
msgid "Because at any given time, the three covers add up to 100 percent, the lowest bare soil fraction can be used to derive highest total vegetation cover."
msgstr ""

#: 
msgid "Difference between the 10th and 90th percentiles provides an estimate of the magnitude of change within a year. In this example, greater variation is observed in the agricultural land for all covers and as specifically shown below, the most significant changes in the green cover are observed in irrigated fields."
msgstr ""

#: 
msgid "Finally, a representative view of the landscape in a year can be obtained by combining the 50th percentiles, or the median values, for the three cover types. Changes from year to year can be visualized easily, which may be particularly useful for monitoring natural vegetation."
msgstr ""

#: 
msgid "**Products used:** `gm_s2_annual <https://explorer.digitalearth.africa/gm_s2_annual>`__, `gm_s2_semiannual <https://explorer.digitalearth.africa/gm_s2_semiannual>`__, `gm_ls8_ls9_annual <https://explorer.digitalearth.africa/products/gm_ls8_ls9_annual>`__, `gm_ls8_annual <https://explorer.digitalearth.africa/gm_ls8_annual>`__, `gm_ls5_ls7_annual <https://explorer.digitalearth.africa/gm_ls5_ls7_annual>`__,"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2 geomedian`, `data used; landsat 8 geomedian`, `data used; sentinel-2 semiannual geomedian`, index:`data used; MADs`, `data used; landsat 5 & 7 geomedian`, `data used; landsat 8 & 9 geomedian`"
msgstr ""

#: 
msgid "Satellite imagery allows us to observe the Earth with significant accuracy and detail. However, missing data — such as gaps caused by cloud cover — can make it difficult to put together a complete image."
msgstr ""

#: 
msgid "In order to produce a single, complete view of a certain area, satellite data must be consolidated, stacking measurements from different points in time to create a composite image."
msgstr ""

#: 
msgid "The Digital Earth Africa (DE Africa) GeoMAD (**Geo**\\ median and **M**\\ edian **A**\\ bsolute **D**\\ eviations) is a cloud-free composite of satellite data compiled for over annual and semi-annual (six-month) periods during each calendar year."
msgstr ""

#: 
msgid "The following GeoMAD products are available on DE Africa platforms:"
msgstr ""

#: 
msgid "``gm_s2_annual``: Annual (calendar year) GeoMAD composite using Sentinel-2 imagery, available for the years **2017 - present**"
msgstr ""

#: 
msgid "``gm_s2_semiannual``: bi-annual (Jan-Jun, Jul-Dec) GeoMAD composites using Sentinel-2 imagery, available for the years **2017 - present**"
msgstr ""

#: 
msgid "``gm_ls8_ls9_annual``: Annual (calendar year) GeoMAD composite using Landsat-8 and Landsat-9 imagery, available for the years **2021 - present**"
msgstr ""

#: 
msgid "``gm_ls8_annual``: Annual (calendar year) GeoMAD composite using Landsat-8 imagery, available for the years **2013 - 2020**"
msgstr ""

#: 
msgid "``gm_ls5_ls7_annual``: Annual (calendar year) GeoMAD composite combining both Landsat-5 and Landsat-7 imagery, available for the years **1984 - 2012**"
msgstr ""

#: 
msgid "Each product combines measurements collected over a defined period (annual or semi-annual) to produce one representative, multi-spectral image for every pixel of the African continent. The end result is a comprehensive dataset that can be used either to generate true-colour images for visual inspection of the landsacpe, or the full spectral dataset can be used to develop more complex algorithms."
msgstr ""

#: 
msgid "To produce a GeoMAD composite, for each pixel, invalid data is discarded, and the remaining observations are mathematically summarised using a high-dimensional geomedian statistic. GeoMAD also includes three measures of Median Absolute Deviation (MAD). These are higher-order statistical measurements on variation relative to the geomedian, pre-calculated at the same annual time scale. These layers can be used on their own or together with geomedian to gain insights about the land surface and understand its change over time. For a detailed description on how the GeoMAD is calculated, see the `GeoMAD technical specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__."
msgstr ""

#: 
msgid "Datacube product names: ``gm_s2_annual``, ``gm_s2_semiannual``, ``gm_ls8_ls9_annual``, ``gm_ls8_annual``, ``gm_ls5_ls7_annual``"
msgstr ""

#: 
msgid "Geomedian surface reflectance product"
msgstr ""

#: 
msgid "Valid scaling range: ``1 - 10,000``"
msgstr ""

#: 
msgid "``0`` is ``no data``"
msgstr ""

#: 
msgid "Median Absolute Deviation product"
msgstr ""

#: 
msgid "Valid scaling range: Spectral MAD: ``0 - 1`` , Bray-Curtis MAD ``0 - 1``, Euclidean MAD ``0 - 10,000``"
msgstr ""

#: 
msgid "``NaN`` is ``nodata``"
msgstr ""

#: 
msgid "Status: Operational"
msgstr ""

#: 
msgid "Date-range: 1984 – present"
msgstr ""

#: 
msgid "Spatial resolution: 10m for S2 products, 30m for Landsat products"
msgstr ""

#: 
msgid "Note: For a detailed description of DE Africa's GeoMAD service, see the DE Africa `GeoMAD technical specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__."
msgstr ""

#: 
msgid "In this notebook we will load GeoMAD data using ``dc.load()`` to return a time series of satellite images. The returned xarray.Dataset will contain analysis-ready images."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the GeoMAD products and measurements available in the datacube 2. Using the native ``dc.load()`` function to load in GeoMAD data \\* Geomedian surface reflectance example \\* Median Absolute Deviations example 3. A simple example anlaysis using GeoMAD 4. An interactive widget for understanding the geomedian statistic"
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect the DE Africa GeoMAD products that are available in the datacube. The table below shows the product names that we will use to load the data, a brief description of the data, and the satellite instrument that acquired the data."
msgstr ""

#: 
msgid "We can further inspect the data available for GeoMAD using datacube's ``list_measurements`` functionality. The table below lists each of the measurements available in the data."
msgstr ""

#: 
msgid "Below, enter the name of the product you would like to see the measurements of. In the default example, we will examine ``gm_s2_annual``, the Sentinel-2 Annual GeoMAD service."
msgstr ""

#: 
msgid "Let's also inpsect the measurements of the Landsat 8-9 GeoMAD, ``gm_ls8_ls9_annual``"
msgstr ""

#: 
msgid "Load GeoMAD data using ``dc.load()``"
msgstr ""

#: 
msgid "Example 1: Surface reflectance"
msgstr ""

#: 
msgid "In the first example below, we will load GeoMAD data from the Eye of Africa in the Sahara Desert, Mauritania, from 2020. We will load data from three spectral satellite bands: ``red``, ``green``, and ``blue``."
msgstr ""

#: 
msgid "Plotting GeoMAD geomedian data"
msgstr ""

#: 
msgid "We can plot the data we loaded using the ``deafrica_tools.plotting.rgb()`` function. By default, the function will plot data as a true colour image using the 'red', 'green', and 'blue' bands."
msgstr ""

#: 
msgid "Example 2 - Median Absolute Deviations"
msgstr ""

#: 
msgid "In this example, we load the Median Absolute Deviation (MAD) bands of data and plot a false-colour map using those three bands. The area selected a farming district around Oum Er-Rbia Rover in Morocco."
msgstr ""

#: 
msgid "Plotting GeoMAD MAD data"
msgstr ""

#: 
msgid "MAD data has three bands (SMAD, EMAD, BCMAD) and is therefore well-suited to being visualised in false-colour. This means each of the MADs is assigned to one of the red, green, and blue colour channels of the image."
msgstr ""

#: 
msgid "Inspecting the xarray.Dataset above, we can see that the scaling of ``smad (0-1)``, ``emad (0-10,000)`` and ``bcmad (0-1)`` all have very different orders of magnitude. That means if we plot them as a three band RGB image (i.e. specifying the argument ``rgb(bands=[\"emad\", \"smad\", \"bcmad\"]``) for false-colour), the larger values in ``emad`` will oversaturate the image (try it!)."
msgstr ""

#: 
msgid "To compensate for the different ranges in the dataset, we can scale the data for each of the three bands according to the range of values present in that band. This brings all the MADs to approximately the same range of values. The plot will then represent each MAD more equally, allowing features with high variability in all three measures to be readily identified by visual inspection."
msgstr ""

#: 
msgid "There are two types of scaling: fixed, and dynamic."
msgstr ""

#: 
msgid "Fixed scaling is useful when you are comparing multiple areas and want to have the same scale on each. It is used in the GeoMAD WMS layer and `Digital Earth Africa Maps <https://maps.digitalearth.africa/>`__ portal for the MADs data. > On the Maps portal, select 'Add Data' > 'Satellite images' > 'Surface reflectance' > 'Annual' > 'Annual GeoMAD (Sentinel-2)' to view GeoMAD data. For instructions on connecting to the DE Africa GIS web services, see `this tutorial <https://docs.digitalearthafrica.org/en/latest/platform_tools/index.html>`__."
msgstr ""

#: 
msgid "In this notebook, we will demonstrate a dynamic scale. This scale is automatically adjusted depending on the area of interest selected, depending on the range of data values for each of the MADs. This is more suitable when investigating a certain area of interest as the scale is tailored to the data contained in that area."
msgstr ""

#: 
msgid "The dynamic scale here uses a ``log`` function to transform each MAD datapoint. The range is cut off at the 2nd and 98th percentiles, removing extreme outliers."
msgstr ""

#: 
msgid "In this case, for each MAD we have used the scaling:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} \\text{MAD}_{\\text{scaled}} = \\frac{\\log{\\text{MAD}} -  \\log \\text{MAD}_{\\text{2 percentile}}}{\\log \\text{MAD}_{\\text{98 percentile}} - \\log \\text{MAD}_{\\text{2 percentile}}} \\end{align*}`"
msgstr ""

#: 
msgid "This is just one example of scaling that can be used to transform the MADs data to a common order of magnitude, without skewing the data. Scaling can be adjusted to suit the purpose or application of the data."
msgstr ""

#: 
msgid "Below we will plot the True colour image for the region alongside our scaled RGB image of the three MAD measurements. The chart below indicates how the RGB colour composition can be interpreted. Areas where all three measures have high values indicates locations where the pixel undergoes a high degree of variation during the year. In this example, the irrigated fields along the river are highly vairable and show up as white in the image."
msgstr ""

#: 
msgid "Example application: Identifying irrigated areas using SMAD"
msgstr ""

#: 
msgid "The following section will demonstrate a simple analysis workflow based on the GeoMAD product. In this example, we will threshold the SMAD band to distinguish irrigated agriclutural fields from rain-fed agricultural fields."
msgstr ""

#: 
msgid "First, lets reload our data over the same region as above. We will load the ``red``, ``green``, and ``blue`` bands, along with ``smad``"
msgstr ""

#: 
msgid "Now plot the ``smad`` band to see if it is useful for distinguishing between irrigated and non-irrigated fields"
msgstr ""

#: 
msgid "It looks like ``smad`` will be useful for identifying irrigation, so lets define a threshold using the ``skimage.filters.threshold_li`` method. This method will automatically find the optimal threhold based on minimizing the cross-entropy between the foreground and the foreground mean, and the background and the background mean"
msgstr ""

#: 
msgid "Apply the threshold and plot the result"
msgstr ""

#: 
msgid "Interactive widget: Understanding the geomedian"
msgstr ""

#: 
msgid "|widget.png|"
msgstr ""

#: 
msgid "widget.png"
msgstr ""

#: 
msgid "*An example of the geomedian interactive widget.*"
msgstr ""

#: 
msgid "The Digital Earth Africa Docs website is read-only. Log in to the `Digital Earth Africa Sandbox <https://sandbox.digitalearth.africa/>`__ and navigate to the **Datasets** folder > **GeoMAD** to interact with the widget."
msgstr ""

#: 
msgid "In this interactive widget example, you have a dataset of Earth observation satellite data. It contains the red, green, and blue bands, which are the bands generally used to generate colour images. The widget focuses on a single pixel that has data for 3 different timesteps. We can composite (combine) these 3 timesteps into one using a statistical composition method such as ``median`` or ``geomedian``."
msgstr ""

#: 
msgid "This widget shows that the median does **not** always account for very large or very small band values, and may not be particularly representative of the variation we see in the three timesteps."
msgstr ""

#: 
msgid "Variation is better incorporated into the ``Geomedian RGB - All timesteps`` result, as the geomedian formula treats each timestep as a multi-dimensional vector. We see this results in differing values between the median and geomedian."
msgstr ""

#: 
msgid "For example, try:"
msgstr ""

#: 
msgid "Timestep 1: (0,0,0)"
msgstr ""

#: 
msgid "Timestep 2: (0, 255, 0)"
msgstr ""

#: 
msgid "Timestep 3: (255, 255, 255)"
msgstr ""

#: 
msgid "The geomedian shows a more representative value that incorporates some of the variation across the timesteps."
msgstr ""

#: 
msgid "**Products used:** `gmw <https://explorer.digitalearth.africa/products/gmw>`__"
msgstr ""

#: 
msgid "**Keywords**: :index: 'data used; Global Mangrove Watch', :index: 'datasets; gmw'"
msgstr ""

#: 
msgid "The **G**\\ lobal **M**\\ angrove **W**\\ atch dataset provides information about mangrove extent. It uses ALOS PALSAR and Landsat (optical) data to form a baseline extent of mangroves. This dataset has been rasterized and indexed from the `UN Environment Program <https://data.unep-wcmc.org/datasets/45>`__ into DE Africa's Open Data Cube. It can also be visualised in the `Global Mangrove Extent Explorer <https://www.globalmangrovewatch.org/?map=eyJiYXNlbWFwIjoibGlnaHQiLCJ2aWV3cG9ydCI6eyJsYXRpdHVkZSI6MjAsImxvbmdpdHVkZSI6MCwiem9vbSI6MiwiYmVhcmluZyI6MCwicGl0Y2giOjB9fQ%3D%3D>`__."
msgstr ""

#: 
msgid "The dataset can be used to identify mangrove ecosystems and monitor changes in mangrove extent. This is important in applications such as quantifying 'blue carbon', mitigating risks from natural disasters, and prioritising restoration activities."
msgstr ""

#: 
msgid "This dataset is available in 0.0002 degrees resolution (~ 24 m) for the following years: \\* 1996 \\* 2007 \\* 2008 \\* 2009 \\* 2010 \\* 2015 \\* 2016 \\* 2017 \\* 2018 \\* 2019 \\* 2020"
msgstr ""

#: 
msgid "Bunting P., Rosenqvist A., Lucas R., Rebelo L-M., Hilarides L., Thomas N., Hardy A., Itoh T., Shimada M. and Finlayson C.M. (2018). The Global Mangrove Watch – a New 2010 Global Baseline of Mangrove Extent. Remote Sensing 10(10): 1669. doi: 10.3390/rs1010669"
msgstr ""

#: 
msgid "In this notebook we will load the Global Mangrove Watch dataset using ``dc.load()``. Then we run through a short comparison of mangrove extent between years."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the gmw product available in the datacube 2. Using the ``dc.load()`` function to load in gmw data 3. Plotting gmw"
msgstr ""

#: 
msgid "The table below shows that the measurement in the Global Mangrove Watch dataset is called 'mangrove', which is a binary classification where 1 corresponds to mangroves and 0 is no mangroves."
msgstr ""

#: 
msgid "Set parameters"
msgstr ""

#: 
msgid "``lat``, ``lon``: The central latitude and longitude to analyse e.g. -16.2818, 39.8633 along the coast of Mozambique"
msgstr ""

#: 
msgid "``buffer``: The number of square degrees to load around the central latitude and longitude. For quick loading times, set this as 0.1 or lower."
msgstr ""

#: 
msgid "``resolution``: We use 20 m here, as it is closest to the native resolution of 0.0002 degrees."
msgstr ""

#: 
msgid "Load the Global Mangrove Watch data"
msgstr ""

#: 
msgid "Plot mangrove extent"
msgstr ""

#: 
msgid "We can generate a basic plot of mangrove extent for each of the available years below."
msgstr ""

#: 
msgid "Analysis example: mangrove area calculation"
msgstr ""

#: 
msgid "In this notebook, we conduct a simple calculation of mangrove area as an analysis example. A much more comprehensive and detailed example of mangrove analysis is available in `real world examples. <../Real_world_examples/Mangrove_analysis.ipynb>`__ The real world example classifies mangroves as 'closed' or 'regular' and identifies areas of mangrove growth and loss."
msgstr ""

#: 
msgid "Calculate area"
msgstr ""

#: 
msgid "We can calculate the area of mangroves in each of the seven available years, then look for change. In this case ~1,500 Ha of mangrove has disapeared since 1996. Again, the `mangrove analysis notebook <../Real_world_examples/Mangrove_analysis.ipynb>`__ in real world examples gives a more comprehensive example of assessing changes in mangrove extent."
msgstr ""

#: 
msgid "High Resolution Population Density Maps"
msgstr ""

#: 
msgid "**Products used:** `High Resolution Population Density Maps + Demographic Estimates by CIESIN and Meta <https://registry.opendata.aws/dataforgood-fb-hrsl/>`__"
msgstr ""

#: 
msgid "*This dataset is external to the Digital Earth Africa platform.*"
msgstr ""

#: 
msgid "Africa is the second most populous continent in the world and has a rapidly growing population. Population growth and its spatial distribution are important factors to be considered for sustainable development. For example, spatially distributed population and demographic information can be used to support infrastructure planning and understand potential impact of environmental changes and disasters on lives."
msgstr ""

#: 
msgid "`High Resolution Population Density Maps + Demographic Estimates by CIESIN and Meta <https://registry.opendata.aws/dataforgood-fb-hrsl/>`__ provides population data at approximately 30 m spatial resolution, i.e. estimate of the number of people living within 30-by-30-meter grid cells. The dataset is created by Meta and the Center for International Earth Science Information Network (CIESIN) at Columbia University. It combines information from census and building identification from high resolution satellite imagery. In addition to overall population density, data are available in the following demographic categories: \\* Male \\* Female \\* Women of reproductive age (ages 15-49) \\* Children (ages 0-5) \\* Youth (ages 15-24) \\* Elderly (ages 60+)"
msgstr ""

#: 
msgid "More information on the method used can be found at https://dataforgood.facebook.com/dfg/docs/methodology-high-resolution-population-density-maps"
msgstr ""

#: 
msgid "This notebook will demonstrate how to load and visualize population data."
msgstr ""

#: 
msgid "The population data is hosted in AWS region ``us-east-1``, therefor we set the AWS region to ``us-east-1`` when running this notebook. The AWS region needs to be changed to ``af-south-1`` to access DEAfrica data."
msgstr ""

#: 
msgid "The default location is in Johannesburg, South Africa."
msgstr ""

#: 
msgid "Loading genenral population data"
msgstr ""

#: 
msgid "The gridded population data are provided in Cloud-Optimized Geotiffs (COGs) covering 10 by 10 degree tiles. We will access the latest version of the COGs through a virtual raster (VRT)."
msgstr ""

#: 
msgid "By setting the ``chunks`` parameter, data is lazy-loaded as a ``dask array`` first."
msgstr ""

#: 
msgid "Loading population data in different demographic categories"
msgstr ""

#: 
msgid "In the example below, we will load and visualize population for Youth (ages 15-24) and Women."
msgstr ""

#: 
msgid "Land Use Land Cover Maps"
msgstr ""

#: 
msgid "**Products used:** `io_lulc <https://explorer.digitalearth.africa/products/io_lulc>`__, `esa_worldcover_2020 <https://explorer.digitalearth.africa/products/esa_worldcover_2020>`__, `esa_worldcover_2021 <https://explorer.digitalearth.africa/products/esa_worldcover_2021>`__, `cgls_landcover <https://explorer.digitalearth.africa/products/cgls_landcover>`__, `cci_landcover <https://explorer.digitalearth.africa/products/cci_landcover>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ESRI Land Cover`, :index:`datasets; io_lulc`, :index:`data used; ESA WorldCover`, :index:`datasets; esa_worldcover_2020` :index:`data used; Copernicus Global Land Service, Land Use/Land Cover at 100 m`, :index:`datasets; cgls_landcover` :index:`data used; ESA Climate Change Initiative Land Cover`, :index:`datasets; cci_landcover`"
msgstr ""

#: 
msgid "**L**\\ and **U**\\ se/\\ **L**\\ and **C**\\ over (LULC) maps classify land into broad categories such as water, crops, or built area. They are useful for visualising the dominant land uses in a given area. The total area or proportion of different classes can also be calculated for a specified area."
msgstr ""

#: 
msgid "Many organisations publish LULC maps. DE Africa provides access to `the Environmental Systems Research Institute (Esri)/Impact Observatory (IO) land use/land cover (LULC) <https://www.arcgis.com/home/item.html?id=d3da5dd386d140cf93fc9ecbf8da5e31>`__, `European Space Agency (ESA) WorldCover <https://esa-worldcover.org/en>`__, `Copernicus Global Land Service (CGLS) Land Use/Land Cover at 100 m <https://land.copernicus.eu/global/content/annual-100m-global-land-cover-maps-available>`__, and `ESA Climate Change Initiative (CCI) land cover <https://www.esa-landcover-cci.org/>`__. The ESRI/IO and ESA products are derived from ESA Sentinel imagery and are available at 10 m resolution annually from 2017, 2020 and 2021 respectively over the entire African continent. The CGLS product is available at 100 m resolution, is updated annually and is currently available from 2015 to 2019. The ESA CCI landcover product is available at 300 resolution, is updated annually and is currently available from 1992 to 2019 ."
msgstr ""

#: 
msgid "The accuracy of landcover maps changes with location and class, so its important to understand the quality of the maps. ESRI publishes information on the accuracy of the 2020 (10 class version) LULC product, which is neatly summarised in the confusion matrix located `here <https://www.arcgis.com/home/item.html?id=d6642f8a4f6d4685a24ae2dc0c73d4ac>`__. The overall accuracy for all classes is 85 %. Keep in mind that the accuracy statistics in the link are for the globe and not specific to Africa."
msgstr ""

#: 
msgid "ESA's WorldCover product comes with an in-depth report on the quality of the product, which we will not reproduce here. However, the full product validation report can be found using the following link: https://esa-worldcover.org/en/data-access. The overall accuracy of the 2020 product for Africa is 73.6%, and it improved to 76.5% in 2021."
msgstr ""

#: 
msgid "The Copernicus Global Land Cover 100m product has a `scientific publication <https://www.sciencedirect.com/science/article/pii/S0034425721004065?via%3Dihub>`__ exploring the accuracy of the annual landcover maps. The overall accuracy for Africa is ~80 %."
msgstr ""

#: 
msgid "**Important details:** \\* Classes and values"
msgstr ""

#: 
msgid "io_lulc value"
msgstr ""

#: 
msgid "io_lulc class"
msgstr ""

#: 
msgid "esa value"
msgstr ""

#: 
msgid "esa class"
msgstr ""

#: 
msgid "cgls value"
msgstr ""

#: 
msgid "cgls class"
msgstr ""

#: 
msgid "cci value"
msgstr ""

#: 
msgid "cci class"
msgstr ""

#: 
msgid "tree cover"
msgstr ""

#: 
msgid "shrubs"
msgstr ""

#: 
msgid "cropland, rainfed"
msgstr ""

#: 
msgid "trees"
msgstr ""

#: 
msgid "shrubland"
msgstr ""

#: 
msgid "herbaceous vegetation"
msgstr ""

#: 
msgid "cropland, rainfed, herbaceous cover"
msgstr ""

#: 
msgid "not used"
msgstr ""

#: 
msgid "grassland"
msgstr ""

#: 
msgid "40"
msgstr ""

#: 
msgid "cultivated and managed vegetation or agriculture"
msgstr ""

#: 
msgid "cropland, rainfed, tree or shrub cover"
msgstr ""

#: 
msgid "flooded vegetation"
msgstr ""

#: 
msgid "cropland"
msgstr ""

#: 
msgid "urban or built up"
msgstr ""

#: 
msgid "cropland, irrigated or post-flooding"
msgstr ""

#: 
msgid "built up"
msgstr ""

#: 
msgid "bare or sparse vegetation"
msgstr ""

#: 
msgid "mosaic cropland/natural vegetation"
msgstr ""

#: 
msgid "bare/sparse vegetation"
msgstr ""

#: 
msgid "70"
msgstr ""

#: 
msgid "snow and ice"
msgstr ""

#: 
msgid "mosaic natural vegetation/cropland"
msgstr ""

#: 
msgid "built area"
msgstr ""

#: 
msgid "80"
msgstr ""

#: 
msgid "permanent water bodies"
msgstr ""

#: 
msgid "tree cover, broadleaved, evergreen, closed to open"
msgstr ""

#: 
msgid "bare ground"
msgstr ""

#: 
msgid "90"
msgstr ""

#: 
msgid "herbaceous wetland"
msgstr ""

#: 
msgid "tree cover, broadleaved, deciduous, closed to open"
msgstr ""

#: 
msgid "snow/ice"
msgstr ""

#: 
msgid "moss and lichen"
msgstr ""

#: 
msgid "61"
msgstr ""

#: 
msgid "tree cover, broadleaved, deciduous, closed"
msgstr ""

#: 
msgid "clouds"
msgstr ""

#: 
msgid "95"
msgstr ""

#: 
msgid "mangroves"
msgstr ""

#: 
msgid "111"
msgstr ""

#: 
msgid "closed forest, evergreen needle leaf"
msgstr ""

#: 
msgid "62"
msgstr ""

#: 
msgid "tree cover, broadleaved, deciduous, open"
msgstr ""

#: 
msgid "rangeland"
msgstr ""

#: 
msgid "112"
msgstr ""

#: 
msgid "closed forest, evergreen broad leaf"
msgstr ""

#: 
msgid "tree cover, needleleaved, evergreen, closed to open"
msgstr ""

#: 
msgid "113"
msgstr ""

#: 
msgid "closed forest, deciduous needle leaf"
msgstr ""

#: 
msgid "71"
msgstr ""

#: 
msgid "tree cover, needleleaved, evergreen, closed"
msgstr ""

#: 
msgid "114"
msgstr ""

#: 
msgid "closed forest, deciduous broad leaf"
msgstr ""

#: 
msgid "72"
msgstr ""

#: 
msgid "tree cover, needleleaved, evergreen, open"
msgstr ""

#: 
msgid "115"
msgstr ""

#: 
msgid "closed forest, mixed"
msgstr ""

#: 
msgid "tree cover, needleleaved, deciduous, closed to open"
msgstr ""

#: 
msgid "116"
msgstr ""

#: 
msgid "closed forest, unknown"
msgstr ""

#: 
msgid "81"
msgstr ""

#: 
msgid "tree cover, needleleaved, deciduous, closed"
msgstr ""

#: 
msgid "121"
msgstr ""

#: 
msgid "open forest, evergreen needle leaf"
msgstr ""

#: 
msgid "82"
msgstr ""

#: 
msgid "tree cover, needleleaved, deciduous, open"
msgstr ""

#: 
msgid "122"
msgstr ""

#: 
msgid "open forest, evergreen broad leaf"
msgstr ""

#: 
msgid "tree cover, mixed leaf type"
msgstr ""

#: 
msgid "123"
msgstr ""

#: 
msgid "open forest, deciduous needle leaf"
msgstr ""

#: 
msgid "mosaic tree and shrub/herbaceous cover"
msgstr ""

#: 
msgid "124"
msgstr ""

#: 
msgid "open forest, deciduous broad leaf"
msgstr ""

#: 
msgid "110"
msgstr ""

#: 
msgid "mosaic herbaceous cover/tree and shrub"
msgstr ""

#: 
msgid "125"
msgstr ""

#: 
msgid "open forest, mixed"
msgstr ""

#: 
msgid "126"
msgstr ""

#: 
msgid "open forest, unknown"
msgstr ""

#: 
msgid "shrubland, evergreen"
msgstr ""

#: 
msgid "200"
msgstr ""

#: 
msgid "open sea"
msgstr ""

#: 
msgid "shrubland, deciduous"
msgstr ""

#: 
msgid "130"
msgstr ""

#: 
msgid "140"
msgstr ""

#: 
msgid "lichens and mosses"
msgstr ""

#: 
msgid "sparse vegetation"
msgstr ""

#: 
msgid "151"
msgstr ""

#: 
msgid "sparse tree"
msgstr ""

#: 
msgid "152"
msgstr ""

#: 
msgid "sparse shrub"
msgstr ""

#: 
msgid "153"
msgstr ""

#: 
msgid "sparse herbaceous cover"
msgstr ""

#: 
msgid "160"
msgstr ""

#: 
msgid "tree cover, flooded, fresh or brakish water"
msgstr ""

#: 
msgid "170"
msgstr ""

#: 
msgid "tree cover, flooded, saline water"
msgstr ""

#: 
msgid "180"
msgstr ""

#: 
msgid "shrub or herbaceous cover, flooded, fresh/saline/brakish water"
msgstr ""

#: 
msgid "190"
msgstr ""

#: 
msgid "urban areas"
msgstr ""

#: 
msgid "bare areas"
msgstr ""

#: 
msgid "201"
msgstr ""

#: 
msgid "consolidated bare areas"
msgstr ""

#: 
msgid "202"
msgstr ""

#: 
msgid "unconsolidated bare areas"
msgstr ""

#: 
msgid "210"
msgstr ""

#: 
msgid "water bodies"
msgstr ""

#: 
msgid "220"
msgstr ""

#: 
msgid "permanent snow and ice"
msgstr ""

#: 
msgid "Time range and spatial resolution"
msgstr ""

#: 
msgid "**io_lulc**"
msgstr ""

#: 
msgid "**esa_worldcover**"
msgstr ""

#: 
msgid "**cgls_landcover**"
msgstr ""

#: 
msgid "**cci_landcover**"
msgstr ""

#: 
msgid "**Time-range**"
msgstr ""

#: 
msgid "2017-2021"
msgstr ""

#: 
msgid "2020-2021"
msgstr ""

#: 
msgid "2015-2019"
msgstr ""

#: 
msgid "**Spatial resolution**"
msgstr ""

#: 
msgid "100m"
msgstr ""

#: 
msgid "300m"
msgstr ""

#: 
msgid "In this notebook we will load LULC data using ``dc.load()`` to return a map of land use and land cover classes for a specified area."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the LULC product available in the datacube 2. Using the ``dc.load()`` function to load in LULC data 3. Plotting LULC using the ``plot_lulc()`` function 4. An example analysis of the area of LULC classes in a given area 5. Loading and plotting the 'cover fractions' in CGLS"
msgstr ""

#: 
msgid "We can inspect the data available for LULC using datacube's ``list_measurements`` functionality. The table below lists the products and measurements available for the two LULC datasets indexed within DE Africa's datacube. We can see that the product contains one layer named 'classification'. The datatype is integer, which corresponds to a LULC class."
msgstr ""

#: 
msgid "``resolution``: the pixel resolution to use for loading the LULC dataset. The native resolution of the product is 10 metres i.e. ``(-10,10)``"
msgstr ""

#: 
msgid "``measurements``: the 'band' or measurement to load from the product, we can use the native measurement names of one of the aliases"
msgstr ""

#: 
msgid "The default location is Madagascar"
msgstr ""

#: 
msgid "Load the LULC datasets"
msgstr ""

#: 
msgid "First, we'll load the ESRI Land Cover. For this annual product, the time window listed in the metadata for a year is from 1 Jan to 1 Jan next year, e.g. 2020 data has a start date of 1 Jan 2020 and end date of 1 Jan 2021. We therefore define the query with both year and month to avoid loading data from a neighboring year."
msgstr ""

#: 
msgid "Now we can load the ``esa_worldcover_2020``,\\ ``esa_worldcover_2021``, ``cgls_landcover``, and ``cci_landcover`` products over the same region."
msgstr ""

#: 
msgid "Plotting data"
msgstr ""

#: 
msgid "We can plot LULC for Madagascar and add a legend which corresponds to the classes using the DE Africa wrapper function ``plot_lulc``. We can see that trees dominate the eastern areas of the island, while scrub/shrub is more prevalent on the western side. We can also identify a few cities/towns with the red 'built area' class. You may also notice that the different datasets don't always agree."
msgstr ""

#: 
msgid "Example Analysis: Investigate the area of classes"
msgstr ""

#: 
msgid "In this example, we will look more closely at the city of Antananarivo, the capital of Madagascar, which can be seen in red in the map above. We will load all LULC datasets, calculate the area of each class in each product, and compare the area of classes between the products. As we are looking at a smaller area, we can load the datasets at 100m resolution (its good practice to down-sample higher resolution datasets to a coarser resolution than vice-versa). We use the 'mode' statistic to down sample the 10m datasets to 100m resolution, this means each pixel will be assigned the most-common class within the 100m metre pixel."
msgstr ""

#: 
msgid "First, let's set up some new parameters"
msgstr ""

#: 
msgid "View selected location"
msgstr ""

#: 
msgid "Load LULC data for Antananarivo"
msgstr ""

#: 
msgid "Plot the datasets"
msgstr ""

#: 
msgid "Calculate the area of each class"
msgstr ""

#: 
msgid "We can use the numpy ``np.unique`` function to return the pixel count for each class."
msgstr ""

#: 
msgid "We can see above that result is an array with classes 1:11 which corresponds to ``water`` through to ``rangeland``, and the count of pixels within these classes. Using the resolution we set in our data loading query, we can calculate the total area of each class in square kilometres and plot the results. Does the plot align with the proportions of classes we can visualise in the map of Antananarivo?"
msgstr ""

#: 
msgid "For more information on area calculations see the water extent calculation section of the Digital Earth Africa Sandbox `training course <https://learn.digitalearthafrica.org/courses/course-v1:digitalearthafrica+DEA101+2021/course/>`__."
msgstr ""

#: 
msgid "Plot the area of each class"
msgstr ""

#: 
msgid "In the plot below, are the proportions of classes similar between the products? What are the classes that typically show confusion?"
msgstr ""

#: 
msgid "Explore CGLS cover fraction"
msgstr ""

#: 
msgid "In the above analysis we can see that the CGLS product classifies a lof of the area in our Antananarivo bounds as 'urban or built up'. Let's see how this relates to the builtup cover fraction measurement in the CGLS product."
msgstr ""

#: 
msgid "The cover fraction measurements in CGLS express the percentage of the pixel that is covered by a specific class of land cover, in this case urban or built-up. We can see below that the percentage cover of urban or built-up area corresponds spatially to the landcover classification."
msgstr ""

#: 
msgid "**Products used:** `ls5_sr <https://explorer.digitalearth.africa/ls5_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/ls7_sr>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 9`, :index:`data used; landsat 8`, :index:`data used; landsat 7`, :index:`data used; landsat 5`, :index:`datasets; landsat 8`, :index:`datasets; landsat 7`, :index:`datasets; landsat 5`,"
msgstr ""

#: 
msgid "The United States Geological Survey's (USGS) `Landsat satellite program <https://www.nasa.gov/mission_pages/landsat/overview/index.html>`__ has been capturing images of the African continent for more than 30 years. These data are highly useful for land and coastal mapping studies."
msgstr ""

#: 
msgid "DE Africa's Landsat data is ingested from the `USGS Collection 2, Level 2 <https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-2?qt-science_support_page_related_con=1#qt-science_support_page_related_con>`__ archive and forms a single, cohesive Analysis Ready Data (ARD) package, which allows you to analyse surface reflectance data as-is without the need to apply additional corrections."
msgstr ""

#: 
msgid "Surface reflectance product"
msgstr ""

#: 
msgid "Native scaling range: ``1 - 65,455`` (``0`` is ``no-data``)"
msgstr ""

#: 
msgid "To achieve surface reflectance values, normalise values to ``0 - 1`` using ``ds = ds * 2.75e-5 - 0.2``"
msgstr ""

#: 
msgid "Using ``dc.load`` will load data in the native scaling range ``1 - 65,455``, while using ``load_ard`` will scale the values"
msgstr ""

#: 
msgid "`CFMask <https://github.com/USGS-EROS/espa-cloud-masking/tree/master/cfmask>`__ used as cloud mask"
msgstr ""

#: 
msgid "Spatial resolution: 30 x 30 m"
msgstr ""

#: 
msgid "For a detailed description of DE Africa's Landsat archive, see the DE Africa's `Landsat surface reflectance technical specifications documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html>`__."
msgstr ""

#: 
msgid "In this notebook we will load **Landsat** data using two methods. Firstly, we will use `dc.load() <../Beginners_guide/03_Loading_data.ipynb>`__ to return a time series of satellite images from a single sensor."
msgstr ""

#: 
msgid "Secondly, we will load a time series using the `load_ard() <../Frequently_used_code/Using_load_ard.ipynb>`__ function, which is a wrapper function around the ``dc.load`` module. This function will load all the images from Landsat 5,7,8 & 9, combine them, and then apply a cloud mask. The returned ``xarray.Dataset`` will contain analysis ready images with the cloudy and invalid pixels masked out."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the Landsat products and measurements available in the datacube 2. Using the native ``dc.load()`` function to load in Landsat data from a single satellite 3. Using the ``load_ard()`` wrapper function to load in a concatenated, sorted, and cloud masked time series from Landsat 5, 7, 8 & 9."
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect DE Africa's Landsat products that are available in the datacube. The table below shows the product names that we will use to load the data, a brief description of the data, and the satellite instrument that acquired the data."
msgstr ""

#: 
msgid "We can search for Landsat Collection 2 Surface Reflectance data by using the search term ``sr``. ``sr`` stands for \"surface reflectance\". The datacube is case-sensitive so this must be typed in lower case."
msgstr ""

#: 
msgid "We can further inspect the data available for each Landsat product using datacube's ``list_measurements`` functionality. The table below lists each of the measurements available in the data."
msgstr ""

#: 
msgid "Load Landsat using ``dc.load()``"
msgstr ""

#: 
msgid "In the example below, we will load data from Landsat 9 from Cape Town for South Africa in January 2022. We will load data from three spectral satellite bands, as well as cloud masking data (``'qa_aerosol'``). By specifying ``output_crs='EPSG:6933'`` and ``resolution=(-30, 30)``, we request that datacube reproject our data to the African Albers coordinate reference system (CRS), with 30 x 30 m pixels. Finally, ``group_by='solar_day'`` ensures that overlapping images taken within seconds of each other as the satellite passes over are combined into a single time step in the data."
msgstr ""

#: 
msgid "Plotting Landsat data"
msgstr ""

#: 
msgid "We can plot the data we loaded using the ``rgb`` function. By default, the function will plot data as a true colour image using the 'red', 'green', and 'blue' bands."
msgstr ""

#: 
msgid "Load Landsat using ``load_ard``"
msgstr ""

#: 
msgid "``load_ard`` applies the linear scaling and offset which converts the native ``uint16`` data to actual surface reflectance values. ``load_ard`` will additionally concatenate and sort the observations by time, and apply a cloud mask. The result is an analysis-ready dataset."
msgstr ""

#: 
msgid "In the example below, we load Landsat 9 data for the same time and place as above. Note a cloud mask has now been applied and the data converted to decimal surface reflectance values."
msgstr ""

#: 
msgid "This function will also load images from all the Landsat sensors if they are added to the ``products`` argument as a list."
msgstr ""

#: 
msgid "You can find more information on this function from the `Using load ard <../Frequently_used_code/Using_load_ard.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Plot the cloud masked landsat data:"
msgstr ""

#: 
msgid "**Products used:** `ls5_st <https://explorer.digitalearth.africa/ls5_st>`__, `ls7_st <https://explorer.digitalearth.africa/ls7_st>`__, `ls8_st <https://explorer.digitalearth.africa/ls8_st>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 8`, :index:`data used; landsat 7`, :index:`data used; landsat 5`, :index:`datasets; landsat 8`, :index:`datasets; landsat 7`, :index:`datasets; landsat 5`, :index:`surface temperature`"
msgstr ""

#: 
msgid "The United States Geological Survey's (USGS) `Landsat satellite program <https://www.nasa.gov/mission_pages/landsat/overview/index.html>`__ has been capturing images of the African continent for more than 30 years. These data are highly useful for land and coastal mapping studies. The Landsat mission not only collects surface reflectance data, but also surface temperature."
msgstr ""

#: 
msgid "Surface temperature measures the Earth’s surface temperature (units of Kelvin) and is an important geophysical parameter in global energy balance studies and hydrologic modeling. Surface temperature is also useful for monitoring crop and vegetation health, and extreme heat events such as natural disasters (e.g. volcanic eruptions, wildfires), and urban heat island effects."
msgstr ""

#: 
msgid "The surface temperature product is generated from:"
msgstr ""

#: 
msgid "Landsat Collection 2 Level-1 thermal infrared bands"
msgstr ""

#: 
msgid "Top of Atmosphere (TOA) reflectance"
msgstr ""

#: 
msgid "TOA brightness temperature"
msgstr ""

#: 
msgid "Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) Global Emissivity Database (GED) data"
msgstr ""

#: 
msgid "ASTER Normalised Difference Vegetation Index (NDVI) data"
msgstr ""

#: 
msgid "Atmospheric profiles of geopotential height, specific humidity, and air temperature extracted from:"
msgstr ""

#: 
msgid "Acquisitions 2000 to present: Goddard Earth Observing System (GEOS) Model , Version 5, Forward Processing Instrument Teams (FP-IT)"
msgstr ""

#: 
msgid "Acquisitions 1982 to 1999: Modern Era Retrospective analysis for Research and Applications Version 2 (MERRA-2)"
msgstr ""

#: 
msgid "For more information and caveats of the product, visit the Landsat Science Products Overview and the `Landsat Surface Temperature webpage <https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-2-surface-temperature#:~:text=Landsat%20surface%20temperature%20measures%20the,balance%20studies%20and%20hydrologic%20modeling.>`__."
msgstr ""

#: 
msgid "Surface temperature product"
msgstr ""

#: 
msgid "Native scaling range: ``1 - 65,535`` (``0`` is ``no-data``)"
msgstr ""

#: 
msgid "To achieve surface temperature values, convert the values to Kelvin using ``ds = ds * 0.00341802 + 149.0``"
msgstr ""

#: 
msgid "Using ``dc.load`` will load data in the native scaling range ``1 - 65,535``, while using ``load_ard`` will convert to Kelvin"
msgstr ""

#: 
msgid "For a detailed description of DE Africa's Landsat archive, see the DE Africa's `Landsat surface temperature technical specifications documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_ST_specs.html>`__."
msgstr ""

#: 
msgid "This notebook demonstrates how to load and use the Land Surface Temperature product from the Landsat Collection 2 dataset. Topics covered include:"
msgstr ""

#: 
msgid "Load surface temperature and filter with quality assessment"
msgstr ""

#: 
msgid "Compare mean surface temperature to daily air temperature at 2-meters height from ERA5"
msgstr ""

#: 
msgid "Inspect related land surface characteristics"
msgstr ""

#: 
msgid "We can search for Landsat Collection 2 Surface Temperature data by using the search term ``_st``. ``st`` stands for \"surface temperature\". The datacube is case-sensitive so this must be typed in lower case."
msgstr ""

#: 
msgid "Note that Landsat 8 surface temperature products are generated with a different algorithm from Landsat 5 and 7. It therefore has different output measurements."
msgstr ""

#: 
msgid "Load Landsat surface temperature using ``dc.load()``"
msgstr ""

#: 
msgid "In the example below, we will load surface temperature data from Landsat 8 for Namibia, across parts of 2018 and 2019. First, we will set up the parameters of our data load: latitude and longitude, time, and band measurements."
msgstr ""

#: 
msgid "By specifying ``output_crs='EPSG:32633'`` and ``resolution=(-30, 30)``, we request that datacube reproject our data to the desired Coordinate Reference System (CRS), with 30 x 30 m pixels."
msgstr ""

#: 
msgid "Plotting Landsat data from dc.load"
msgstr ""

#: 
msgid "We can plot the data we loaded for each timestep and inspect it."
msgstr ""

#: 
msgid "Notice the scale of surface temperature is very large. This is because the data loaded with ``dc.load`` has not been scaled according to the scale factor and offsets determined by USGS. Loading data with ``load_ard`` performs that scaling automatically, to give temperature in Kelvin."
msgstr ""

#: 
msgid "``load_ard`` applies the linear scaling and offset which converts the native loaded data to actual surface temperature values. ``load_ard`` will additionally concatenate and sort the observations by time, and apply a cloud mask. The result is an analysis-ready dataset, which is much easier to use."
msgstr ""

#: 
msgid "In the example below, we load Landsat 8 data for the same time and place as above. We will call this dataset ``ds`` to distinguish it from the previously-loaded dataset. Note a cloud mask has now been applied. ``load_ard`` also converts the temperature data into Kelvin."
msgstr ""

#: 
msgid "You can find more information on the ``load_ard`` function from the `Using load ard <../Frequently_used_code/Using_load_ard.ipynb>`__ notebook."
msgstr ""

#: 
msgid "We now want to drop empty slices and convert the ``surface_temperature`` band to degrees Celsius. We then plot the time slices with valid data."
msgstr ""

#: 
msgid "Compare mean surface temperature to daily air temperature"
msgstr ""

#: 
msgid "We can load some ERA5 atmospheric data to compare with the Landsat 8 mean surface temperature. Here we use ERA5 daily air temperature at 2 metres height. It is loaded using the ``load_era5`` function and then converted into degrees Celsius. For more information on the ERA5 data and how it is loaded into the Sandbox, see the `Climate Data ERA5 <./Climate_Data_ERA5_AWS.ipynb>`__ notebook."
msgstr ""

#: 
msgid "To plot the data together, we find the average of the land surface temperature over our selected area. This can then be shown together with the corresponding 2-metre air temperature data."
msgstr ""

#: 
msgid "Monthly NDVI Anomaly"
msgstr ""

#: 
msgid "**Products used:** `ndvi_anomaly <https://explorer.digitalearth.africa/products/ndvi_anomaly>`__, `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data datasets; ndvi anomaly`, :index:`data used; crop_mask`"
msgstr ""

#: 
msgid "Digital Earth Africa's Monthly NDVI and Anomalies service provides an estimate of vegetation condition for each calendar month, as well as comparison of this against the long-term baseline condition measured for the month over the period 1984 to 2020 in the `NDVI Climatology <https://docs.digitalearthafrica.org/en/latest/data_specs/NDVI_Climatology_specs.html>`__."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{Standardised anomaly }=\\frac{\\text{NDVI}_{month, year}-\\text{NDVI}_{month}}{\\sigma} \\end{equation}`"
msgstr ""

#: 
msgid "where :math:`\\text{NDVI}_{month, year}` is the NDVI measured for a month in a year, :math:`\\text{NDVI}_{month}` is the long-term mean for this month from 1984 to 2020, and :math:`\\sigma` is the long-term standard deviation. A standarised anomaly therefore measures the direction and significance of vegetation change against normal conditions."
msgstr ""

#: 
msgid "Further details on the product are available in the `NDVI Anomaly technical specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/NDVI_Anomaly_specs.html>`__ documentation."
msgstr ""

#: 
msgid "Datacube product name: ``ndvi_anomaly``"
msgstr ""

#: 
msgid "``ndvi_mean``: Mean NDVI for a month."
msgstr ""

#: 
msgid "``ndvi_std_anomaly``: Standardised NDVI anomaly for a month"
msgstr ""

#: 
msgid "``clear_count``: Number of clear observations in a month"
msgstr ""

#: 
msgid "Date-range: monthly from January 2017"
msgstr ""

#: 
msgid "Spatial resolution: 30m"
msgstr ""

#: 
msgid "From September 2022, the Monthly NDVI Anomaly is generated as a low latency product, i.e. anomaly for a month is generated on the 5th day of the following month. This ensures data is available shortly after the end of a month and all Landsat 9 and Sentinel-2 observations are included. Not all Landsat 8 observations for the month will be used, because the Landsat 8 Surface Refelectance product from USGS has a latency of over 2 weeks (see `Landsat Collection 2 Generation Timeline <https://www.usgs.gov/media/images/landsat-collection-2-generation-timeline>`__)."
msgstr ""

#: 
msgid "In this notebook we will load the NDVI and Anomalies product using ``dc.load()`` to return the mean, standard deviation, and clear observation count for each calendar month. A final section explores an example analysis using the product."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the NDVI and Anomalies product and measurements available in the datacube. 2. Using the native ``dc.load()`` function to load in NDVI Anomaly for a defined area. 3. Visualise the mean NDVI and standardised anomalies. 4. Plot the phenology curve of croplands. 5. Extract mean NDVI and anomalies for a selected month and region. 6. Compare mean NDVI to conditions observed in the previous years."
msgstr ""

#: 
msgid "Available measurements"
msgstr ""

#: 
msgid "The table printed below shows the measurements available in the NDVI and Anomalies product. The mean NDVI, standardised NDVI anomaly, and clear obervations count can be loaded for each calendar month."
msgstr ""

#: 
msgid "``lat, lon, buffer``: center lat/lon and analysis window size for the area of interest."
msgstr ""

#: 
msgid "``resolution``: the pixel resolution to use for loading the ``ndvi_anomaly``. The native resolution of the product is 30 metres i.e. ``(-30,30)`` as the product is Landsat derived."
msgstr ""

#: 
msgid "``time_range``: time range for loading the monthly anomalies."
msgstr ""

#: 
msgid "The default location is a cropping region in Western Cape, South Africa where an irrigation scheme along a river is surrounded by rain-fed cropping."
msgstr ""

#: 
msgid "Load data"
msgstr ""

#: 
msgid "Below, we use the ``dc.load`` function to load all the measurements over the region specified above."
msgstr ""

#: 
msgid "Plotting monthly NDVI and anomalies"
msgstr ""

#: 
msgid "Plot NDVI phenology"
msgstr ""

#: 
msgid "We can use the monthly NDVI to extract the phenology curve for specific landscapes. Limiting our analysis of the area above to a crop mask enables us to investigate the phenology of cropland."
msgstr ""

#: 
msgid "Plot phenology curve"
msgstr ""

#: 
msgid "Below, we summarise the datasets spatially by taking the mean across the ``x`` and ``y`` dimensions. This will leave us with the average trend through ``time`` for the region we've loaded."
msgstr ""

#: 
msgid "From the phenology plot, we can conclude that crop growth in this area commenced around May and continued until harvest around October."
msgstr ""

#: 
msgid "For a more detailed vegetation phenology analysis, see the notebook `Vegetation Phenology notebook <../Real_world_examples/Vegetation_phenology.ipynb>`__."
msgstr ""

#: 
msgid "Extract NDVI anomalies for a selected month and region"
msgstr ""

#: 
msgid "Load the African Countries shapefile"
msgstr ""

#: 
msgid "This shapefile contains polygons for the boundaries of African countries and will allows us to calculate NDVI anomalies within a chosen country."
msgstr ""

#: 
msgid "List countries"
msgstr ""

#: 
msgid "You can change the country in the analysis parameters cell to any African country. A complete list of countries is printed below."
msgstr ""

#: 
msgid "Setup polygon"
msgstr ""

#: 
msgid "The country selected needs to be transformed into a geometry object to be used in the ``load_ard`` function."
msgstr ""

#: 
msgid "Load NDVI anomaly"
msgstr ""

#: 
msgid "Plot NDVI climatology, monthly mean, and standardised anomaly"
msgstr ""

#: 
msgid "Compare monthly NDVI conditions over the years"
msgstr ""

#: 
msgid "Below, the spatial mean is taken so we can present the monthly anomalies aggregated across the selected country."
msgstr ""

#: 
msgid "NDVI Climatology"
msgstr ""

#: 
msgid "**Products used:** `ndvi_climatology_ls <https://explorer.digitalearth.africa/products/ndvi_climatology_ls>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ndvi climatology`"
msgstr ""

#: 
msgid "Climatology refers to conditions averaged over a long period of time, typically greater than 30 years. The Digital Earth Africa NDVI Climatology product represents the long-term average baseline condition of vegetation for every Landsat pixel over the African continent. Both mean and standard deviation NDVI climatologies are available for each calendar month based on calculation over the period 1984-2020. NDVI climatologies may be used for many applications including identifying extremeties (anomalies) in vegetation condition, identifying both long and short-term changes in vegetation condition, and as an input into machine learning processes for land use classification."
msgstr ""

#: 
msgid "Further details on the calculation of the product are available in the `NDVI Climatology technical specifications <https://docs.digitalearthafrica.org/en/latest/data_specs/NDVI_Climatology_specs.html>`__ documentation."
msgstr ""

#: 
msgid "Datacube product name: ``ndvi_climatology_ls``"
msgstr ""

#: 
msgid "``count_<month>``: These measaurements show the number of clear observations that go into creating the mean and standard deviation measurements. Importantly, caution should be used when applying this product to regions where the clear observation count is less than approximately 20-30. This can often be the case over equatorial Africa due to frequent cloud cover and inconsistent coverage of Landsat-5."
msgstr ""

#: 
msgid "Status: Provisional"
msgstr ""

#: 
msgid "Date-range: The time dimension represents calendar months aggregated across the period 1984-2020."
msgstr ""

#: 
msgid "In this notebook we will load the NDVI Climatology product using ``dc.load()`` to return mean, standard deviation, and clear observation count for each calendar month. A final section explores an example analysis using the product."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the NDVI Climatology product and measurements available in the datacube. 2. Using the native ``dc.load()`` function to load in NDVI Climatology. 3. Inspect perennial and annual vegtation using NDVI mean and standard deviation. 4. Exaple analysis: analyse and plot the climatological (long-term average) phenology of croplands"
msgstr ""

#: 
msgid "The table printed below shows the measurements available in the NDVI Climatology product. The mean NDVI, standard deviation of NDVI, and clear obervations count can be loaded for each calendar month."
msgstr ""

#: 
msgid "``resolution``: the pixel resolution to use for loading the ``ndvi_climatology_ls``. The native resolution of the product is 30 metres i.e. ``(-30,30)`` as the product is Landsat derived."
msgstr ""

#: 
msgid "The default location is an cropping region in Western Cape, South Africa where an irrigation scheme along a river is surrounded by rain-fed cropping."
msgstr ""

#: 
msgid "Below we use the ``dc.load`` function to load all the measurements over the region specified above."
msgstr ""

#: 
msgid "Plotting NDVI Climatology"
msgstr ""

#: 
msgid "Store measurements"
msgstr ""

#: 
msgid "As this dataset has a lot of measurements, it is easier to store them in a list and access them as we need when plotting etc., rather than typing out each measurement"
msgstr ""

#: 
msgid "Add a time dimension to the climatologies"
msgstr ""

#: 
msgid "Adding a time dimension to the dataset by concatenating the months together allows us to quickly make plots or calculate ket statistics without looping through separate datasets."
msgstr ""

#: 
msgid "**Important note:** The date '2002' is meaningless, its simply the middle point between 1984 and 2020 - the range over which the climatologies were calculated."
msgstr ""

#: 
msgid "Facet plot the mean NDVI climatology"
msgstr ""

#: 
msgid "The plots below show that, on average, the irrigated fields around the river, and the riparian vegetetation are more persistently green throughout the year, while the rainfed cropping regions are green through the winter months of June, July, August, and September."
msgstr ""

#: 
msgid "Facet plot the standard deviation NDVI climatology"
msgstr ""

#: 
msgid "Note the irrigated regions tend to show greater variability than the other pixels. By enabling distinction between classes of agricultural land and other vegetation, this might be a good input to land use classification methods such as thresholding or more complex machine learning approaches."
msgstr ""

#: 
msgid "Facet plot the clear count"
msgstr ""

#: 
msgid "We can use these plots to understand how many observations are going into the climatology calculations. Below (in the default example) we can that in the drier months there are ~25-35 observations (over the 37 year period of the climatology), while in the winter months there are ~20. In this case, because the observation count is relatvely low for the winter months, we should be careful when using the climatology in those months. In this specific example the mean and standard deviation measurements plotted above look okay, probably because the region is at a higher latitude and therefore not so affected by cloud. If this region was in the tropics then the dataset may be of a poorer quality."
msgstr ""

#: 
msgid "Example Analysis: Cropland Climatological Phenology"
msgstr ""

#: 
msgid "We can use the NDVI climatology product to generate long-term average phenological patterns for specific regions, landscapes, or vegetation types. Limiting our analysis of the area above to a crop mask enables us to investigate the long-term average phenology of cropland."
msgstr ""

#: 
msgid "Load the cropmask dataset for the region"
msgstr ""

#: 
msgid "Mask the datasets with the crop mask"
msgstr ""

#: 
msgid "Below we summarise the datasets spatially by taking the mean across the ``x`` and ``y`` dimensions, this will leave us with the average trend through ``time`` for the region we've loaded."
msgstr ""

#: 
msgid "When we plot the phenology curve below, we will add +- 1 standard deviation around the mean curve to indicate, on average, how much the trends vary around the long-term mean."
msgstr ""

#: 
msgid "From the phenology plot, we can conclude that crop growth generally commences around May and continues until harvest around October."
msgstr ""

#: 
msgid "Plot the mean phenology curve, with +-1 standard deviation envelope"
msgstr ""

#: 
msgid "Per pixel climatological phenology"
msgstr ""

#: 
msgid "Having plotted in the spatially averaged climatological phenology, we can now use the DE Africa function ``xr_phenology`` to calculate the typical phenology of every pixel in the dataset."
msgstr ""

#: 
msgid "This function computes key phenological statistics expressed as the day-of-the-year (DOY) at: \\* Start of Season (SOS), \\* Peak of Season (POS), \\* End of Season (EOS)."
msgstr ""

#: 
msgid "It also gives NDVI values (v) for the times above (e.g. vSOS for the NDVI value at the start of season), and other variables including: \\* Trough: minimum NDVI value of season, \\* LOS: Length of season, \\* AOS: Amplitude of season (difference between the base and maximum NDVI values), \\* ROG: Rate of greening, \\* ROS: Rate of senescence."
msgstr ""

#: 
msgid "**Important note:** Remember that this product is monthly (not daily) so the DOY is simply the middle of the month when the NDVI peaks, for example (we set the time dimension to be the 15th of each month in the \"adding time dimension\" section above)."
msgstr ""

#: 
msgid "Plot per pixel phenology"
msgstr ""

#: 
msgid "OpenStreetMap"
msgstr ""

#: 
msgid "**Products used:** `OpenStreetMap <https://www.openstreetmap.org/>`__"
msgstr ""

#: 
msgid "`OpenStreetMap <https://www.openstreetmap.org/>`__ is a free and open geographic database, providing location information of roads, buildings, and landmarks. It is built, maintained and supported by a world-wide geospatial community."
msgstr ""

#: 
msgid "OpenStreetMap data is licensed under the `Open Data Commons Open Database License (ODbL) <https://opendatacommons.org/licenses/odbl/>`__ by the OpenStreetMap Foundation (OSMF). It is free to copy, distribute, transmit and adapt the data, providing credit to OpenStreetMap and its contributors. Full licence information and attribution guidelines can be found at the `OpenStreetMap's Copyright and License page <https://www.openstreetmap.org/copyright>`__."
msgstr ""

#: 
msgid "This notebook will demonstrate how to access OpenStreetMap data using Python package ```osmnx`` <https://osmnx.readthedocs.io/en/stable/osmnx.html>`__."
msgstr ""

#: 
msgid "The ``osmnx`` package will be installed if it's not yet available in the environment."
msgstr ""

#: 
msgid "By default, ``osmnx`` will cache the query response so it doesn't have to call the API repeatedly for the same request. Accessing the cache is efficient when refining an analysis or when a user's main area of interest if fixed. The users should, however, be aware that the cached files will take up storage space."
msgstr ""

#: 
msgid "Whether to use the cache and where to store the cached data can be configured. In this example, we will set the cache to be stored in a temporary folder that is cleared when a user logs out of the Sandbox. This may not be necessary for some users."
msgstr ""

#: 
msgid "The OpenStreetMap API provides a few different ways to define location. While methods using address or place name are convenient to use, they depend on geocoding and are more likely to yield ambiguous location matches. If place name is used, the ``osmnx.geocode_to_gdf()`` function can be used to check whether a location name yields the correct place boundary. For combined analysis with DEAfrica datasets, query using bounding box or polygon is preferred."
msgstr ""

#: 
msgid "When using bounding box to query, note the order of bounds are \"north, south, east, west\"."
msgstr ""

#: 
msgid "Retrieve building geometries from OpenStreetMap"
msgstr ""

#: 
msgid "Different types of geometries can be queried by defining the ``tags`` parameter. For example, ``tags={'building': True}`` would return all building footprints in the area."
msgstr ""

#: 
msgid "Using the location and tags, geometries will be retrieved from OpenStreetMap and the results are returned as a Geopandas GeoDataFrame."
msgstr ""

#: 
msgid "Retrieve road geometries from OpenStreetMap"
msgstr ""

#: 
msgid "Road networks can be retrieved using the ``highway`` tag. A list of tag values can be used to select specific types of geometries."
msgstr ""

#: 
msgid "Tag values for ``highway`` and their descriptions can be found at https://wiki.openstreetmap.org/wiki/OpenStreetMap_Carto/Lines"
msgstr ""

#: 
msgid "This notebook accesses OpenStreetMap data, therefore when sharing analysis results, attribution should follow guidellines from the `OpenStreetMap's Copyright and License page <https://www.openstreetmap.org/copyright>`__."
msgstr ""

#: 
msgid "Planet monthly mosaic data"
msgstr ""

#: 
msgid "**Products used:** `DE Africa Waterbodies <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html>`__, `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `Planet API <>`__"
msgstr ""

#: 
msgid "Norway's International Climate and Forests Initiative (NICFI) is an international development fund that helps save the world's tropical forests while improving the livelihoods of those who live off, in, and near forests. In September 2020, the Norwegian Ministry of Climate and Environment awarded an international contract to Kongsberg Satellite Services (KSAT), with partners Planet and Airbus, to provide comprehensive access to high-resolution satellite monitoring of the tropics. As part of this program, Planet partnered with NICFI to make high-resolution satellite imagery of the tropics available free of charge to users, advancing the NICFI purpose of reducing and reversing tropical forest loss, combating climate change, conserving biodiversity, and facilitating sustainable development. Additional information on the program can be found on the `NICFI program website <https://www.planet.com/nicfi>`__."
msgstr ""

#: 
msgid "Digital Earth Africa has enabled users to view NICFI's latest monthly and biannual high-resolution (<5 m) mosaics through its platform (Maps and Sandbox). These visual mosaics provide optimized, true-color imagery, making them ideal for visual display and interpretation. For more information and access to additional visual and analytic products from Planet, visit the `NICFI program website <https://www.planet.com/nicfi>`__"
msgstr ""

#: 
msgid "Planet Monthly Mosaic"
msgstr ""

#: 
msgid "Spatial resolution: 4.77m"
msgstr ""

#: 
msgid "Bands: Red, Green, Blue (3-band)"
msgstr ""

#: 
msgid "Temporal resolution: monthly"
msgstr ""

#: 
msgid "Temporal range: 2020-09 – present"
msgstr ""

#: 
msgid "Update frequency: Monthly"
msgstr ""

#: 
msgid "Update latency: Max 5 days from previous month"
msgstr ""

#: 
msgid "Api access: ``https://api.digitalearth.africa/planet/tiles/basemaps/v1/planet-tiles/planet_medres_visual_year-month_mosaic/gmap/{z}/{x}/{y}.png``"
msgstr ""

#: 
msgid "Archive Planet biannual Mosaic"
msgstr ""

#: 
msgid "Temporal resolution: 6 months"
msgstr ""

#: 
msgid "Temporal range: 2015-12 – 2020-08"
msgstr ""

#: 
msgid "`Visualise on DE Africa Maps <https://maps.digitalearth.africa/#share=s-3nQm2WLyXLl1LahsxI1JJ5bgWFO>`__"
msgstr ""

#: 
msgid "For a detailed description visit `NICFI_UserGuidesFAQ.pdf <https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf>`__."
msgstr ""

#: 
msgid "This notebook demonstrates how to use the Planet monthly mosaic data in conjunction with other DE Africa services."
msgstr ""

#: 
msgid "Define area of interest"
msgstr ""

#: 
msgid "Plotting of waterbody, Normalized Difference Vegetation Index (NDVI) and Build-Up Index (BUI) with planet monthly mosaic as basemap"
msgstr ""

#: 
msgid "Uncomment the below cell if ``localtileserver`` throws up an error and rerun the cell"
msgstr ""

#: 
msgid "Once installed comment it out."
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis over. The parameters are"
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``10.338``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``-1.055``)."
msgstr ""

#: 
msgid "Select location"
msgstr ""

#: 
msgid "To define the area of interest, there are two methods available:"
msgstr ""

#: 
msgid "By specifying the latitude, longitude, and buffer. This method requires you to input the central latitude, central longitude, and the buffer value in square degrees around the center point you want to analyze. For example, ``lat = 10.338``, ``lon = -1.055``, and ``buffer = 0.1`` will select an area with a radius of 0.1 square degrees around the point with coordinates (10.338, -1.055)."
msgstr ""

#: 
msgid "To use one of these methods, you can uncomment the relevant line of code and comment out the other one. To comment out a line, add the ``\"#\"`` symbol before the code you want to comment out. By default, the first option which defines the location using latitude, longitude, and buffer is being used."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers the Bui Dam in Ashanti Region, Ghana."
msgstr ""

#: 
msgid "Plotting of Result"
msgstr ""

#: 
msgid "The cell below plots the map with ``ipyleaflet`` functions, which load ``opensteetmap`` and the ``Latest Planet monthly mosaic`` as the basemap. It also loads the"
msgstr ""

#: 
msgid "``Built up area`` : generated using Build-Up Index (BUI)"
msgstr ""

#: 
msgid "``Vegetation`` : generated using Normalized Difference Vegetation Index (NDVI)"
msgstr ""

#: 
msgid "``Water body`` : maximum extent mapped in Waterbodies service"
msgstr ""

#: 
msgid "The NDVI and BUI were computed from Sentinel-2 Annual GeoMad. More information on the `GeoMAD <GeoMAD.ipynb>`__."
msgstr ""

#: 
msgid "The loadplanet function takes two parameters - ``lon_range`` : longitude buffer for the study area - ``lat_range`` : latitude buffer for the study area"
msgstr ""

#: 
msgid "The next cell will display the selected area on an interactive map. Feel free to zoom in and out to get a better understanding of the area you'll be analysing."
msgstr ""

#: 
msgid "Rainfall - Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS)"
msgstr ""

#: 
msgid "**Products used:** `rainfall_chirps_monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__, `rainfall_chirps_daily <https://explorer.digitalearth.africa/products/rainfall_chirps_daily>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`datasets; CHIRPS`, :index:`climate`, :index:`rainfall`, :index:`monthly`"
msgstr ""

#: 
msgid "This notebook demonstrates how to access and use the **Monthly Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS)** from the DE Africa Open Data Cube."
msgstr ""

#: 
msgid "For offical information on this dataset, see `CHIRPS <https://www.chc.ucsb.edu/data/chirps>`__. The abstract from this documentation is copied below:"
msgstr ""

#: 
msgid "The current CHIRPS datasets that are accessible from DE Africa's platforms are the ``CHIRPS-2.0 Africa Monthly`` dataset, copied from `here <https://data.chc.ucsb.edu/products/CHIRPS-2.0/africa_monthly/tifs/>`__ and the ``CHIRPS-2.0 Africa Daily`` dataset, copied from `here <https://data.chc.ucsb.edu/products/CHIRPS-2.0/africa_daily/tifs/>`__. They have been converted to cloud-opitmized geotiffs, and indexed into DE Africa's Open-Data-Cube."
msgstr ""

#: 
msgid "**Important specifications:**"
msgstr ""

#: 
msgid "Datacube product name: ``rainfall_chirps_monthly``"
msgstr ""

#: 
msgid "Measurement Type: Monthly Atmospheric Precipitation"
msgstr ""

#: 
msgid "Precipitation Units: Total mm/month"
msgstr ""

#: 
msgid "Date-range: ``1981-01`` to present"
msgstr ""

#: 
msgid "Spatial resolution: 0.05 degrees, approximately 5.55 km"
msgstr ""

#: 
msgid "Datacube product name: ``rainfall_chirps_daily``"
msgstr ""

#: 
msgid "Precipitation Units: Total mm/day"
msgstr ""

#: 
msgid "In this notebook we will load CHIRPS data using ``dc.load()`` to return a time series of datasets."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the monthly CHIRPS product and measurements available in the datacube 2. Using the native ``dc.load()`` function to load CHIRPS data 3. Facet plotting the CHIRPS datasets 4. Conduct a simple analysis workflow: finding the long-term monthly mean rainfall"
msgstr ""

#: 
msgid "The default location cover all of Nigeria"
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect the CHIRPS rainfall datasets available in the datacube. The table below shows the product names that we will use to load the data and a brief description of the data"
msgstr ""

#: 
msgid "We can further inspect the data available for CHIRPS using datacube's ``list_measurements`` functionality. The table below lists each of the measurements available in the data."
msgstr ""

#: 
msgid "Load CHIRPS data using ``dc.load()``"
msgstr ""

#: 
msgid "In the first example below, we will load CHIRPS data for region covering Nigeria"
msgstr ""

#: 
msgid "Plotting CHIRPS Monthly Rainfall"
msgstr ""

#: 
msgid "Let's facet plot the time-series to see the total rainfall each month during 2020 over Nigeria."
msgstr ""

#: 
msgid "Loading and plotting daily rainfall"
msgstr ""

#: 
msgid "In the above plot we can see that a lot of rain fell in July 2020. We'll load the daily rainfall data for this month, aggregrate it across the region, and plot the daily totals to see how this rainfall was distributed within the month."
msgstr ""

#: 
msgid "Example application: finding the monthly mean rainfall over a region"
msgstr ""

#: 
msgid "The following section will demonstrate a simple analysis workflow based on CHIRPS rainfall. We will use a 10-year time-series of rainfall over Nigeria to find the long-term monthly mean rainfall total."
msgstr ""

#: 
msgid "First we will load the data, the parameters here are the same as the example above only we've increased to time-range from one year to 10 years."
msgstr ""

#: 
msgid "Find the long-term monthly mean rainfall"
msgstr ""

#: 
msgid "We find the mean rainfall across the region (``ds_rf.mean(['x', 'y'])``), then we group all the same months together and find the mean of the all the January's, February's etc. (``groupby('time.month').mean()``). Lastly we convert the result to a pandas dataframe (``.drop('spatial_ref').to_dataframe()``) to faciliate the plotting of a bar-chart"
msgstr ""

#: 
msgid "Plot the result"
msgstr ""

#: 
msgid "Rolling GeoMAD"
msgstr ""

#: 
msgid "**Products used:** `gm_s2_rolling <https://explorer.digitalearth.africa/gm_s2_rolling>`__, `ndvi_anomaly <https://explorer.digitalearth.africa/s2_l2a>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; rolling geomad`, `data used; sentinel-2`"
msgstr ""

#: 
msgid "Satellite imagery allows us to observe the Earth in a repetitive and detailed manner. However, missing data — such as gaps caused by cloud cover — can make it difficult to put together a complete image. In order to produce a single, complete view of a certain area, satellite data may be consolidated, stacking measurements from different points in time to create a composite image."
msgstr ""

#: 
msgid "The Digital Earth Africa (DE Africa) Sentinel-2 Rolling GeoMAD (**Geo**\\ median and **M**\\ edian **A**\\ bsolute **D**\\ eviations) service provides monthly Geomedian and MADs calculated using a moving window of 3 months . This is a cloud-free time series that can be used to monitor change on a more frequent basis than an annual or semiannual product."
msgstr ""

#: 
msgid "Each product combines measurements collected over a 3-month period to produce one representative, multi-spectral image for every pixel of the African continent for each calendar month. The end result is a comprehensive dataset that can be used either to generate true-colour images for visual inspection of the landsacpe, or the full spectral dataset can be used to develop more complex algorithms."
msgstr ""

#: 
msgid "Datacube product names: ``gm_s2_rolling``"
msgstr ""

#: 
msgid "Status: provisional"
msgstr ""

#: 
msgid "Date-range: January 2019 – present"
msgstr ""

#: 
msgid "Spatial resolution: 10m"
msgstr ""

#: 
msgid "For more information on DE Africa's GeoMAD service, see the DE Africa `GeoMAD <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__."
msgstr ""

#: 
msgid "In this notebook we will work with the Sentinel-2 Rolling GeoMAD and demonstrate how it can be used to monitor changes in landscapes through time."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the Rolling GeoMAD products and measurements available in the datacube 2. Load Rolling GeoMAD data 3. Display rgb of Rolling GeoMAD 4. Calculate and plot NDVI from Rolling GeoMAD 5. Inspect the MAD bands from the GeoMAD \\**\\*"
msgstr ""

#: 
msgid "Inspect the measurement or bands available for the Sentinel-2 Rolling GeoMAD using datacube's ``list_measurements`` functionality."
msgstr ""

#: 
msgid "In this example, we will inspect an area of sugarcane plantations in Zimbabwe. The GeoMAD is particularly suited to classification and change detection applications, such as in agriculture and forestry. We will see how the GeoMAD can be used to draw inferences about agricultural practices, such as harvest dates, later in the notebook."
msgstr ""

#: 
msgid "Display area of interest with a basemap using ``display_map()``"
msgstr ""

#: 
msgid "Load Sentinel-2 Rolling GeoMAD data using ``dc.load()``."
msgstr ""

#: 
msgid "For more discussion on how to load data using the datacube, refer to the `Introduction to loading data <../Beginners_guide/03_Loading_data.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Dealing with time"
msgstr ""

#: 
msgid "The rolling nature of this product means the loading behaviour for specified time periods is different to other Digital Earth Africa products. The reason is that there is temporal overlap between images. This is illustrated below in the chart which conceptualises the loading behaviour for the specified period ``2021-01-01 - 2021-03-31`` denoted by dotted black lines. As this period covers three months (Jan, Feb & Mar), users may expect the query to return three images. However, in the case of the rolling GeoMAD this will return five images as shown below. That's because the ``dc.load`` function will bring in all images that include image acquisitions within the time of interest. For example, the December 2020 GeoMAD includes images from November and December 2020, and January 2021, so will be loaded as part of the ``2021-01-01 - 2021-03-31`` query. The date label in the loaded dataset will be ``2020-12-16``."
msgstr ""

#: 
msgid "The loading behaviour described above is evident in the ``ds`` returned below."
msgstr ""

#: 
msgid "The cell below slices the beginning and end times to get the time range specified. Note that the ``ds`` object below only includes images labelled as ``2021``."
msgstr ""

#: 
msgid "Display rgb of Sentinel-2 Rolling GeoMAD"
msgstr ""

#: 
msgid "We can plot the data we loaded using the ``rgb()`` function. By default, the function will plot data as a true colour image using the 'red', 'green', and 'blue' bands."
msgstr ""

#: 
msgid "Calculate NDVI using ``calculate indices``"
msgstr ""

#: 
msgid "Refer to the `Calculating band indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ notebook for more information. >Note: This product is suitable for calculating any indices, not just NDVI."
msgstr ""

#: 
msgid "Plot NDVI"
msgstr ""

#: 
msgid "NDVI is plotted below for each month of 2021. Are there any noticeable patterns or changes in the distribution of NDVI in space?"
msgstr ""

#: 
msgid "Plot SMAD"
msgstr ""

#: 
msgid "The Median Absolute Deviation (MAD) bands provide information about change within the period of geomedian calculation. It does this while preserving the high-dimensional relationships between satellite bands. For example, higher spectral median absolute deviation (SMAD) values indicate a greater amount of change within a period; in this case, the three month rolling window."
msgstr ""

#: 
msgid "This information can help identify areas that are more dynamic in a given period. In managed (e.g. agricultural) environments, this can relate to activity like cultivation, harvest, or planting of crops."
msgstr ""

#: 
msgid "Inspecting the images below, can you identify fields in the sugarcane plantation that have undergone change? Try comparing these fields with both the NDVI and rgb images above to see if you can draw any inferences about what has occurred."
msgstr ""

#: 
msgid "This notebook has demonstrated loading and plotting the Rolling GeoMAD. It has also shown how the rolling nature of this product means that is has images that overlap in time, which has implications for loading procedures."
msgstr ""

#: 
msgid "**Products used:** `s1_rtc <https://explorer.digitalearth.africa/products/s1_rtc>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-1`,:index:`datasets; sentinel-1`, index:`SAR`"
msgstr ""

#: 
msgid "The `Sentinel-1 <https://sentinel.esa.int/web/sentinel/missions/sentinel-1>`__ mission is composed of a constellation of two Synthetic Aperture Radar (SAR) satellites, Sentinel-1A and Sentinel-1B, sharing the same orbital plane. Sentinel-1 provides dual polarisation capability, very short revisit times, and rapid product delivery. The mission currently collects data every 12 days over Africa at a spatial resolution of approximately 20m. Sentinel-1A was launched on 3 April 2014 and Sentinel-1B followed on 25 April 2016. Two other spacecraft (Sentinel-1C and Sentinel-1D) are planned to replace the first two satellites at the end of their operational lifespan. For more information on the Sentinel-1 platforms and applications, check out the `European Space Agency <https://www.esa.int/Applications/Observing_the_Earth/Copernicus/Sentinel-1>`__ website."
msgstr ""

#: 
msgid "SAR data has the advantage of operating at wavelengths not impeded by cloud cover and can acquire data over a site during the day or night. The Sentinel-1 mission is the European Radar Observatory for the Copernicus joint initiative of the European Commission (EC) and the European Space Agency (ESA) that can offer reliable and repeated wide area monitoring with its SAR instrument."
msgstr ""

#: 
msgid "Radar backscatter measures the amount of microwave radiation reflected back to the centre from the ground surface. This measurement is sensitive to surface roughness, moisture content, and viewing geometry. DEAfrica provides Sentinel-1 backscatter as Radiometric Terrain Corrected (RTC) gamma-0 (γ0) where variation due to changing observation geometries has been mitigated."
msgstr ""

#: 
msgid "DE Africa provides Sentinel-1 data acquired in Interferometric Wide Swath (IW) mode and with dual polarisation (VV and VH). The dual polarisation backscatter timeseries can be used in applications for forests, agriculture, wetlands, and land cover classification. SAR's ability to see through clouds makes it critical for mapping and monitoring land cover changes in the wet tropics."
msgstr ""

#: 
msgid "DEAfrica Sentinel-1 backscatter is processed to be compliant with the `CEOS Analysis Ready Data for Land (CARD4L) <https://ceos.org/ard/>`__ specification. More technical information can be found in the `DE Africa User Guide <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-1_specs.html>`__."
msgstr ""

#: 
msgid "In this notebook we will load sentinel-1 Radiometric Terrain Corrected (RTC) SAR backscatter data."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the Sentinel-1 product and measurements available in the datacube 2. Using the native ``dc.load()`` function to load in Sentinel-1 data 3. Using the ``load_ard`` wrapper function to load masked Sentinel-1 data"
msgstr ""

#: 
msgid "The Sentinel-1 product has five measurements: \\* Backscatter in two polarisations,\\ ``VV`` and ``VH``. The two letters correspond to the polarisations of the light sent and received by the satellite. *VV* refers to the satellite sending out vertically-polarised light and receiving vertically-polarised light back, whereas *VH* refers to the satellite sending out vertically-polarised light and receiving horizontally-polarised light back. \\* A data mask, with ``0`` for ``no-data``, ``1`` for valid data, and ``2`` for in/near radar shadow. \\* Scattering area, the normalization that has been calcuated using a digital elevation model and been applied to obtain radiometric terrain correction. \\* Local incidence angle."
msgstr ""

#: 
msgid "Load Sentinel-1 dataset using ``dc.load()``"
msgstr ""

#: 
msgid "Now that we know what products and measurements are available for the product, we can load data from the datacube using ``dc.load``."
msgstr ""

#: 
msgid "In the example below, we will load Sentinel-1 for part of Ghana in 2020."
msgstr ""

#: 
msgid "We will load data from two polarisation bands,\\ ``VV`` and ``VH``, as well as the data mask (``'mask'``). The data is loaded in native EPSG:4326 coordinate reference system (CRS). It can be reprojected if ``output_crs`` and ``resolution`` are defined in the query."
msgstr ""

#: 
msgid "We will also define an orbit direction for this query. Sentinel-1 data are acquired in either ``ascending`` or ``descending`` passes. Because the antenna is right-looking, data acquired in different orbit directions will have different viewing geometries. This may lead to a difference in backscatter values, e.g. over bare or sparsely vegetated areas."
msgstr ""

#: 
msgid "Most of the African continent is regularly covered by ``ascending`` passes. For some locations, ``descending`` passes are also available."
msgstr ""

#: 
msgid "For some applications, a user may wish to use data from both directions. In this case, any potential bias should be evaluated first."
msgstr ""

#: 
msgid "Low backscatter is measured over water due to specular reflection."
msgstr ""

#: 
msgid "You may have noticed that the water in the individual *VV* and *VH* images isn't a consistent colour. The distortion you're seeing is a type of noise known as speckle, which gives the images a grainy appearence. Speckle noise can be reduced through filtering. Applying a speckle filter will reduce noise and improve our ability to distinguish water from land. If interested, you can find a technical introduction to speckle filtering `here <https://web.archive.org/web/20200618064515/https://earth.esa.int/documents/653194/656796/Speckle_Filtering.pdf>`__."
msgstr ""

#: 
msgid "In the above false color composites, low backscatter is measured over water which appears black or dark blue. High backscatter is measured in urban areas which appear green. The salt and pepper a.k.a speckle noise over water is also visible."
msgstr ""

#: 
msgid "Load Sentinel-1 using ``load_ard``"
msgstr ""

#: 
msgid "This function will load images from Sentinel-1 and apply a pixel-quality mask. The result is an analysis ready dataset free of shadow, and missing data."
msgstr ""

#: 
msgid "Below we plot the masked Sentinel-1 data with high quality."
msgstr ""

#: 
msgid "Histogram Analysis for Sentinel-1 Dataset"
msgstr ""

#: 
msgid "Histrograms below show bimodal distributions where low backscatter is measured over water."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2`, :index:`datasets; sentinel-2`"
msgstr ""

#: 
msgid "Sentinel-2 is an Earth observation mission from the EU Copernicus Programme that systematically acquires optical imagery at high spatial resolution (up to 10 m for some bands). The mission is based on a constellation of two identical satellites in the same orbit, 180° apart for optimal coverage and data delivery. Together, they cover all Earth's land surfaces, large islands, inland and coastal waters every 3-5 days."
msgstr ""

#: 
msgid "Digital Earth Africa provides `Sentinel-2, Level 2A <https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a-processing>`__ (processed to Level 2A using the Sen2Cor algorithm) surface reflectance data. Surface reflectance provides standardised optical datasets by using robust physical models to correct for variations in image radiance values due to atmospheric properties, as well as sun and sensor geometry, resulting an Analysis Ready Data (ARD) product. ARD allows you to analyse surface reflectance data as is without the need to apply additional corrections. The resulting stack of surface reflectance grids are consistent over space and time, which is instrumental in identifying and quantifying environmental change."
msgstr ""

#: 
msgid "Sentinel-2A and Sentinel-2B satellite sensors are stored together under a single product name: ``'s2_l2a'``"
msgstr ""

#: 
msgid "Surface reflectance product (Level 2A)"
msgstr ""

#: 
msgid "Valid SR scaling range: ``1 - 10,000 (0 is no-data)``"
msgstr ""

#: 
msgid "`SCL <https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm>`__ used as pixel quality band"
msgstr ""

#: 
msgid "Date-range: 2017 – present"
msgstr ""

#: 
msgid "Spatial resolution: 10, 20 & 60m"
msgstr ""

#: 
msgid "Note: For a detailed description of DE Africa's Sentinel-2 archive, see DE Africa's `Sentinel-2 technical docs <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-2_Level-2A_specs.html>`__"
msgstr ""

#: 
msgid "In this notebook we will load Sentinel-2 data using two methods. Firstly, we will use ``dc.load()`` to return a time series of satellite images. Secondly, we will load a time series using the ``load_ard()`` function, which is a wrapper function around the dc.load module. This function will load all the images from Sentinel-2 and apply a cloud mask. The returned xarray.Dataset will contain analysis ready images with the cloudy and invalid pixels masked out."
msgstr ""

#: 
msgid "Topics covered include: 1. Inspecting the Sentinel-2 product and measurements available in the datacube 2. Using the native ``dc.load()`` function to load in Sentinel-2 data 3. Using the ``load_ard()`` wrapper function to load in a cloud and pixel-quality masked time series"
msgstr ""

#: 
msgid "We can use datacube's ``list_products`` functionality to inspect the DE Africa's Sentinel-2 products that are available in the datacube. The table below shows the product names that we will use to load the data, a brief description of the data, and the satellite instrument that acquired the data."
msgstr ""

#: 
msgid "We can further inspect the data available for the Sentinel-2 using datacube's ``list_measurements`` functionality. The table below lists each of the measurements available in the data."
msgstr ""

#: 
msgid "Load Sentinel-2 data using ``dc.load()``"
msgstr ""

#: 
msgid "In the example below, we will load data from Sentinel-2 from the Cape of Good Hope, SA in January 2018. We will load data from three spectral satellite bands, as well as cloud masking data (``'SCL'``). By specifying ``output_crs='EPSG:6933'`` and ``resolution=(-10, 10)``, we request that datacube reproject our data to the African Albers coordinate reference system (CRS), with 10 x 10 m pixels. Finally, ``group_by='solar_day'`` ensures that overlapping images taken within seconds of each other as the satellite passes over are combined into a single time step in the data."
msgstr ""

#: 
msgid "Note: Be aware that setting ``resolution`` to the highest available resolution (i.e. ``resolution=(-10, 10)``) will downsample the coarser resolution 20 m and 60 m bands, which may introduce unintended artefacts into your analysis. It is typically best practice to set ``resolution`` to match the lowest resolution band being analysed. For example, if your analysis uses both 10 m and 20 m resolution bands, set ``resolution=(-20, 20)``."
msgstr ""

#: 
msgid "Plotting Sentinel-2 data"
msgstr ""

#: 
msgid "We can plot the data we loaded using the rgb function. By default, the function will plot data as a true colour image using the 'red', 'green', and 'blue' bands."
msgstr ""

#: 
msgid "Load Sentinel-2 using ``load_ard``"
msgstr ""

#: 
msgid "This function will load images from Sentinel-2 and apply a cloud/pixel-quality mask. The result is an analysis ready dataset free of cloud, cloud-shadow, and missing data."
msgstr ""

#: 
msgid "Below we plot the cloud masked Sentinel-2 data."
msgstr ""

#: 
msgid "Note: In the left image, notice that the Sentinel-2 cloud mask (``SCL`` band) fails to identify a lot of the cloud cover. In the image on the right, some of the bright, white coastline has been miss-classified as cloud. These are known limitations of the Sentinel-2 cloud mask, and users should be wary of these limitations when conducting analyses."
msgstr ""

#: 
msgid "**Products used:** `GRAFS <http://dap.nci.org.au/thredds/remoteCatalogService?catalog=http://dapds00.nci.org.au/thredds/catalog/ub8/global/GRAFS/catalog.xml>`__, `ERA5 <https://registry.opendata.aws/ecmwf-era5/>`__"
msgstr ""

#: 
msgid "*Both datasets are external to the Digital Earth Africa platform.*"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ERA5`, :index:`datasets; ERA5`, :index:`data used; GRAFS`, :index:`datasets; GRAFS`, :index:`soil moisture`, :index:`precipitation`"
msgstr ""

#: 
msgid "Soil moisture is a measure of water stored in the soil zone that is accessible to plant roots, making it a major contributing factor to plant health and crop yield."
msgstr ""

#: 
msgid "This product is regularly updated and made available through National Computational Infrastructure's open access THREDDS data server."
msgstr ""

#: 
msgid "This notebook demonstrates the following steps: 1. Retrieval of surface and root-zone wetness through NCI's THREDDS OPeNDAP service 2. Compare soil moisture to precipitation data from ERA5"
msgstr ""

#: 
msgid "Define location and time period of interest. The time period is chosen to be less than a year to limit ERA5 data download."
msgstr ""

#: 
msgid "Retrieval of surface and root-zone wetness"
msgstr ""

#: 
msgid "``Surface wetness`` is measured relative to wettest condition recorded for a location."
msgstr ""

#: 
msgid "``Rootzone Soil Water Index`` is derived from surface relative wetness"
msgstr ""

#: 
msgid "Plot surface and root-zone wetness over time"
msgstr ""

#: 
msgid "Compare soil moisture to precipitation data from ERA5"
msgstr ""

#: 
msgid "The first cell will load the precipitation parameter, ``precipitation_amount_1hour_Accumulation``, from ERA5. Depending on the size of your query, this step can take a few minutes to complete. Data will be stored in the folder ``era5``."
msgstr ""

#: 
msgid "Plot soil moisture with precipitation"
msgstr ""

#: 
msgid "Water Observations from Space (WOfS)"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls <https://explorer.digitalearth.africa/wofs_ls>`__, `wofs_ls_summary_annual <https://explorer.digitalearth.africa/wofs_ls_summary_annual>`__, `wofs_ls_summary_alltime <https://explorer.digitalearth.africa/wofs_ls_summary_alltime>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`datasets; wofs_ls`, :index:`datasets; wofs_ls_summary_alltime`, :index:`datasets; wofs_ls_summary_annual`"
msgstr ""

#: 
msgid "`Water Observations from Space (WOfS) <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ is a service that draws on satellite imagery to provide historical surface water observations of the whole African continent. WOfS allows users to understand the location and movement of inland and coastal water present in the African landscape. It shows where water is usually present; where it is seldom observed; and where inundation of the surface has been observed by satellite."
msgstr ""

#: 
msgid "They are generated using the WOfS classification algorithm on Landsat satellite data. There are several WOfS products available for the African continent, as listed below:"
msgstr ""

#: 
msgid "The ratio of wet to clear observations from each calendar year"
msgstr ""

#: 
msgid "The ratio of wet to clear observations over all time"
msgstr ""

#: 
msgid "WOFLs (WOfS Feature Layers)"
msgstr ""

#: 
msgid "**WOfS Annual/All-Time Summary:** The frequency a pixel was classified as wet. This requires:"
msgstr ""

#: 
msgid "Total number of clear observations for each pixel: the number of observations that were clear (no cloud or shadow) for the selected time period. The classification algorithm then assigns these as either wet, or dry."
msgstr ""

#: 
msgid "The WOfS Summaries are calculated as the ratio of clear wet observations to total clear observations."
msgstr ""

#: 
msgid "\\text{WOfS Summary (frequency)} = \\frac{\\text{Number of Clear and Wet Observations}}{\\text{Number of Clear Observations}}\n"
"\n"
""
msgstr ""

#: 
msgid "**WOFLs (WOfS Feature Layers):** Individual water-classified images are called Water Observation Feature Layers (WOFLs), and are created from the input satellite data. There is one WOFL for each satellite dataset processed for the occurrence of water. For more information on WOFLs, see the `Applying WOfS bitmasking <../Frequently_used_code/Applying_WOfS_bitmasking.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Mueller, N., Lewis, A., Roberts, D., Ring, S., Melrose, R., Sixsmith, J., Lymburner, L., McIntyre, A., Tan, P., Curnow, S., & Ip, A. (2016). Water observations from space: Mapping surface water from 25 years of Landsat imagery across Australia. Remote Sensing of Environment, 174, 341-352."
msgstr ""

#: 
msgid "This notebook explains loading WOFLs and the WOfS summaries."
msgstr ""

#: 
msgid "This notebook demonstrates how to: 1. Load and plot WOFLS for multiple time-steps 2. Load WOfS annual summaries 3. Load the WOfS all-time summary"
msgstr ""

#: 
msgid "For a detailed example of using WOfS for water resource management, see the `Water_extent_WOfS <../Real_world_examples/Water_extent_WOfS.ipynb>`__ notebook in the DE Africa sandbox."
msgstr ""

#: 
msgid "List of WOfS products available in Digital Earth Africa"
msgstr ""

#: 
msgid "The following items are included in the \"query\" that defines what the datacube need to return."
msgstr ""

#: 
msgid "``time``: date range to fetch the scenes. The approximate time between two scenes is 16 days. If there is a location near a swathe boundary, it may be captured in two passes and so there could be two images within the 16 day period."
msgstr ""

#: 
msgid "The default location is Lake Ngami in Botswana."
msgstr ""

#: 
msgid "Load WOfS Feature Layers (WOFLs)"
msgstr ""

#: 
msgid "Here, it is not necessary to directly call on the bit flags as we can use the selection ``wet=True`` to create the water mask, while ``dry=True`` gives the opposite. In this case, ``isel`` is used to select a single timestep, and shows the wet/dry pixels for that increment only."
msgstr ""

#: 
msgid "We can plot WOFLs using the ``plot_wofs`` function. We can see that our study area includes one large waterbody. We can also see that some observations contain clouds, cloud shadow, and regions of no-data."
msgstr ""

#: 
msgid "Masking using WOfS bit flags"
msgstr ""

#: 
msgid "WOFLs uses `bit flags <https://datacube-core.readthedocs.io/en/latest/api/indexed-data/masking.html>`__ to flag pixels as \"wet\" or otherwise. For more details on bitmasking with WOfS, see the `Applying WOfS bitmasking <../Frequently_used_code/Applying_WOfS_bitmasking.ipynb>`__ notebook."
msgstr ""

#: 
msgid "We can convert the WOfS bit field into a binary array containing True and False values. This allows us to use the WOFL data as a mask that can be applied to other datasets."
msgstr ""

#: 
msgid "The ``make_mask`` function allows us to create a mask using the flag labels (e.g. \"wet\" or \"dry\") rather than the binary numbersin the mask. For example, we can easily identify pixels that were wet in each image (i.e. yellow) by passing the flag ``wet=True``:"
msgstr ""

#: 
msgid "Loading WOfS annual summaries"
msgstr ""

#: 
msgid "To look at a summary of WOFLs over a calender year, we can load the ``wofs_ls_summary_annual`` product. This can be useful to understand at a glance the annual dynamics of a waterbody. The WOfS Annual Summary product is pre-calculated, which makes it faster to load. It has three measuremts: ``count_wet``, ``count_clear``, and ``frequency``."
msgstr ""

#: 
msgid "Plotting WOfS frequency"
msgstr ""

#: 
msgid "The plot below will have values that range from 0 to 1. Values that approach 1 indicate a permanent waterbody, while values closer to 0 indicate a more ephemeral or seasonal waterbody."
msgstr ""

#: 
msgid "Loading WOfS 'all-time' summaries"
msgstr ""

#: 
msgid "To look at a summary of WOFLs over the entire Landsat archive (around 1984 to present), we can load the ``wofs_ls_summary_alltime`` product."
msgstr ""

#: 
msgid "Plot the WOfS all-time summary"
msgstr ""

#: 
msgid "Waterbodies"
msgstr ""

#: 
msgid "**Products used:** `DE Africa Waterbodies <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; waterbodies`"
msgstr ""

#: 
msgid "The service offers two products:"
msgstr ""

#: 
msgid "The DE Africa Waterbodies Historical Extent"
msgstr ""

#: 
msgid "The DE Africa Waterbodies Surface Area Change"
msgstr ""

#: 
msgid "The DE Africa Waterbodies Historical Extent product is a static polygon-based view of the DE Africa Water Observations from Space All-Time Summary product. The historical extent represents where water has appeared in at least 5% of clear observations since 1987. It is not a capture of a water body’s true extent in any given year, but a record of where water has appeared since 1987. To be captured in the dataset, polygons must have an area of at least 4,500 metres squared (5 Landsat pixels). The historical extent polygons have been derived from the `DE Africa Water Observations from Space All-Time Summary <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-All-Time-Summary>`__ product, which provides historical surface water observations across the African continent."
msgstr ""

#: 
msgid "For each water body, the Surface Area Change product provides the percentage of the historical extent that was classified as wet, dry, or invalid, for each `DE Africa Water Observation from Space Feature Layer <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html#WOfS-Feature-Layer>`__ scene that captured the water body. This can be used to identify when water bodies are increasing or decreasing in wet surface area."
msgstr ""

#: 
msgid "**Disclaimer: DE Africa Waterbodies Surface Area Change measures the wet surface area of waterbodies as estimated from satellites. This product does not measure depth, volume, purpose of the waterbody, nor the source of the water.**"
msgstr ""

#: 
msgid "Identify and analyse persistent and seasonal water bodies"
msgstr ""

#: 
msgid "Water resource management"
msgstr ""

#: 
msgid "Gain insights into the severity and spatial distribution of drought"
msgstr ""

#: 
msgid "This notebook will demonstrate how to load historical extents and wet surface area timeseries from the `DE Africa Waterbodies service <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html>`__."
msgstr ""

#: 
msgid "Getting a list of available polygons in a given area"
msgstr ""

#: 
msgid "Select and plot a single polygon"
msgstr ""

#: 
msgid "Plotting the surface area of the polygon over time"
msgstr ""

#: 
msgid "To run this analysis, run all the cells in the notebook, starting with the “Load packages” cell."
msgstr ""

#: 
msgid "``lat``, ``lon``, ``buffer``: center lat/lon and analysis window size for the area of interest (in degrees)"
msgstr ""

#: 
msgid "The default area is a water body in Mauritania."
msgstr ""

#: 
msgid "Getting data"
msgstr ""

#: 
msgid "The ``deafrica_waterbodies`` module allows you to query water bodies by location or geohash."
msgstr ""

#: 
msgid "List waterbody polygons in an area"
msgstr ""

#: 
msgid "We can get a list of waterbody polygons inside a bounding box of coordinates using ``get_waterbodies``."
msgstr ""

#: 
msgid "The returned geodataframe includes all the water bodies which are located within the bounding box. This dataset contains metadata for each water body in the dataset, including the ID, UID, WB_UID, area, perimeter and time series. See the `Waterbodies Historical Extent documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html#Waterbodies-Historical-Extent>`__ for descriptions of each attribute."
msgstr ""

#: 
msgid "Displaying the polygons"
msgstr ""

#: 
msgid "Once the water body polygons are in memory, you can plot them directly, or explore them in an interactive window."
msgstr ""

#: 
msgid "Geohashes"
msgstr ""

#: 
msgid "Every water body in DE Africa Water Bodies has a unique identifier (UID) called a `geohash <https://en.wikipedia.org/wiki/Geohash>`__. The geohash of a water body is derived from its position, and this process can be reversed to obtain the location from the geohash. A waterbody's geohash is contained under the UID attribute and can be obtained through `DE Africa Maps <https://maps.digitalearth.africa/>`__ by clicking on a waterbody."
msgstr ""

#: 
msgid "**Note:** You might notice that these polygons have a range of similar geohash prefixes ('edyg' or 'edz'). If two geohashes have a similar prefix, this means that they are close together."
msgstr ""

#: 
msgid "Getting data for a specific water body"
msgstr ""

#: 
msgid "We can use the ``.explore()`` function above to interactively explore the subset of water bodies located within the bounding box. Hovering over a water body will display its attributes, including the water body's geohash (UID). After noting the geohash from the ``.explore()`` function, we can use it to extract just that water body through the ``get_waterbody()`` function."
msgstr ""

#: 
msgid "By default, try the geohash ``edz5cm96jh``."
msgstr ""

#: 
msgid "Plot the selected water body"
msgstr ""

#: 
msgid "Get the wet surface area time series for the selected waterbody"
msgstr ""

#: 
msgid "For any given geohash or a polygon, we can also use the ``get_time_series()`` function to get various measures of the water body surface over time. See the `Waterbodies Historical Extent documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html#Waterbodies-Surface-Area-Change>`__ for descriptions of the different surface measures."
msgstr ""

#: 
msgid "The function also calculates a rolling median of the water body surface wet percentage. This is used to visualise the overall trend in the surface wet percentage. The rolling median uses the last three observations to determine the median at a given date."
msgstr ""

#: 
msgid "Display the wet surface area time series for the selected waterbody"
msgstr ""

#: 
msgid "After loading the water body time series, we can use the ``display_time_series()`` function to create an interactive visualisation of the time series."
msgstr ""

#: 
msgid "The visualisation shows the invalid percentage and the wet percentage. The invalid percentage indicates the proportion of the water body that couldn't be clearly observed. To provide the most representative measurements of water body surface area, the time series only contains values where the invalid percentage is lower than 10%."
msgstr ""

#: 
msgid "There are some caveats to be aware of:"
msgstr ""

#: 
msgid "To appear in the time series, an observation must record clear observations of at least 90% of the water body's surface area. If 10% or more of the surface area is covered by cloud or cloud shadow, the observation will be excluded. This can cause large gaps in the time series."
msgstr ""

#: 
msgid "If the invalid percentage is high, it's likely that the wet percentage is an underestimate of the true wet surface area."
msgstr ""

#: 
msgid "Annual and seasonal trends should only be inferred during times with sufficient observations. You should take care when infering the surface water change across time when there are few observations."
msgstr ""

#: 
msgid "The time series is based on the Water Observations from Space product, which has known limitations. See the `DE Africa Waterbodies service documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Waterbodies_specs.html>`__ for more information."
msgstr ""

#: 
msgid "The World Settlement Footprint (WSF)"
msgstr ""

#: 
msgid "**Products used:** `wsf_2015 <https://explorer.digitalearth.africa/products/wsf_2015>`__, `wsf_2019 <https://explorer.digitalearth.africa/products/wsf_2019>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; World Settlement Footprint`, :index:`datasets; wsf_2015` :index:`datasets; wsf_2019` :index:`data used; World Settlement Footprint`"
msgstr ""

#: 
msgid "To improve the understanding of current trends in global urbanisation, ESA and the German Aerospace Center (DLR), in collaboration with the Google Earth Engine team, are jointly developing the World Settlement Footprint – the world’s most comprehensive dataset on human settlement (G.D.Team, 2023)."
msgstr ""

#: 
msgid "The **World Settlement Footprint 2015** is a 10m (0.32 arc sec) resolution binary mask outlining the 2015 global settlement extent derived by jointly exploiting multitemporal Sentinel-1 radar and Landsat-8 optical satellite imagery (Marconcini et al., 2020)."
msgstr ""

#: 
msgid "The **World Settlement Footprint 2019** features data from the Copernicus Sentinel-1 and Sentinel-2 missions and provides information on global human settlements with unprecedented detail and precision (Marconcini et al., 2021)."
msgstr ""

#: 
msgid "The World Settlement Footprint 2015 and 2019 data are now indexed in the DE Africa platform."
msgstr ""

#: 
msgid "This notebook is a walkthrough on how to use the World Settlement Footprint 2015 and 2019 in the data cube. The worked example takes users through the code required to:"
msgstr ""

#: 
msgid "Inspect the WSF dataset"
msgstr ""

#: 
msgid "Use the ``dc.load()`` function in loading WSF dataset"
msgstr ""

#: 
msgid "Plot results for the WSF dataset \\**\\*"
msgstr ""

#: 
msgid "We can inspect the data available for WSF using datacube's ``list_measurements`` functionality. The table below lists the products and measurements available for the three WSF datasets indexed within DE Africa's datacube."
msgstr ""

#: 
msgid "The default location is Kumasi, Ashanti Region, Ghana"
msgstr ""

#: 
msgid "Loading of the WSF Dataset"
msgstr ""

#: 
msgid "The WSF dataset will be loaded using the ``dc.load`` function. For more discussion on how to load data using the datacube, refer to the `Introduction to loading data <../Beginners_guide/03_Loading_data.ipynb>`__ notebook."
msgstr ""

#: 
msgid "The cell below loads the wsf_2015 dataset. Notice the ``product`` and ``measurements`` values. These will be updated for the subsequent data when they are being loaded."
msgstr ""

#: 
msgid "The cell below loads the wsf_2019 dataset, notice the product and measurement is change to ``wsf_2019`` and ``wsf2019`` respectively. Aside from that the query is the same as the previous query defined."
msgstr ""

#: 
msgid "Spatial Plotting of data"
msgstr ""

#: 
msgid "The WSF dataset comes with two pixel values: ``0`` (no data) and ``255`` (settlement footprint). For the plot below, because we are interested in the settlement footprint so the dataset will be filtered to only include ``255`` values. After the filtering, the WSF datasets for 2015 and 2019 are plotted."
msgstr ""

#: 
msgid "Calculate the area of the settlement footprint"
msgstr ""

#: 
msgid "The number of pixels can be used for the area of the building if the pixel area is known. Run the following cell to generate the necessary constants for performing this conversion."
msgstr ""

#: 
msgid "The constant value ``area_per_pixel`` calculated above will be multiplied by the number of pixels to get the area of the building footprint for 2015 and 2019. The area will be plotted in a bar chart to compare the metric values across the evolution of buildings between the two years."
msgstr ""

#: 
msgid "Plotting of Spatial Change"
msgstr ""

#: 
msgid "A bar graph aided in visualizing the comparison of the settlement area between 2015 and 2019, but a spatial plot will enable us to visualise the areas where there was development of settlements. To identify the areas that had an change between 2015 and 2019, 2015 will serve as the baseline against 2019. The difference will be plotted to determine the area of change."
msgstr ""

#: 
msgid "The World Settlement Footprint offers a knowledge base that can help researchers, governmental organizations, and other stakeholders, such as urban planners, better understand how urbanization is happening and, concurrently, put in place sustainable urban development strategies for informed policy decisions at local and national levels."
msgstr ""

#: 
msgid "**Note**"
msgstr ""

#: 
msgid "To run for different area go to cell **Analysis parameters**, change the **lat** and **lon** values in the **define_area_function**."
msgstr ""

#: 
msgid "Referencing"
msgstr ""

#: 
msgid "World Settlement Footprint - Evolution"
msgstr ""

#: 
msgid "**Products used:** `wsf_evolution <https://explorer.digitalearth.africa/products/wsf_evolution>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; World Settlement Footprint`,:index:`data used; World Settlement Footprint - Evolution`, :index:`datasets; wsf_evolution`"
msgstr ""

#: 
msgid "To improve the understanding of current trends in global urbanisation, ESA and the German Aerospace Center (DLR), in collaboration with the Google Earth Engine team, are jointly developing the World Settlement Footprint – the world’s most comprehensive dataset on human settlement."
msgstr ""

#: 
msgid "The **World Settlement Footprint Evolution** was produced by processing seven million images from the US Landsat satellite collected between 1985 and 2015 and shows the annual growth of human settlements globally (Mapping Our Human Footprint From Space, 2023). It is worth noting that **past Landsat-5/7 availability** considerably varies across the world and over time. Independently from the implemented approach, this might then result in a lower quality of the final product where few/no scenes have been collected. To provide users with a suitable and intuitive measure that accounts for the availabilty of Landsat imagery, the **Input Data Consistency (IDC) score** was implemented. It ranges from 6 to 1 with: 6) very good; 5) good; 4) fair; 3) moderate; 2) low; 1) very low. The IDC score supports a proper interpretation of the WSF evolution product (Marconcini et al., 2021)."
msgstr ""

#: 
msgid "The World Settlement Footprint evolution data are now indexed in the DE Africa platform."
msgstr ""

#: 
msgid "This notebook is a walkthrough on how to use the World Settlement Footprint Evolution data in the data cube. The worked example takes users through the code required to:"
msgstr ""

#: 
msgid "Inspecting the WSF Evolution data in the datacube"
msgstr ""

#: 
msgid "Use ``dc.load()`` function to load in WSF data"
msgstr ""

#: 
msgid "Plotting of results for WSF Evolution data"
msgstr ""

#: 
msgid "The default location is Mansoura, Egypt."
msgstr ""

#: 
msgid "Loading of the WSF Evolution Dataset"
msgstr ""

#: 
msgid "The WSF Evolution dataset will be loaded using the ``dc.load`` function. For more discussion on how to load data using the datacube, refer to the `Introduction to loading data <../Beginners_guide/03_Loading_data.ipynb>`__ notebook."
msgstr ""

#: 
msgid "The cell below loads the WSF Evolution dataset. Notice the ``product`` and ``measurements`` values. These will be updated for the subsequent data when they are being loaded."
msgstr ""

#: 
msgid "Spatial Plotting of WSF Evolution data"
msgstr ""

#: 
msgid "Spatial plot enable us to visualise the areas where there was development of settlements. To identify evolution of the area from 1985 to 2015."
msgstr ""

#: 
msgid "The IDC score supports a proper interpretation of the WSF Evolution product. **Input Data Consistency (IDC) score,which ranges from 6 to 1 with: 6 - very good; 5 - good; 4 - fair; 3 - moderate; 2 - low; 1 - very low**."
msgstr ""

#: 
msgid "From the spatial plotting above, the left image shows the evolution from 1985 to 2015, while the right image indicates the IDC score for the study area. Looking at the IDC score of **6** for the area of study, the values obtained from the WSF Evolution data can be classified as **very good**, and one can rely on it for further analysis."
msgstr ""

#: 
msgid "Calculate the area of settlement footprint"
msgstr ""

#: 
msgid "Plotting of the WSF Evolution data"
msgstr ""

#: 
msgid "Each pixel represents the year value of the WSF evolution dataset; to get the area of the evolution, the year pixel has to be counted and saved in a Pandas dataframe to enable calculation of the area. The cumulative sum of area will be calculated based on how it has increased over the period."
msgstr ""

#: 
msgid "Note that there is a discrepancy between the area calculated for 2015 from the WSF 2015 product and the Evolution product. This may be because the Evolution product is derived from Landsat-5 and Landsat-7, whereas WSF 2015 and 2019 are derived from Sentinel-1 and Landsat-8."
msgstr ""

#: 
msgid "It is worth noting that past Landsat-5/7 availability considerably varies across the world and over time. Independently from the implemented approach, this might then result in a lower quality of the final product where few/no scenes have been collected. The **IDC score** supports a proper interpretation of the WSF evolution product."
msgstr ""

#: 
msgid "Animation of WSF Evolution data from 1985 to 2015"
msgstr ""

#: 
msgid "The cell below plots out the dataset and shows the animation of how the building footprint has evolved over the years from 1985 to 2015."
msgstr ""

#: 
msgid "iSDA soil data"
msgstr ""

#: 
msgid "**Products used:** `iSDA Soil <https://aws.amazon.com/marketplace/pp/prodview-3bfpv6jsl4tqk?sr=0-4&ref_=beagle&applicationId=AWSMPContessa>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; iSDA soil`, :index:`soil`, :index:`data used; isda_soil_bedrock_depth`, :index:`data used; isda_soil_bulk_density`, :index:`data used; isda_soil_carbon_total`, :index:`data used; isda_soil_clay_content`, :index:`data used; isda_soil_sand_content`, :index:`data used; isda_soil_silt_content`,"
msgstr ""

#: 
msgid "`iSDAsoil <https://www.isda-africa.com/isdasoil/>`__ is an open access soils data resource for the African continent. Soils data can be useful for a range of applications including land suitability mapping for agriculture, soil amelioration planning (e.g. liming to address acidic soils or fertiliser to address fertility constraints), and for construction/ infrastructure planning."
msgstr ""

#: 
msgid "This notebook demonstrates how to integrate this data with DE Africa products and workflows. For technical information on iSDAsoil, see `Miller et al. 2021 <https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.3001441>`__. Some of the code in this notebook has been adapted from the `iSDA-Africa GitHub <https://github.com/iSDA-Africa>`__."
msgstr ""

#: 
msgid "Load iSDA data"
msgstr ""

#: 
msgid "Visualise iSDA against DE Africa products"
msgstr ""

#: 
msgid "Note that we are loading a module called ``load_isda()`` for this notebook which takes a little while to load."
msgstr ""

#: 
msgid "iSDA offers numerous soil variables shown in the table below. Many of the variables have four layers: mean and standard deviation at 0-20cm and 20-5cm depth. We will see through the notebook that we can bring in each variable with the Access Names e.g. 'bedrock_depth'."
msgstr ""

#: 
msgid "Aluminium, extractable"
msgstr ""

#: 
msgid "aluminium_extractable"
msgstr ""

#: 
msgid "Calcium, extractable"
msgstr ""

#: 
msgid "calcium_extractable"
msgstr ""

#: 
msgid "Carbon, organic"
msgstr ""

#: 
msgid "carbon_organic"
msgstr ""

#: 
msgid "Effective Cation Exchange Capacity"
msgstr ""

#: 
msgid "cation_exchange_capacity"
msgstr ""

#: 
msgid "Fertility Capability Classification"
msgstr ""

#: 
msgid "fcc"
msgstr ""

#: 
msgid "Single classification layer"
msgstr ""

#: 
msgid "Iron, extractable"
msgstr ""

#: 
msgid "iron_extractable"
msgstr ""

#: 
msgid "Magnesium, extractable"
msgstr ""

#: 
msgid "magnesium_extractable"
msgstr ""

#: 
msgid "Nitrogen, total"
msgstr ""

#: 
msgid "nitrogen_total"
msgstr ""

#: 
msgid "pH"
msgstr ""

#: 
msgid "ph"
msgstr ""

#: 
msgid "Phosphorus, extractable"
msgstr ""

#: 
msgid "phosphorous_extractable"
msgstr ""

#: 
msgid "Potassium, extractable"
msgstr ""

#: 
msgid "potassium_extractable"
msgstr ""

#: 
msgid "Stone content"
msgstr ""

#: 
msgid "stone_content"
msgstr ""

#: 
msgid "Coarse fragments predicted at 0-20cm depth"
msgstr ""

#: 
msgid "Sulphur, extractable"
msgstr ""

#: 
msgid "sulphur_extractable"
msgstr ""

#: 
msgid "USDA Texture Class"
msgstr ""

#: 
msgid "texture_class"
msgstr ""

#: 
msgid "0-20cm and 20-50cm depth, predicted mean"
msgstr ""

#: 
msgid "Zinc, extractable"
msgstr ""

#: 
msgid "zinc_extractable"
msgstr ""

#: 
msgid "Indexed soil data"
msgstr ""

#: 
msgid "There are six iSDA soil datasets indexed by Digital Earth Africa and available for direct loading."
msgstr ""

#: 
msgid "Many of the soil products have measurements for two depths: 0-20cm and 20-50cm. They also have mean estimates plus standard deviations, as shown below for total soil carbon."
msgstr ""

#: 
msgid "Define parameters"
msgstr ""

#: 
msgid "Let's define some parameters for loading the soil carbon data for a coastal area near Cape Town, South Africa."
msgstr ""

#: 
msgid "Load iSDA soil data using ``dc.load()``"
msgstr ""

#: 
msgid "Now that we know what products and measurements are available, we can load data from the datacube using ``dc.load``."
msgstr ""

#: 
msgid "Apply transformation"
msgstr ""

#: 
msgid "Importantly, much of the iSDA data needs to be transformed before it's applied. For indexed datasets, we can get conversion metadata associated with each variable in the ``flags_definition``. This is performed for our selected variable below."
msgstr ""

#: 
msgid "Plot soil information"
msgstr ""

#: 
msgid "The plots below show soil carbon in g/kg. There are some outliers evident in the standard deviation products so we use ``clip(0,1)`` to plot a sensible range."
msgstr ""

#: 
msgid "Load iSDA data from source"
msgstr ""

#: 
msgid "As we saw in the introductory sections of this notebook, there are six iSDA variables indexed by Digital Earth Africa for loading using ``dc.load``."
msgstr ""

#: 
msgid "Other iSDA datasets can be loaded from source. Though there are some complexities with this method of loading as metadata must be accessed to identify transformations, and we must also allocate a spatial projection."
msgstr ""

#: 
msgid "Link to iSDA metadata"
msgstr ""

#: 
msgid "There are a few complexities associated with the iSDA data, such as back-transformations / conversions that we will see later in the notebook. We need to link to metadata so we can explore these."
msgstr ""

#: 
msgid "The cell below provides a link to the necessary metadata."
msgstr ""

#: 
msgid "Load Fertility Capability Classification"
msgstr ""

#: 
msgid "The cell below uses the ``load_isda()`` function to bring in Fertility Capability Classification for the area defined above."
msgstr ""

#: 
msgid "We can see below that the function returns a variable called ``band_data`` as ``float32``."
msgstr ""

#: 
msgid "Importantly, much of the iSDA data needs to be transformed before it's applied. We can use the object we stored called ``assets`` to get conversion metadata associated with each variable. This is performed for our selected variable below."
msgstr ""

#: 
msgid "We can see that the ``fcc`` variable returns a conversion value of ``%3000``."
msgstr ""

#: 
msgid "Below, the transformation is made and a new band added to the dataset. The values are converted to integers for easier interpretation and plotting."
msgstr ""

#: 
msgid "Labels can also be drawn from the metadata. Below, classes of fertility are mapped to their respective integers for better plotting outputs."
msgstr ""

#: 
msgid "Plot Fertility Capability Classification"
msgstr ""

#: 
msgid "We can now plot the ``fcc`` data with labels."
msgstr ""

#: 
msgid "Clay in Okavango Delta"
msgstr ""

#: 
msgid "Now we'll inspect soil clay content in the Okavango Delta, Botswana."
msgstr ""

#: 
msgid "New parameters"
msgstr ""

#: 
msgid "New parameters for data loading are defined in the cell below. The ``var`` object is taken from the relevant Access Name shown at the beginning of this notebook."
msgstr ""

#: 
msgid "Use the ``load_isda()`` function to bring in clay content data."
msgstr ""

#: 
msgid "Check if and how the data needs to be transformed. In this case, there is no transformation and the data can be interpreted as %, so we can proceed."
msgstr ""

#: 
msgid "Soil pH"
msgstr ""

#: 
msgid "Finally, we'll inspect soil pH for the same Okavango Delta region."
msgstr ""

#: 
msgid "The ``lat`` and ``lon`` definitions will remain constant, just the ``var`` is changed below, as per the table with Access Names at the beginning of the notebook."
msgstr ""

#: 
msgid "Check if and how the data needs to be transformed."
msgstr ""

#: 
msgid "We need to divide by 10, which is executed below."
msgstr ""

#: 
msgid "Inspecting the xarray.Dataset above, from when we called ``ds``, also indicates the need for transformation. We would expect pH values to range between 0 and 14, but we can see values around 60-70. The range below, after dividing by 10, looks better."
msgstr ""

#: 
msgid "Conclusions"
msgstr ""

#: 
msgid "This notebook gave an introduction into loading `iSDA soil <https://www.isda-africa.com/isdasoil/>`__ data into the Digital Earth Africa sandbox."
msgstr ""

#: 
msgid "Are any patterns observable between the Okavango Delta formation, clay content, and soil pH? How does the Fertility Capability Classification map align with the true colour image?"
msgstr ""

#: 
msgid "This notebook is intended to be a starting point. Users may like to try loading data for other areas or other soil variables."
msgstr ""

#: 
msgid "Notebooks introducing DE Africa's satellite datasets and derived products, including how to load each dataset and any special features of the data. Some external datasets that are useful for analysing and interpreting DE Africa products are also covered."
msgstr ""

#: 
msgid "Run analyses on multiple polygons"
msgstr ""

#: 
msgid "**Keywords**: :index:`spatial analysis; polygons`, :index:`data used; sentinel-2`, :index:`python package; GeoPandas`, :index:`band index; NDVI`"
msgstr ""

#: 
msgid "Many users need to run analyses on their own areas of interest. A common use case involves running the same analysis across multiple polygons in a vector file (e.g. ESRI Shapefile or GeoJSON). This notebook will demonstrate how to use a vector file and the Open Data Cube to extract satellite data from Digital Earth Africa to match individual polygon geometries."
msgstr ""

#: 
msgid "If we have a vector file containing multiple polygons, we can use the python package `geopandas <https://geopandas.org/>`__ to open it as a ``GeoDataFrame``. We can then iterate through each geometry and extract satellite data corresponding with the extent of each geometry. Further anlaysis can then be conducted on each resulting ``xarray.Dataset``."
msgstr ""

#: 
msgid "In this notebook, we demonstrate how to retrieve data for each polygon and perform an analysis. The example analysis in this notebook is to load and plot the normalised difference vegetation index (NDVI). This is conducted through the following steps:"
msgstr ""

#: 
msgid "Open the file of polygons using ``geopandas``."
msgstr ""

#: 
msgid "Iterate through the generated GeoDataFrame, extracting satellite data from DE Africa's Open Data Cube."
msgstr ""

#: 
msgid "Calculate NDVI as an example analysis on one of the extracted satellite timeseries."
msgstr ""

#: 
msgid "Plot NDVI for the polygon extent."
msgstr ""

#: 
msgid "Please note the use of ``datacube.utils`` package ``geometry``: this is important for saving the coordinate reference system of the incoming shapefile in a format that the Digital Earth Africa query can understand."
msgstr ""

#: 
msgid "Connect to the datacube database to enable loading Digital Earth Australia data."
msgstr ""

#: 
msgid "``time_range`` : Enter a time range for your query, e.g.\\ ``('2019-01', '2019-12')`` if you wanted data from all of 2019"
msgstr ""

#: 
msgid "``vector_file`` : A path to a vector file (ESRI Shapefile or GeoJSON) containing polygons to load. For this example we have provided a demonstration Shapefile"
msgstr ""

#: 
msgid "``attribute_col`` : A column in the vector file used to label the output ``xarray`` datasets containing satellite images. Each row of this column should have a unique identifier"
msgstr ""

#: 
msgid "``products`` : A list of product names to load from the datacube, e.g. ``['ls8_c2l2', 'ls7_c2l2']``. In this example we will use only Sentinel-2 data, ``['s2_l2a']``"
msgstr ""

#: 
msgid "``measurements`` : A list of band names to load from the satellite product, e.g. ``['red', 'green']``"
msgstr ""

#: 
msgid "``resolution`` : The spatial resolution of the loaded satellite data in the ``x`` and ``y`` directions in metres. For this Sentinel-2 example, we have selected ``(-20, 20)``"
msgstr ""

#: 
msgid "``output_crs`` : The coordinate reference system/map projection to load data into, e.g. ``'EPSG:6933'`` to load data in an Equal Area projection for Africa"
msgstr ""

#: 
msgid "Look at the structure of the vector file"
msgstr ""

#: 
msgid "Import the file and take a look at how the file is structured so we understand what we are iterating through. There are three polygons in the file:"
msgstr ""

#: 
msgid "We will also update the ``id`` column to give each polygon a unique identifier. This will be used to identify the satelllite data corresponding with the polygon in the results dictionary"
msgstr ""

#: 
msgid "We can then plot the ``geopandas.GeoDataFrame`` using the function ``map_shapefile`` to make sure it covers the area of interest we are concerned with:"
msgstr ""

#: 
msgid "Create a datacube query object"
msgstr ""

#: 
msgid "We then create a dictionary that will contain the parameters that will be used to load data from the Digital Earth Africa datacube:"
msgstr ""

#: 
msgid "**Note:** We do not include the usual ``x`` and ``y`` spatial query parameters here, as these will be taken directly from each of our vector polygon objects."
msgstr ""

#: 
msgid "Loading satellite data"
msgstr ""

#: 
msgid "Here we will iterate through each row of the ``geopandas.GeoDataFrame`` and load satellite data. The results will be appended to a dictionary object which we can later index to analyse each dataset."
msgstr ""

#: 
msgid "Further analysis"
msgstr ""

#: 
msgid "Our ``results`` dictionary will contain ``xarray`` objects labelled by the unique ``attribute_col`` values we specified in the ``Analysis parameters`` section:"
msgstr ""

#: 
msgid "Enter one of those values below to index our dictionary and conduct further analsyis on the satellite timeseries for that polygon."
msgstr ""

#: 
msgid "Plot an RGB image"
msgstr ""

#: 
msgid "We can now use the ``dea_plotting.rgb`` function to plot our loaded data as a three-band RGB plot:"
msgstr ""

#: 
msgid "Calculate NDVI and plot"
msgstr ""

#: 
msgid "We can also apply analyses to data loaded for each of our polygons. For example, we can calculate the normalised difference vegetation index (NDVI) to identify areas of growing vegetation."
msgstr ""

#: 
msgid "**Note**: NDVI can be calculated using the `calculate_indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ function, imported from `deafrica_tools.bandindices <../Tools/deafrica_tools/bandindices.py>`__. Here, we use ``satellite_mission='s2'`` since we are working with Sentinel-2 data."
msgstr ""

#: 
msgid "Generating animated time series using ``xr_animation``"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`data methods; animation`, :index:`band index; NDWI`"
msgstr ""

#: 
msgid "Animations can be a powerful method for visualising change in the landscape across time using satellite imagery. Satellite data from Digital Earth Africa is an ideal subject for animations as it has been georeferenced, processed to analysis-ready surface reflectance, and stacked into a spatio-temporal 'data cube', allowing landscape conditions to be extracted and visualised consistently across time."
msgstr ""

#: 
msgid "Using the DE Africa functions in ``Scripts/deafrica_plotting``, which are based on ``matplotlib.animation`` and ``xarray``, we can take a time series of Digital Earth Africa satellite imagery and export a visually appealing time series animation that shows how any location in Africa has changed."
msgstr ""

#: 
msgid "This notebook demonstrates how to:"
msgstr ""

#: 
msgid "Import a time series of cloud-free satellite imagery from multiple satellites (i.e. Sentinel-2A and -2B) as an xarray dataset"
msgstr ""

#: 
msgid "Plot the data as a three band time series animation"
msgstr ""

#: 
msgid "Plot the data as a one band time series animation"
msgstr ""

#: 
msgid "Export the resulting animations as either a GIF or MP4 file"
msgstr ""

#: 
msgid "Add custom vector overlays"
msgstr ""

#: 
msgid "Apply custom image processing functions to each animation frame"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results."
msgstr ""

#: 
msgid "Load satellite data from datacube"
msgstr ""

#: 
msgid "We can use the `load_ard <Using_load_ard.ipynb>`__ function to load data from multiple satellites (i.e. Sentinel-2A and -2B), and return a single ``xarray.Dataset`` containing only observations with a minimum percentage of good quality pixels. This will allow us to create a visually appealing time series animation of observations that are not affected by cloud."
msgstr ""

#: 
msgid "In the example below, we request that the function returns only observations which are 95% free of clouds and other poor quality pixels by specifyinge ``min_gooddata=0.95``."
msgstr ""

#: 
msgid "To get a quick idea of what the data looks like, we can plot the dataset in true colour using the ``rgb`` function:"
msgstr ""

#: 
msgid "Plot time series as a RGB/three band animated GIF"
msgstr ""

#: 
msgid "The ``xr_animation()`` function is based on functionality within ``matplotlib.animation``. It takes an ``xarray.Dataset`` and exports a one band or three band (e.g. true or false colour) GIF or MP4 animation showing changes in the landscape across time."
msgstr ""

#: 
msgid "In the next cell, we plot the dataset we loaded above as an animated GIF, using the ``['red', 'green', 'blue']`` satellite bands to generate a true colour RGB animation."
msgstr ""

#: 
msgid "The interval between the animation frames is set to to 200 milliseconds using ``interval``, and the width of the animation to 300 pixels using ``width_pixels``. If these parameters are not specified, the function will use a default ``interval`` value of 100 milliseconds, and a default ``width_pixels`` value of 500 pixels."
msgstr ""

#: 
msgid "We can also use different band combinations (e.g. false colour) using ``bands``, add additional text using ``show_text``, and change the font size using ``annotation_kwargs``, which passes a dictionary of values to the matplotlib ``plt.annotate`` function (see `matplotlib.pyplot.annotate <https://matplotlib.org/api/_as_gen/matplotlib.pyplot.annotate.html>`__ for options)."
msgstr ""

#: 
msgid "The function will automatically select an appropriate colour stretch by clipping the data to remove outliers/extreme values smaller or greater than the 2 and 98th percentiles (e.g. similar to xarray's ``robust=True``). This can be controlled further with the ``percentile_stretch`` parameter. For example, setting ``percentile_stretch=(0.01, 0.99)`` will apply a colour stretch with less contrast:"
msgstr ""

#: 
msgid "Plotting single band animations"
msgstr ""

#: 
msgid "It is also possible to plot a single band image instead of a three band image. For example, we could plot an index like the Normalized Difference Water Index (NDWI), which has high values where a pixel is likely to be open water (e.g. NDWI > 0)."
msgstr ""

#: 
msgid "By default the colour bar limits are set based on ``percentile_stretch`` which will discard outliers/extreme values to optimise the colour stretch (set ``percentile_stretch=(0.0, 1.00)`` to show the full range of values from min to max)."
msgstr ""

#: 
msgid "We can customise animations based on a single band like NDWI by specifying parameters using ``imshow_kwargs``, which is passed to the matplotlib `plt.imshow <https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html>`__ function (see link for options). For example, we can use a more appropriate blue colour scheme with ``'cmap': 'Blues'``, and set ``'vmin': 0.0, 'vmax': 0.5`` to overrule the default colour bar limits with manually specified values:"
msgstr ""

#: 
msgid "One band animations show a colour bar by default, but this can be disabled using ``show_colorbar``:"
msgstr ""

#: 
msgid "One band animations show a colour bar by default, but this can be disabled:"
msgstr ""

#: 
msgid "Available output formats"
msgstr ""

#: 
msgid "The above examples have focused on exporting animated GIFs, but MP4 files can also be generated. The two formats have their own advantages and disadvantages:"
msgstr ""

#: 
msgid "``.mp4``: fast to generate, smallest file sizes and highest quality; suitable for Twitter/social media and recent versions of Powerpoint"
msgstr ""

#: 
msgid "``.gif``: slow to generate, large file sizes, low rendering quality; suitable for all versions of Powerpoint and Twitter/social media"
msgstr ""

#: 
msgid "Note: To preview a ``.mp4`` file from within JupyterLab, find the file (e.g. 'animated_timeseries.mp4') in the file browser on the left, right click, and select 'Open in New Browser Tab'."
msgstr ""

#: 
msgid "Adding vector overlays"
msgstr ""

#: 
msgid "The animation code supports plotting vector files (e.g. ESRI Shapefiles or GeoJSON) over the top of satellite imagery. To do this, we first load the file using geopandas, and pass this to ``xr_animation`` using the ``show_gdf`` parameter:"
msgstr ""

#: 
msgid "You can customise styling for vector overlays by including a column called ``'color'`` in the ``geopandas.GeoDataFrame`` object:"
msgstr ""

#: 
msgid "Plotting vectors by time"
msgstr ""

#: 
msgid "It can be useful to plot vector features over the top of imagery at specific times in an animation. For example, in this example we may want to plot different vectors depending on how full our waterbody was during our analysis period."
msgstr ""

#: 
msgid "To do this, we can create new ``start_time`` and ``end_time`` columns in our ``geopandas.GeoDataFrame`` that tell ``xr_animation`` how long to plot each feature over the top of our imagery:"
msgstr ""

#: 
msgid "**Note**: Dates can be provided in any string format that can be converted using the `pandas.to_datetime() <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html>`__ function. For example, '2009', '2009-11', '2009-11-01' etc."
msgstr ""

#: 
msgid "We can now pass the updated ``geopandas.GeoDataFram``\\ e to ``xr_animation``. We will also change our vector colours to a semi-transperant blue, and give them a blue outline using the ``gdf_kwargs`` parameter:"
msgstr ""

#: 
msgid "Custom image processing functions"
msgstr ""

#: 
msgid "The image_proc_funcs parameter allows you to pass custom image processing functions that will be applied to each frame of your animation as they are rendered. This can be a powerful way to produce visually appealing animations - some example applications include:"
msgstr ""

#: 
msgid "Improving brightness, saturation or contrast"
msgstr ""

#: 
msgid "Sharpening your images"
msgstr ""

#: 
msgid "Histogram matching or equalisation"
msgstr ""

#: 
msgid "To demonstrate this, we will apply two functions from the `skimage.exposure <https://scikit-image.org/docs/dev/api/skimage.exposure.html>`__ module which contains many powerful image processing algorithms:"
msgstr ""

#: 
msgid "``skimage.exposure.rescale_intensity`` will first scale our data between 0.0 and 1.0 (required for step 2)"
msgstr ""

#: 
msgid "``skimage.exposure.equalize_adapthist`` will take this re-scaled data and apply an alogorithm that will enhance and contrast local details of the image"
msgstr ""

#: 
msgid "**Note:** Functions supplied to ``image_proc_funcs`` are applied one after another to each timestep in ``ds`` (e.g. each frame in the animation). Any custom function can be supplied to ``image_proc_funcs``, providing it both **accepts and outputs** a ``numpy.ndarray`` with a shape of ``(y, x, bands)``."
msgstr ""

#: 
msgid "Applying WOfS Bitmasking"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls <https://explorer.digitalearth.africa/wofs_ls>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; WOfS`, :index:`data methods; wofs_fuser`, :index:`analysis; masking`"
msgstr ""

#: 
msgid "The `Water Observations from Space (WOfS) <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ product shows water observed by Landsat satellites over Africa."
msgstr ""

#: 
msgid "Individual water classified images are called Water Observation Feature Layers (WOFLs), and are created in a 1-to-1 relationship with the input satellite data. Hence there is one WOFL for each satellite dataset processed for the occurrence of water."
msgstr ""

#: 
msgid "This notebook explains both the structure of the WOFLs, and how you can use this for powerful and flexible image masking."
msgstr ""

#: 
msgid "The data in a WOFL is stored as a bit field. This is a binary number, where each digit of the number is independantly set or not based on the presence (1) or absence (0) of a particular attribute (water, cloud, cloud shadow etc). In this way, the single decimal value associated to each pixel can provide information on a variety of features of that pixel."
msgstr ""

#: 
msgid "The notebook demonstrates how to:"
msgstr ""

#: 
msgid "Load WOFL data for a given location and time period"
msgstr ""

#: 
msgid "Inspect the WOLF bit flag information"
msgstr ""

#: 
msgid "Use the WOFL bit flags to create a binary mask"
msgstr ""

#: 
msgid "After finishing the analysis, you can modify some values in the \"Analysis parameters\" cell and re-run the analysis to load WOFLs for a different location or time period."
msgstr ""

#: 
msgid "To load WOFL data, we can first create a re-usable query that will define the spatial extent and time period we are interested in, as well as other important parameters that are used to correctly load the data."
msgstr ""

#: 
msgid "Load WOFL data"
msgstr ""

#: 
msgid "As WOFLs are created scene-by-scene, and some scenes overlap, it's important when loading data to ``group_by`` solar day, and ensure that the data between scenes is combined correctly by using the WOfS ``fuse_func``. This will merge observations taken on the same day, and ensure that important data isn't lost when overlapping datasets are combined."
msgstr ""

#: 
msgid "Plot the loaded WOFLs using the ``plot_wofs`` function"
msgstr ""

#: 
msgid "Understanding the WOFLs"
msgstr ""

#: 
msgid "As mentioned above, WOFLs are stored as a binary number, where each digit of the number is independantly set or not based on the presence (1) or absence (0) of a particular feature. Below is a breakdown of which bits represent which features, along with the decimal value associated with that bit being set to true."
msgstr ""

#: 
msgid "Bit / position"
msgstr ""

#: 
msgid "Decimal value"
msgstr ""

#: 
msgid "0: ``0-------`` or ``1-------``"
msgstr ""

#: 
msgid "Non contiguous"
msgstr ""

#: 
msgid "1: ``-0------`` or ``-1------``"
msgstr ""

#: 
msgid "Sea (not used)"
msgstr ""

#: 
msgid "2: ``--0-----`` or ``--1-----``"
msgstr ""

#: 
msgid "Terrain or low solar angle"
msgstr ""

#: 
msgid "3: ``---0----`` or ``---1----``"
msgstr ""

#: 
msgid "High slope"
msgstr ""

#: 
msgid "4: ``----0---`` or ``----1---``"
msgstr ""

#: 
msgid "5: ``-----0--`` or ``-----1--``"
msgstr ""

#: 
msgid "6: ``------0-`` or ``------1-``"
msgstr ""

#: 
msgid "7: ``-------0`` or ``-------1``"
msgstr ""

#: 
msgid "The values in the above plots are the decimal representation of the combination of set flags. For example a value of 136 indicates water (128) AND terrain shadow / low solar angle (8) were observed for the pixel, whereas a value of 144 would indicate water (128) AND high slope (16)."
msgstr ""

#: 
msgid "This flag information is available inside the loaded data and can be visualised as below"
msgstr ""

#: 
msgid "Masking"
msgstr ""

#: 
msgid "We can convert the WOFL bit field into a binary array containing True and False values. This allows us to use the WOFL data as a mask that can be applied to other datasets."
msgstr ""

#: 
msgid "The ``make_mask`` function allows us to create a mask using the flag labels (e.g. \"wet\" or \"dry\") rather than the binary numbers we used above."
msgstr ""

#: 
msgid "Create custom masks by combining flags"
msgstr ""

#: 
msgid "Flags can be combined. When chaining flags together, they will be combined in a logical AND fashion. This process works by passing a dictionary with true/false values to the make_mask function. This allows you to chose whether you want to remove clouds and/or cloud shadows from imagery."
msgstr ""

#: 
msgid "Or, to look at only the clear areas which are good quality data and not wet, we can use the 'dry' flag."
msgstr ""

#: 
msgid "Calculating band indices"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`band index; NDVI`, :index:`band index; NDWI`, :index:`band index; MNDWI`"
msgstr ""

#: 
msgid "Remote sensing indices are combinations of spectral bands used to highlight features in the data and the underlying landscape. For example, one of the most commonly used indices is the Normalised Difference Vegetation Index (NDVI), which uses the ratio of the red and near-infrared (NIR) band to highlight healthy vegetation (see `here <https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php>`__ for a deeper explanation). Using Digital Earth Africa's archive of analysis-ready satellite data, we can easily calculate a wide range of remote sensing indices that can be used to assist in mapping and monitoring features like vegetation and water consistently through time, or as inputs to machine learning or classification algorithms."
msgstr ""

#: 
msgid "Calculate an index manually using ``xarray``"
msgstr ""

#: 
msgid "Calculate one or multiple indices using the function ``calculate_indices`` from ``deafrica_bandindices.py``"
msgstr ""

#: 
msgid "Create a query and load satellite data"
msgstr ""

#: 
msgid "To demonstrate how to compute a remote sensing index, we first need to load in a time series of satellite data for an area. We will use data from the Sentinel-2 satellite:"
msgstr ""

#: 
msgid "It is highly recommended to load data with ``load_ard`` when calculating indices, and when using the ``calculate_indices`` function introduced below. This is because ``load_ard`` performs the necessary data cleaning and scaling for more robust index results."
msgstr ""

#: 
msgid "Plot the first image to see what our area looks like"
msgstr ""

#: 
msgid "We can use the ``rgb`` function to plot the timesteps in our dataset as true colour RGB images:"
msgstr ""

#: 
msgid "Manually calculate an index"
msgstr ""

#: 
msgid "One of the most commonly used remote sensing indices is the Normalised Difference Vegetation Index or ``NDVI``. This index uses the ratio of the red and near-infrared (NIR) bands to identify live green vegetation. The formula for NDVI is:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDVI} & = \\frac{(\\text{NIR} - \\text{Red})}{(\\text{NIR} + \\text{Red})} \\\\\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "When interpreting this index, high values indicate vegetation, and low values indicate soil or water."
msgstr ""

#: 
msgid "In the image above, vegetation shows up as green (NDVI > 0). Sand shows up as yellow (NDVI ~ 0) and water shows up as red (NDVI < 0)."
msgstr ""

#: 
msgid "Use the ``calculate_indices`` function to calculate an index"
msgstr ""

#: 
msgid "The ``calculate_indices`` function provides an easier way to calculate a wide range of remote sensing indices, including:"
msgstr ""

#: 
msgid "**ASI** (Artificial Surface Index, Yongquan Zhao & Zhe Zhu 2022)"
msgstr ""

#: 
msgid "**AWEI_ns** (Automated Water Extraction Index,no shadows, Feyisa 2014)"
msgstr ""

#: 
msgid "**AWEI_sh** (Automated Water Extraction Index,shadows, Feyisa 2014)"
msgstr ""

#: 
msgid "**BAEI** (Built-Up Area Extraction Index, Bouzekri et al. 2015)"
msgstr ""

#: 
msgid "**BAI** (Burn Area Index, Martin 1998)"
msgstr ""

#: 
msgid "**BSI** (Bare Soil Index, Rikimaru et al. 2002)"
msgstr ""

#: 
msgid "**BUI** (Built-Up Index, He et al. 2010)"
msgstr ""

#: 
msgid "**CMR** (Clay Minerals Ratio, Drury 1987)"
msgstr ""

#: 
msgid "**ENDISI** (Enhanced Normalised Difference for Impervious Surfaces Index, Chen et al. 2019)"
msgstr ""

#: 
msgid "**EVI** (Enhanced Vegetation Index, Huete 2002)"
msgstr ""

#: 
msgid "**FMR** (Ferrous Minerals Ratio, Segal 1982)"
msgstr ""

#: 
msgid "**IOR** (Iron Oxide Ratio, Segal 1982)"
msgstr ""

#: 
msgid "**LAI** (Leaf Area Index, Boegh 2002)"
msgstr ""

#: 
msgid "**MBI** (Modified Bare Soil Index, Nguyen et al. 2021)"
msgstr ""

#: 
msgid "**MNDWI** (Modified Normalised Difference Water Index, Xu 1996)"
msgstr ""

#: 
msgid "**MSAVI** (Modified Soil Adjusted Vegetation Index, Qi et al. 1994)"
msgstr ""

#: 
msgid "**NBI** (New Built-Up Index, Jieli et al. 2010)"
msgstr ""

#: 
msgid "**NBR** (Normalised Burn Ratio, Lopez Garcia 1991)"
msgstr ""

#: 
msgid "**NDBI** (Normalised Difference Built-Up Index, Zha 2003)"
msgstr ""

#: 
msgid "**NDCI** (Normalised Difference Chlorophyll Index, Mishra & Mishra, 2012)"
msgstr ""

#: 
msgid "**NDMI** (Normalised Difference Moisture Index, Gao 1996)"
msgstr ""

#: 
msgid "**NDSI** (Normalised Difference Snow Index, Hall 1995)"
msgstr ""

#: 
msgid "**NDTI** (Normalised Difference Turbidity Index, Lacaux et al. 2007)"
msgstr ""

#: 
msgid "**NDVI** (Normalised Difference Vegetation Index, Rouse 1973)"
msgstr ""

#: 
msgid "**NDWI** (Normalised Difference Water Index, McFeeters 1996)"
msgstr ""

#: 
msgid "**SAVI** (Soil Adjusted Vegetation Index, Huete 1988)"
msgstr ""

#: 
msgid "**TCB** (Tasseled Cap Brightness, Crist 1985)"
msgstr ""

#: 
msgid "**TCG** (Tasseled Cap Greeness, Crist 1985)"
msgstr ""

#: 
msgid "**TCW** (Tasseled Cap Wetness, Crist 1985)"
msgstr ""

#: 
msgid "**WI** (Water Index, Fisher 2016)"
msgstr ""

#: 
msgid "The ``calculate_indices`` function can be found in the `deafrica_tools.bandindices <../Tools/deafrica_tools/bandindices.py>`__ script. This script provides all required band math involved in creating each index and is worth a look."
msgstr ""

#: 
msgid "Using ``calculate_indices`` to get the same result"
msgstr ""

#: 
msgid "The function provides a simple way to calculate band indices without needing to explicitly write code for the band math."
msgstr ""

#: 
msgid "**Note**: when using the ``calculate_indices`` function, it is important to set the ``satellite_mission`` parameter correctly. This is because different satellite missions use different names for the same bands, which can lead to invalid results if not accounted for. For Sentinel-2 , specify ``satellite_mission='s2'``. For Landsat Collection 2, specify ``satellite_mission='ls'``."
msgstr ""

#: 
msgid "Using ``calculate_indices`` to calculate multiple indices at once"
msgstr ""

#: 
msgid "The ``calculate_indices`` function makes it straightforward to calculate multiple remote sensing indices in one line of code."
msgstr ""

#: 
msgid "In the example below, we will calculate ``NDVI`` as well as two common water indices: the Normalised Difference Water Index (``NDWI``), and the Modified Normalised Difference Index (``MNDWI``). The new indices will appear in the list of ``data_variables`` below:"
msgstr ""

#: 
msgid "We can also drop the original satellite bands from the dataset using ``drop=True``. The dataset produced below should now only include the new ``'NDVI', 'NDWI', 'MNDWI'`` bands under ``data_variables``:"
msgstr ""

#: 
msgid "Calculating band indices with Spyndex package"
msgstr ""

#: 
msgid "Remote sensing indices are combinations of spectral bands used to highlight features in the data and the underlying landscape. The `Spyndex python package <https://www.nature.com/articles/s41597-023-02096-0>`__ provides access to spectral indices from the Awesome Spectral Indices catalogue. This is a standardized, ready to use, curated list of spectral indices. The Spyndex package currently includes `232 optical and radar indices <https://github.com/awesome-spectral-indices/awesome-spectral-indices/blob/main/output/spectral-indices-table.csv>`__."
msgstr ""

#: 
msgid "One of the benefits of this package is the large number of ``optical and radar`` indices available for DE Africa sandbox users to easily calculate a wide range of remote sensing indices that can be used to assist in mapping and monitoring features like vegetation and water consistently through time, or as inputs to machine learning or classification algorithms using Digital Earth Africa's archive of analysis-ready satellite data."
msgstr ""

#: 
msgid "Load Digital Earth Africa's archive of analysis-ready satellite data using ``load_ard``"
msgstr ""

#: 
msgid "Calculate a range of vegetation indices using the ``spyndex`` function"
msgstr ""

#: 
msgid "Plot the results for all the indices"
msgstr ""

#: 
msgid "Connect to the datacube database to enable loading Digital Earth Africa data."
msgstr ""

#: 
msgid "Using the ``define_area`` function, select area of interest by specifying ``lat``,\\ ``lon`` and ``buffer``. If you have the vector or shapefile uncomment the code below **Method 2** and replace the ``aoi.shp`` with the path of your shapefile."
msgstr ""

#: 
msgid "To demonstrate how to compute a remote sensing index, we first need to load time series of satellite data for an area. Sentinel-2 satellite data will be used:"
msgstr ""

#: 
msgid "It is highly recommended to load data with ``load_ard`` when calculating indices. This is because ``load_ard`` performs the necessary data cleaning and scaling for more robust index results. Refer to `Using_load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ to learn more"
msgstr ""

#: 
msgid "Selecting a time slide"
msgstr ""

#: 
msgid "#### Print the xarray dataset"
msgstr ""

#: 
msgid "Plot the images in true colour"
msgstr ""

#: 
msgid "The ``rgb`` function is used to plot the timesteps in our dataset as true colour RGB images:"
msgstr ""

#: 
msgid "Viewing the attributes for an index"
msgstr ""

#: 
msgid "``spyndex.indices[indexName]`` provides the specifications for the index of interest. The cell below prints out the information for the ``NDVI``"
msgstr ""

#: 
msgid "Calculate the Normalized Difference Vegetation Index using the ``spectral computeIndex`` method."
msgstr ""

#: 
msgid "The cell below shows how spyndex computes the spectral indices using ``spectral computeindex`` function. The ``spectral computeindex function`` takes the \\* ``index`` argument and it specifies the spectral indices that is to be calculated \\* ``params`` argument takes the bands from the DE Africa dataset and its corresponding formula name shown in the ``print(spyndex.indices[\"NDVI\"])`` above. ``NDVI`` NDVI requires ``N`` and ``R`` bands as input which are defined for the DE Africa dataset as ``ds.nir`` and ``ds.red``."
msgstr ""

#: 
msgid "Calculate Enhanced Vegetation Index using spyndex"
msgstr ""

#: 
msgid "Using ``spyndex.indices[indexName]`` gives the details of the Spectral Index being used. The cell below prints information concerning the ``EVI`` Spectral Index."
msgstr ""

#: 
msgid "Calculate the Enhanced Vegetation Index index using the ``spectral computeIndex`` method."
msgstr ""

#: 
msgid "The ``EVI`` has constant values for its computation, as we can see in the formula above."
msgstr ""

#: 
msgid "The Spyndex package provides default constant values which can also be overwritten. The `constants <https://github.com/awesome-spectral-indices/awesome-spectral-indices/blob/main/output/constants.json>`__ can be accessed using ``spyndex.constants`` as shown below."
msgstr ""

#: 
msgid "Normalisation"
msgstr ""

#: 
msgid "The ``calculate_indices`` function from ``deafrica_tools`` normalises Sentinel-2 values according to a maximum surface reflectance value of ``10,000``. We can adapt the Spyndex calculation, as below, to match this normalisation procedure."
msgstr ""

#: 
msgid "Green Normalized Difference Vegetation Index (GNDVI)"
msgstr ""

#: 
msgid "The Green Normalized Difference Vegetation Index `GNDVI <https://pro.arcgis.com/en/pro-app/latest/arcpy/image-analyst/gnvdi.htm#:~:text=The%20Green%20Normalized%20Difference%20Vegetation%20Index%20(GNDVI)%20method%20is%20a,uptake%20into%20the%20plant%20canopy.>`__ is a vegetation index for estimating photosynthetic activity and is a commonly used to determine water and nitrogen uptake into the plant canopy. GNDVI is more sensitive to chlorophyll variation in the crop and has a higher saturation point than NDVI. It can be used in crops with dense canopies or in more advanced stages of development. More information can be found in the Reference in the cell below."
msgstr ""

#: 
msgid "Viewing the attributes of the Green Normalized Difference Vegetation Index"
msgstr ""

#: 
msgid "Calculate Green Normalized Difference Vegetation Index using spyndex"
msgstr ""

#: 
msgid "Kernel Normalized Difference Vegetation Index (kNDVI)"
msgstr ""

#: 
msgid "The NDVI can only capture linear relationships of the near infrared (NIR) - red difference and a parameter of interest, such as green biomass. In reality, this relationship is nonlinear. `Kernel NDVI (kNDVI) was developed <https://www.science.org/doi/10.1126/sciadv.abc7447>`__ to account for higher-order relations between the spectral channels with a nonlinear generalization of the commonly used Normalized Difference Vegetation Index (NDVI). kNDVI has been shown to produce more accurate estimates of key physical variables such as gross primary productivity."
msgstr ""

#: 
msgid "Plot each vegetation index"
msgstr ""

#: 
msgid "The plot below enables comparison of NDVI, EVI, GNDVI, and kNDVI. Can you observe any differences between the indices? For example, there appears to be more saturation (greater frequency of higher/greener values) for NDVI and GNDVI in the July timestep compared with EVI and kNDVI."
msgstr ""

#: 
msgid "This notebook demonstrates how the ``Spyndex package`` can be used with DE Africa datasets to compute Spectral Indices. There are `232 optical and radar <https://github.com/awesome-spectral-indices/awesome-spectral-indices/blob/main/output/spectral-indices-table.csv>`__ indices available through the package, try it out and modify the notebook to test different indices and their results."
msgstr ""

#: 
msgid "Cloud and pixel quality masking for Landsat"
msgstr ""

#: 
msgid "**Keywords** :index:`data methods; dilate`, :index:`data methods; masking`, :index:`cloud masking`, :index:`data methods; buffering`"
msgstr ""

#: 
msgid "In the past, remote sensing researchers would reject partly cloud-affected scenes in favour of cloud-free scenes. However, multi-temporal analysis techniques increasingly make use of every quality assured pixel within a time series of observations. The capacity to automatically exclude low quality pixels (e.g. clouds, shadows or other invalid data) is essential for enabling these new remote sensing methods."
msgstr ""

#: 
msgid "Analysis-ready satellite data from Digital Earth Africa includes pixel quality information that can be used to easily \"mask\" data (i.e. keep only certain pixels in an image) to obtain a time series containing only clear or cloud-free pixels."
msgstr ""

#: 
msgid "In this notebook, we show how to mask Digital Earth Africa Landsat satellite data using boolean masks. The notebook demonstrates how to:"
msgstr ""

#: 
msgid "Load in a time series of satellite data including the ``pixel_qa`` pixel quality band"
msgstr ""

#: 
msgid "Inspect the band's ``flags_definition`` attributes"
msgstr ""

#: 
msgid "Create a mask where pixels are cloudy, have cloud-shadow, or no-data"
msgstr ""

#: 
msgid "Apply binary morphological operators on the cloudy pixels to improve the mask"
msgstr ""

#: 
msgid "Masking of high aerosols"
msgstr ""

#: 
msgid "Apply the masks to the satellite data so we retain only the good quality observations, and plot the results"
msgstr ""

#: 
msgid "Rescaling of Landsat data and masking invalid data"
msgstr ""

#: 
msgid "Using ``load_ard`` to mask poor quality pixels, taking advantage of all its in-built features for masking"
msgstr ""

#: 
msgid "Digital Earth Africa provides wrapper functions that will automatically provide cloud-masked satellite data, more information can be found in the `Using_load_ard <./Using_load_ard.ipynb>`__ notebook."
msgstr ""

#: 
msgid "First we import relevant packages and connect to the datacube. Then we define our example area of interest and load in a time series of satellite data."
msgstr ""

#: 
msgid "To demonstrate how to mask satellite data, we will load Landsat 8 surface reflectance RGB data along with a pixel quality classification band called ``pixel_quality``."
msgstr ""

#: 
msgid "The absence of satellite observation is indicated by a \"nodata\" value for the band, which is listed under the **Attributes** category of the returned ``xarray.DataArray``."
msgstr ""

#: 
msgid "We see that the ``nodata`` attribute reports the value ``0``."
msgstr ""

#: 
msgid "We can find the classification scheme of the ``pixel_qa`` band in its flags definition."
msgstr ""

#: 
msgid "We see that ``pixel_quality`` also reports the ``nodata`` pixels, and along with the ``cloud`` and ``cloud_shadow`` pixels, it also picks up ``snow`` and ``water`` pixels."
msgstr ""

#: 
msgid "Creating a cloud and pixel quality mask"
msgstr ""

#: 
msgid "We create a mask by specifying conditions that our pixels must satisfy. But we will only need the labels (not the values) to create a mask."
msgstr ""

#: 
msgid "In this example below, we want to exclude multiple catagories of bad pixels, i.e. if a pixel has any of the flags (cloud, cirrus or cloud_shadow) set, the pixel will be masked."
msgstr ""

#: 
msgid "Below, we'll plot the pixel quality mask along with the true colour satellite images."
msgstr ""

#: 
msgid "Does the cloud mask exactly match the clouds you see in the RGB plots? Landsat's pixel quality algorithm has known limitations that result in bright objects, such as beaches and cities, mistakenly being classified as clouds."
msgstr ""

#: 
msgid "Applying morphological processing on the cloud mask"
msgstr ""

#: 
msgid "We can improve on the false positives detected by Landsat's pixel quality mask by applying binary morphological image processing techniques (e.g. `binary_closing <https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.ndimage.morphology.binary_closing.html#scipy.ndimage.morphology.binary_closing>`__, `binary_erosion <https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.ndimage.morphology.binary_erosion.html#scipy.ndimage.morphology.binary_erosion>`__ etc.). The Open-Data-Cube library `odc-algo <https://github.com/opendatacube/odc-tools/tree/develop/libs/algo>`__ has a function, ``odc.algo.mask_cleanup`` that can perform a few of these operations. Below, we will try to improve the cloud mask by apply a number of these filters."
msgstr ""

#: 
msgid "Feel free to experiment with the values in ``filters``"
msgstr ""

#: 
msgid "Masking pixels with high aerosol"
msgstr ""

#: 
msgid "The atmospheric correction algorithm applied to Landsat uses aerosol as an input. When the aerosol value is high, the surface reflectance value may be unreliable especially over dark surfaces. Therefore for some applications, masking data with high aerosol may help remove unreliable observations."
msgstr ""

#: 
msgid "In the example below, we use the ``masking.make_mask()`` function to create a mask for pixels with \"high aerosol\" and combine it with the filtered cloud mask from above."
msgstr ""

#: 
msgid "Now we combine the aerosol mask with the ``clear_filtered`` mask to produce of mask where the data is unreliable either due to cloud or high aerosols"
msgstr ""

#: 
msgid "Applying the cloud-mask"
msgstr ""

#: 
msgid "We can now get the clear images we want by erasing the cloud, non-data, and/or high-aerosol pixels from the data. We'll do this for the origial PQ mask, the PQ mask that underwent binary morphological image processing, and the mask with additional aerosol masking."
msgstr ""

#: 
msgid "Plot the results of our 'clear' masking"
msgstr ""

#: 
msgid "Plot the results of our 'clear_filtered' masking"
msgstr ""

#: 
msgid "As you can see, the morphological filtering operations have minimised the impact of the false-postives in the cloud mask over the cities and along the coast"
msgstr ""

#: 
msgid "Plot the results of our 'clear_filtered' and 'aerosol' masked data"
msgstr ""

#: 
msgid "Masking high aerosols removes many pixels over the ocean where surface reflectance values are low and unreliable. Noting, however, this might also remove useful observations. Users should use this mask with care."
msgstr ""

#: 
msgid "Recaling Landsat data and masking invalid data"
msgstr ""

#: 
msgid "Rescale the Landsat data to ~0-1 in accordance with the scale and offset factors provided by the USGS Landsat Collection 2 `documentation <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html#Measurements>`__."
msgstr ""

#: 
msgid "Note: USGS Landsat data has different scale and offset values depending on the measurement. The example scale and offset values shown below only applies to the surface reflectance bands"
msgstr ""

#: 
msgid "Before we can rescale the values, we need to ensure the data is first converted to ``float32``, this makes sure the no-data values in the native data-type (``0``) are converted to ``NaN``, thus ensuring the no-data values in the rescaled data are also ``NaN``."
msgstr ""

#: 
msgid "Below we replot ``clear_filtered`` in true colour. Note the land surface looks more vivid because the function ``rgb`` is no longer including the ``0`` values in the colour ramps, and because the surface reflectance has been rescaled to its intended values (~0-1)."
msgstr ""

#: 
msgid "Cloud masking, morphological filtering, and rescaling with ``load_ard``"
msgstr ""

#: 
msgid "Most of the steps undertaken above can be achieved by using the function ``deafrica_tools.datahanding.load_ard``. This function will create a cloud mask, apply morphological filters (if desired), and apply the Landsat scale and offset factors."
msgstr ""

#: 
msgid "Note: There are some limitations to ``load_ard`` due to its design. An important part of its intended functionality is to provide a simple means of concatenating Landsat 5, 7, & 8 together to form a single xarray object. However, this means that ``load_ard`` can only apply pixel quality masking to pq-categories that are common across Landsat sensors. For example, Landsat-8 has a dedicated bit flag for cirrus bands, but Landsat 5 and 7 do not. This means that ``load_ard`` cannot accept ``'cirrus': 'high_confidence'`` as a pq-category. The same issue also applies for masking of aerosols, Landat 5 and 7 have different means of recording high aerosol than Landsat 8, and thus ``load_ard`` does not support masking of aerosols. However, ``load_ard`` does remove negative surface reflectance values (negative values are an occassional artefact of the correction algorithms employed by USGS), which often coincide with areas prone to high aerosol values such as large waterbodies and along the coast."
msgstr ""

#: 
msgid "Extracting contour lines"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `dem_srtm <https://explorer.digitalearth.africa/dem_srtm>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`data used; SRTM`, :index:`data methods; contour extraction`, :index:`analysis; image processing`, :index:`band index; NDWI`"
msgstr ""

#: 
msgid "`Contour extraction <https://en.wikipedia.org/wiki/Contour_line>`__ is a fundamental image processing method used to detect and extract the boundaries of spatial features. While contour extraction has traditionally been used to precisely map lines of given elevation from digital elevation models (DEMs), contours can also be extracted from any other array-based data source. This can be used to support remote sensing applications where the position of a precise boundary needs to be mapped consistently over time, such as extracting dynamic waterline boundaries from satellite-derived Normalized Difference Water Index (NDWI) data."
msgstr ""

#: 
msgid "This notebook demonstrates how to use the ``subpixel_contours`` function based on tools from ``skimage.measure.find_contours`` to:"
msgstr ""

#: 
msgid "Extract one or multiple contour lines from a single two-dimensional digital elevation model (DEM) and export these as a shapefile"
msgstr ""

#: 
msgid "Optionally include custom attributes in the extracted contour features"
msgstr ""

#: 
msgid "Load in a multi-dimensional satellite dataset from Digital Earth Africa, and extract a single contour value consistently through time along a specified dimension"
msgstr ""

#: 
msgid "Filter the resulting contours to remove small noisy features"
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``6.502``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``-1.409``)."
msgstr ""

#: 
msgid "``buffer``: The number of square degrees to load around the central latitude and longitude. For reasonable loading times, set this as ``0.1`` or lower."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers Lake Bosomtwe, one of the largest lakes in Western Africa."
msgstr ""

#: 
msgid "**To run the notebook for a different area**, make sure Sentinel-2 data is available for the chosen area using the `DEAfrica Explorer <https://explorer.digitalearth.africa>`__. Use the drop-down menu to check coverage for ``s2_l2a``."
msgstr ""

#: 
msgid "Load elevation data"
msgstr ""

#: 
msgid "To demonstrate contour extraction, we first need to obtain an elevation dataset. DE Africa's datacube contains a Digital Elevation Model (DEM) from the Shuttle Radar Topography Mission (SRTM), so we can load in elevation data directly from the datacube using ``dc.load``. In this example, the coordinates above correpsond to a region around Mount Kilimanjaro."
msgstr ""

#: 
msgid "The returned ``xarray`` has a single entry in the time dimension. To make the ``xarray`` easier to work with, we can apply the ``.squeeze()`` method, which remove any dimensions where there is only one entry (``time`` in this case)."
msgstr ""

#: 
msgid "Plot the loaded data"
msgstr ""

#: 
msgid "We can plot the elevation data for a region around Mount Kilimanjaro using a custom terrain-coloured colour map:"
msgstr ""

#: 
msgid "Contour extraction in 'single array, multiple z-values' mode"
msgstr ""

#: 
msgid "The ``deafrica_spatialtools.subpixel_contours`` function uses ``skimage.measure.find_contours`` to extract contour lines from an array. This can be an elevation dataset like the data imported above, or any other two-dimensional or multi-dimensional array. We can extract contours from the elevation array imported above by providing a single z-value (e.g. elevation) or a list of z-values."
msgstr ""

#: 
msgid "Extracting a single contour"
msgstr ""

#: 
msgid "Here, we extract a single 4000 m elevation contour:"
msgstr ""

#: 
msgid "This returns a ``geopandas.GeoDataFrame`` containing a single contour line feature with the z-value (i.e. elevation) given in a shapefile field named ``z_value``. We can plot the extracted contour over the DEM:"
msgstr ""

#: 
msgid "Extracting multiple contours"
msgstr ""

#: 
msgid "We can easily import multiple contours from a single array by supplying a list of z-values to extract. The function will then extract a contour for each value in ``z_values``, skipping any contour elevation that is not found in the array."
msgstr ""

#: 
msgid "Custom shapefile attributes"
msgstr ""

#: 
msgid "By default, the shapefile includes a single ``z_value`` attribute field with one feature per input value in ``z_values``. We can instead pass custom attributes to the output shapefile using the ``attribute_df`` parameter. For example, we might want a custom column called ``elev_km`` with heights in Kilometres (km) instead of metres (m), and a ``location`` column giving the location, Mt Kilamanjaro (KLJ)."
msgstr ""

#: 
msgid "We can achieve this by first creating a ``pandas.DataFrame`` with column names giving the name of the attribute we want included with our contour features, and one row of values for each number in ``z_values``:"
msgstr ""

#: 
msgid "We can now extract contours, and the resulting contour features will include the attributes we created above:"
msgstr ""

#: 
msgid "Exporting contours to file"
msgstr ""

#: 
msgid "To export the resulting contours to file, use the ``output_path`` parameter. The function supports two output file formats:"
msgstr ""

#: 
msgid "GeoJSON (.geojson)"
msgstr ""

#: 
msgid "Shapefile (.shp)"
msgstr ""

#: 
msgid "Contours from non-elevation datasets in 'single z-value, multiple arrays' mode"
msgstr ""

#: 
msgid "As well as extracting multiple contours from a single two-dimensional array, ``subpixel_contours`` also allows you to extract a single z-value from every array along a specified dimension in a multi-dimensional array. This can be useful for comparing the changes in the landscape across time. The input multi-dimensional array does not need to be elevation data: contours can be extracted from any type of data."
msgstr ""

#: 
msgid "For example, we can use the function to extract the boundary between land and water (for a more in-depth analysis using contour extraction to monitor coastal erosion, `see this notebook <../Real_world_examples/Coastal_erosion.ipynb>`__). First, we will load in a time series of Sentinel-2 imagery and calculate a simple Normalized Difference Water Index (NDWI) on two images. This index will have high values where a pixel is likely to be open water (e.g. NDWI > 0, coloured in blue below):"
msgstr ""

#: 
msgid "Calculate NDWI on the first and last image in the dataset"
msgstr ""

#: 
msgid "We can now identify the land-water boundary by extracting the 0 NDWI contour for each array in the dataset along the ``time`` dimension. By plotting the resulting contour lines for a zoomed in area, we can then start to compare phenomenon like lake levels across time."
msgstr ""

#: 
msgid "Dropping small contours"
msgstr ""

#: 
msgid "Contours produced by ``subpixel_contours`` can include many small features. We can optionally choose to extract only contours larger than a certain number of vertices using the ``min_vertices`` parameter. This can be useful for focusing on large contours, and remove possible noise in a dataset. Here we set ``min_vertices=10`` to keep only contours with at least 10 vertices. Observe the small waterbody in the bottom-left of the image disappear:"
msgstr ""

#: 
msgid "Downloading and streaming data using STAC metadata"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/products/s2_l2a>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; s2_l2a`:index:`data used; Sentinel-2`"
msgstr ""

#: 
msgid "Digital Earth Africa stores a range of data products on Amazon Web Service's Simple Cloud Storage (S3) with free public access. These products can be browsed on the interactive Sandbox Explorer. To make it easier to find data in the Digital Earth Africa archive, the Sandbox Explorer also provides a SpatioTemporal Asset Catalog (STAC) endpoint for listing or searching metadata (https://explorer.digitalearth.africa/stac)."
msgstr ""

#: 
msgid "STAC is a recently developed specification that provides a common language to describe geospatial information so it can more easily be indexed and discovered. DEA's STAC metadata can be used to quickly identify all available data for a given product, location or time period. This information can then be used to efficiently download data from the cloud onto a local disk, or stream data directly into desktop GIS software like `QGIS <https://qgis.org/en/site/>`__."
msgstr ""

#: 
msgid "This notebook provides a brief introduction to accessing and using Digital Earth Africa's STAC metadata:"
msgstr ""

#: 
msgid "How to construct a STAC metadata API call"
msgstr ""

#: 
msgid "How to search for STAC metadata and load the results into Python"
msgstr ""

#: 
msgid "How to inspect and plot the unique STAC Items contained in the metadata"
msgstr ""

#: 
msgid "How to inspect assets contained within a STAC Item"
msgstr ""

#: 
msgid "How to download data using STAC metadata"
msgstr ""

#: 
msgid "How to stream data into Python and QGIS using STAC metadata (without downloading it first)"
msgstr ""

#: 
msgid "Searching STAC metadata"
msgstr ""

#: 
msgid "Construct the STAC API call"
msgstr ""

#: 
msgid "First we need to set up some analysis parameters that will be used to search for metadata. This includes ``product``, which is the same product name used to load data directly using ``dc.load`` (see `Introduction to loading data <../Beginners_guide/03_Loading_data.ipynb>`__). In this example we'll choose a small area over Madagascar."
msgstr ""

#: 
msgid "For a full list of available products, browse the `DE Africa Sandbox Explorer <https://explorer.digitalearth.africa/products/s2_l2a/extents>`__."
msgstr ""

#: 
msgid "We can now combine the parameters above to create a URL that will be used to query Digital Earth Africa's STAC metadata. This metadata can be previewed in another tab by clicking the URL."
msgstr ""

#: 
msgid "Load STAC metadata"
msgstr ""

#: 
msgid "We can now load metadata from the URL above into Python. STAC metadata is stored in JSON format, which we can read into nested Python dictionaries using the ``json`` Python module."
msgstr ""

#: 
msgid "Inspecting STAC Items"
msgstr ""

#: 
msgid "In the output above, the ``numberReturned`` value indicates our search returned six unique results. These results are known as `STAC Items <https://stacspec.org/core.html>`__. These are an atomic collection of inseparable data and metadata, such as a unique satellite dataset."
msgstr ""

#: 
msgid "Data for each STAC Item is contained in the metadata's list of ``features``:"
msgstr ""

#: 
msgid "STAC's ``features`` are stored as `GeoJSON <https://geojson.org/>`__, a widely used file format for storing geospatial vector data. This means we can easily convert it to a spatial object using the ``geopandas`` Python module. This allows us to plot and inspect the spatial extents of our data:"
msgstr ""

#: 
msgid "If we print the GeoDataFrame itself, we can see that it contains useful metadata fields that provide information about each dataset:"
msgstr ""

#: 
msgid "We can use this to learn more about our data. For example, we can plot our datasets using the ``eo:cloud_cover`` field to show what percent of each dataset was obscured by cloud (yellow = high cloud cover):"
msgstr ""

#: 
msgid "Inspecting assets"
msgstr ""

#: 
msgid "Each STAC Item listed in ``features`` can contain multiple ``assets``. This assets represent unique data files or layers, for example individual remote sensing bands. For Digital Earth Africa's Sentinel-2 products, these can include the bands, metadata, etc."
msgstr ""

#: 
msgid "Importantly, each asset (for example, ``'B05'``) provides a unique URL (``href``) that can be used to access or download the data. In this case, the ``s3://`` prefix indicates our data is stored in the cloud on Amazon S3."
msgstr ""

#: 
msgid "Downloading files using STAC"
msgstr ""

#: 
msgid "Now that we have a URL, we can use this to download data to our local disk. For example, we may want to download data for the ``'B05'`` satellite band in our STAC Item. We can do this using the ``s3_download`` function from ``odc.aws``:"
msgstr ""

#: 
msgid "To verify that this file downloaded correctly, we can load it into our notebook as an ``xarray.Dataset()`` using ``rioxarray.open_rasterio``:"
msgstr ""

#: 
msgid "**Note**: If this notebook is being run on the DE Africa Sandbox, the saved file will appear in the ``Frequently_used_code`` directory in the JupyterLab File Browser. To save it to your local PC, right click on the file and click ``Download``."
msgstr ""

#: 
msgid "Downloading multiple files"
msgstr ""

#: 
msgid "To download data from the ``'B05'`` band for each of the six STAC Items returned by our search:"
msgstr ""

#: 
msgid "To download all available bands (i.e. ``assets``) for a single STAC Item:"
msgstr ""

#: 
msgid "Streaming data without downloading"
msgstr ""

#: 
msgid "Due to the increasing size of satellite datasets, downloading data directly to your own local disk can be time-consuming and slow. Sometimes, it is better to stream data directly from the cloud without downloading it first. This can be particularly powerful for data that is stored in the `Cloud Optimised GeoTIFF (COG) <https://www.cogeo.org/>`__ format which is optimised for efficiently streaming small chunks of an image at a time."
msgstr ""

#: 
msgid "This section demonstrates how data can be streamed directly from the cloud into both Python and the `QGIS GIS software (v3.14) <https://qgis.org/en/site/>`__. As a first step, we need to convert our Amazon S3 URL (e.g. ``s3://``) into HTTPS format (e.g. ``https://``) so that it can be read more easily:"
msgstr ""

#: 
msgid "Streaming data into Python"
msgstr ""

#: 
msgid "To stream data directly from the cloud into an ``xarray.Dataset()`` format so it can be analysed in Python, we can supply the HTTPS URL above directly to the ``rioxarray.open_rasterio`` function:"
msgstr ""

#: 
msgid "Streaming and reprojecting data"
msgstr ""

#: 
msgid "The code above will stream the entire dataset from the cloud into a ``xarray.Dataset()``. Sometimes, however, we may only want to stream a portion of large dataset into a spatial grid (e.g. resolution and coordinate reference system) that exactly matches data we have already loaded using Datacube."
msgstr ""

#: 
msgid "For example, we may have already used ``dc.load`` to load example data from the datacube into the Africa Albers Equal Area Conic projection and a 5000 m pixel resolution:"
msgstr ""

#: 
msgid "We can now use the ``rio_slurp_xarray`` function to stream the data we identified using STAC into a format that is consistent with the ``ds`` data we loaded using the Datacube. Note that ``gbox=ds.geobox`` tells the function to load the data to match ``ds``'s characteristics. The output should therefore appear far more pixelated than previous plots:"
msgstr ""

#: 
msgid "**Note:** For more about reprojecting data, see the `Reprojecting datacube and raster data <Reprojecting_data.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Streaming data into QGIS"
msgstr ""

#: 
msgid "To stream data directly into a GIS software like QGIS without having to download it, first select and copy the HTTPS URL above (e.g. ``'https://dea-public-data...``) to our clipboard, then open QGIS. In QGIS, click ``Layer > Add Layer > Add Raster Layer``:"
msgstr ""

#: 
msgid "|image0|"
msgstr ""

#: 
msgid "image0"
msgstr ""

#: 
msgid "On the ``Data Source Manager | Raster`` dialogue, click ``Protocol: HTTP(S), cloud, etc``. Ensure ``Type`` is set to ``HTTP/HTTPS/FTP``, and paste the URL you copied into the ``URI`` box:"
msgstr ""

#: 
msgid "|image1|"
msgstr ""

#: 
msgid "image1"
msgstr ""

#: 
msgid "Click ``Add``, then ``Close``. After a few moments, the image we identified using STAC will appear on the map. This data is being streamed directly from the cloud - no downloading required!"
msgstr ""

#: 
msgid "|image2|"
msgstr ""

#: 
msgid "image2"
msgstr ""

#: 
msgid "Exporting Cloud-Optimised GeoTIFFs"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`data methods; exporting`, :index:`data format; GeoTIFF`"
msgstr ""

#: 
msgid "At the end of an analysis it can be useful to export data to a GeoTIFF file (e.g. ``outputname.tif``), either to save results or to allow for exploring results in a GIS software platform (e.g. ArcGIS or QGIS)."
msgstr ""

#: 
msgid "A ``Cloud Optimized GeoTIFF (COG)`` is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud."
msgstr ""

#: 
msgid "This notebook shows a number of ways to export a GeoTIFF file:"
msgstr ""

#: 
msgid "Exporting a single-band, single time-slice GeoTIFF from an xarray object loaded through a ``dc.load`` query"
msgstr ""

#: 
msgid "Exporting a multi-band, single time-slice GeoTIFF from an xarray object loaded through a ``dc.load`` query"
msgstr ""

#: 
msgid "Exporting multiple GeoTIFFs, one for each time-slice of an xarray object loaded through a ``dc.load`` query"
msgstr ""

#: 
msgid "Exporting data from lazily loaded ``dask arrays``"
msgstr ""

#: 
msgid "Load Sentinel-2 data from the datacube"
msgstr ""

#: 
msgid "Here we are loading in a timeseries of Sentinel-2 satellite images through the datacube API. This will provide us with some data to work with."
msgstr ""

#: 
msgid "Plot an rgb image to confirm we have data"
msgstr ""

#: 
msgid "The white regions are cloud cover."
msgstr ""

#: 
msgid "Export a single-band, single time-slice GeoTIFF"
msgstr ""

#: 
msgid "This method uses the ``datacube.utils.cog`` function `write_cog <https://datacube-core.readthedocs.io/en/latest/api/utilities/generate/datacube.utils.cog.write_cog.html>`__, where cog stands for `Cloud-Optimised-Geotiff <https://www.cogeo.org/>`__ to export a simple single-band, single time-slice COG."
msgstr ""

#: 
msgid "A few important caveats should be noted when using this function: 1. It requires an ``xarray.DataArray``; supplying an ``xarray.Dataset`` will return an error. To convert a ``xarray.Dataset`` to an array run the following:"
msgstr ""

#: 
msgid "This function generates a temporary in-memory tiff file without compression. This means the function will use about 1.5 to 2 times the memory required using the depreciated ``datacube.helper.write_geotiff``."
msgstr ""

#: 
msgid "If you pass a ``dask array`` into the function, ``write_cog`` will not output a geotiff, but will instead return a\\ ``Dask Delayed`` object. To trigger the output of the geotiff run ``.compute()`` on the dask delayed object:"
msgstr ""

#: 
msgid "Export a multi-band, single time-slice GeoTIFF"
msgstr ""

#: 
msgid "Here we select a single time and export all the bands in the dataset using the ``datacube.utils.cog.write_cog`` function."
msgstr ""

#: 
msgid "Export multiple GeoTIFFs, one for each time-slice of an xarray"
msgstr ""

#: 
msgid "If we want to export all of the time steps in a dataset as a GeoTIFF, we can wrap our ``write_cog`` function in a for-loop."
msgstr ""

#: 
msgid "Advanced"
msgstr ""

#: 
msgid "Exporting GeoTIFFs from a dask array"
msgstr ""

#: 
msgid "If you pass a lazily-loaded dask array into the function, ``write_cog`` will not immediately output a GeoTIFF, but will instead return a ``dask.delayed`` object:"
msgstr ""

#: 
msgid "To trigger the GeoTIFF to be exported to file, run ``.compute()`` on the ``dask.delayed`` object. The file will now appear in the file browser to the left."
msgstr ""

#: 
msgid "Generating continental animated time series using ``xr_animation``"
msgstr ""

#: 
msgid "**Products used:** `ndvi_anomaly <https://explorer.digitalearth.africa/ndvi_anomaly>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; ndvi_anomaly`, :index:`data methods; animation`, :index:`band index; ndvi_mean`"
msgstr ""

#: 
msgid "**Minimum Required Memory Size: 32GB or higher**"
msgstr ""

#: 
msgid "Please note that this notebook requires a minimum of 32GB memory or higher to run successfully within the Digital Earth Africa Sandbox. The default 16GB memory allocation may not be sufficient to run the notebook successfully."
msgstr ""

#: 
msgid "If you encounter any memory-related issues, please consider increasing the memory allocation for your Digital Earth Africa Sandbox."
msgstr ""

#: 
msgid "**Note**: The actual memory requirements may vary depending on the specific computations and data involved in the notebook."
msgstr ""

#: 
msgid "Import a time series of mean monthly xarray dataset avaibale on the DE Africa platform. For this notebook we will be using the Mean NDVI and Anomalies service. More infomation on available `dataset <https://docs.digitalearthafrica.org/en/latest/data_specs/index.html>`__"
msgstr ""

#: 
msgid "Export the resulting dataset in the form of animations as either a GIF or MP4"
msgstr ""

#: 
msgid "We will use the dc load function to load data (i.e. ndvi_anomaly), and return an ``xarray.Dataset``. This will allow us to create a visually appealing time series animation of observations for the selected time."
msgstr ""

#: 
msgid "Animations"
msgstr ""

#: 
msgid "Generating composite images"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`band index; NDVI`, :index:`analysis; time series`, :index:`analysis; composites`"
msgstr ""

#: 
msgid "Individual remote sensing images can be affected by noisy data, including clouds, cloud shadows, and haze. To produce cleaner images that can be compared more easily across time, we can create 'summary' images or 'composites' that combine multiple images into one."
msgstr ""

#: 
msgid "Some methods for generating composites include estimating the ``median``, ``mean``, ``minimum``, or ``maximum`` pixel values in an image. Care must be taken with these, as they do not necessarily preserve spectral relationships across bands. To learn how to generate a composite that does preserve these relationships, see the `Generating geomedian composites notebook <Generating_geomedian_composites.ipynb>`__."
msgstr ""

#: 
msgid "This notebook demonstrates how to generate a number of different composites from satellite images, and discusses the uses of each. Specifically, this notebook demonstrates how to generate:"
msgstr ""

#: 
msgid "Median composites"
msgstr ""

#: 
msgid "Mean composites"
msgstr ""

#: 
msgid "Minimum and maximum composites"
msgstr ""

#: 
msgid "Nearest-time composites"
msgstr ""

#: 
msgid "Connect to the datacube so we can access DE Africa data. The ``app`` parameter is a unique name for the analysis which is based on the notebook file name."
msgstr ""

#: 
msgid "Load Sentinel-2 data"
msgstr ""

#: 
msgid "Here we load a timeseries of cloud-masked Sentinel-2 satellite images through the datacube API using the `load_ard <Using_load_ard.ipynb>`__ function."
msgstr ""

#: 
msgid "Plot timesteps in true colour"
msgstr ""

#: 
msgid "To visualise the data, use the pre-loaded ``rgb`` utility function to plot a true colour image for a series of timesteps. White areas indicate where clouds or other invalid pixels in the image have been masked."
msgstr ""

#: 
msgid "The code below will plot four timesteps of the time series we just loaded."
msgstr ""

#: 
msgid "One of the key reasons for generating a composite is to replace pixels classified as clouds with realistic values from the available data. This results in an image that doesn't contain any clouds. In the case of a median composite, each pixel is selected to have the median (or middle) value out of all possible values."
msgstr ""

#: 
msgid "Care should be taken when using these composites for analysis, since the relationships between spectral bands are not preserved. These composites are also affected by the timespan they're generated over. For example, the median pixel in a single season may be different to the median value for the whole year."
msgstr ""

#: 
msgid "Generating a single composite from all data"
msgstr ""

#: 
msgid "To generate a single median composite, we use the ``xarray.median`` method, specifying ``'time'`` as the dimension to compute the median over."
msgstr ""

#: 
msgid "Generating multiple composites based on length of time"
msgstr ""

#: 
msgid "Rather than using all the data to generate a single median composite, it's possible to use the ``xarray.resample`` method to group the data into smaller time-spans and generate medians for each of these. Some resampling options are \\* ``'nD'`` - number of days (e.g. ``'7D'`` for seven days) \\* ``'nM'`` - number of months (e.g. ``'6M'`` for six months) \\* ``'nY'`` - number of years (e.g. ``'2Y'`` for two years)"
msgstr ""

#: 
msgid "If the area is particularly cloudy during one of the time-spans, there may still be masked pixels that appear in the median. This will be true if that pixel is always masked."
msgstr ""

#: 
msgid "Group By"
msgstr ""

#: 
msgid "Similar to resample, grouping works by looking at part of the date, but ignoring other parts. For instance, ``'time.month'`` would group together all January data together, no matter what year it is from."
msgstr ""

#: 
msgid "Some examples are: \\* ``'time.day'`` - groups by the day of the month (1-31) \\* ``'time.dayofyear'`` - groups by the day of the year (1-365) \\* ``'time.week'`` - groups by week (1-52) \\* ``'time.month'`` - groups by the month (1-12) \\* ``'time.season'`` - groups into 3-month seasons: - ``'DJF'`` December, Jaunary, February - ``'MAM'`` March, April, May - ``'JJA'`` June, July, August - ``'SON'`` September, October, November \\* ``'time.year'`` - groups by the year"
msgstr ""

#: 
msgid "Mean composites involve taking the average value for each pixel, rather than the middle value as is done for a median composite. Unlike the median, the mean composite can contain pixel values that were not part of the original dataset. Care should be taken when interpreting these images, as extreme values (such as unmasked cloud) can strongly affect the mean."
msgstr ""

#: 
msgid "To generate a single mean composite, we use the ``xarray.mean`` method, specifying ``'time'`` as the dimension to compute the mean over."
msgstr ""

#: 
msgid "**Note**: If there are no valid values for a given pixel, you may see the warning: ``RuntimeWarning: Mean of empty slice``. The composite will still be generated, but may have blank areas."
msgstr ""

#: 
msgid "As with the median composite, it's possible to use the ``xarray.resample`` method to group the data into smaller time-spans and generate means for each of these. See the previous section for some example resampling time-spans."
msgstr ""

#: 
msgid "*Note:* If you get the warning ``RuntimeWarning: Mean of empty slice``, this just means that for one of your groups there was at least one pixel that contained all ``nan`` values."
msgstr ""

#: 
msgid "These composites can be useful for identifying extreme behaviour in a collection of satellite images."
msgstr ""

#: 
msgid "For example, comparing the maximum and minimum composites for a given band index could help identify areas that take on a wide range of values, which may indicate areas that have high variability over the time-line of the composite."
msgstr ""

#: 
msgid "To demonstrate this, we start by calculating the normalised difference vegetation index (NDVI) for our data, which can then be used to generate the maximum and minimum composites."
msgstr ""

#: 
msgid "Maximum composite"
msgstr ""

#: 
msgid "To generate a single maximum composite, we use the ``xarray.max`` method, specifying ``'time'`` as the dimension to compute the maximum over."
msgstr ""

#: 
msgid "Minimum composite"
msgstr ""

#: 
msgid "To generate a single minimum composite, we use the ``xarray.min`` method, specifying ``'time'`` as the dimension to compute the minimum over."
msgstr ""

#: 
msgid "To get an image at a certain time, often there is missing data, due to clouds and other masking. We can fill in these gaps by using data from surrounding times."
msgstr ""

#: 
msgid "To generate these images, we can use the custom functions ``first``, ``last`` and ``nearest`` from the `deafrica.datahandling <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.datahandling.html>`__ module."
msgstr ""

#: 
msgid "You can also use the in-built ``.first()`` and ``.last()`` methods when doing ``groupby`` and ``resample`` as described above. They are described in the `xarray documentation <http://xarray.pydata.org/en/stable/groupby.html#first-and-last>`__ on grouped data."
msgstr ""

#: 
msgid "Most-recent composite"
msgstr ""

#: 
msgid "Sometime we may want to determine what the landscape looks like by examining the most recent image. If we look at the last image for our dataset, we can see there is some missing data in the center of the last image."
msgstr ""

#: 
msgid "We can calculate how much of the data is missing in this most recent image"
msgstr ""

#: 
msgid "In order to fill in the gaps and produce a complete image showing the most-recent satellite acquistion for every pixel, we can run the ``last`` function on one of the arrays."
msgstr ""

#: 
msgid "To see how recent each pixel is, we can compare the age of the pixels with the latest value we have."
msgstr ""

#: 
msgid "Here we can see that most pixels were from the last time slice, although there are some that were much older."
msgstr ""

#: 
msgid "We can run this method on all of the bands. However we only want pixels that have data in every band. On the edges of a satellite pass, some bands don't have data."
msgstr ""

#: 
msgid "To get rid of pixels with missing data, we will convert the dataset to an array, and select only those pixels with data in all bands."
msgstr ""

#: 
msgid "Now we can run the ``last`` function on the array, then turn it back into a dataset."
msgstr ""

#: 
msgid "Before and after composites"
msgstr ""

#: 
msgid "Often it is useful to view images before and after an event, to see the change that has occured."
msgstr ""

#: 
msgid "To generate a composite on either side of an event, we can split the dataset along time."
msgstr ""

#: 
msgid "We can then view the composite ``last`` image before the event, and the composite ``first`` image after the event."
msgstr ""

#: 
msgid "The composite image before the event, up to 2019-06-01:"
msgstr ""

#: 
msgid "The composite image after the event, from 2019-06-03:"
msgstr ""

#: 
msgid "Nearest time composite"
msgstr ""

#: 
msgid "Sometimes we just want the closest availible data to a particular point in time. This composite will take values from before *or* after the specified time to find the nearest observation."
msgstr ""

#: 
msgid "By looking at the ``time`` for each pixel, we can see if the pixel was taken from before or after the target time."
msgstr ""

#: 
msgid "Generating GeoMAD composites"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`data used; landsat 8`, index:`data used; MADs`, :index:`data methods; geomedian`, :index:`analysis; composites`, :index:`dask`, :index:`data methods; resample`, :index:`data methods; groupby`"
msgstr ""

#: 
msgid "Individual remote sensing images can be affected by noisy data, including clouds, cloud shadows, and haze. To produce cleaner images that can be compared more easily across time, we can create 'summary' images or 'composites' that combine multiple images into one image to reveal the median or 'typical' appearance of the landscape for a certain time period."
msgstr ""

#: 
msgid "One approach is to create a `geomedian <https://github.com/daleroberts/hdmedians>`__. A ``geomedian`` is based on a high-dimensional statistic called the 'geometric median' `(Small 1990) <https://www.jstor.org/stable/1403809>`__, which effectively trades a temporal stack of poor quality observations for a single high-quality pixel composite with reduced spatial noise `(Roberts et al. 2017) <https://ieeexplore.ieee.org/abstract/document/8004469>`__. In contrast to a standard median, a geomedian maintains the relationship between spectral bands. This allows us to conduct further analysis on the composite images just as we would on the original satellite images (e.g by allowing the calculation of common band indices, like NDVI)."
msgstr ""

#: 
msgid "DE Africa's GEoMAD product (**Geo**\\ median and **M**\\ edian **A**\\ bsolute **D**\\ eviations), in addition to containing geomedians of the surface relfectance bands, GeoMAD also includes three Median Absolute Deviation (MAD) layers. These are higher-order statistical measurements on variation relative to the geomedian. These layers can be used on their own or together with geomedian to gain insights about the land surface and understand its change over time."
msgstr ""

#: 
msgid "All the data of the selected timeframe has to be loaded to compute a composite, so geomedians can be computationally intensive to calculate, especially over large areas or long timescales. To assist with such analyses, DE Africa hosts a number of pre-calculated geoMAD products:"
msgstr ""

#: 
msgid "`Sentinel-2 annual GeoMAD <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__ from 2017 to present, with product name ``gm_s2_annual``"
msgstr ""

#: 
msgid "`Sentinel-2 semi-annual (six-month) GeoMAD <https://explorer.digitalearth.africa/products/gm_s2_semiannual/extents>`__ from 2019 to present, with product name ``gm_s2_semiannual``"
msgstr ""

#: 
msgid "`Landat annual GeoMAD <https://explorer.digitalearth.africa/products/gm_ls8_annual/extents>`__ from 2013 to present, with product name ``gm_ls8_annual``"
msgstr ""

#: 
msgid "This reduces the time and resource needed to calculate the geomedian if you are conducting analysis over an annual timescale. Instructions on how to use the geomedian from the Sentinel-2 GeoMAD can be found in the `Datasets/GeoMAD.ipynb <../Datasets/GeoMAD.ipynb>`__ notebook."
msgstr ""

#: 
msgid "For analysis on other timescales, such as investigating change over seasons, it is not possible to use the annual geomedian product. In those cases, it can be useful to calculate GeoMAD for that specific time period."
msgstr ""

#: 
msgid "In this notebook we will take of time series of noisy satellite images and calculate a GeoMAD composite which is largely free of clouds and other noisy data."
msgstr ""

#: 
msgid "GeoMAD computations are expensive in terms of memory, data bandwidth, and CPU usage. The ODC has a useful function, `geomedian_with_mads <https://github.com/opendatacube/odc-tools/blob/6c7a8bf9058d4e96ca27e5de21c7ff039338fc1c/libs/algo/odc/algo/_geomedian.py#L305>`__ that allows `dask <https://docs.dask.org/en/latest/>`__ to perform the computation in parallel across many threads to speed things up. In this notebook a ``local dask cluster`` is used, but the same approach should work using a larger, distributed dask cluster."
msgstr ""

#: 
msgid "Set up a dask cluster"
msgstr ""

#: 
msgid "This will help keep our memory use down and conduct the analysis in parallel. If you'd like to view the ``dask dashboard``, click on the hyperlink that prints below the cell. You can use the dashboard to monitor the progress of calculations."
msgstr ""

#: 
msgid "Load Sentinel-2 from the datacube"
msgstr ""

#: 
msgid "Here we are loading in a timeseries of cloud-masked Sentinel-2 satellite images through the datacube API using the `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ function. This will provide us with some data to work with. To limit computation and memory this example uses only three optical bands (red, green, blue)."
msgstr ""

#: 
msgid "Compared to the typical use of ``load_ard`` which by default returns data with floating point numbers containing ``NaN`` (i.e. ``float32``), in this example we will set the ``dtype`` to ``'native'``. This will keep our data in its original integer data type (i.e. ``Int16``), with nodata values marked with ``-999``. Doing this will halve the amount of memory our data takes up, which can be extremely valuable when conducting large-scale analyses."
msgstr ""

#: 
msgid "To visualise the data, use the pre-loaded ``rgb`` utility function to plot a true colour image for a series of timesteps. Black areas indicate where clouds or other invalid pixels in the image have been set to ``-999`` to indicate no data."
msgstr ""

#: 
msgid "The code below will plot three timesteps of the time series we just loaded."
msgstr ""

#: 
msgid "Generate a geomedian"
msgstr ""

#: 
msgid "As you can see above, most satellite images will have at least some areas masked out due to clouds or other interference between the satellite and the ground. Running the ``geomedian_with_mads`` function will generate a geomedian composite by combining all the observations in our ``xarray.Dataset`` into a single, complete (or near complete) image representing the geometric median of the time period."
msgstr ""

#: 
msgid "**Note:** Because our data was lazily loaded with ``dask``, the geomedian algorithm itself will not be triggered until we call the ``.compute()`` method in the next step."
msgstr ""

#: 
msgid "Run the computation"
msgstr ""

#: 
msgid "The ``.compute()`` method will trigger the computation of the geomedian algorithm above. This will take about a few minutes to run; view the ``dask dashboard`` to check the progress."
msgstr ""

#: 
msgid "If we print our result, you will see that the ``time`` dimension has now been removed and we are left with a single image that represents the geometric median of all the satellite images in our initial time series:"
msgstr ""

#: 
msgid "Plot the geomedian composite"
msgstr ""

#: 
msgid "Plotting the result, we can see that the geomedian image is much more complete than any of the individual images. We can also use this data in downstream analysis as the relationships between the spectral bands are maintained by the geometric median statistic."
msgstr ""

#: 
msgid "Generate median absolute deviations"
msgstr ""

#: 
msgid "In addition to running a geomedian composite, which will return the median observations for each band, we can also compute the variation that each pixel undergoes during the time series. The ``geomedian_with_mads`` function returns three measures of variability: the spectral median absolute deviation (``smad``), the Euclidian median absolute deviation (``emad``), and the bray-curtis median absolute deviation (``bcmad``)."
msgstr ""

#: 
msgid "To compute the three measures of variability simply pass ``compute_mads=True`` to the ``geomedian_with_mads`` function. This function also supports returning the ``count``, which returns the number of clear observations for each pixel."
msgstr ""

#: 
msgid "Plot median absolute deviations and clear count"
msgstr ""

#: 
msgid "Running GeoMADs on grouped or resampled timeseries"
msgstr ""

#: 
msgid "In the notebook `Generating composites <./Generating_composites.ipynb>`__, built in functions such as ``mean`` and ``median`` are run on timeseries data that has been resampled or grouped."
msgstr ""

#: 
msgid "We can use the same techniques with the geomedian function."
msgstr ""

#: 
msgid "Resampling"
msgstr ""

#: 
msgid "First we will split the timeseries into the desired groups. Resampling can be used to create a new set of times at regular intervals:"
msgstr ""

#: 
msgid "``grouped = da_scaled.resample(time=1M)``"
msgstr ""

#: 
msgid "``'nD'`` - number of days (e.g. ``'7D'`` for seven days)"
msgstr ""

#: 
msgid "``'nM'`` - number of months (e.g. ``'6M'`` for six months)"
msgstr ""

#: 
msgid "``'nY'`` - number of years (e.g. ``'2Y'`` for two years)"
msgstr ""

#: 
msgid "Grouping works by looking at part of the date, but ignoring other parts. For instance, ``'time.month'`` would group together all January data together, no matter what year it is from."
msgstr ""

#: 
msgid "``grouped = da_scaled.groupby('time.month')``"
msgstr ""

#: 
msgid "``'time.day'`` - groups by the day of the month (1-31)"
msgstr ""

#: 
msgid "``'time.dayofyear'`` - groups by the day of the year (1-365)"
msgstr ""

#: 
msgid "``'time.week'`` - groups by week (1-52)"
msgstr ""

#: 
msgid "``'time.month'`` - groups by the month (1-12)"
msgstr ""

#: 
msgid "``'time.season'`` - groups into 3-month seasons:"
msgstr ""

#: 
msgid "``'DJF'`` December, Jaunary, February"
msgstr ""

#: 
msgid "``'MAM'`` March, April, May"
msgstr ""

#: 
msgid "``'JJA'`` June, July, August"
msgstr ""

#: 
msgid "``'SON'`` September, October, November"
msgstr ""

#: 
msgid "``'time.year'`` - groups by the year"
msgstr ""

#: 
msgid "Here we will resample into three two-monthly groups (``'2M'``), with the group starting at the start of the month (represented by the ``'S'`` at the end)."
msgstr ""

#: 
msgid "Now we will apply the ``geomedian_with_mads`` function to each resampled group using the ``map`` method."
msgstr ""

#: 
msgid "Instead of calling ``geomedian_with_mads(ds)`` on the entire array, we pass the ``geomedian_with_mads`` function to ``map`` to apply it separately to each resampled group."
msgstr ""

#: 
msgid "We can now trigger the computation, and watch progress using the dask dashboard."
msgstr ""

#: 
msgid "We can plot the output geomedians, and see the change in the landscape over the year:"
msgstr ""

#: 
msgid "Advanced: GeoMADs on Landsat data"
msgstr ""

#: 
msgid "Below we calculate GeoMADs using Landsat 8. For the GeoMAD to match Sentinel-2, we need to take one extra step. Landsat surface relfetance data is scaled from 0 to 1, while Sentinel-2 data is scaled from 0-10,000. For the two datasets to match, we need to multiply the Landsat bands by 10,000 (this will make the geoMADs produced in this notebook match the ``gm_ls8_annual`` dataset available in the datacube). The bands ``bcmad`` and ``smad`` do *not* need to be mulitplied by 10,000."
msgstr ""

#: 
msgid "Calculate GeoMADs on the Landsat data"
msgstr ""

#: 
msgid "Multiply bands by 10,000 to match Sentinel-2"
msgstr ""

#: 
msgid "Plot the Landsat GeoMAD"
msgstr ""

#: 
msgid "Image segmentation"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`analysis; machine learning`, :index:`machine learning; image segmentation`, :index:`data methods; composites`, :index:`analysis; GEOBIA`, :index:`band index; NDVI`, :index:`data format; GeoTIFF`"
msgstr ""

#: 
msgid "In the last two decades, as the spatial resolution of satellite images has increased, remote sensing has begun to shift from a focus on pixel-based analysis towards Geographic Object-Based Image Analysis (GEOBIA), which aims to group pixels together into meaningful image-objects. There are two advantages to a GEOBIA worklow; one, we can reduce the 'salt and pepper' effect typical of classifying pixels; and two, we can increase the computational efficiency of our workflow by grouping pixels into fewer, larger, but meaningful objects. A review of the emerging trends in GEOBIA can be found in `Chen et al. (2017) <https://www.tandfonline.com/doi/abs/10.1080/15481603.2018.1426092>`__."
msgstr ""

#: 
msgid "This notebook demonstrates a method for conducting ``image segmentation``, which is a common image analysis technique used to transform a digital satellite image into objects. In brief, `image segmentation <https://en.wikipedia.org/wiki/Image_segmentation>`__ aims to partition an image into segments, where each segment consists of a group of pixels with similar characteristics. Here we use the `Quickshift <https://scikit-image.org/docs/dev/api/skimage.segmentation.html#skimage.segmentation.quickshift>`__ algorithm, implemented through the python package ``scikit-image``, to perform the image segmentation."
msgstr ""

#: 
msgid "``time``: The date range to analyse (e.g. ``(\"2017-08-01\", \"2019-11-01\")``). For reasonable loading times, make sure the range spans less than 3 years. Note that Sentinel-2 data is only available after July 2015."
msgstr ""

#: 
msgid "Here we are loading in a timeseries of ``Sentinel-2`` satellite images through the datacube API using the `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ function. This will provide us with some data to work with."
msgstr ""

#: 
msgid "Combine observations into a noise-free statistical summary image"
msgstr ""

#: 
msgid "Individual remote sensing images can be affected by noisy and incomplete data (e.g. due to clouds). To produce cleaner images that we can feed into the image segmentation algorithm, we can create summary images, or ``composites``, that combine multiple images into one image to reveal the 'typical' appearance of the landscape for a certain time period. In the code below, we take the noisy, incomplete satellite images we just loaded and calculate the mean ``Normalised Difference Vegetation Index (NDVI)``. The mean NDVI will be our input into the segmentation algorithm."
msgstr ""

#: 
msgid "Calculate mean NDVI"
msgstr ""

#: 
msgid "Quickshift Segmentation"
msgstr ""

#: 
msgid "Using the function `quickshift <https://scikit-image.org/docs/dev/api/skimage.segmentation.html#skimage.segmentation.quickshift>`__ from the python package ``scikit-image``, we will conduct an image segmentation on the mean NDVI array. We then calculate a zonal mean across each segment using the input dataset. Our last step is to export our results as a GeoTIFF."
msgstr ""

#: 
msgid "Follow the quickshift hyperlink above to see the input parameters to the algorithm, and the following `link <https://scikit-image.org/docs/dev/auto_examples/segmentation/plot_segmentations.html>`__ for an explanation of quickshift and other segmentation algorithms in ``scikit-image``."
msgstr ""

#: 
msgid "Export result to GeoTIFF"
msgstr ""

#: 
msgid "See this `notebook <../Frequently_used_code/Exporting_GeoTIFFs.ipynb>`__ for more info on writing GeoTIFFs to file."
msgstr ""

#: 
msgid "`Leaflet <https://leafletjs.com/>`__ is the leading open-source JavaScript library for mobile-friendly interactive maps. Functionality it provides is exposed to Python users by `ipyleaflet <https://github.com/jupyter-widgets/ipyleaflet>`__. This library enables interactive maps in the Jupyter notebook/JupyterLab environment."
msgstr ""

#: 
msgid "This notebook demonstrates how to plot an image and dataset footprints on a map."
msgstr ""

#: 
msgid "Find a location"
msgstr ""

#: 
msgid "Find some datasets to load"
msgstr ""

#: 
msgid "Load pixel data in ``EPSG:3857`` projection, same as used by most web maps"
msgstr ""

#: 
msgid "Create dataset footprints to display on a map"
msgstr ""

#: 
msgid "Create an opacity control to display on the same map"
msgstr ""

#: 
msgid "Display image loaded from the datasets on the same map"
msgstr ""

#: 
msgid "The selected latitude and longitude will be displayed as a red box on the map below the next cell. This map can be used to find coordinates of other places, simply scroll and click on any point on the map to display the latitude and longitude of that location."
msgstr ""

#: 
msgid "Find datasets"
msgstr ""

#: 
msgid "Use the `Digital Earth Africa Explorer <https://explorer.digitalearth.africa/products>`__ or ``dc.list_products()`` to find avaliable datasets. For more information on using ``dc.list_products()``, see the `Products and measurements notebook <../Beginners_guide/02_Products_and_measurements.ipynb>`__."
msgstr ""

#: 
msgid "In this example we are using the Sentinel-2A ARD product. We will be visualizing a portion of the swath taken by Sentinel-2A on 12-Jan-2018."
msgstr ""

#: 
msgid "Create Leaflet Map with dataset footprints"
msgstr ""

#: 
msgid "We want to display dataset footprints as well as captured imagery. Therefore we use ``dss = dc.find_datasets(..)`` to obtain a list of ``datacube.Dataset`` objects overlapping with our query first."
msgstr ""

#: 
msgid "Then we convert list of dataset objects into a GeoJSON of dataset footprints, while also computing bounding box. We will use the bounding box to set initial viewport of the map."
msgstr ""

#: 
msgid "Create ``ipyleaflet.Map`` with full-screen and layer visibility controls. Set initial view to be centered around dataset footprints. We will not be displaying the map just yet."
msgstr ""

#: 
msgid "Now we add footprints to the map."
msgstr ""

#: 
msgid "Create Leaflet image layer"
msgstr ""

#: 
msgid "Under the hood ``mk_image_layer`` will:"
msgstr ""

#: 
msgid "Convert 16-bit ``rgb`` xarray to an 8-bit RGBA image"
msgstr ""

#: 
msgid "Encode RGBA image as PNG data ``odc.ui.to_rgba``"
msgstr ""

#: 
msgid "Render PNG data to \"data uri\""
msgstr ""

#: 
msgid "Compute image bounds"
msgstr ""

#: 
msgid "Construct ``ipyleaflet.ImageLayer`` with uri from step 3 and bounds from step 4"
msgstr ""

#: 
msgid "JPEG compression can also be used (e.g ``fmt=\"jpeg\"``), useful for larger images to reduce notebook size in bytes (use ``quality=40`` to reduce size further), downside is no opacity support unlike PNG."
msgstr ""

#: 
msgid "Satellite imagery is often 12-bit and higher, but web images are usually 8-bit, hence we need to reduce bit-depth of the input imagery such that there are only 256 levels per color channel. This is where ``clamp`` parameter comes in. In this case we use ``clamp=2000``. Input values of ``2000`` and higher will map to value ``255`` (largest possible 8-bit unsigned value), ``0`` will map to ``0`` and every other value in between will scale linearly."
msgstr ""

#: 
msgid "Add opacity control"
msgstr ""

#: 
msgid "Add Vertical Slider to the map"
msgstr ""

#: 
msgid "Dragging slider down lowers opacity of the image layer"
msgstr ""

#: 
msgid "Use of ``jslink`` from ``ipywidgets`` ensures that this interactive behaviour will work even on a pre-rendered notebook (i.e. on nbviewer)"
msgstr ""

#: 
msgid "Finally display the map"
msgstr ""

#: 
msgid "Sharing notebooks online"
msgstr ""

#: 
msgid "Unlike notebooks with ``matplotlib`` figures, saving a notebook after running it is not enough to have interactive maps displayed when sharing rendered notebooks online. You also need to make sure that \"Widget State\" is saved. In JupyterLab make sure that ``Save Widget State Automatically`` setting is enabled. You can find it under ``Settings`` menu."
msgstr ""

#: 
msgid "Integrating external data from a CSV"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 8`, :index:`external data`, :index:`data methods; interpolation`, :index:`data used; csv`, :index:`intertidal`, :index:`coastal`, :index:`water`"
msgstr ""

#: 
msgid "It is often useful to combine external data (e.g. from a CSV or other dataset) with data loaded from Digital Earth Africa. For example, we may want to combine data from a tide or river guage with satellite data to determine water levels at the exact moment each satellite observation was made. This can allow us to manipulate and extract satellite data and obtain additional insights using data from our external source."
msgstr ""

#: 
msgid "This example notebook loads in a time series of external tide modelling data from a CSV, and combines it with satellite data loaded from Digital Earth Africa. This workflow could be applied to any external time series dataset (e.g. river guages, tide guagues, rainfall measurements etc). The notebook demonstrates how to:"
msgstr ""

#: 
msgid "Load a time series of Landsat 8 data"
msgstr ""

#: 
msgid "Load in external time series data from a CSV"
msgstr ""

#: 
msgid "Convert this data to an ``xarray.Dataset`` and link it to each satellite observation by interpolating values at each satellite timestep"
msgstr ""

#: 
msgid "Add this new data as a variable in our satellite dataset, and use this to filter satellite imagery to high and low tide imagery"
msgstr ""

#: 
msgid "Demonstrate how to swap dimensions between ``time`` and the new ``tide_height`` variable"
msgstr ""

#: 
msgid "First we load in three years of Landsat 8 data. We will use Msasani Bay in Tanzania for this demonstration, as we have a CSV of tide height data for this location that we wish to combine with satellite data. We load a single band ``nir`` which clearly differentiates between water (low values) and land (higher values). This will let us verify that we can use external tide data to identify low and high tide satellite observations."
msgstr ""

#: 
msgid "Integrating external data"
msgstr ""

#: 
msgid "Load in a CSV of external data with timestamps"
msgstr ""

#: 
msgid "In the code below, we aim to take a CSV file of external data (in this case, half-hourly tide heights for a location in Msasani Bay, Tanzania for a five year period between 2014 and 2018 generated using the `OTPS TPXO8 tidal model <https://www.tpxo.net/global/tpxo8-atlas>`__), and link this data back to our satellite data timeseries."
msgstr ""

#: 
msgid "We can load the existing tide height data using the ``pandas`` module which we imported earlier. The data has a column of ``time`` values, which we will set as the index column (roughly equivelent to a ``dimension`` in ``xarray``)."
msgstr ""

#: 
msgid "Link external data to satellite data"
msgstr ""

#: 
msgid "Now that we have the tide height data, we need to estimate the tide height for each of our satellite images. We can do this by interpolating between the data points we do have (hourly measurements) to get an estimated tide height for the exact moment each satellite image was taken."
msgstr ""

#: 
msgid "The code below generates an ``xarray.Dataset`` with the same number of timesteps as the original satellite data. The dataset has a single variable ``tide_height`` that gives the estimated tide hight for each observation:"
msgstr ""

#: 
msgid "Now we have our tide heights in ``xarray`` format that matches our satellite data, we can add this back into our satellite dataset as a new variable:"
msgstr ""

#: 
msgid "We can now plot tide heights for our satellite data:"
msgstr ""

#: 
msgid "Filtering by external data"
msgstr ""

#: 
msgid "Now that we have a new variable ``tide_height`` in our dataset, we can use ``xarray`` indexing methods to manipulate our data using tide heights (e.g. filter by tide to select low or high tide images):"
msgstr ""

#: 
msgid "We can plot the median of the filtered images for low and high tide to examine the difference between them. Taking the median allows us to view a cloud-free image."
msgstr ""

#: 
msgid "For the low-tide images:"
msgstr ""

#: 
msgid "and for the high-tide images:"
msgstr ""

#: 
msgid "Note that many tidal flat areas in the low-tide image (blue-green) now appear inundated by water (dark blue/purple) in the high-tide image."
msgstr ""

#: 
msgid "Swapping dimensions based on external data"
msgstr ""

#: 
msgid "By default, ``xarray`` uses ``time`` as one of the main dimensions in the dataset (in addition to ``x`` and ``y``). Now that we have a new ``tide_height`` variable, we can change this to be an actual dimension in the dataset in place of ``time``. This enables additional more advanced operations, such as calculating rolling statistics or aggregating by ``tide_heights``."
msgstr ""

#: 
msgid "In the example below, you can see that the dataset now has three dimensions (``tide_height``, ``x`` and ``y``). The dimension ``time`` is no longer a dimension in the dataset."
msgstr ""

#: 
msgid "Principal component analysis for multi-spectral data"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`analysis; principal component analysis`"
msgstr ""

#: 
msgid "Principal Component Analysis (PCA) is a popular technique for dimensionality reduction. It can be used to explore patterns in high-dimensional data and assist unsupervised learning."
msgstr ""

#: 
msgid "Principal components are a series of linear combinations of the original variables, among which the first principal component accounts for the greatest variance within a dataset. Each subsequent principal component accounts for the next greatest possible variance and is uncorrelated with the previously defined components."
msgstr ""

#: 
msgid "This technique is useful for understanding Sentinel-2 data as images are captured in 12 spectral bands but only 3 variables can be visualized in a RGB composite. PCA can also be applied to timeseries data to investigate temporal evolution patterns for different land cover types."
msgstr ""

#: 
msgid "This notebook demonstrates a principal component analysis for Sentinel-2 multi-spectal data. Following steps are covered:"
msgstr ""

#: 
msgid "Loading Sentinel-2 multi-spectral data."
msgstr ""

#: 
msgid "Applying PCA to transform and visualize data. \\**\\*"
msgstr ""

#: 
msgid "Connect to the datacube so we can access DEAfrica data."
msgstr ""

#: 
msgid "``time``: The date range to analyse (e.g. ``(\"2017-08-01\", \"2019-11-01\")``). For reasonable loading times, make sure the range spans less than 3 years."
msgstr ""

#: 
msgid "Acceptable range of cloud cover percentage for input Sentinel-2 granule (``min_gooddata``)"
msgstr ""

#: 
msgid "Spectral bands to be explored"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The default location is Betsiboka Estuary, Madagascar."
msgstr ""

#: 
msgid "Loading Sentinel-2 multi-spectral data"
msgstr ""

#: 
msgid "Only high probablity cloud is excluded in this example, but this can be modified for a different area."
msgstr ""

#: 
msgid "Applying PCA to transform and visualize data"
msgstr ""

#: 
msgid "To perform a PCA, data is first transformed into a numpy array that can be used by sklearn."
msgstr ""

#: 
msgid "A PCA model is generated with 3 principal components and fitted on the data."
msgstr ""

#: 
msgid "We can investigate how much variance is accounted for in each principal component. In the default example, the first principal component accounts for a much high variance than the next two."
msgstr ""

#: 
msgid "This step can help determine whether more principal components are needed."
msgstr ""

#: 
msgid "The input data can now be transformed into this new reference space and rearranged into a xarray dataset compatible with input data."
msgstr ""

#: 
msgid "Visualise PCA results"
msgstr ""

#: 
msgid "Rasterising vectors & vectorising rasters"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls_summary_annual <https://explorer.digitalearth.africa/wofs_ls_summary_annual>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; WOfS`, :index:`data methods; rasterize`, :index:`data methods; vectorize`, :index:`data format; GeoTIFF`, :index:`data format; shapefile`"
msgstr ""

#: 
msgid "Many remote sensing and/or geospatial workflows require converting between vector data (e.g. shapefiles) and raster data (e.g. pixel-based data like that in an ``xarray.DataArray``). For example, we may need to use a shapefile as a mask to limit the analysis extent of a raster, or have raster data that we want to convert into vector data to allow for easy geometry operations."
msgstr ""

#: 
msgid "In this notebook, we show how to use the Digital Earth Africa function ``xr_rasterize`` and ``xr_vectorize`` in `deafrica_tools.spatial <../Tools/deafrica_tools/spatial.py>`__. The notebook demonstrates how to:"
msgstr ""

#: 
msgid "Load in data from the `Water Observations from Space (WOfS) <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ product"
msgstr ""

#: 
msgid "Vectorise the pixel-based ``xarray.DataArray`` WOfS object into a vector-based ``geopandas.GeoDataFrame`` object containing persistent water-bodies as polygons"
msgstr ""

#: 
msgid "Export the ``geopandas.GeoDataFrame`` as a shapefile"
msgstr ""

#: 
msgid "Rasterise the ``geopandas.GeoDataFrame`` vector data back into an ``xarray.DataArray`` object and export the results as a GeoTIFF"
msgstr ""

#: 
msgid "Load WOfS data from the datacube"
msgstr ""

#: 
msgid "We will load in an annual summary from the Water Observations from Space (WOfS) product to provide us with some data to work with."
msgstr ""

#: 
msgid "Plot the WOfS summary"
msgstr ""

#: 
msgid "Let's plot the WOfS data to get an idea of the objects we will be transforming. In the code below, we first select the pixels where the satellite has observed water at least 25% of the year, this is so we can isolate the more persistent water bodies and reduce some of the noise before we vectorise the raster."
msgstr ""

#: 
msgid "Vectorising an ``xarray.DataArray``"
msgstr ""

#: 
msgid "To convert our ``xarray.DataArray`` object into a vector based ``geopandas geodataframe``, we can use the DE Africa function ```xr_vectorize`` <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.spatial.html#deafrica_tools.spatial.xr_vectorize>`__ in the `deafrica_tools.spatial <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.spatial.html>`__ module. This tool is based on the `rasterio.features.shape <https://rasterio.readthedocs.io/en/stable/api/rasterio.features.html>`__ function, and can accept any of the arguments in ``rasterio.features.shape`` using the same syntax."
msgstr ""

#: 
msgid "In the cell below, we use the argument ``mask=water_bodies.values==1`` to indicate we only want to convert the values in the xarray object that are equal to 1."
msgstr ""

#: 
msgid "**Note**: Both ``xr_rasterize`` and ``xr_vectorize`` will attempt to automatically obtain the ``crs`` and ``transform`` from the input data, but if the data does not contain this information, you will need to manually provide this. In the cell below, we will get the ``crs`` and ``transform`` from the original dataset."
msgstr ""

#: 
msgid "Plot our vectorised raster"
msgstr ""

#: 
msgid "Export as shapefile"
msgstr ""

#: 
msgid "Our function also allows us to very easily export the ``GeoDataFrame`` as a ``shapefile`` for use in other applications using the ``export_shp`` parameter."
msgstr ""

#: 
msgid "Rasterising a shapefile"
msgstr ""

#: 
msgid "Using the ```xr_rasterize`` <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.spatial.html#deafrica_tools.spatial.xr_rasterize>`__ function in the `deafrica_tools.spatial <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.spatial.html>`__ module (based on the rasterio function: `rasterio.features.rasterize <https://rasterio.readthedocs.io/en/stable/api/rasterio.features.html>`__, and can accept any of the arguments in ``rasterio.features.rasterize`` using the same syntax) we can turn the ``geopandas.GeoDataFrame`` back into a ``xarray.DataArray``."
msgstr ""

#: 
msgid "As we already have the ``GeoDataFrame`` loaded we don't need to read in the shapefile, but if we wanted to read in a shapefile first we can use `gpd.read_file() <https://geopandas.org/en/stable/docs/reference/api/geopandas.read_file.html#geopandas.read_file>`__."
msgstr ""

#: 
msgid "This function uses an ``xarray.dataArray`` object as a **template** for converting the ``geodataframe`` into a raster object (the template provides the ``size``, ``crs``, ``dimensions``, ``transform``, and ``attributes`` of the output array)."
msgstr ""

#: 
msgid "Export as GeoTIFF"
msgstr ""

#: 
msgid "``xr_rasterize`` also allows for exporting the results as a GeoTIFF using the parameter ``export_tiff``. To do this, a ``named`` array is required. If one is not provided, the functon wil provide a default one."
msgstr ""

#: 
msgid "Reprojecting datacube and raster data"
msgstr ""

#: 
msgid "**Special requirements:** This notebook loads data from an external raster file (``madagascar_CHPclim_02.tif``) from the ``Supplementary_data`` folder of this repository"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2 geomedian`, :index:`data used; CHIRPS`, :index:`data methods; reprojecting`, :index:`data methods; resampling`, :index:`data format; GeoTIFF`, :index:`data methods; geobox`"
msgstr ""

#: 
msgid "It is often valuable to combine data from the datacube with other external raster datasets. For example, we may want to use a rainfall raster to focus our analysis on satellite data to mask areas of higher or lower precipitation. However, it can be challenging to combine datasets if they have different extents, resolutions (e.g. 20 m vs. 250 m), or coordinate reference systems (e.g. WGS 84 vs. Africa Albers Equal Area Conic). To be able to combine these datasets, we need to be able to *reproject* them into identical spatial grids prior to analysis."
msgstr ""

#: 
msgid "Datacube stores information about the location, resolution and coordinate reference system of a rectangular grid of data using an object called a ``GeoBox``. This `GeoBox object <https://datacube-core.readthedocs.io/en/latest/api/core-classes/generate/datacube.utils.geometry.GeoBox.html>`__ is added to all data loaded from the datacube, and all rasters loaded with ``xr.open_rasterio`` (provided that ``import datacube`` is run *before* the raster is loaded). Datacube functions can use this object to provide a template that can be used to reproject raster and datacube data - either applying this reprojection directly when new data is being loaded, or to reproject existing data that has already been loaded into memory. This makes it straightforward to reproject one dataset into the exact spatial grid of another dataset for further analysis."
msgstr ""

#: 
msgid "This notebook demonstrates how to perform three key reprojection workflows when working with datacube data and external rasters:"
msgstr ""

#: 
msgid "Loading and reprojecting datacube data to match a raster file using ``dc.load``"
msgstr ""

#: 
msgid "Reprojecting existing datacube data to match a raster using ``xr_reproject``"
msgstr ""

#: 
msgid "Loading and reprojecting a raster to match datacube data using ``rio_slurp_xarray``"
msgstr ""

#: 
msgid "Loading and reprojecting datacube data to match a raster"
msgstr ""

#: 
msgid "Load a raster file"
msgstr ""

#: 
msgid "First we load a GeoTIFF raster from file using ``rioxarray.open_rasterio``. The example below loads a long-term mean rainfall data for the month of February as according to `Climate Hazards Group InfraRed Precipitation with Station <https://www.chc.ucsb.edu/data/chirps>`__ (CHIRPS) for a section of Madagascar. It has a spatial resolution of ~0.05 decimal degrees (approximately equal to 5 km pixels at the equator) in the WGS 84 (``EPSG:4326``) coordinate reference system."
msgstr ""

#: 
msgid "If we plot our loaded raster, we can see there are areas with higher rainfall, and areas with lower rainfall."
msgstr ""

#: 
msgid "GeoBox objects"
msgstr ""

#: 
msgid "Now we have loaded our raster dataset, we can inspect its ``GeoBox`` object that we will use to allow us to reproject data. The ``GeoBox`` can be accessed using the ``.geobox`` method. It includes a set of information that together completely define the spatial grid of our data: \\* The width (e.g. ``20``) and height (e.g. ``20``) of our data in pixels \\* An ``Affine`` object which defines the spatial resolution (e.g. ``-0.05000000074505806`` and ``0.05000000074505806``) and spatial position (e.g. ``46.00000336766243`` and ``-18.00000160932541``) of our data \\* The coordinate reference system of our data (e.g. ``+init=epsg:4326``)"
msgstr ""

#: 
msgid "The ``GeoBox`` also has a number of useful methods that can be used to view information about the spatial grid of our data. For example, we can inspect the spatial resolution of our data:"
msgstr ""

#: 
msgid "Or obtain information about the data's spatial extent:"
msgstr ""

#: 
msgid "**Note:** For more information about ``GeoBox`` objects and a complete list of their methods, refer to the `datacube documentation <https://datacube-core.readthedocs.io/en/latest/api/core-classes/generate/datacube.utils.geometry.GeoBox.html>`__."
msgstr ""

#: 
msgid "Load and reproject datacube data"
msgstr ""

#: 
msgid "We can now use datacube to load and reproject satellite data to exactly match the coordinate reference system and resolution of our raster data. By specifying ``like=raster.geobox``, we can load datacube data that will be reprojected to match the spatial grid of our raster."
msgstr ""

#: 
msgid "When we plot the result, it should appear similarly pixelated to the raster we loaded above, which has a lower resolution."
msgstr ""

#: 
msgid "We can also directly compare the geobox of the two datasets to verify they share the same spatial grid:"
msgstr ""

#: 
msgid "Now that our two datasets share the same spatial grid, we can use our raster as a mask. For example, we can mask out all satellite pixels except those with higher rainfall (e.g. more than 350 mm/month of rain):"
msgstr ""

#: 
msgid "Reprojecting existing datacube data to match a raster"
msgstr ""

#: 
msgid "The example above demonstrated how to load *new* satellite data from the datacube to match the spatial grid of a raster. However, sometimes we may have already loaded satellite data with a coordinate reference system and resolution that is different from our raster. In this case, we need to reproject this existing dataset to match our raster."
msgstr ""

#: 
msgid "For example, we have loaded the 2018 Sentinel-2 geomedian data from the datacube with 20 m-resolution pixels in the ``EPSG:6933`` coordinate reference system. Note that in this example we manually specify the ``x``, ``y``, ``resolution`` and ``output_crs`` parameters, rather than taking them directly from our raster using ``like=raster.geobox`` in the previous example."
msgstr ""

#: 
msgid "If we plot our satellite data, we can see that it is much higher resolution than our pixelated CHIRPS precipitation raster:"
msgstr ""

#: 
msgid "Reproject datacube data"
msgstr ""

#: 
msgid "We can now use the ``xr_reproject`` function to reproject our existing high resolution satellite dataset. We specify ``geobox=raster.geobox`` to request that the data gets reprojected to match the spatial grid of our low resolution raster."
msgstr ""

#: 
msgid "To control how the data is reprojected, we can specify a custom ``resampling`` method that will control how our high resolution pixels will be transformed into lower resolution pixels. In this case, we specify ``\"average\"``, which will set the value of each larger pixel to the average of all smaller pixels that fall within its pixel boundary."
msgstr ""

#: 
msgid "**Note:** Refer to the `rasterio documentation <https://rasterio.readthedocs.io/en/latest/api/rasterio.enums.html#rasterio-enums-module>`__ for a full list of available resampling methods."
msgstr ""

#: 
msgid "Now if we plot our reprojected dataset, we can see that our satellite imagery now has a similar resolution to our low resolution raster (e.g. with a pixelated appearance). Note however, that this result will appear smoother than the previous example due to the ``\"average\"`` resampling method used here (compared to ``\"nearest\"``)."
msgstr ""

#: 
msgid "Once again, we can also verify that the two datasets have identical spatial grids:"
msgstr ""

#: 
msgid "Loading and reprojecting a raster to match datacube data"
msgstr ""

#: 
msgid "Rather than reprojecting satellite data to match the resolution and projection system of our raster, we may instead wish to reproject our raster to match the spatial grid of our satellite data. This can be particularly useful when we have a lower resolution raster file (e.g. like the ~5 km resolution CHIRPS data we are using in this example), but we don't want to lose the better spatial resolution of our satellite data."
msgstr ""

#: 
msgid "Load datacube data"
msgstr ""

#: 
msgid "As in the previous example, we can load in satellite data from the datacube at 20 m spatial resolution and ``EPSG:6933`` coordinate reference system:"
msgstr ""

#: 
msgid "Load and reproject raster data"
msgstr ""

#: 
msgid "We can now use the ``rio_slurp_xarray`` function to load and reproject our raster file to match our higher resolution satellite dataset. We specify ``gbox=ds.geobox`` to request that our raster gets reprojected to match the spatial grid of ``ds``. As in the previous ``xr_reproject`` example, we can also specify a custom ``resampling`` method which will be used during the reprojection. In this case, we specify ``'bilinear'``, which will produce a smooth output without obvious pixel boundaries."
msgstr ""

#: 
msgid "If we plot our resampled raster data, it should now appear less pixelated than the original ~250 m resolution raster."
msgstr ""

#: 
msgid "The resampled raster should also match the spatial grid of our higher resolution satellite data:"
msgstr ""

#: 
msgid "Now both of our datasets share the same spatial grid, we can use our resampled raster to mask our higher resolution satellite dataset as we did in the first section (e.g. mask out all areas with less than 350 mm of rainfall in February). Compared to the first example, this masked satellite dataset should appear much higher resolution, with far less obvious pixelation:"
msgstr ""

#: 
msgid "Combining satellite data with tidal modelling using OTPS"
msgstr ""

#: 
msgid "**Products used:** `ls5_sr <https://explorer.digitalearth.africa/ls5_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/ls7_sr>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`tidal; modelling`, :index:`intertidal`, :index:`dask`"
msgstr ""

#: 
msgid "Ocean tides are the periodic rise and fall of the ocean caused by the gravitational pull of the moon and sun and the earth's rotation. Tides in coastal areas can greatly influence how these environments appear in satellite imagery as water levels vary by up to 12 metres. To be able to study environmental processes along Africa's coastline, it is vital to obtain data on tidal conditions at the exact moment each satellite image was acquired."
msgstr ""

#: 
msgid "This notebook demonstrates how to tidally tag remotely sensed imagery using functions from the ``deafrica_tools.coastal`` package so that images can be extracted or analysed by tidal stage (e.g. low, high, ebb, flow). These functions use the `OTPS TPXO8 tidal model <https://www.tpxo.net/global/tpxo8-atlas>`__ to calculate the height (relative to mean sea level) and stage of the tide at the exact moment each satellite image was acquired."
msgstr ""

#: 
msgid "Load an example time series of satellite data"
msgstr ""

#: 
msgid "Use the ``tidal_tag`` function from ``deafrica_tools.coastal`` to model tide heights for each satellite observation"
msgstr ""

#: 
msgid "Use tide height data to produce median composites of the coast at low and high tide"
msgstr ""

#: 
msgid "Swap a dataset's dimensions to compute a rolling median along the ``tide_m`` dimension"
msgstr ""

#: 
msgid "Compute ebb or flow tide phase data to determine whether water levels were rising or falling in each satellite observation"
msgstr ""

#: 
msgid "Use the ``tidal_stats`` function to evaluate any biases in the tidal conditions observed by a satellite"
msgstr ""

#: 
msgid "Set up a Dask cluster"
msgstr ""

#: 
msgid "Dask can be used to better manage memory use down and conduct the analysis in parallel. For an introduction to using Dask with Digital Earth Africa, see the `Dask notebook <../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "**Note**: We recommend opening the Dask processing window to view the different computations that are being executed; to do this, see the *Dask dashboard in DE Africa* section of the `Dask notebook <../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "To use Dask, set up the local computing cluster using the cell below."
msgstr ""

#: 
msgid "Set up data query"
msgstr ""

#: 
msgid "First we set up a query to define the area, time period and other parameters required for loading data. In this example, we will load 30 years of Landsat 5, 7 and 8 data for the Geba River Estuary in southern Guinea-Bissau. We load the ``'red', 'green', 'blue'`` bands so that we can plot the data as true colour imagery."
msgstr ""

#: 
msgid "**Note**: The ``dask_chunks`` parameter allows us to `use Dask to lazily load data rather than load data directly into memory <https://examples.dask.org/xarray.html>`__, as the standard loading method can take a long time and large amounts of memory. Lazy loading can be a very useful approach for when you need to load large amounts of data without crashing your analysis. In coastal applications, it allows us to load (using either ``.compute()`` or by plotting our data) only a small subset of observations from our entire time series (e.g. only low or high tide observations) without having to load the entire dataset into memory first, which can greatly decrease processing times."
msgstr ""

#: 
msgid "Define location"
msgstr ""

#: 
msgid "We can preview the area that we will load data for:"
msgstr ""

#: 
msgid "Load satellite time-series"
msgstr ""

#: 
msgid "To obtain some satellite data to analyse, we use the ``load_ard`` function to import a time series of Landsat 5, 7 and 8 observations as an ``xarray.Dataset``. The input data does not need to be from Landsat: any remotely-sensed imagery with timestamps and spatial coordinates provide enough data to run the tidal model."
msgstr ""

#: 
msgid "Model tide heights for each observation"
msgstr ""

#: 
msgid "We use the ``tidal_tag`` function from ``deafrica_coastaltools`` to associate each satellite observation in our timeseries with a tide height relative to mean sea level. This function uses the time and date of acquisition and the geographic location of each satellite observation as inputs to the OSU Tidal Prediction Software (OTPS) tidal model. From `Sagar et al. 2015 <https://www.sciencedirect.com/science/article/pii/S0034425717301591>`__:"
msgstr ""

#: 
msgid "**Note**: The **OTPS TPX08** tidal model consists of a multi-resolution bathymetric grid solution, with a 1/6° solution in the global open ocean, and a 1/30° local resolution solution to improve modelling in complex shallow water environments. The OTPS model is based on a system of linear partial differential equations, called Laplace's tidal equations, parametrised with nine harmonic tidal constituents. The model is fitted to track-averaged TOPEX/Poseidon altimeter data collected from 1992 to 2016 and Jason-1 (Poseidon 2) altimeter data from 2002 to 2013, enabling estimation of the tidal height and harmonic constituents at discrete temporal epochs and spatial locations."
msgstr ""

#: 
msgid "The function will automatically select a tide modelling location based on the dataset centroid. It will then output modelled tide heights as a new ``tide_m`` variable in the ``xarray.Dataset`` (the variable should appear under ``Data variables`` above)."
msgstr ""

#: 
msgid "We can easily plot this new variable to inspect the range of tide heights observed by the satellites in our timeseries. In this example, our observed tide heights range from approximately -1.0 to 1.0 m relative to Mean Sea Level:"
msgstr ""

#: 
msgid "Example tide height analysis"
msgstr ""

#: 
msgid "To demonstrate how tidally tagged images can be used to produce composites of high and low tide imagery, we can compute the lowest 5% and highest 5% percent of tide heights, and use these to filter our observations. We can then combine and plot these filtered observations to visualise what the landscape looks like at low and high tide:"
msgstr ""

#: 
msgid "**Note**: An alternative approach to combining observations into a composite can be achieved using a geomedian, which ensures band relationships are kept consistent. More information is provided in the `Generating geomedian composites notebook <Generating_geomedian_composites.ipynb>`__."
msgstr ""

#: 
msgid "Swapping dimensions"
msgstr ""

#: 
msgid "The ``tidal_tag`` function allows you to use tide heights as the primary dimension in the dataset, rather than time. Setting ``swap_dims=True`` will swap the ``time`` dimension in the original ``xarray.Dataset`` to the new ``tide_m`` variable."
msgstr ""

#: 
msgid "The dataset now contains three dimensions: ``tide_m``, ``x`` and ``y``."
msgstr ""

#: 
msgid "This can make it easier to analyse the data with respect to tide, e.g. computing a rolling median by tide height (e.g. along the ``tide_m`` dimension), as is done in the following cell."
msgstr ""

#: 
msgid "Modelling ebb and flow tidal phases"
msgstr ""

#: 
msgid "The ``tidal_tag`` function also allows us to determine whether each satellite observation was taken while the tide was rising/incoming (flow tide) or falling/outgoing (ebb tide) by setting ``ebb_flow=True``. This is achieved by comparing tide heights 15 minutes before the before and after the observed satellite observation."
msgstr ""

#: 
msgid "Ebb and flow data can provide valuable contextual information for interpreting satellite imagery, particularly in tidal flat or mangrove forest environments where water may remain in the landscape for considerable time after the tidal peak."
msgstr ""

#: 
msgid "We now have data giving us the both the tide height and tidal phase ('ebb' or 'flow') for every satellite image:"
msgstr ""

#: 
msgid "We could for example use this data to filter our observations to keep ebbing phase observations only:"
msgstr ""

#: 
msgid "Evaluating observed vs. all modelled tide heights"
msgstr ""

#: 
msgid "The complex behaviour of tides mean that a sun synchronous sensor like Landsat `does not observe the full range of the tidal cycle at all locations <https://www.sciencedirect.com/science/article/pii/S0272771418308783#sec3>`__. Biases in the proportion of the tidal range observed by satellites can prevent us from obtaining data on areas of the coastline exposed or inundated at the extremes of the tidal range. This can risk gaining misleading insights into the true extent of the area of the coastline affected by tides, and make it difficult to compare high or low tide images fairly in different locations."
msgstr ""

#: 
msgid "The ``tidal_stats`` function can assist in evaluating how the range of tides observed by satellites compare to the full tidal range. It works by using the OTPS tidal model to model tide heights at a regular interval (every two hours by default) across the entire time period covered by the input satelliter timeseries dataset. This is then compared against the tide heights in observed by the satellite and used to calculate a range of statistics and a plot that summarises potential biases in the data."
msgstr ""

#: 
msgid "**Note**: For a more detailed discussion of the issue of tidal bias in sun-synchronous satellite observations of the coastline, refer to the `'Limitations and future work' section in Bishop-Taylor et al. 2018 <https://www.sciencedirect.com/science/article/pii/S0272771418308783#sec3>`__."
msgstr ""

#: 
msgid "The function also outputs a ``pandas.Series`` object containing a set of statistics that compare the observed vs. full modelled tidal ranges. These statistics include:"
msgstr ""

#: 
msgid "**tidepost_lat:** latitude used for modelling tide heights"
msgstr ""

#: 
msgid "**tidepost_lon:** longitude used for modelling tide heights"
msgstr ""

#: 
msgid "**observed_min_m:** minimum tide height observed by the satellite (in metre units)"
msgstr ""

#: 
msgid "**all_min_m:** minimum tide height from full modelled tidal range (in metre units)"
msgstr ""

#: 
msgid "**observed_max_m:** maximum tide height observed by the satellite (in metre units)"
msgstr ""

#: 
msgid "**all_max_m:** maximum tide height from full modelled tidal range (in metre units)"
msgstr ""

#: 
msgid "**observed_range_m:** tidal range observed by the satellite (in metre units)"
msgstr ""

#: 
msgid "**all_range_m:** full modelled tidal range (in metre units)"
msgstr ""

#: 
msgid "**spread_m:** proportion of the full modelled tidal range observed by the satellite (see Bishop-Taylor et al. 2018)"
msgstr ""

#: 
msgid "**low_tide_offset:** proportion of the lowest tides never observed by the satellite (see Bishop-Taylor et al. 2018)"
msgstr ""

#: 
msgid "**high_tide_offset:** proportion of the highest tides never observed by the satellite (see Bishop-Taylor et al. 2018)"
msgstr ""

#: 
msgid "**observed_slope:** slope of any relationship between observed tide heights and time"
msgstr ""

#: 
msgid "**all_slope:** slope of any relationship between all modelled tide heights and time"
msgstr ""

#: 
msgid "**observed_pval:** significance/p-value of any relationship between observed tide heights and time"
msgstr ""

#: 
msgid "**all_pval:** significance/p-value of any relationship between all modelled tide heights and time"
msgstr ""

#: 
msgid "Using ``load_ard`` to load and cloud mask multiple satellite sensors"
msgstr ""

#: 
msgid "**Products Used:** `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/ls7_sr>`__, `ls5_sr <https://explorer.digitalearth.africa/ls5_sr>`__, `s2_l2a <https://explorer.digitalearth.africa/s2a_l2a>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`data used; landsat 9`, :index:`data used; sentinel-2`, :index:`cloud masking`, :index:`cloud filtering`, :index:`pixel quality`, :index:`dask`"
msgstr ""

#: 
msgid "This notebook demonstrates how to use the ``load_ard`` function to import a time series of cloud-free observations over Africa from multiple Landsat satellites (i.e. Landsat 5, 7, 8, and 9) and Sentinel-2 satellites (i.e. Sentinel-2A and Sentinel-2B). The function automatically applies cloud masking to the input data and returns all available data from multiple sensors as a single combined ``xarray.Dataset``."
msgstr ""

#: 
msgid "Optionally, the function can be used to return only observations that contain a minimum proportion of good quality non-cloudy or shadowed pixels. This can be used to extract visually appealing time series of observations that are not affected by cloud."
msgstr ""

#: 
msgid "The ``load_ard`` function currently supports the following products:"
msgstr ""

#: 
msgid "USGS Collection 2: ``ls5_sr, ls7_sr, ls8_sr, ls9_sr``"
msgstr ""

#: 
msgid "Sentinel 2: ``s2_l2a``"
msgstr ""

#: 
msgid "Sentinel 1: ``s1_rtc``"
msgstr ""

#: 
msgid "This notebook demonstrates how to use ``load_ard`` to 1. Load and combine Landsat 5, 7, 8, and 9 data into a single ``xarray.Dataset`` 2. Optionally apply a cloud mask to the resulting data 3. Filter resulting data to keep only cloud-free observations 4. Applying morphological processing on the cloud mask 5. Filter data before loading using a custom function 6. Load Sentinel-2 data 7. Lazily load data using Dask"
msgstr ""

#: 
msgid "Loading multiple Landsat sensors"
msgstr ""

#: 
msgid "The ``load_ard`` function can be used to load a single, combined timeseries of cloud-masked data from multiple Landsat satellites. At its simplest, you can use the function similarly to ``dc.load`` by passing a set of spatiotemporal query parameters (e.g. ``x``, ``y``, ``time``, ``measurements``, ``output_crs``, ``resolution``, ``group_by`` etc) directly into the function (`see the dc.load documentation for all possible options <https://datacube-core.readthedocs.io/en/latest/api/indexed-data/generate/datacube.Datacube.load.html>`__). The key difference from ``dc.load`` is that the function also requires an existing ``Datacube`` object, which is passed using the ``dc`` parameter. This gives us the flexibilty to load data from development or experimental datacubes."
msgstr ""

#: 
msgid "In the examples below, we load three bands of data (``red``, ``green``, ``blue``) from the three USGS Collection 2 products (Landsat 5, 7, 8, and 9) by specifying:"
msgstr ""

#: 
msgid "``products=['ls5_sr', 'ls7_sr', 'ls8_sr', ls9_sr']``"
msgstr ""

#: 
msgid "Note: There are some limitations to ``load_ard`` due to its design. An important part of its intended functionality is to provide a simple means of concatenating Landsat 5, 7, 8, and 9 together to form a single xarray object. However, this means that ``load_ard`` can only apply pixel quality masking to pq-categories that are common across Landsat sensors. For example, Landsat-8 has a dedicated bit flag for cirrus bands, but Landsat 5 and 7 do not. This means that ``load_ard`` cannot accept ``'cirrus': 'high_confidence'`` as a pq-category. The same issue also applies for masking of aerosols, Landat 5 and 7 have different means of recording high aerosol than Landsat 8, and thus ``load_ard`` does not support masking of aerosols."
msgstr ""

#: 
msgid "The function outputs the number of observations for each product, and the total number loaded if the ``verbose=`` parameter is set to ``True`` (which it is by default)"
msgstr ""

#: 
msgid "Explicit syntax"
msgstr ""

#: 
msgid "The following example demonstrates how key parameters can be passed directly to ``load_ard``."
msgstr ""

#: 
msgid "Query syntax"
msgstr ""

#: 
msgid "The following example demonstrates how key parameters can be stored in a ``query`` dictionary, to be passed as a single parameter to ``load_ard``. The ``query`` can then be reused in other ``load_ard`` calls."
msgstr ""

#: 
msgid "Working with cloud masking"
msgstr ""

#: 
msgid "By plotting a time slice from the data we loaded above, you can see an area of white pixels where clouds have been masked out and set to ``NaN``:"
msgstr ""

#: 
msgid "By default, ``load_ard`` applies a pixel quality mask to loaded data using the sensor's pixel quality band."
msgstr ""

#: 
msgid "For USGS Collection 2, the following mask parameters are applied to the ``qa_pixel`` band:"
msgstr ""

#: 
msgid "For Sentinel 2, the following mask parameters are applied to the `SCL <https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm>`__ band:"
msgstr ""

#: 
msgid "**Note:** These masking parameters can be customised using the ``categories_to_mask_ls`` parameter for USGS data, and the ``categories_to_mask_s2`` parameter for Sentinel 2 data"
msgstr ""

#: 
msgid "We can de-activate pixel masking completely by setting ``mask_pixel_quality=False``:"
msgstr ""

#: 
msgid "Filtering to non-cloudy observations"
msgstr ""

#: 
msgid "In addition to masking out cloud, ``load_ard`` allows you to discard any satellite observation that contains less than a minimum proportion of good quality (e.g. non-cloudy) pixels. This can be used to obtain a time series of only clear, cloud-free observations."
msgstr ""

#: 
msgid "To discard all observations with less than ``X``\\ % good quality pixels, use the ``min_gooddata`` parameter. For example, ``min_gooddata=0.90`` will return only observations where less than 10 % of pixels contain cloud, cloud shadow or other invalid data, resulting in a smaller number of clear, cloud free images being returned by the function:"
msgstr ""

#: 
msgid "There are significant known limitations to the cloud masking algorithms employed by Sentinel-2 and Landsat. For example, bright objects like buildings and coastlines are commonly mistaken for cloud. We can improve on the false positives detected by Landsat and Sentinel-2's pixel quality mask by applying binary moprhological image processing techniques (e.g. `binary_closing <https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.ndimage.morphology.binary_closing.html#scipy.ndimage.morphology.binary_closing>`__, `binary_erosion <https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.ndimage.morphology.binary_erosion.html#scipy.ndimage.morphology.binary_erosion>`__ etc.). The Open-Data-Cube library `odc-algo <https://github.com/opendatacube/odc-tools/tree/develop/libs/algo>`__ has a function, ``odc.algo.mask_cleanup`` that can perform a few of these operations. Below, we will try to improve the cloud mask by apply a number of these filters."
msgstr ""

#: 
msgid "Below, you may notice that in the second and fourth images some of the false postives over the river/river banks have been removed by the morphological filters"
msgstr ""

#: 
msgid "Filtering data before load using a custom function"
msgstr ""

#: 
msgid "The ``load_ard`` function has a powerful predicate parameter that allows you to filter out satellite observations before they are actually loaded using a custom function. Some examples of where this may be useful include:"
msgstr ""

#: 
msgid "Filtering to return data from a specific season (e.g. summer, winter)"
msgstr ""

#: 
msgid "Filtering to return data acquired on a particular day of the year"
msgstr ""

#: 
msgid "Filtering to return data based on an external dataset (e.g. data acquired during specific climatic conditions such as drought or flood)"
msgstr ""

#: 
msgid "A predicate function should take a ``datacube.model.Dataset`` object as an input (e.g. as returned from ``dc.find_datasets(product='ls8_sr', **query)[0]``, and return either ``True`` or ``False``. For example, a predicate function could be used to return True for only datasets acquired in April:"
msgstr ""

#: 
msgid "``dataset.time.begin.month == 4``"
msgstr ""

#: 
msgid "Filter to a single month"
msgstr ""

#: 
msgid "In the example below, we create a simple predicate function that will filter our data to return only satellite data acquired in April:"
msgstr ""

#: 
msgid "We can print the time steps returned by load_ard to verify that they now include only April observations (e.g. 2018-04-...):"
msgstr ""

#: 
msgid "Filter to a single season"
msgstr ""

#: 
msgid "An example of a predicate function that will return data from a season of interest would look as follows:"
msgstr ""

#: 
msgid "After applying this predicate function, running the following command demonstrates that our dataset only contains months during the Dec, Jan, Feb period"
msgstr ""

#: 
msgid "Loading Sentinel-2 data"
msgstr ""

#: 
msgid "Data from the Sentinel-2A and Sentinel-2B satellites can also be loaded using ``load_ard``. To do this, we need to specify the Sentinel-2 product (``['s2a_l2a']`` - both sensors S2a and S2b are covered by this product name) in place of the Landsat products above."
msgstr ""

#: 
msgid "Cloudy pixels are masked out by default from the resulting observations similarly to Landsat"
msgstr ""

#: 
msgid "Lazy loading with Dask"
msgstr ""

#: 
msgid "Rather than load data directly - which can take a long time and large amounts of memory - all datacube data can be lazy loaded using Dask. This can be a very useful approach for when you need to load large amounts of data without crashing your analysis, or if you want to subsequently scale your analysis by distributing tasks in parallel across multiple workers."
msgstr ""

#: 
msgid "The load_ard function can be easily adapted to lazily load data rather than loading it into memory by providing a dask_chunks parameter using either the explicit or query syntax. The minimum required to lazily load data is ``dask_chunks={}``, but chunking can also be performed spatially (e.g. ``dask_chunks={'x': 3000, 'y': 3000}``) or by time (e.g. ``dask_chunks={'time': 1}``) depending on the analysis being conducted. See the `Dask documentation <https://docs.dask.org/en/latest/array-chunks.html>`__ for more information about setting chunk sizes."
msgstr ""

#: 
msgid "To learn more about lazy-loading with Dask, see the `Dask notebook <../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "Working with time in xarray"
msgstr ""

#: 
msgid "**Keywords** :index:`analysis; time series`, :index:`data used; sentinel-2`, :index:`data methods; groupby`,:index:`data methods; nearest`, index:`data methods; interpolating`, :index:`data methods; resampling`, :index:`data methods; compositing`"
msgstr ""

#: 
msgid "`Time series data <https://en.wikipedia.org/wiki/Time_series>`__ is a series of data points usually captured at successively spaced points in time. In a remote-sensing context, time series data is a sequence of discrete satellite images taken at the same area at successive times. Time series analysis uses different methods to extract meaningful statistics, patterns and other characteristics of the data. Time series data and analysis has widespread application ranging from monitoring agricultural crops, natural vegetation change detection, mineral prospectivity mapping, and tidal height modelling."
msgstr ""

#: 
msgid "The ``xarray`` Python package provides many useful techniques for dealing with time series data that can be applied to Digital Earth Africa data. This notebook demonstrates how to use ``xarray`` techniques to:"
msgstr ""

#: 
msgid "Select different time periods of data (e.g. year, month, day) from an ``xarray.Dataset``"
msgstr ""

#: 
msgid "Use datetime accessors to extract additional information from a dataset's ``time`` dimension"
msgstr ""

#: 
msgid "Summarise time series data for different time periods using ``.groupby()`` and ``.resample()``"
msgstr ""

#: 
msgid "Interpolate time series data to estimate landscape conditions at a specific date that the satellite did not observe"
msgstr ""

#: 
msgid "For additional information about the techniques demonstrated below, refer to the ``xarray`` `time series data guide <http://xarray.pydata.org/en/stable/time-series.html>`__."
msgstr ""

#: 
msgid "Loading Landsat data"
msgstr ""

#: 
msgid "First, we load in around two years' of Sentinel-2 data, using the `load_ard <Using_load_ard.ipynb>`__ function and filtering for timesteps with at least 95% good-quality pixels."
msgstr ""

#: 
msgid "Explore xarray data using time"
msgstr ""

#: 
msgid "Here we will explore several ways to utilise the time dimension within an ``xarray.Dataset``. This section outlines selecting, summarising and interpolating data at specific times."
msgstr ""

#: 
msgid "Indexing by time"
msgstr ""

#: 
msgid "We can select data for an entire year by passing a string to ``.sel()``:"
msgstr ""

#: 
msgid "Or select a single month:"
msgstr ""

#: 
msgid "Or select a range of dates using ``slice()``. This selects all observations between the two dates, inclusive of both the start and stop values:"
msgstr ""

#: 
msgid "To select the nearest time to a desired time value, we set it to use a nearest neighbour method, ``'nearest'``. We have to specify the time using a ``datetime`` object, otherwise xarray indexing assumes we are selecting a range, like the ``ds.sel(time='2018-05')`` month example above."
msgstr ""

#: 
msgid "Here, we have picked a date at the start of December 2018. ``'nearest'`` will find the observation closest to that date."
msgstr ""

#: 
msgid "You can select the closest time **before** a given time using ``ffill`` (forward-fill)."
msgstr ""

#: 
msgid "To select the closest time **after** a given time, use ``bfill`` (back-fill)."
msgstr ""

#: 
msgid "The same methods also work on a list of times:"
msgstr ""

#: 
msgid "Using the datetime accessor"
msgstr ""

#: 
msgid "``xarray`` allows you to easily extract additional information from the ``time`` dimension in Digital Earth Africa data. For example, we can get a list of what season each observation belongs to:"
msgstr ""

#: 
msgid "Or the day of the year:"
msgstr ""

#: 
msgid "Grouping and resampling by time"
msgstr ""

#: 
msgid "``xarray`` also provides some shortcuts for aggregating data over time. In the example below, we first group our data by season, then take the median of each group. This produces a new dataset with only four observations (one per season)."
msgstr ""

#: 
msgid "We can also use the ``.resample()`` method to summarise our dataset into larger chunks of time. In the example below, we produce a median composite for every 6 months of data in our dataset:"
msgstr ""

#: 
msgid "Interpolating new timesteps"
msgstr ""

#: 
msgid "Sometimes, we want to return data for specific times/dates that weren't observed by a satellite. To estimate what the landscape appeared like on certain dates, we can use the ``.interp()`` method to interpolate between the nearest two observations."
msgstr ""

#: 
msgid "By default, the ``interp()`` method uses linear interpolation (``method='linear'``). Another useful option is ``method='nearest'``, which will return the nearest satellite observation to the specified date(s)."
msgstr ""

#: 
msgid "Frequently Used Code"
msgstr ""

#: 
msgid "A recipe book of simple code examples demonstrating how to perform common geospatial analysis tasks using DE Africa and open-source software."
msgstr ""

#: 
msgid "True colour animations with rainfall"
msgstr ""

#: 
msgid "**Products used:** `gm_s2_rolling <https://explorer.digitalearth.africa/gm_s2_rolling>`__, `gm_ls8_ls9_annual <https://explorer.digitalearth.africa/products/gm_ls8_ls9_annual>`__, `gm_ls8_annual <https://explorer.digitalearth.africa/gm_ls8_annual>`__, `gm_ls5_ls7_annual <https://explorer.digitalearth.africa/gm_ls5_ls7_annual>`__, `rainfall_chirps_monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__, `rainfall_chirps_daily <https://explorer.digitalearth.africa/products/rainfall_chirps_daily>`__"
msgstr ""

#: 
msgid "**Keywords**:  :index:`data used; sentinel-2`, :index:`data used; rolling GeoMAD`, :index:`datasets; CHIRPS`, :index:`climate`, :index:`rainfall`, :index:`data used; sentinel-2 geomedian`, :index:`data used; landsat 8 & 9 geomedian`, :index:`data used; landsat 8 geomedian`, :index:`data used; landsat 5 & 7 geomedian`"
msgstr ""

#: 
msgid "It can be informative to visualise true colour imagery of an area through time alongside a variable which contributes to the land surface state, such as rainfall. Inspecting an animated timeseries of a given area through time alongside cumulative rainfall can show how landscape features (vegetation, water bodies etc.) respond to rain events or lack thereof."
msgstr ""

#: 
msgid "This notebook demonstrates how rainfall and true colour imagery data can be assimilated to produce informative animations."
msgstr ""

#: 
msgid "We can use surface reflectance and CHIRPS rainfall data to produce these animations. Through the DE Africa Sandbox we can integrate these datasets over a time period of interest and align them both temporally and spatially to visualise them synchronously."
msgstr ""

#: 
msgid "The animations are produced in this notebook by following the steps below:"
msgstr ""

#: 
msgid "Select an area of interest."
msgstr ""

#: 
msgid "Load surface reflectance (true colour) imagery."
msgstr ""

#: 
msgid "Resample and interpolate imagery to generate a regular timeseries."
msgstr ""

#: 
msgid "Load rainfall data."
msgstr ""

#: 
msgid "Resample rainfall data to generate a regular timeseries."
msgstr ""

#: 
msgid "Define axes and update function for the animation."
msgstr ""

#: 
msgid "Run and interpret the animation."
msgstr ""

#: 
msgid "The default area is Mosiotunya - the smoke that thunders - (Victoria Falls) on the Zambezi River bordering Zimbabwe and Zambia."
msgstr ""

#: 
msgid "Initially, we will load the rolling geomedian true colour (red, green, blue) bands to visualise changes in the landscape within a recent year. We load a month prior and following the period of interest as it assists in generating a regular timeseries within the year of interest."
msgstr ""

#: 
msgid "Interpolation of timeseries"
msgstr ""

#: 
msgid "We want to generate an animation for a single calendar year, so we need a regular timeseries with time-steps that match rainfall data. This is generally not available from an analysis-ready dataset as some images will be omitted due to cloud cover, especially in wetter seasons."
msgstr ""

#: 
msgid "To regulate the timeseries, we downsample the temporal resolution using interpolation. This means that we are generating new data, or gap-filling through time, based on the existing data. **It is important that this is disclosed to viewers and users because the interpolated data is not observational and is therefore subject to uncertainty.**"
msgstr ""

#: 
msgid "There are several methods available for interpolation: \"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", and \"polynomial\". The method determines the flexibility or 'wiggliness' allowed in the temporal gap-filling. You can try a few different methods below. Further information can be found in the `scipy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html#scipy.interpolate.interp1d>`__."
msgstr ""

#: 
msgid "In this case, we generate a timeseries with an image for every two days of the year, giving a dataset with 182 time-steps (approx. = 365/2). This gives a nice smooth animation without placing excessive demand on computation and memory."
msgstr ""

#: 
msgid "Load rainfall data"
msgstr ""

#: 
msgid "We will load daily rainfall data from CHIRPS and then resample it to sum rainfall every two days, so the temporal resolution matches that of the true-colour imagery. We will also accumulate rainfall across the year using the ``cumsum()`` function. This enables us to visualise total rainfall, which can be more informative than viewing sporadic rainfall events. However, there are numerous other ways rainfall can be visualised through time which you may like to explore."
msgstr ""

#: 
msgid "A static chart of cumulative annual rainfall is generated below. For the default location of Mosiotunya (Victoria Falls), a distinct dry season through the middle part of the year is evident."
msgstr ""

#: 
msgid "Define and run animation"
msgstr ""

#: 
msgid "The below cell defines and runs the animation through the following steps: 1. Setting up two sublots. 2. Defining axis parameters. 3. Defining an update function. 4. Running and plotting the animation."
msgstr ""

#: 
msgid "You can optionally save the animation to a ``.gif`` by removing the # before the ``ani.save()`` command. Note that this closes the plot so you will have to add the # back in and run the cell again to visualise the animation in dynamic form."
msgstr ""

#: 
msgid "For the default region, we can see that the vegetation is green and waterfall flowing in early months. As the dry period begins, the vegetation senesces, though the flow of the waterfall takes longer to slow."
msgstr ""

#: 
msgid "Long term annual rainfall"
msgstr ""

#: 
msgid "We can also inspect longer term rainfall patterns alongside annual geomedian images to derive insights into inter-annual patterns in rainfall and landscapes."
msgstr ""

#: 
msgid "Load geomedians"
msgstr ""

#: 
msgid "The Landsat-derived geomedian products allow us to inspect long periods of time. In this case, we load annual images from Landsat 5, 7, 8 and 9 covering the epoch from 1990 - 2021."
msgstr ""

#: 
msgid "Load monthly rainfall"
msgstr ""

#: 
msgid "In this animation, our time-steps are annual, so we will generate an annual total rainfall timeseries. We do this by loading annual rainfall and summing values by year."
msgstr ""

#: 
msgid "We will also calculate the rainfall anomaly as this can be a useful way of visualising the relativity of annual rainfall. For this reason we calculate and store the mean and standard deviation in annual rainfall across the entire period."
msgstr ""

#: 
msgid "Calculate standardised anomalies"
msgstr ""

#: 
msgid "The function below calculates standardised anomalies using the stored mean and standard deviation values from above."
msgstr ""

#: 
msgid "Prepare rainfall data"
msgstr ""

#: 
msgid "Finally, we collapse the spatial dimensions of the rainfall data to generate a dataframe containing columns for time and annual rainfall volume (mm)."
msgstr ""

#: 
msgid "Burnt area mapping using Sentinel-2 data"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2`, :index:`band index; NBR`, :index:`fire mapping`"
msgstr ""

#: 
msgid "Normalized Burn Ratio"
msgstr ""

#: 
msgid "The Normalized Burn Ratio (NBR) is an index that uses the differences in the way healthy green vegetation and burnt vegetation reflect light to find burnt area. It is calculated using the following Sentinel-2 bands: Near Infrared/Band 8 and Shortwave Infrared/Band 12. The equation is defined below:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{NBR} = \\frac{(\\text{NIR} - \\text{SWIR})}{(\\text{NIR} + \\text{SWIR})} \\end{equation}`"
msgstr ""

#: 
msgid "NBR returns values between -1 and 1. **Healthy green vegetation will have a high NBR value while burnt vegetation will have a low value**. Areas of dry, brown vegetation or bare soil will also return lower NBR values than green vegetation."
msgstr ""

#: 
msgid "Delta Normalized Burn Ratio"
msgstr ""

#: 
msgid "Change in Normalized Burn Ratio - also called Delta Normalized Burn Ratio (dNBR) - is calculated by subtracting the post-fire NBR value from the baseline NBR value as defined in this equation:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{dNBR} = \\text{NBR}_{\\text{baseline}} - \\text{NBR}_{\\text{post fire}} \\end{equation}`"
msgstr ""

#: 
msgid "The dNBR value can be more useful than the NBR alone to determine what is burnt as it shows change from the baseline state. **A burnt area will have a positive dNBR value** while an unburnt area will have a negative dNBR value or a value close to zero."
msgstr ""

#: 
msgid "dNBR can also be used to describe burn severity (although this notebook does not look at burn severity). A higher severity fire will burn more vegetation, resulting in a higher dNBR. More information on NBR, dNBR and using it to measure burn severity can be found `on the UN-SPIDER knowledge portal <http://un-spider.org/advisory-support/recommended-practices/recommended-practice-burn-severity/in-detail/normalized-burn-ratio>`__."
msgstr ""

#: 
msgid "Defining Burnt From Unburnt Areas"
msgstr ""

#: 
msgid "`Rahman et al. 2018 <https://doi.org/10.1109/IGARSS.2018.8518449>`__ found a dNBR threshold value of +0.1 appropriate for differentiating burnt from unburnt areas when using Sentinel-2. However, some exploration with different threshold levels may be needed to get a good result in areas with different vegetation types."
msgstr ""

#: 
msgid "Using +0.1 as a threshold here may result in many false positives being picked up in the unburnt urban and forest areas where vegetation drying has occurred prior to the fire. A much more conservative threshold here of +0.3 produces a better result. Keep in mind the limitations of remote sensing and that in an ideal situation ground truth data collected in the location of interest would be used to assist in selecting a threshold."
msgstr ""

#: 
msgid "Some care should also be taken when interpreting results as a number of possible false positives can return a positive dNBR result:"
msgstr ""

#: 
msgid "A lot of smoke in the post burn image can interfere with the dNBR value"
msgstr ""

#: 
msgid "Areas that have been cleared of vegetation by some other means (logging, harvesting, and landslides) towards the end of the baseline period may incorrectly show up as burnt"
msgstr ""

#: 
msgid "Drying out of bright green vegetation such as grasses. If a fire event has been preceded by a rapid drying out of vegetation this can result in a low positive dNBR value in areas that have not burnt."
msgstr ""

#: 
msgid "This notebook calculates the change in Normalized Burn Ratio between a baseline composite image of the pre-fire condition of a selected area and a post-fire event image, in order to find burnt area extent."
msgstr ""

#: 
msgid "The user can change the location over which this notebook is run and specify a different date between which pre and post fire condition will be compared. The length of time over which the baseline composite image will be generated can be specified as 3, 6 or 12 months."
msgstr ""

#: 
msgid "The notebook contains the following steps:"
msgstr ""

#: 
msgid "Select a location for the analysis."
msgstr ""

#: 
msgid "Define fire event date and length of composite image."
msgstr ""

#: 
msgid "Load all baseline data."
msgstr ""

#: 
msgid "Generate Normalized Burn Ratio for baseline period."
msgstr ""

#: 
msgid "Load post-fire data."
msgstr ""

#: 
msgid "Generate Normalized Burn Ratio for post fire image."
msgstr ""

#: 
msgid "Calculate Delta Normalized Burn Ratio."
msgstr ""

#: 
msgid "Apply threshold to Delta Normalized Burn Ratio."
msgstr ""

#: 
msgid "Calculate the area burnt."
msgstr ""

#: 
msgid "Export results as a GeoTIFF."
msgstr ""

#: 
msgid "Connect to the datacube so we can access DEA data. The ``app`` parameter is a unique name for the analysis which is based on the notebook file name."
msgstr ""

#: 
msgid "``fire_date``: The event date of the fire (e.g. ``'2020-01-01'``)."
msgstr ""

#: 
msgid "``baseline_length``: To understand the effect of the fire, the analysis produces a baseline image, which is compiled from all available data over the ``baseline_length`` time period prior to the ``fire_date``. This can be set as ``'3 months'``, ``'6 months'`` or ``'12 months'``."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers a fire in Northern Ghana."
msgstr ""

#: 
msgid "**To run the notebook for a different area**, make sure Sentinel-2 data is available for the chosen area using the `DEAfrica Explorer <https://explorer.digitalearth.africa>`__. Use the drop-down menu to check both Sentinel-2A (``s2a_msil2a``) and Sentinel-2B (``s2b_msil2a``)."
msgstr ""

#: 
msgid "Define fire event date and length of composite image"
msgstr ""

#: 
msgid "Delta Normalized Burn Ratio produces the best result when using a post-fire image that was collected before much re-growth has occured. However, images collected while the fire is still active can be obscured by smoke and not show the full burn extent. As a result some adjustment of the fire event date entered may be needed to get the best result."
msgstr ""

#: 
msgid "The length of the baseline period can be automatically set to ``3, 6 or 12 months``"
msgstr ""

#: 
msgid "After setting the ``fire_date`` and ``baseline_length``, the code below automatically calculates start and end dates for the pre-fire and post-fire periods. The post-fire period is defined as 30 days after the ``fire_date``."
msgstr ""

#: 
msgid "Load all baseline data"
msgstr ""

#: 
msgid "The first step in the analysis is load Sentinel-2 data for the pre-fire period, as defined by the baseline length set above. This uses the pre-defined `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ utility function. This function will automatically mask any clouds in the dataset, and only return images where more than 60% of the pixels were classified as clear (set using ``min_gooddata=0.6``). When working with Sentinel-2, the function will also combine and sort images from both Sentinel-2A and Sentinel-2B."
msgstr ""

#: 
msgid "**Note**: This analysis performs calculations that use the on-ground area of each pixel. For this type of analysis, it is recommended that all data be reprojected to an equal area projection, such as `EPSG:6933 <https://epsg.io/6933>`__. This is done below by setting the ``output_crs`` parameter to ``\"EPSG:6933\"``."
msgstr ""

#: 
msgid "**Please be patient**. The data may take a few minutes to load and progress will be indicated by text output. The load is complete when the cell status goes from ``[*]`` to ``[number]``."
msgstr ""

#: 
msgid "**Once the load is complete**, examine the data by printing it in the next cell. The ``Dimensions`` argument revels the number of time steps in the data set, as well as the number of pixels in the ``x`` (longitude) and ``y`` (latitude) dimensions."
msgstr ""

#: 
msgid "Clip the datasets to the shape of the area of interest"
msgstr ""

#: 
msgid "A geopolygon represents the bounds and not the actual shape because it is designed to represent the extent of the geographic feature being mapped, rather than the exact shape. In other words, the geopolygon is used to define the outer boundary of the area of interest, rather than the internal features and characteristics."
msgstr ""

#: 
msgid "Clipping the data to the exact shape of the area of interest is important because it helps ensure that the data being used is relevant to the specific study area of interest. While a geopolygon provides information about the boundary of the geographic feature being represented, it does not necessarily reflect the exact shape or extent of the area of interest."
msgstr ""

#: 
msgid "Generate Normalized Burn Ratio for baseline period"
msgstr ""

#: 
msgid "We now calculate the NBR values for the baseline period using the `calculate_indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ function, imported from `deafrica_tools.bandindices <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.bandindices.html>`__. Here, we use ``satellite_mission='s2'`` since we're working with Sentinel-2 data. When using ``calculate_indices`` the index is added directly to the ``baseline_ard`` dataset."
msgstr ""

#: 
msgid "Visualise NBR"
msgstr ""

#: 
msgid "To see how NBR corresponds with a standard image, we can plot the baseline NBR data side-by-side with an RGB plot of the study area:"
msgstr ""

#: 
msgid "Load post-fire data"
msgstr ""

#: 
msgid "We now load images that occur up to 30 days after the fire. Since we previously defined the area of interest and measurements with the ``query`` parameter, we can reuse this to simplify the load command, noting that we only need to change the ``time`` variable to use the post-fire dates calculated earlier."
msgstr ""

#: 
msgid "Clip the datasets to the shape of the study area"
msgstr ""

#: 
msgid "Generate Normalized Burn Ratio for post fire image"
msgstr ""

#: 
msgid "The code in the next cell calculates the NBR for the first image in the post-fire dataset. If the image is very cloudy, try a different image by changing the index in ``post_col.isel(time=0)``. > **Note**: the maximum value for the index is determined by how many images you loaded. Check the number of time steps listed above in the ``load_ard`` output for the post-fire dataset. Python counts from 0, so the maximum index you can use will be one fewer than the number of time steps."
msgstr ""

#: 
msgid "While the first image will give you an immediate picture of the landscape close to post-fire event, you could also generate the median image from the 30-day post-fire period using the code below. If using this, comment the code for the single image and then copy and paste the code for the median image into the cell below."
msgstr ""

#: 
msgid "**Median**"
msgstr ""

#: 
msgid "MODIS and VIIRS hotspot data"
msgstr ""

#: 
msgid "The Fire information for Resource Management System (`FIRMS <https://firms.modaps.eosdis.nasa.gov/>`__) distributes hotspots observed from satellites for near real time (NRT) active fires and historical fires. The hotspot information is generated from both the Moderate Resolution Imaging Spectroradiometer (MODIS) and the Visible Infrared Imaging Radiometer Suite (VIIRS)."
msgstr ""

#: 
msgid "Here, the hotspots data from FIRMS is used to analyse the changes in NBR at the locations identified as active (or historical) fire. To obtain the data from FIRMS, a new request can be created on the `Archive Download <https://firms.modaps.eosdis.nasa.gov/download/>`__ webpage. It is possible to specify the region and dates of interest for the hotspots information. Once the processing of request has been completed, shapefiles containing data from MODIS C6 and VIIRS will be available for download. The hotspots files for MODIS and VIIRS are processed separately."
msgstr ""

#: 
msgid "As the region used for requesting hotspots can be different from the region used to process Sentinel-2 data, following two steps can be done either offline or within the notebook. The aforementioned two pre-processing steps are:"
msgstr ""

#: 
msgid "Clip hotspots data for (``lon_range, lat_range``)"
msgstr ""

#: 
msgid "Merge hotspot information from MODIS and VIIRS"
msgstr ""

#: 
msgid "After clipping and merging the hotspots information, open the hotspots shapefile using the next cell:"
msgstr ""

#: 
msgid "The next cell projects hotspots from the source projection (``\"EPSG:4326\"``) to the projection we're using for Sentinel-2 data (``EPSG:6933``). Here, we have used proj4 to transform hotspot locations from source to a desired projection."
msgstr ""

#: 
msgid "Examine hotspots"
msgstr ""

#: 
msgid "The next cell plots the FIRMS hotspots on top of the post-fire NBR image, and plots the baseline NBR image alongside. This allows for direct comparison of the NBR values before and after the fire, as well as how hotspots spatially correlate with areas that register as burnt after the fire. Hotspots are shown as black squares in the second image."
msgstr ""

#: 
msgid "Extract data at the FIRMS hotspots for baseline NBR and post-fire NBR"
msgstr ""

#: 
msgid "The next step is to extract the NBR values at the hotspot locations; doing this for the baseline and post-fire NBR images allows us to examine how the fire has influenced the NBR values."
msgstr ""

#: 
msgid "To extract data, we use the ``xarray.DataArray.sel`` method, which returns a two dimensional array. This in artefact of how we specified the coordinates of the hotspot locations, which are one dimensional numpy array. The values along the diagonal of the returned two dimensional array correspond to the hotspot locations which can be obtained using ``np.diagonal`` method."
msgstr ""

#: 
msgid "Using the extracted data, we can make a box-plot of NBR obtained from baseline and post-fire datasets for all the hotspot locations."
msgstr ""

#: 
msgid "Here, we can notice that the post-fire NBR decreases from the baseline NBR at the hotspots, consistent with those locations having been affected by the fire."
msgstr ""

#: 
msgid "We can also compare the change in NBR over the course of three months at the hotspots. To that end, we will use ``xarray`` method to extract the data the hotspot locations. To do this, we also extact cleaned versions of the dates of the baseline observations."
msgstr ""

#: 
msgid "After plotting the change in NBR over a period of three months, we can notice that there is sharp drop in NBR between October 2019 and November 2019, however, there is little to no change between November 2019 to January 2020."
msgstr ""

#: 
msgid "Finally, we plot the post-fire NBR data side-by-side with an RGB plot of the study area:"
msgstr ""

#: 
msgid "Calculate Delta Normalized Burn Ratio"
msgstr ""

#: 
msgid "We can now compute delta NBR by subtracting our post-fire NBR data from our baseline NBR data:"
msgstr ""

#: 
msgid "Apply threshold to Delta Normalized Burn Ratio"
msgstr ""

#: 
msgid "We now apply the dNBR threshold value to try and reduce false positives, only keeping areas with dNBR values greater than the chosen threshold value of 0.3. The chosen threshold value may need to be adjusted depending on the use case."
msgstr ""

#: 
msgid "Re-visualize pre and post-fire true colour images to help adjust the NBR threshold:"
msgstr ""

#: 
msgid "Calculate area burnt"
msgstr ""

#: 
msgid "The next cell uses the resolution of Sentinel-2 pixels to estimate the amount of area burnt, defined as those areas with dNBR values greater than the set threshold. A number of other statistics are calculated, accounting for areas that have no data."
msgstr ""

#: 
msgid "Export results to GeoTIFF"
msgstr ""

#: 
msgid "The baseline reference image and the post fire image will both be saved as a multiband GeoTIFF with the following bands in the following order: Blue, Green, Red, NIR, SWIR."
msgstr ""

#: 
msgid "The thresholded burnt area image will be saved as a single band image, where a value of 1 = burnt and a value of 0 = not burnt."
msgstr ""

#: 
msgid "Near real-time burnt area mapping using the Digital Earth Africa datacube"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/products/ls9_sr>`__"
msgstr ""

#: 
msgid "This notebook shows an example of how to use Digital Earth Africa’s near real-time freely available imagery for users tracking recent fire events. This notebook outlines a workflow to select the most suitable ‘near real-time’ and baseline imagery for comparison from the Landsat 8 & 9 and Sentinel-2A & Sentinel-2B sensors. Thresholding is applied to detect unverified burnt areas, before creating an exportable polygon vector file."
msgstr ""

#: 
msgid "**What does ‘Near Real-time’ Burnt Area Mapping mean?**"
msgstr ""

#: 
msgid "“Near real-time (NRT)” or “Rapid Mapping” within this context refers to satellite data or imagery from the Sentinel-2 and Landsat satellites that will be processed as soon as possible after the data is received by Digital Earth Africa. It can take a few days after an image is captured by a sensor to become available for analysis in the Digital Earth Africa Sandbox Environment. Although Digital Earth Africa makes every effort to make imagery available ASAP, unforeseen challenges may cause delays in image availability."
msgstr ""

#: 
msgid "When to use this notebook"
msgstr ""

#: 
msgid "This notebook is designed to map the extent of fires within Africa over the previous fortnight dependent on the availability of suitable imagery. The output of this notebook does not measure the severity of fires."
msgstr ""

#: 
msgid "For users interested in mapping historical fires, please use the `Burnt area mapping using Sentinel-2 data notebook <Burnt_area_mapping.ipynb>`__ instead."
msgstr ""

#: 
msgid "Normalised Burn Ratio (NBR) and delta Normalised Burn Ratio (dNBR)"
msgstr ""

#: 
msgid "The Normalised Burn Ratio (NBR) is a Fire Severity Index (FSI) that uses the differences in the way healthy green vegetation and burnt vegetation reflect light to detect burnt pixels in multi-spectral imagery. The NBR index requires signals from the NIR (Near Infrared) and SWIR (Short-wave Infrared) parts of the electromagnetic spectrum and is defined below."
msgstr ""

#: 
msgid "Comparing the most-recent NBR values to a baseline or past NBR (i.e. dNBR) can assist in removing noise and isolating environmental change in an EO workflow. The change in NBR is called the delta NBR (dNBR) and is defined as:"
msgstr ""

#: 
msgid "More information on NBR and dNBR can be found in the `Burnt area mapping using Sentinel-2 data notebook <Burnt_area_mapping.ipynb>`__ instead."
msgstr ""

#: 
msgid "Relativized Burn Ratio (RBR)"
msgstr ""

#: 
msgid "The Relativized Burn Ratio (RBR) is a variation of the Relativized delta Normalised Burn Ratio (RdNBR) developed by `Parks et al., 2014 <https://www.mdpi.com/2072-4292/6/3/1827>`__ that solves some of the numerical problems with the original RdNBR algorithm. Like the RdNBR, the RBR aims to improve burnt area mapping over burnt areas that had low levels of pre-fire vegetation by considering the baseline NBR measurement to prevent these areas being thresholded out."
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{RBR} = \\frac{dNBR}{(\\text{NBR}_{\\text{baseline}} + 1.001)}\\end{equation}`"
msgstr ""

#: 
msgid "Later on in this analysis, you may wish to use the RBR index instead of the dNBR index if your Area of Interest (AOI) has considerable amounts of burnt area that originally had low vegetation levels. For example, the RBR may work better mapping fires over AOI’s with both barren grasslands and dense canopies then the dNBR method."
msgstr ""

#: 
msgid "This notebook contains the following steps: 1. Getting started and defining an area of interest (AOI) 2. Define suitable date ranges for the baseline and near real-time images 3. Load, visualise, and select a near real-time image 4. Load and select baseline imagery 5. Calculate NBR and dNBR dataarray’s and perform optional post-processing 6. Convert raster data to vector and export products"
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest to conduct the analysis over. #### Select location To define the area of interest, there are two methods available:"
msgstr ""

#: 
msgid "By specifying the latitude, longitude, and buffer, or separate latitude and longitude buffers, this method allows you to define an area of interest around a central point. You can input the central latitude, central longitude, and a buffer value in degrees to create a square area around the center point. For example, ``lat = 10.338``, ``lon = -1.055``, and ``buffer = 0.1`` will select an area with a radius of 0.1 square degrees around the point with coordinates ``(10.338, -1.055)``."
msgstr ""

#: 
msgid "Alternatively, you can provide separate buffer values for latitude and longitude for a rectangular area. For example, ``lat = 10.338``, ``lon = -1.055``, and ``lat_buffer = 0.1`` and\\ ``lon_buffer = 0.08`` will select a rectangular area extending 0.1 degrees north and south, and 0.08 degrees east and west from the point ``(10.338, -1.055)``."
msgstr ""

#: 
msgid "For reasonable loading times, set the buffer as ``0.1`` or lower."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers a fire event in an area within the southern Cape forestry area near George, South Africa. During late October and early November 2018, relatively dry weather conditions prevailed, creating favorable conditions for forest fires that destroyed extensive areas of plantation forests. Two wildfires occurred in succession: the first broke out due to human-induced ignition on October 24th, and the second was ignited by lightning on October 29th."
msgstr ""

#: 
msgid "**To run the notebook for a different area**, make sure Sentinel-2 or Landsat 8 or 9 data is available for the chosen area using the `DEAfrica Explorer <https://explorer.digitalearth.africa>`__."
msgstr ""

#: 
msgid "By default, images from the previous 14 days from the current date are extracted from the datacube and visualised for manual selection. If a different NRT date range is desired, enter this for the ``nrt_time_delta`` variable in ``DD`` format."
msgstr ""

#: 
msgid "For the selection of a baseline image, the default is to extract and visualise imagery that was acquired within the period extending between 14 days to two months prior to the current date. If a different date range is preferred, adjust the ``baseline_time_delta`` below in ``DD`` format."
msgstr ""

#: 
msgid "The date ranges calculated below are a good starting point, but your chosen AOI may require larger or smaller date ranges."
msgstr ""

#: 
msgid "**For the purpose of demonstrating the capability of this notebook during a fire event, a static date has been entered for the ``nrt_date_end`` variable. To run this notebook for a current fire, please instead run the second line of code noted below to set ``nrt_date_end`` to the current date.**"
msgstr ""

#: 
msgid "The availability of cloud-free and recent imagery is the largest limiting factor in undertaking Burn Area Mapping in near real-time while a fire event occurs. Therefore, we will look at recent images from both the Sentinel-2 and Landsat imagery collections to maximise the chance of finding a suitable image."
msgstr ""

#: 
msgid "To reduce the impact of cross-sensor influence on our analysis, we will only load baseline imagery from the sensor from which our near real-time image is selected."
msgstr ""

#: 
msgid "Define Load Parameters"
msgstr ""

#: 
msgid "NB: The ``min_gooddata_nrt`` and ``min_gooddata_base`` variables are used to filter out poor-quality images for the chosen AOI in the Near Real-time and Baseline Imagery extracts respectively. The values assigned to these variables set the threshold for the number of ‘good’ (i.e. cloud free) pixels required for the image to be extracted."
msgstr ""

#: 
msgid "A ``min_gooddata`` value of 0.9 will ensure that only images with over 90% cloud free pixels over the AOI are extracted. To increase the number of images extracted, these values can be reduced to allow images with more cloudy pixels to be extracted."
msgstr ""

#: 
msgid "Load images from the Sentinel-2 collection"
msgstr ""

#: 
msgid "Load images from the Landsat collection"
msgstr ""

#: 
msgid "Near real-time image visualisation"
msgstr ""

#: 
msgid "Images from both the Sentinel-2 and Landsat collections that met the spatial, temporal, and quality requirements we previously defined will be visualised below. Make note of the date, index number and sensor of each image located in the subplot title."
msgstr ""

#: 
msgid "In the next step, we will need to set the ``nrt_img_index`` and ``nrt_sensor`` variables to the chosen images index and sensor respectively."
msgstr ""

#: 
msgid "**It is not uncommon for no suitable landsat images to have been acquired that meet the near real-time requirements in the previous 14 days. If this occurs, the notebook will continue to run without issue.**"
msgstr ""

#: 
msgid "Define ``plot_variable_images`` function"
msgstr ""

#: 
msgid "The ``plot_variable_images`` function dynamically plots images from an xarray dataset containing RGB bands, with titles displaying the date and index, and optionally the sensor type if specified. It first checks that the input is a valid xarray dataset and calculates the number of images. If no images are present, it raises an error. The function determines the necessary number of subplot rows, creates the subplots, and iterates through each image to plot it as an RGB image, ensuring robust color scaling."
msgstr ""

#: 
msgid "Looking at the near real-time (NRT) images available from both Sentinel-2 and Landsat, the Landsat image appears to be the most suitable option for further analysis. Although there is a single Sentinel-2 image (Index: 3) with a higher spatial resolution, it has more gaps than the available Landsat image."
msgstr ""

#: 
msgid "For the baseline image selection process which occurs a few cells down in the code, imagery from the sensor of the selected NRT image will be loaded. If a Sentinel-2 NRT image is selected, then Sentinel-2 imagery will be loaded for selection of the baseline image. Similarly, if a Landsat NRT image is chosen, then Landsat imagery will be loaded for selection. This ensures continuity and consistency in the dataset, facilitating accurate comparison and analysis between the NRT and baseline periods."
msgstr ""

#: 
msgid "Near real-time image selection"
msgstr ""

#: 
msgid "From the above images, note the index value of the most appropriate scene and set the ``nrt_img_index`` variable below to that value. For example, if the first image displayed is the most desirable, set ``nrt_img_index = 0``."
msgstr ""

#: 
msgid "Additionally, set the rt_sensor variable to the sensor that the chosen near real-time image originated from, s2 for Sentinel-2 or ls for Landsat. Only imagery from the selected collection will be displayed for the baseline image visualisaion below to reduce cross-sensor influence on the analysis."
msgstr ""

#: 
msgid "Load and select baseline imagery"
msgstr ""

#: 
msgid "Visualise the extracted baseline imagery"
msgstr ""

#: 
msgid "Baseline image selection"
msgstr ""

#: 
msgid "A baseline image from the above selection must be chosen. It is important to remember that the dNBR index measured environmental changes associated with fire induced landscape change. Therefore, a scene similar to the near real-time image that is free from fire affects will provide the best comparison point to detect burn scars. For example, if the landscape in the near real-time image is dry, it is better to chose a baseline image where the landscape has a similar level of dryness compared to a greener image."
msgstr ""

#: 
msgid "Note the index number of the baseline image chosen above, then set it to the baseline_img_index variable."
msgstr ""

#: 
msgid "Calculate NBR and dNBR dataarray’s and perform optional post-processing"
msgstr ""

#: 
msgid "dNBR vs RBR for burnt area mapping"
msgstr ""

#: 
msgid "As previously discussed, two differenced fire severity indices are available in this notebook. Try using the dNBR index in the first instance. However, if the fire in your AOI occurs over less densely vegetated landscapes such as grasslands, you may wish to trial the RBR index. In this example, we have used the RBR index as the fire has occurred over substantial amounts of grass dominated areas."
msgstr ""

#: 
msgid "Depending on your choice of Fire Severity Index, set the ``bam_method`` variable to either ‘dNBR’ or ‘RBR’."
msgstr ""

#: 
msgid "Setting the threshold value to identify burnt areas"
msgstr ""

#: 
msgid "A value needs to be chosen to delineate burnt and unburnt areas. This value can vary depending on the vegetation structure and environmental conditions of the area being mapped. A value of 0.3 could be used as a starting point. However, it is helpful to interpret the above histogram and dNBR plot to help determine the most suitable value for your AOI. The selection of a threshold value involves compromise between a value that is so low that false returns are included, and high enough that low-severity and less vegetated burnt areas are excluded."
msgstr ""

#: 
msgid "Set the chosen threshold value to the ``threshold`` variable below."
msgstr ""

#: 
msgid "Optional: morphological post-processing"
msgstr ""

#: 
msgid "The result of our analysis may have resulted in an unacceptable amount of isolated pixels and other noisy returns. We can apply morphological operations to the binary xr dataarray ro remove this from the products and simplify the geometry of the output polygons. This step is optional, but can be useful when the analysis produces noisy and ‘speckled’ outputs."
msgstr ""

#: 
msgid "Closing, Erosion, and Dilation operations are called below. Closing is a compound operation of a dilation followed by an erosion to remove small holes. Erosion shrinks the image pixels, helping to remove noisy and isolated returns. Dilatation extends image pixels to remove small holes and otherwise simplify the geometry of the derived polygons."
msgstr ""

#: 
msgid "These operations are carried out using a disk structuring element. A default size of 3 pixels is used below, but this value can be altered to vary the degree of post-processing applied."
msgstr ""

#: 
msgid "Convert raster data to vector and export products"
msgstr ""

#: 
msgid "Exporting rasters"
msgstr ""

#: 
msgid "Three rasters are exported below: 1. An RGB geotiff of the Near Real-time imagery 2. An RGB geotiff of the baseline imagery 3. An unmasked single-band geotiff of the chosen delta NBR index - Those wanting to clip these images to the delineated burnt area can use the below shapefile."
msgstr ""

#: 
msgid "Converting the raster bam data to vector format before exporting to shapefile"
msgstr ""

#: 
msgid "We will convert the raster dataarray into vectory format using the xr_vectorize tool and export it to a shapefile. The shapefile will be visualised below."
msgstr ""

#: 
msgid "Monitoring change through time using satellite imagery filmstrip plots"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/ls7_sr>`__, `ls5_sr <https://explorer.digitalearth.africa/ls5_sr>`__"
msgstr ""

#: 
msgid "**Keywords:** :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`visualisation; filmstrip`, :index:`analysis; change monitoring`, :index:`interactive`"
msgstr ""

#: 
msgid "Understanding how natural and human landscapes have changed through time can provide vital information about the health of local ecosystems and development of the built environment. For example, data on changes in the distribution of vegetation in the landscape can be used to monitor the impact of deforestation, or track the recovery of forests after habitat restoration or extreme natural events (e.g. bushfires). Tracking changes within urban areas can be used to monitor the growth of infrastructure such as ports and transport networks, while data on coastal changes can be vital for predicting and managing the impacts of coastal erosion or the loss of coastal wetlands (e.g. mangroves)."
msgstr ""

#: 
msgid "Although these examples of change can be tracked using direct on-the-ground monitoring (e.g. vegetation surveys), it can be extremely challenging and expensive to obtain a comprehensive understanding of these processes at a broader landscape scale. For many applications, it can also be extremely useful to obtain a record of the history of a location undergoing change. This typically requires historical monitoring data which is unlikely to be available for all but the most intensively monitored locations."
msgstr ""

#: 
msgid "Digital Earth Africa use case"
msgstr ""

#: 
msgid "More than 30 years of satellite imagery from the `NASA/USGS Landsat program <https://www.usgs.gov/land-resources/nli/landsat>`__ is freely available for Africa, making this a powerful resource for monitoring natural and human-driven change across the African continent. Because these satellites image every location over Africa regularly (approximately once every 16 days), they provide an unparalleled archive of how many of Africa's landscapes have changed through time."
msgstr ""

#: 
msgid "Analysing change from individual satellite images can be made difficult by the presence of clouds, cloud shadow, sunglint over water, and dynamic processes like changing tides along the coastline. By combining individual noisy images into cleaner, cloud-free \"summary\" images that cover a longer time period (e.g. one or multiple years), we can obtain a clear, consistent view of the African environment that can be compared to reveal changes in the landscape over time."
msgstr ""

#: 
msgid "In this example, Digital Earth Africa Landsat data is extracted for a given time range and location, and combined using the geometric median (\"geomedian\") statistic to reveal the median or 'typical' appearance of the landscape for a series of time periods (for more information about geomedians, see the `Geomedian composites notebook <../Frequently_used_code/Generating_geomedian_composites.ipynb>`__)."
msgstr ""

#: 
msgid "For coastal applications, the analysis can be customised to select only satellite images obtained during a specific tidal range (e.g. low, average or high tide)."
msgstr ""

#: 
msgid "The results for each time period are combined into a 'filmstrip' plot which visualises how the landscape has changed in appearance across time, with a 'change heatmap' panel highlighting potential areas of greatest change:"
msgstr ""

#: 
msgid "|Example of filmstrip plot|"
msgstr ""

#: 
msgid "Example of filmstrip plot"
msgstr ""

#: 
msgid "Import Python packages used for the analysis."
msgstr ""

#: 
msgid "The following cell sets important required parameters for the analysis:"
msgstr ""

#: 
msgid "``output_name``: A name that will be used to name the output filmstrip plot file"
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``time_range = ('1984-01-01', '2019-12-31)``)"
msgstr ""

#: 
msgid "``time_step``: This parameter allows us to choose the length of the time periods we want to compare (e.g. ``time_step = {'years': 5}`` will generate one filmstrip plot for every five years of data in the dataset; ``time_step = {'months': 18}`` will generate one plot for each 18 month period etc. Time periods are counted from the first value given in ``time_range``."
msgstr ""

#: 
msgid "Optional parameters:"
msgstr ""

#: 
msgid "``tide_range``: This parameter allows you to generate filmstrip plots based on specific ocean tide conditions. This can be valuable for analysing change consistently along the coast. For example, ``tide_range = (0.0, 0.2)`` will select only satellite images acquired at the lowest 20% of tides; ``tide_range = (0.8, 1.0)`` will select images from the highest 20% of tides. The default is ``tide_range = (0.0, 1.0)`` which will select all images regardless of tide."
msgstr ""

#: 
msgid "``resolution``: The spatial resolution to load data. The default is ``resolution = (-30, 30)``, which will load data at 30 m pixel resolution. Increasing this (e.g. to ``resolution = (-100, 100)``) can be useful for loading large spatial extents."
msgstr ""

#: 
msgid "``max_cloud``: This parameter allows you to exclude satellite images with excessive cloud. The default is ``0.5``, which will keep all images with less than 50% cloud."
msgstr ""

#: 
msgid "``ls7_slc_off``: Whether to include data from after the Landsat 7 SLC failure (i.e. SLC-off). Defaults to ``False``, which removes all Landsat 7 observations after May 31 2003. Setting this to ``True`` will result in extra data, but can also introduce horizontal striping in the output filmstrip plots."
msgstr ""

#: 
msgid "``size_limit``: An optional integer (in square kilometres) specifying the size limit for the data query. Queries larger than this size will receive a warning that he data query is too large (and may therefore result in memory errors)."
msgstr ""

#: 
msgid "Select location and generate filmstrips"
msgstr ""

#: 
msgid "Run the following cell to start the analysis. This will plot an interactive map that is used to select the area to load satellite data for."
msgstr ""

#: 
msgid "Select the ``Draw a rectangle`` or ``Draw a polygon`` tool on the left of the map, and draw a shape around the area you are interested in."
msgstr ""

#: 
msgid "If running this notebook for the first time, **draw a rectangle around West African Cement Company plant** to see an example of change driven by urban development. You should draw a rectangle similar to the image shown below:"
msgstr ""

#: 
msgid "|Area of interest|"
msgstr ""

#: 
msgid "Area of interest"
msgstr ""

#: 
msgid "If running this notebook for a new area, zoom and pan around the map until you find an area of interest, then draw a rectangle or polygon as described above. You will need to check the availability of Landsat data in your chosen area using the `Digital Earth Africa Explorer <https://explorer.digitalearth.africa/products/ls8_sr>`__."
msgstr ""

#: 
msgid "When you are ready, press the green ``done`` button on the top right of the map. This will start loading the data, and then generate a filmstrips plot."
msgstr ""

#: 
msgid "Depending on the size of the area you select, this step can take **several minutes to complete**. To keep load times reasonable, select an area **smaller than 10,000 hectares** in size. When using the rectangle drawing tool, the area in hectares will be displayed to help guide you. The 10,000 hectare limit can be overuled by supplying the ``size_limit`` parameter in the ``Analysis Parameters`` section above."
msgstr ""

#: 
msgid "Once the analysis reaches the ``Generating geomedian composites`` step, you can check the status of the data load by clicking the **Dashboard** link under **Client** below."
msgstr ""

#: 
msgid "Using filmstrip plots to identify change"
msgstr ""

#: 
msgid "The filmstrip plot above contains several colour imagery panels that summarise the median or 'typical' appearance of the landscape for the time periods defined using ``time_range`` and ``time_step``. If you ran the analysis over the West African Cemement Company plant, inspect each of the imagery plots. You should be able to see the expansion of the plant over time."
msgstr ""

#: 
msgid "Change heatmap"
msgstr ""

#: 
msgid "To make it easier to identify areas that have changed between each filmstrip panel, the final panel provides a \"change heatmap\". This highlights pixels whose values vary greatly between the panels in the filmstrip plot. Bright colours indicate pixels that have changed; dark colours indicate pixels that have remained relatively similar across time."
msgstr ""

#: 
msgid "Compare the \"change heatmap\" panel against the colour imagery panels. You should be able to see the expansion clearly in bright pixels and the central plant buildings in the darkest pixels."
msgstr ""

#: 
msgid "**Technical info:** The \"change heatmap\" is calculated by first taking a log transform of the imagery data to emphasize dark pixels, then calculating standard deviation across all of the filmstrip panels to reveal pixels that changed over time."
msgstr ""

#: 
msgid "Downloading filmstrip plot"
msgstr ""

#: 
msgid "The high resolution version of the filmstrip plot generated above will be saved to the same location you are running this notebook from (e.g. typically ``Real_world_examples``). In JupyterLab, use the file browser to locate the image file with a name in the following format:"
msgstr ""

#: 
msgid "``filmstrip_{output_name}_{date_string}_{time_step}.png``"
msgstr ""

#: 
msgid "You can download the image to your PC by right clicking on the image file and selecting ``Download``."
msgstr ""

#: 
msgid "Export GeoTIFF data"
msgstr ""

#: 
msgid "It can be useful to export each of the filmstrip panels generated above as GeoTIFF raster files so that they can be loaded into a Geographic Information System (GIS) software for further analysis. Because the filmstrip panels were generated using the \"geomedian\" statistic that preserves relationships between spectral bands, the resulting data can be validly analysed in the same way as we would analyse an individual satellite image."
msgstr ""

#: 
msgid "To export the GeoTIFFs, run the following cell then right click on the files in the JupyterLab file browser and select ``Download``."
msgstr ""

#: 
msgid "When you are done, return to the `Analysis parameters <#Analysis-parameters>`__ section, modify some values and rerun the analysis. For example, you could try:"
msgstr ""

#: 
msgid "Modify ``time_range`` to look at a specific time period of interest."
msgstr ""

#: 
msgid "Setting a shorter ``time_step`` (e.g. ``time_step = {'years': 5}``) for a more detailed look at how the landscape has changed over shorter time periods."
msgstr ""

#: 
msgid "Move to a different area of interest."
msgstr ""

#: 
msgid "Monitoring chlorophyll-\\ *a* in African waterbodies"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel 2`, :index:`band index; MNDWI`, :index:`band index; NDCI`, :index:`analysis; change monitoring`, :index:`water quality`"
msgstr ""

#: 
msgid "Inland waterbodies are essential for supporting human life, both through the supply of drinking water and the support of agriculture and aquaculture. Such waterbodies can be contaminated by `urban pollutants <https://www.ghanaweb.com/GhanaHomePage/NewsArchive/Lake-Bosumtwi-Dying-From-Pollution-159303>`__ from the communities living nearby, causing health issues for people and animals. While the health of waterbodies can be monitored from the ground through sampling, satellite imagery can complement this. One particular event that is related to poor water quality is the presence of algal blooms. Specifically, waters with high levels of nutrients from fertilizers, sewage or urban runoff can host large algal blooms. However, there needs to be a well-understood and tested way to link satellite observations to the presence of algal blooms."
msgstr ""

#: 
msgid "Sentinel-2 use case"
msgstr ""

#: 
msgid "Algal blooms are associated with the presence of chlorophyll-\\ *a* in waterbodies. `Mishra and Mishra (2012) <https://doi.org/10.1016/j.rse.2011.10.016>`__ developed the normalised difference chlorophyll index (NDCI), which serves as a qualitative indicator for the concentration of clorophyll-\\ *a* on the surface of a waterbody. The index requires information from a specific part of the infrared specturm, known as the 'red edge'. This is captured as part of Sentinel-2's 13 spectral bands, making it possible to measure the NDCI with Sentinel-2."
msgstr ""

#: 
msgid "In this example, we measure the NDCI for Lake Bosomtwe, which is getting affected by the pollution as mentioned in the Background section. This is combined with information about the size of the waterbody, which is used to build a helpful visualisation of how the water-level and presence of chlorophyll-\\ *a* changes over time. The worked example takes users through the code required to:"
msgstr ""

#: 
msgid "Load cloud-free Sentinel-2 images for an area of interest."
msgstr ""

#: 
msgid "Compute indices to measure the presence of water and clorophyll-\\ *a*."
msgstr ""

#: 
msgid "Generate informative visualisations to identify the presence of clorophyll-\\ *a*."
msgstr ""

#: 
msgid "Some caveats"
msgstr ""

#: 
msgid "The NDCI is currently treated as an experimental index for Sentinel-2 sensors, as futher work is needed to calibrate and validate how well the index relates to the presence of clorophyll-\\ *a*."
msgstr ""

#: 
msgid "It is also important to remember that algal blooms will usually result in increased values of the NDCI, but not all NDCI increases will be from algal blooms. For example, there may be seasonal fluctuations in the amount of clorophyll-\\ *a* in a waterbody."
msgstr ""

#: 
msgid "Further validation work is required to understand how shallow water and atmospheric effects affect the NDCI, and its use in identifying high concentrations of clorophyll-\\ *a*."
msgstr ""

#: 
msgid "**To run this analysis**, run all the cells in the notebook, starting with the \"Load packages\" cell."
msgstr ""

#: 
msgid "**After finishing the analysis**, return to the \"Analysis parameters\" cell, modify some values (e.g. choose a different location or time period to analyse) and re-run the analysis. There are additional instructions on modifying the notebook at the end."
msgstr ""

#: 
msgid "Load key Python packages and supporting functions for the analysis."
msgstr ""

#: 
msgid "Activate the datacube database, which provides functionality for loading and displaying stored Earth observation data."
msgstr ""

#: 
msgid "Load and view Sentinel-2 data"
msgstr ""

#: 
msgid "The first step in the analysis is to load Sentinel-2 data for the specified area of interest and time range. This uses the pre-defined ``load_ard`` utility function. This function will automatically mask any clouds in the dataset, and only return images where more than 80% of the pixels were classified as clear."
msgstr ""

#: 
msgid "Plot example timestep in true colour"
msgstr ""

#: 
msgid "To visualise the data, use the pre-loaded ``rgb`` utility function to plot a true colour image for a given time-step."
msgstr ""

#: 
msgid "The settings below will display images for a two time steps, one in November 2017, one in January 2019. White areas indicate where clouds or other invalid pixels in the image have been masked. What are the key differences between the two images?"
msgstr ""

#: 
msgid "Feel free to experiement with the values for the ``initial_timestep`` and ``final_timestep`` variables; re-run the cell to plot the images for the new timesteps. The values for the timesteps can be ``0`` to ``n_time - 1`` where ``n_time`` is the number of timesteps (see the ``time`` listing under the ``Dimensions`` category in the dataset print-out above)."
msgstr ""

#: 
msgid "**Note:** if the location and time are changed, you may need to change the ``intial_timestep`` and ``final_timestep`` parameters to view images at similar times of year."
msgstr ""

#: 
msgid "Compute band indices"
msgstr ""

#: 
msgid "This study measures the presence of water through the modified normalised difference water index (MNDWI) and clorophyll-\\ *a* through the normalised difference clorophyll index (NDCI)."
msgstr ""

#: 
msgid "MNDWI is calculated from the green and shortwave infrared (SWIR) bands to identify water. The formula is"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{MNDWI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}.\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "NDCI is calculated from the red edge 1 and red bands to identify water. The formula is"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDCI} = \\frac{\\text{Red edge 1} - \\text{Red}}{\\text{Red edge 1} + \\text{Red}}.\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "When interpreting this index, high values indicate the presence of clorophyll-\\ *a*."
msgstr ""

#: 
msgid "Both indices are available through the `calculate_indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ function, imported from `deafrica_tools.bandindices <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.bandindices.html>`__. Here, we use ``satellite_mission=\"s2\"`` since we're working with Sentinel-2 data."
msgstr ""

#: 
msgid "The MNDWI and NDCI values should now appear as data variables, along with the loaded measurements, in the ``ds`` data set. Check this by printing the data set below:"
msgstr ""

#: 
msgid "Build summary plot"
msgstr ""

#: 
msgid "To get an understanding of how the waterbody has changed over time, the following section builds a plot that uses the MNDWI to measure the rough area of the waterbody, along with the NDCI to track how the concentration of clorophyll-\\ *a* is changing over time. This could be used to quickly assess the status of a given waterbody."
msgstr ""

#: 
msgid "Set up constants"
msgstr ""

#: 
msgid "The number of pixels classified as water (MNDWI > 0) can be used as a proxy for the area of the waterbody if the pixel area is known. Run the following cell to generate the necessary constants for performing this conversion."
msgstr ""

#: 
msgid "Compute the total water area"
msgstr ""

#: 
msgid "The next cell starts by filtering the data set to only keep the pixels that are classified as water. It then calculates the water area by counting all of the MNDWI pixels in the filtered data set, calculating a rolling median (this helps smooth the results to account for variation from cloud-masking), then multiplies this median count by the area-per-pixel."
msgstr ""

#: 
msgid "Compute the average NDCI"
msgstr ""

#: 
msgid "The next cell computes the average NDCI for each time step using the filtered data set. This means that we're only tracking the NDCI in waterbody areas, and not on any land. To make the summary plot, we calculate NDCI across all pixels; this allows us to track overall changes in NDCI, but doesn't tell us where the increase occured within the waterbody (this is covered in the next section)."
msgstr ""

#: 
msgid "Combine the data to build the summary plot"
msgstr ""

#: 
msgid "The cell below combines the total water area and average NDCI time series we generated above into a single summary plot. Notice that Python can be used to build highly-customised plots. If you're interested, take some time to understand how the plot is built. Otherwise, run the cell to build the plot."
msgstr ""

#: 
msgid "**Note**: The colour map used below is normalised so that the maximum ``NDCI`` value is 0.5, which is thought to correspond to a severe algal bloom event `(Mishra and Mishra 2012) <https://doi.org/10.1016/j.rse.2011.10.016>`__. The minimum ``NDCI`` value of -0.1 corresponds to low conentrations of chlorophyll-\\ *a*. This makes it more straightforward to identify severe algal bloom events in the plot."
msgstr ""

#: 
msgid "What does the plot reveal about the waterbody? Are there periods that show high NDCI values?"
msgstr ""

#: 
msgid "Compare spatial NDCI at two different dates"
msgstr ""

#: 
msgid "While the summary plot is useful at a glance it can be interesting to see the full spatial picture at times where the NDCI is low vs. high. The code below defines two useful functions: ``closest_date`` will find the date in a list of dates closest to any given date; ``date_index`` will return the position of a particular date in a list of dates. These functions are useful for selecting images to compare."
msgstr ""

#: 
msgid "Run the cell below to set two dates to compare. Feel free to change the dates to look at the NDCI of the waterbody at different times."
msgstr ""

#: 
msgid "Run the cell below to see the true-colour images for the same dates"
msgstr ""

#: 
msgid "Drawing conclusions"
msgstr ""

#: 
msgid "Here are some questions to think about:"
msgstr ""

#: 
msgid "How well do increased NDCI values match with what you see in the true-colour images?"
msgstr ""

#: 
msgid "When would it be more helpful to use the summary plot vs. the time comparison plot and vice-versa?"
msgstr ""

#: 
msgid "What does the water look like in the true-colour image when the NDCI is low-to-medium vs. high?"
msgstr ""

#: 
msgid "What other information might you seek if you detected an abnormally high NDCI value?"
msgstr ""

#: 
msgid "When you are done, return to the \"Analysis parameters\" section, modify some values (e.g. ``lat``, ``lon`` or ``time``) and rerun the analysis. You can use the interactive map in the \"View the selected location\" section to find new central latitude and longitude values by panning and zooming, and then clicking on the area you wish to extract location values for. You can also use Google maps to search for a location you know, then return the latitude and longitude values by clicking the map."
msgstr ""

#: 
msgid "If you're going to change the location, you'll need to make sure Sentinel-2 data is available for the new location, which you can check at the `DEAfrica Explorer <https://explorer.digitalearth.africa>`__. Use the drop-down menu to check ``s2a_l2a`` coverage."
msgstr ""

#: 
msgid "If you want to look at Weija Reservoir, try the following coordinates over the same time period as the original example:"
msgstr ""

#: 
msgid "Monitoring coastal erosion along Africa's coastline"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__ `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__ `s1_rtc <https://explorer.digitalearth.africa/s1_rtc>`__"
msgstr ""

#: 
msgid "Over 40% of the world’s population lives within 100 km of the coastline. However, coastal environments are constantly changing, with erosion and coastal change presenting a major challenge to valuable coastal infrastructure and important ecological habitats. Up-to-date data on coastal change and erosion is essential for coastal managers to be able to identify and minimise the impacts of coastal change and erosion."
msgstr ""

#: 
msgid "Monitoring coastlines and rivers using field surveys can be challenging and hazardous, particularly at regional or national scale. Aerial photography and LiDAR can be used to monitor coastal change, but this is often expensive and requires many repeated flights over the same areas of coastline to build up an accurate history of how the coastline has changed across time."
msgstr ""

#: 
msgid "Imagery from satellites such as the NASA/USGS Landsat, Copernicus Sentinel-1/2 constellations is available for free for the entire planet, making satellite imagery a powerful and cost-effective tool for monitoring coastlines and rivers at regional or national scale."
msgstr ""

#: 
msgid "DE Africa use case"
msgstr ""

#: 
msgid "The usefulness of optical imagery such as `Landsat <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_C2_SR_specs.html>`__ and `Sentinel-2 <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-2_Level-2A_specs.html>`__ in the coastal zone can be affected by the presence of clouds, sun-glint over water, poor water quality (e.g. sediment), and the influence of tides. The effect of these factors can be reduced by combining individual noisy images into cleaner \"summary\" or composite layers, and filtering the data to focus only on images taken at certain tidal conditions (e.g. mid-tide). These clean, tidally-constrained composite images can then be used to identify and extract the precise boundary between water and land. This allows us to extract accurate shorelines that can be compared across time to reveal hotspots of erosion and coastal change."
msgstr ""

#: 
msgid "Radar observations are largely unaffected by cloud cover. By developing a process to classify the observed pixels as either water or land, it is possible to identify the shoreline under all weather from the `Sentinel-1 analysis ready backscatter data <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-1_specs.html>`__. Since radar measurement is sensitive to surface roughness, moisture content, and viewing geometry, the shoreline delineation can be affected by surface conditions such as breaking waves. Our temporal composite approach reduces noise caused by temporary conditions but shorelines mapped by radar may still be biased compared to shoreline identified in optical imagery. For example, smooth and flat beaches may be mistaken for water when they exhibit extremely low backscatter values."
msgstr ""

#: 
msgid "In this example, we use a simplified version of the `DE Africa Coastlines <https://github.com/digitalearthafrica/deafrica-coastlines.git>`__ method to combine time series data with image compositing and tide filtering techniques to accurately map shorelines across time, and identify changes. For a selected area of interest, data from Landsat, Sentinel-2 or Sentinel-1 are selected based on availability."
msgstr ""

#: 
msgid "Following steps are demonstrated: 1. Query the satellite data and select best available product 2. Process the selected data and generate annual composite images for each year 3. Extract shorelines and calculate rates of coastal change"
msgstr ""

#: 
msgid "First we need to install additional tools from the `DE Africa Coastlines <https://github.com/digitalearthafrica/deafrica-coastlines.git>`__ repository that will allow us to estimate rates of coastal change. > **Note:** If you run into any error messages in this analysis, try restarting the notebook by clicking ``Kernel``, then ``Restart Kernel and Clear All Outputs``."
msgstr ""

#: 
msgid "Now we can load key Python packages and supporting functions for the analysis."
msgstr ""

#: 
msgid "**Note**: We recommend opening the Dask processing window to view the different computations that are being executed; to do this, see the *Dask dashboard in DE Africa* section of the `Dask notebook <../Beginners_guide/08_parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "The following cell set important parameters for the analysis:"
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``14.283``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``-16.921``)."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2018', '2021')``)"
msgstr ""

#: 
msgid "``time_step``: This parameter allows us to choose the length of the time periods we want to compare: e.g. shorelines for each year, or shorelines for each six months etc. ``1Y`` will generate one coastline for every year in the dataset; ``2Y`` will produce a coastline for every two years, etc."
msgstr ""

#: 
msgid "``filter_size``: An integer number defining the size of the speckle filter window used for Sentinel-1. As we will use temporal composites, which will help remove speckle noise, we recommend setting this filter size as None to disable speckle filtering, or a very small value (e.g. 2) to avoid significant degradation of spatial resolution."
msgstr ""

#: 
msgid "``s1_orbit_filtering``: A boolean value defining whether to filter Sentinel-1 observations by satellite orbit. When this is set to True, a per-pixel filtering will be applied to keep only observations acquired in the orbit with higher frequency. This parameter is set to False by default, which means observations from both descending and ascending orbits will be returned."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example explores coastal change in Comoros."
msgstr ""

#: 
msgid "**To run the notebook for a different area**, make sure at least one of Landsat, Sentinel-2 or Sentinel-1 data is available for the new location, which you can check at the `DE Africa Explorer <https://explorer.digitalearth.africa/>`__."
msgstr ""

#: 
msgid "To ensure that the tidal modelling part of this analysis works correctly, please make sure that **part of the study area is located over water** when setting ``lat_range`` and ``lon_range``."
msgstr ""

#: 
msgid "Query to find the best available product"
msgstr ""

#: 
msgid "The first step in this analysis is to select from the available satellite imagery products (Landsat, Sentinel-2, Sentinel-1 or merged Landsat and Sentinel-2) and load the best available one for shoreline mapping at the given location and study period. Here we use the function ``load_best_available_ds`` to select and load the data. The function implements a few steps: 1. Query all three products using the ``lat_range``, ``lon_range`` and ``time_range`` specified above and the ``load_ard`` function. The ``load_ard`` function will load and automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data. For more information see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__."
msgstr ""

#: 
msgid "2. Calculate the average number and frequency of valid obseravations within each time period. Optionally the calculation can be restricted to a simplified coastal zone instead of the full image extent."
msgstr ""

#: 
msgid "3. Apply product selection rules using the calculated mean numbers and frequencies of valid observations, based on the decision tree as illustrated in the figure below. By default the required number and frequency of valid observations within each time period are 10 and 20% respectively, which can also be changed by setting the parameters ``thresh_n_valid`` and ``thresh_freq``."
msgstr ""

#: 
msgid "|select_products.jpg|"
msgstr ""

#: 
msgid "select_products.jpg"
msgstr ""

#: 
msgid "The function takes in the ``dc``, ``lat_range``, ``lon_range``, ``time_range`` and ``time_step`` as specified above. Other important optional parameters include: \\* ``combine_ls_s2``: A boolean value deciding whether to include merged Landsat and Sentinel-2 products as one of the products to choose from. By default it is set to False so that only Landsat, Sentinel-2 or Sentinel-1 will be used. \\* ``coastal_masking``: A boolean value deciding whether to calculate a simplified coastal zone mask and restrict the comparison of the products within the masked area. Enabling this option would likely exclude pixels outside coastal zone (e.g. inland or deep ocean) that are not critical for coastline mapping, but require more time (e.g. several minutes) to process. By default this parameter is set to False to accelerate data query and loading. \\* ``set_resolution``: A pre-set spatial resolution (e.g. 20) in metres to query all products. By default this parameter is not set, so the original resolutions of the products will be used, i.e. 30 m for Landsat, 20 m for Sentinel-1 and 10 m for Sentinel-2."
msgstr ""

#: 
msgid "\\* ``set_product``: Set this to only query and load a pre-selected product, i.e. 'ls' for Landsat,'s1' for Sentinel-1,'s2' for Sentinel-2, or 'ls_s2' for merged/stacked Landsat and Sentinel-2 data. By setting this parameter no other products will be queried or compared."
msgstr ""

#: 
msgid "Note: Depending on parameter setting, **the cell below may take more than 10 minutes to finish**."
msgstr ""

#: 
msgid "The function above will print out some useful information on parameters setting, progress of the processing and why the product is chosen based on the selection rules. Using the default parameters set in this notebook, you will find that Sentinel-2 is chosen as the best available product by the above function, because it has the higher mean number and frequency of valid observations compared to Landsat across the scene and within each time step. Moreover, Sentinel-2 and Landsat are preferred over Sentinel-1 due to the occasional challenges in distinguishing between land and water in SAR backscatter images. Smooth and flat beaches, in particular, can exhibit extremely low backscatter values, making differentiation from water pixels difficult."
msgstr ""

#: 
msgid "If the date range is set to start before 2017, only Landsat data will be queried and loaded due to limited availability of Sentinel data."
msgstr ""

#: 
msgid "Once the load is complete, you can examine the product name and data by printing it in the next cell. The ``Dimensions`` argument reveals the number of time steps in the data set, as well as the number of pixels in the ``x`` (longitude) and ``y`` (latitude) dimensions."
msgstr ""

#: 
msgid "Plot example timestamp"
msgstr ""

#: 
msgid "Here we can plot an example image at the selected location at a given timestamp. To visualise Landsat or Sentinel-2 data, use the pre-loaded ``rgb`` utility function to plot a true colour image for a given timestamp. White areas indicate where clouds or other invalid pixels in the image have been masked. If the selected product is Sentinel-1, we plot the vh band as an example."
msgstr ""

#: 
msgid "Change the value for ``timestamp`` and re-run the cell to plot a different timestamp (timestamps are numbered from ``0`` to ``n_time - 1`` where ``n_time`` is the total number of timestamps; see the ``time`` listing under the ``Dimensions`` category in the dataset print-out above)."
msgstr ""

#: 
msgid "Process selected data and generate annual composites"
msgstr ""

#: 
msgid "Model tide height"
msgstr ""

#: 
msgid "For each satellite timestep, we use the ``pixel_tides`` function to model tide heights into a low-resolution 5 x 5 km grid (matching resolution of the `FES2014 tidal model <https://www.aviso.altimetry.fr/en/data/products/auxiliary-products/global-tide-fes/description-fes2014.html>`__), then reprojects modelled tides into the spatial extent of our satellite image. We add this new data as a new variable ``tide_m`` in our satellite dataset to allow each satellite pixel to be analysed and filtered/masked based on the tide height at the exact moment of satellite image acquisition."
msgstr ""

#: 
msgid "Based on the entire time-series of tide heights, we can compute the max and min satellite-observed tide height for each pixel, then calculate tide cutoffs used to restrict our data to satellite observations centred over mid-tide (0 m Above Mean Sea Level) using the tide_cutoffs function:"
msgstr ""

#: 
msgid "With the tide cutoffs calculated for all pixels, we now only keep observations within the tide height cutoff ranges. We also want to drop time-steps with no pixels within the cutoff ranges:"
msgstr ""

#: 
msgid "Process selected data"
msgstr ""

#: 
msgid "To extract shoreline locations, we need to be able to separate water from land in our study area. To do this, for Landsat or Sentinel-2 we can calculate a water index called the ``Modified Normalised Difference Water Index``, or MNDWI. This index uses the ratio of green and Shortwave-Infrared (SWIR) radiation to identify the presence of water `(Xu 2006) <https://doi.org/10.1080/01431160600589179>`__. The formula is:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{MNDWI} &= \\frac{(\\text{Green} - \\text{SWIR})}{(\\text{Green} + \\text{SWIR})}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "where ``Green`` is the green band and ``SWIR`` is the SWIR band."
msgstr ""

#: 
msgid "For Sentinel-1 data, we have implemented a few optional pre-processing steps. As radar observations appear speckly due to random interference of coherent signals from target scatters, we implemented speckle filtering using Lee filter, which is one of the popular adaptive speckle filters that takes into account local homogeneity."
msgstr ""

#: 
msgid "Besides, each of the Sentinel-1 observations were acquired from either a descending or ascending orbit. The orbital direction impacts on the local incidence angle and backscatter value. Therefore, we implemented a per-pixel filtering to keep only observations from the dominant orbit, which is expected to minimise the effects of inconsistent looking angle and obit direction for each individual pixel. In addition, it is often useful to convert the backscatter to decible (dB) for analysis. Backscatter in dB unit has a more symmetric noise profile and less skewed value distribution for easier statistical evaluation."
msgstr ""

#: 
msgid "These preprocessing steps are applied using function ``preprocess_s1`` and the parameter ``filter_size`` and ``s1_orbit_filtering`` as specified at the begining of the notebook. Note that Sentinel-1 preprocessing may take a few minutes to finish."
msgstr ""

#: 
msgid "Combine observations into noise-free summary images"
msgstr ""

#: 
msgid "Individual remote sensing images can be affected by noisy data, e.g. cloud/cloud shadow for optical images and effects of wind on the water for radar images. To produce cleaner images that can be compared more easily across time, we can create 'summary' images or composites that combine multiple images into one image to reveal the median or 'typical' appearance of the landscape for a certain time period. In this case, we use the median as the summary statistic because it prevents strong outliers from skewing the data, which would not be the case if we were to use the mean."
msgstr ""

#: 
msgid "In the code below, we take the time series of images and combine them into single images for each ``time_step``. For example, if ``time_step = '1Y'``, the code will produce one new image for each year in the dataset. This step can take **several minutes to load** if the study area is large."
msgstr ""

#: 
msgid "When it comes to interpreting the index, **high values (blue colours) typically represent water pixels**, while **low values (red colours) represent land**."
msgstr ""

#: 
msgid "Extract shorelines and calculate rates of coastal change"
msgstr ""

#: 
msgid "Extract shorelines from imagery"
msgstr ""

#: 
msgid "We now want to extract an accurate shoreline for each of the summary images above. The code below identifies the boundary between land and water by tracing a line along pixels with a given threshold value. For Landsat and Sentinel-2 images, we use a water index value of ``0``."
msgstr ""

#: 
msgid "For Sentinel-1 images, the threshold could be determined either through simple automatic thresholding, or using a more complicated supervised classification method. In this notebook we use the ``threshold_minimum`` function, which computes the histogram for all backscatter values, smooths it until there are only two maxima and find the minimum in between as the threshold."
msgstr ""

#: 
msgid "We use the ``subpixel_contours`` function to identify the boundary between land and water by tracing a line along pixels with the previously identified threshold value. It returns a vector file with one line for each time step:"
msgstr ""

#: 
msgid "Plot resampled shorelines on an interactive map"
msgstr ""

#: 
msgid "The next cell provides an interactive map with an overlay of the shorelines identified in the previous cell. Run it to view the map (this step can take **several minutes to load** if the study area is large)."
msgstr ""

#: 
msgid "Zoom in to the map below to explore the resulting set of shorelines. Older shorelines are coloured in black, and more recent shorelines in yellow. Hover over the lines to see the time period for each shoreline printed above the map. Using this data, we can easily identify areas of coastline or rivers that have changed significantly over time, or areas that have remained stable over the entire time period."
msgstr ""

#: 
msgid "Calculate rates of coastal change"
msgstr ""

#: 
msgid "To identify parts of the coastline that are changing rapidly, we can use our annual shoreline data to calculate rates of coastal change in metres per year. This can be particularly useful to reveal hotspots of coastal retreat (e.g. erosion), or hotspots of coastal growth."
msgstr ""

#: 
msgid "To do this, we first need to create a set of evenly spaced points at every 20 metres along the most recent shoreline in our dataset. These points will be used to plot rates of coastal change across our study area."
msgstr ""

#: 
msgid "Now that we have a set of modelling points, we can measure distances from each of the points to each annual shoreline. This gives us a table of distances, where negative values (e.g. ``-6.5``) indicate that an annual shoreline was located inland of our points, and positive values (e.g. ``2.3``) indicate a shoreline was located towards the ocean. Because our points were created along our most recent 2023 shoreline, distances for 2023 will always have a distance of 0 m."
msgstr ""

#: 
msgid "Finally, we can calculate annual rates of coastal change (in metres per year) using linear regression. This will add several new columns to our table:"
msgstr ""

#: 
msgid "``rate_time``: Annual rates of change (in metres per year) calculated by linearly regressing annual shoreline distances against time (excluding outliers; see ``outl_time``). Negative values indicate retreat and positive values indicate growth."
msgstr ""

#: 
msgid "``sig_time``: Significance (p-value) of the linear relationship between annual shoreline distances and time. Small values (e.g. p-value < 0.01 or 0.05) may indicate a coastline is undergoing consistent coastal change through time."
msgstr ""

#: 
msgid "``se_time``: Standard error (in metres) of the linear relationship between annual shoreline distances and time. This can be used to generate confidence intervals around the rate of change given by rate_time (e.g. 95% confidence interval = ``se_time * 1.96``)"
msgstr ""

#: 
msgid "``outl_time``: Individual annual shoreline are noisy estimators of coastline position that can be influenced by environmental conditions (e.g. clouds, breaking waves, sea spray) or modelling issues (e.g. poor tidal modelling results or limited clear satellite observations). To obtain reliable rates of change, outlier shorelines are excluded using a robust Median Absolute Deviation outlier detection algorithm, and recorded in this column."
msgstr ""

#: 
msgid "Plot rates of coastal change on an interactive map"
msgstr ""

#: 
msgid "Now that we have calculated rates of coastal change, we can plot these on an interactive map to identify parts of the coastline that are retreating or growing over time."
msgstr ""

#: 
msgid "When the map appears below, hover your mouse over the coloured dots that appear along the coastline for a summary of recent coastal change at those locations. Red dots represent locations that are retreating (e.g. erosion), and blue dots represent locations that are growing."
msgstr ""

#: 
msgid "|coastal_change.jpg|"
msgstr ""

#: 
msgid "coastal_change.jpg"
msgstr ""

#: 
msgid "**Important note:** This notebook may produce misleading rates of change for non-coastal waterbodies that might fluctuate naturally year-by-year. The full `Digital Earth Africa Coastlines repository <https://github.com/digitalearthafrica/deafrica-coastlines.git>`__ contains additional methods for producing more accurate rates of change by cleaning and filtering annual shoreline data to focus only on coastal shorelines."
msgstr ""

#: 
msgid "Export rates of change to file"
msgstr ""

#: 
msgid "Finally, we can export our output rates of change file so that it can be loaded in GIS software (e.g. ESRI ArcGIS or QGIS)."
msgstr ""

#: 
msgid "Plot annual shorelines animated GIF"
msgstr ""

#: 
msgid "When you are done, return to the \"Set up analysis\" cell, modify some values (e.g. ``time_range``, ``time_step`` or ``lat``/``lon``) and rerun the analysis. If you're going to change the location, you'll need to make sure at least one of Landsat, Sentinel-2 and Sentinel-1 products is available for the new location, which you can check at the `DE Africa Explorer <https://explorer.digitalearth.africa/products/>`__."
msgstr ""

#: 
msgid "For more information about the method behind this notebook, read the scientific paper: > Bishop-Taylor, R., Nanson, R., Sagar, S., Lymburner, L. (2021). Mapping Australia's dynamic coastline at mean sea level using three decades of Landsat imagery. Remote Sensing of Environment 267, 112734. Available: https://doi.org/10.1016/j.rse.2021.112734"
msgstr ""

#: 
msgid "Measuring crop health"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2`, :index:`band index; NDVI`, :index:`interactive`, :index:`analysis; time series`, :index:`agriculture`"
msgstr ""

#: 
msgid "While crops are growing, fields may look visually similar. However, health or growth rates from these fields can be quite different, leading to variability and unpredictability in revenue. Identifying underperforming crops can have two benefits:"
msgstr ""

#: 
msgid "Ability to scout for disease damage."
msgstr ""

#: 
msgid "Ability to investigate poor performing fields and undertake management action such as soil testing or targeted fertilising to improve yield."
msgstr ""

#: 
msgid "Satellite imagery can be used to measure plant health over time and identify any changes in growth patterns between otherwise similar fields. Sentinel-2's 20-metre resolution makes it ideal for understanding the health of large fields."
msgstr ""

#: 
msgid "The Normalised Difference Vegetation Index (NDVI) describes the difference between visible and near-infrared reflectance of vegetation cover. This index estimates the density of green on an area of land and can be used to track the health and growth of crops as they mature. Comparing the NDVI of two similar planting areas will help to identify any anomalies in growth patterns."
msgstr ""

#: 
msgid "In this example, data from Sentinel-2 is used to assess crop growing patterns over two years. The worked example below takes users through the code required to:"
msgstr ""

#: 
msgid "Create a time series data cube over croplands."
msgstr ""

#: 
msgid "Select multiple areas for comparison."
msgstr ""

#: 
msgid "Create graphs to identify crop performance trends over two years."
msgstr ""

#: 
msgid "Interpret the results."
msgstr ""

#: 
msgid "**To run this analysis**, run all the cells in the notebook, starting with the \"Load packages and apps\" cell."
msgstr ""

#: 
msgid "Load packages and apps"
msgstr ""

#: 
msgid "This notebook works via two functions, which are referred to as apps: ``load_crophealth_data`` and ``run_crophealth_app``. The apps allow the majority of the analysis code to be stored in another file, making the notebook easy to use and run. To view the code behind the apps, open the `crophealth.py <../Tools/deafrica_tools/app/crophealth.py>`__ file."
msgstr ""

#: 
msgid "The following cell sets important parameters for the analysis. There are four parameters that control where the data will be loaded:"
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``14.789064``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``-17.065202``)."
msgstr ""

#: 
msgid "``date``: The most recent date to show data for. The app will automatically load all data available for the two years prior to this date. (e.g. ``'2020-08-01'`` shows data from August 2018 to August 2020)."
msgstr ""

#: 
msgid "These can be changed in the cell below, noting that the `DE Africa Explorer <https://explorer.digitalearth.africa/products/s2_l2a>`__ can be used to check whether Sentinel-2 data is available over the selected area."
msgstr ""

#: 
msgid "Suggested areas"
msgstr ""

#: 
msgid "Here are some suggestions for areas to look at. To view one of these areas, copy and paste the parameter values into the cell below, then run the notebook."
msgstr ""

#: 
msgid "**Croplands, Senegal**"
msgstr ""

#: 
msgid "**Aviv Coffee Farm, Tanzania**"
msgstr ""

#: 
msgid "**Croplands, Western Kenya**"
msgstr ""

#: 
msgid "Load the data"
msgstr ""

#: 
msgid "The ``load_crophealth_data()`` command performs several key steps:"
msgstr ""

#: 
msgid "identify all available Sentinel-2 data in the case-study area over the two years prior to the set date"
msgstr ""

#: 
msgid "remove any bad quality pixels"
msgstr ""

#: 
msgid "keep images where more than half of the image contains good quality pixels"
msgstr ""

#: 
msgid "calculate the NDVI from the red and near infrared bands"
msgstr ""

#: 
msgid "return the collated data for analysis"
msgstr ""

#: 
msgid "The cleaned and collated data is stored in the ``dataset`` object. As the command runs, feedback will be provided below the cell, including information on the number of cleaned images loaded from the satellite."
msgstr ""

#: 
msgid "The function takes four arguments: ``lat``, ``lon``, and ``buffer``, ``date``. These determine the area of interest adn date range that the function loads, and can be changed in the previous cell."
msgstr ""

#: 
msgid "**Please be patient**. The load is complete when the cell status goes from ``[*]`` to ``[number]``."
msgstr ""

#: 
msgid "Run the crop health app"
msgstr ""

#: 
msgid "The ``run_crophealth_app()`` command launches an interactive map. Drawing polygons within the red boundary (which represents the area covered by the loaded data) will result in plots of the average NDVI in that area. Draw polygons by clicking the ⬟ symbol in the app."
msgstr ""

#: 
msgid "The function works by taking the loaded data ``dataset`` as an argument, as well as the ``lat``, ``lon``, and ``buffer`` parameters used to define the spatial extent."
msgstr ""

#: 
msgid "**Note:** data points will only appear for images where more than 50% of the pixels were classified as good quality. This may cause trend lines on the average NDVI plot to appear disconnected. Available data points will be marked with the ``*`` symbol."
msgstr ""

#: 
msgid "What are some factors that might explain differences or similarities across different sections of the study area?"
msgstr ""

#: 
msgid "Are there any noticable patterns across the two years of data? Could these correspond to specific events such as planting or harvesting?"
msgstr ""

#: 
msgid "Monitoring Crop Health using Enhanced Vegetation Index"
msgstr ""

#: 
msgid "**Products used:** `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; Landsat-9`, :index:`band index; EVI`"
msgstr ""

#: 
msgid "`Enhanced Vegetation Index <https://shorturl.at/oHRY9>`__ can be calculated from Landsat or Sentinel-2 images, and is similar to the Normalized Difference Vegetation Index (NDVI), as it quantifies vegetation greenness. However, the EVI corrects for some atmospheric conditions and canopy background noise and is more sensitive in areas with dense vegetation."
msgstr ""

#: 
msgid "Using Digital Earth Africa's archive of analysis-ready satellite data, we can easily calculate the EVI for mapping and monitoring vegetation through time, or as inputs to machine learning or classification algorithms."
msgstr ""

#: 
msgid "Load Landsat 9 images for an area of interest (AOI)"
msgstr ""

#: 
msgid "Calculate the Enhanced Vegetation Index (EVI)"
msgstr ""

#: 
msgid "Visualize the results."
msgstr ""

#: 
msgid "The ``load_ard`` function will automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data. It will also exclude images where more than 99% of the pixels are masked, which is set using the ``min_gooddata`` parameter in the ``load_ard`` call."
msgstr ""

#: 
msgid "Plot the images to see what the area looks like"
msgstr ""

#: 
msgid "We use the ``rgb`` function to plot the timesteps in our dataset as true colour RGB images."
msgstr ""

#: 
msgid "Calculating the EVI using the calculate_indices function"
msgstr ""

#: 
msgid "The Enhanced Vegetation Index requires the red, nir and blue bands as well as an “L” value to adjust for canopy background, “C” values as coefficients for atmospheric resistance, and a gain factor (G)."
msgstr ""

#: 
msgid "The formula is"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{EVI} & = G \\times \\frac{(\\text{NIR} - \\text{Red})}{(\\text{NIR} + C1 \\times \\text{Red} -C2 \\times \\text{Blue} + L)} \\\\\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The index is available through the `calculate_indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ function, imported from `deafrica_tools.bandindices <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.bandindices.html>`__. Here,\\ ``satellite_mission='ls'`` is used since we're working with Landsat 9."
msgstr ""

#: 
msgid "Mask region with DE Africa's cropland extent map"
msgstr ""

#: 
msgid "Load the cropland mask over the region of interest."
msgstr ""

#: 
msgid "Zonal mean of the EVI"
msgstr ""

#: 
msgid "To understand changes in vegetation health throughout the year(s), we plot a zonal time series over the region of interest. First we will do a simple plot of the zonal mean of the data."
msgstr ""

#: 
msgid "The plot below shows two peaks, suggesting the area of interest is used for double cropping (growing two crops per year)."
msgstr ""

#: 
msgid "Plot an individual image to view the spatial variations in EVI"
msgstr ""

#: 
msgid "Exporting high quality satellite images"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/products/ls7_sr>`__, `ls5_sr <https://explorer.digitalearth.africa/products/ls5_sr>`__, `s2_l2a <https://explorer.digitalearth.africa/products/s2_l2a>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`widgets`, :index:`interactive`, :index:`plotting`"
msgstr ""

#: 
msgid "Most of the case studies in this repository focus on quantitatively analysing satellite data to obtain insights into Africa's changing environment. However, satellite imagery also represents a powerful tool for visualisation. Images taken by satellites can help explain physical processes, highlight change over time, or provide valuable context to better understand the impacts of recent environmental events such as flooding or fire. Satellite data can also be processed to create images of the landscape based on invisible wavelengths of light (e.g. false colour images), allowing us to obtain richer insights into features and processes that would otherwise be invisible to the human eye."
msgstr ""

#: 
msgid "**Digital Earth Africa** provides over three decades of satellite imagery across the entire continent of Africa. Satellite data from the `NASA/USGS Landsat program <https://www.usgs.gov/land-resources/nli/landsat>`__ allow us to produce fortnightly images of Africa's diverse natural and artificial landscapes at any time since 1984. More recently, the `Copernicus Sentinel-2 mission <https://sentinel.esa.int/web/sentinel/missions/sentinel-2>`__ has provided even higher resolution imagery as frequently as every 5 days since 2017."
msgstr ""

#: 
msgid "This notebook provides an interactive tool for selecting, loading, processing and exporting satellite imagery as a high quality image file. This can be used in combination with the interactive `Digital Earth Africa Maps <https://maps.digitalearth.africa/>`__ platform to identify an image of interest, then download it using this notebook for use in other applications."
msgstr ""

#: 
msgid "The tool supports Sentinel-2 and Landsat data, creating True and False colour images."
msgstr ""

#: 
msgid "Select imagery"
msgstr ""

#: 
msgid "The following cell sets important required parameters used to plot and select satellite imagery on the interactive map."
msgstr ""

#: 
msgid "``date``: The exact date used to display imagery on the map (e.g. ``date='1988-01-01'``)."
msgstr ""

#: 
msgid "``satellites``: The satellite data to be shown on the map. Five options are currently supported:"
msgstr ""

#: 
msgid "**\"Landsat-8\"**"
msgstr ""

#: 
msgid "Data from the Landsat 8 optical satellite"
msgstr ""

#: 
msgid "**\"Landsat-7\"**"
msgstr ""

#: 
msgid "Data from the Landsat 7 optical satellite"
msgstr ""

#: 
msgid "**\"Landsat-5\"**"
msgstr ""

#: 
msgid "Data from the Landsat 5 optical satellite"
msgstr ""

#: 
msgid "**\"Sentinel-2\"**"
msgstr ""

#: 
msgid "Data from the Sentinel-2A and 2B optical satellites"
msgstr ""

#: 
msgid "**\"Sentinel-2 geomedian\"**"
msgstr ""

#: 
msgid "Data from the Sentinel-2 annual geomedian"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results.*\\*"
msgstr ""

#: 
msgid "**If passing in ``'Sentinel-2 geomedian'``, ensure the ``date`` looks like this: ``'<year>-01-01'``**"
msgstr ""

#: 
msgid "Select location on a map"
msgstr ""

#: 
msgid "Run the following cell to plot the interactive map that is used to select the area to load and export satellite imagery."
msgstr ""

#: 
msgid "Select the ``Draw a rectangle`` or ``Draw a polygon`` tool on the left of the map, and draw a shape around the area you are interested in. When you are ready, press the green ``done`` button on the top right of the map."
msgstr ""

#: 
msgid "To keep load times reasonable, select an area **smaller than 10000 square kilometers** in size (this limit can be overuled by supplying the ``size_limit`` parameter in the ``select_region_app`` function below)."
msgstr ""

#: 
msgid "Export image"
msgstr ""

#: 
msgid "The optional parameters below allow you to fine-tune the appearance of your output image."
msgstr ""

#: 
msgid "``style``: The style used to produce the image. Two options are currently supported:"
msgstr ""

#: 
msgid "**\"True colour\"**"
msgstr ""

#: 
msgid "Creates a true colour image using the red, green and blue satellite bands"
msgstr ""

#: 
msgid "**\"False colour\"**"
msgstr ""

#: 
msgid "Creates a false colour image using short-wave infrared, infrared and green satellite bands."
msgstr ""

#: 
msgid "``resolution``: The spatial resolution to load data. By default, the tool will automatically set the best possible resolution depending on the satellites selected (i.e. 30 m for Landsat, 10 m for Sentinel-2). Increasing this (e.g. to ``resolution = (-100, 100)``) can be useful for loading large spatial extents."
msgstr ""

#: 
msgid "``vmin, vmax``: The minimum and maximum surface reflectance values used to clip the resulting imagery to enhance contrast."
msgstr ""

#: 
msgid "``percentile_stretch``: A tuple of two percentiles (i.e. between 0.00 and 1.00) that can be used to clip the imagery to optimise the brightness and contrast of the image. If this parameter is used, ``vmin`` and ``vmax`` will have no effect."
msgstr ""

#: 
msgid "``power``: Raises imagery by a power to reduce bright features and enhance dark features. This can add extra definition over areas with extremely bright features like snow, beaches or salt pans."
msgstr ""

#: 
msgid "``image_proc_funcs`` An optional list containing functions that will be applied to the output image. This can include image processing functions such as increasing contrast, unsharp masking, saturation etc. The function should take *and* return a ``numpy.ndarray`` with shape ``[y, x, bands]``."
msgstr ""

#: 
msgid "``standardise_name``: Whether to export the image file with a machine-readable file name (e.g. ``sentinel-2a_2020-01-30_bitou-local-municipality-western-cape_true-colour-10-m-resolution.jpg``)"
msgstr ""

#: 
msgid "Once you are happy with the parameters above, run the cell below to load the satellite data and export it as an image:"
msgstr ""

#: 
msgid "Downloading exported image"
msgstr ""

#: 
msgid "The image export will be completed when ``Finished exporting image`` appears above, and a preview of your image is shown below the map."
msgstr ""

#: 
msgid "The high resolution image file generated above will be saved to the same location you are running this notebook from (e.g. typically ``Real_world_examples``). In JupyterLab, use the file browser to locate the image file with a name in the following format:"
msgstr ""

#: 
msgid "``Sentinel-2A - 2020-01-30 - Bitou Local Municipality, Western Cape - True colour, 10 m resolution``"
msgstr ""

#: 
msgid "If you are using the **DE Africa Sandbox**, you can download the image to your PC by right clicking on the image file and selecting ``Download``."
msgstr ""

#: 
msgid "Change ``satellites`` to ``\"Landsat\"`` to export a Landsat image instead of Sentinel-2."
msgstr ""

#: 
msgid "Modify ``style`` to ``\"False colour\"`` to export a false colour view of the landscape that highlights growing vegetation and water."
msgstr ""

#: 
msgid "Specify a custom resolution, e.g. ``resolution = (-1000, 1000)``."
msgstr ""

#: 
msgid "Experiment with the ``vmin``, ``vmax``, ``percentile_stretch`` and ``power`` parameters to alter the appearance of the resulting image."
msgstr ""

#: 
msgid "Detection of Floating Marine Debris"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__ `wofs_ls_summary_alltime <https://explorer.digitalearth.africa/wofs_ls_summary_alltime>`__"
msgstr ""

#: 
msgid "Marine plastic pollution is a global concern that threatens marine ecosystems and human health. Detecting and quantifying plastic waste in the marine environment is crucial for addressing this problem. Remote sensing techniques, particularly using satellite imagery, have emerged as a promising tool for identifying and monitoring plastic debris in the ocean. In this notebook, we will explore the use of the Floating Debris Index (FDI) and Normalized Difference Vegetation Index (NDVI) for detecting floating plastics in Sentinel-2 satellite imagery. These indices have demonstrated superior performance in detecting floating marine plastics in various locations such as Greece (`Topouzelis et al., 2019 <https://doi.org/10.1016/j.jag.2019.03.011>`__, `2020 <https://doi.org/10.3390/rs12122013>`__), Cyprus `(Themistocleous et al., 2020) <https://doi.org/10.3390/RS12162648>`__, and Durban `(Biermann et al., 2020) <https://doi.org/10.1038/s41598-020-62298-z>`__."
msgstr ""

#: 
msgid "**Detecting Marine Debris**:"
msgstr ""

#: 
msgid "Marine Debris pose a significant threat to marine life and human health. Detecting their presence in water bodies has become a global priority. To address this, we will utilize the FDI and NDVI applied to Sentinel-2 satellite imagery."
msgstr ""

#: 
msgid "Floating Debris Index (FDI): The Floating Debris Index (FDI) is a spectral index specifically designed to detect and quantify floating debris on the water surface. By calculating the FDI using Sentinel-2 satellite imagery, we can effectively identify areas where marine debris are present in the study area. The FDI takes advantage of the unique spectral characteristics exhibited by floating debris, allowing us to distinguish them from other features in the image. A thresholding technique will be applied to the FDI values, enabling the separation of marine debris from the surrounding water and other materials."
msgstr ""

#: 
msgid "Normalized Difference Vegetation Index (NDVI): Although primarily designed for vegetation monitoring, the Normalized Difference Vegetation Index (NDVI) can be adapted to detect floating marine debris as well. marine debris often exhibit spectral properties that distinguish them from natural features. By calculating the NDVI using Sentinel-2 imagery, we can leverage these spectral differences to identify potential marine debris locations. The NDVI quantifies the difference between the near-infrared and red spectral bands, providing an indication of the presence of marine debris based on their unique spectral responses. This allows us to distinguish marine debris from other materials in the image, aiding in the detection and characterization of floating plastic debris."
msgstr ""

#: 
msgid "Notebook Workflow: The following steps will be covered in this notebook to detect floating marine debris:"
msgstr ""

#: 
msgid "Data Preprocessing:"
msgstr ""

#: 
msgid "Obtain Sentinel-2 satellite imagery for the study area."
msgstr ""

#: 
msgid "Perform necessary pre-processing steps such as atmospheric correction and radiometric calibration."
msgstr ""

#: 
msgid "Calculation of Spectral Indices:"
msgstr ""

#: 
msgid "Calculate the FDI and NDVI based on the spectral bands of the Sentinel-2 imagery."
msgstr ""

#: 
msgid "Thresholding Techniques:"
msgstr ""

#: 
msgid "Apply thresholding techniques to the FDI and NDVI to separate marine debris from other features in the imagery."
msgstr ""

#: 
msgid "Determine suitable threshold values based on previous studies or experimentation."
msgstr ""

#: 
msgid "Marine debris Detection and Quantification:"
msgstr ""

#: 
msgid "Identify and extract potential marine debris locations based on the thresholded indices."
msgstr ""

#: 
msgid "Generate statistics and metrics to quantify the extent and distribution of marine debris in the study area."
msgstr ""

#: 
msgid "Result Analysis:"
msgstr ""

#: 
msgid "Analyze the detected marine debris distribution patterns and their potential sources."
msgstr ""

#: 
msgid "Compare the results with available ground-truth data to validate the findings."
msgstr ""

#: 
msgid "For assessing the accuracy of our marine debris detection method, this notebook uses the `Marine Debris Dataset for Object Detection in Planetscope Imagery Dataset <https://mlhub.earth/data/nasa_marine_debris>`__. This dataset comprises 256x256 pixel images extracted from PlanetScope optical imagery, annotated with bounding boxes and geographical coordinates. The dataset covers diverse marine debris types, including plastics, algae, sargassum, wood, and other artifacts. This dataset will serve as ground truth, enabling us to quantitatively measure our detection model's accuracy."
msgstr ""

#: 
msgid "Import necessary libraries"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |upload_files_icon.png| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "upload_files_icon.png"
msgstr ""

#: 
msgid "Load the Sentinel-2 data for the area of interest and time range"
msgstr ""

#: 
msgid "**Note**: In this notebook, the presented example focuses on a single timestamp, specifically '2018-10-31,' for which we have access to ground truth data in the form of the `Marine Debris Dataset for Object Detection in Planetscope Imagery Dataset <https://mlhub.earth/data/nasa_marine_debris>`__ within the designated area of interest. However, the workflow's flexibility allows for seamless adaptation to analye data over a range of timestamps. This capability enables you to examine the presence and distribution of debris across different points in time within the specified date range. Whether you're interested in a specific time period or conducting comparative analyses across multiple timestamps, the workflow can be customized to suit your research needs."
msgstr ""

#: 
msgid "Normalise the intensity of the bands"
msgstr ""

#: 
msgid "Normalizing the intensity of the bands used in the Floating Debris Index (FDI) is important to ensure that the FDI is not biased by differences in brightness or reflectance values across the image. Normalization helps to standardize the range of values across the bands, so that each band contributes equally to the index regardless of its original intensity values."
msgstr ""

#: 
msgid "If the intensity values of the bands are not normalized, it can lead to inaccuracies in the FDI results, such as false positives or false negatives. For example, if one band has significantly higher intensity values than the others, it may dominate the FDI calculation and lead to an overestimation of the amount of floating debris present in the image."
msgstr ""

#: 
msgid "By normalizing the intensity values, the FDI is calculated based on the relative differences in reflectance values between the two bands, rather than the absolute intensity values. This helps to ensure that the FDI is a more accurate indicator of the presence of floating debris, and reduces the impact of other factors that may affect the brightness or reflectance values of the image, such as cloud cover or varying illumination conditions."
msgstr ""

#: 
msgid "Mask non-marine areas"
msgstr ""

#: 
msgid "World Bank-approved coastlines downloaded from https://datacatalog.worldbank.org/search/dataset/0038272"
msgstr ""

#: 
msgid "Removing additional land areas using the WOfS 'all-time' Summary"
msgstr ""

#: 
msgid "The World Bank coastlines dataset is used to mask out land areas. However, due to the dataset's global nature, inaccuracies can occur where coastlines extend into the ocean or further inland. To address this, the Water Observation from Space (WOfS) 'all-time' summary layer is employed to remove erroneously included land areas within the region of interest. Unfortunately, there are no provisions to re-include accidentally excluded water or marine areas in the current notebook."
msgstr ""

#: 
msgid "Calculate and plot the Floating Debris Index (FDI) and the Normalized Difference Vegetation Index (NDVI)"
msgstr ""

#: 
msgid "Floating Debris Index (FDI)"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{FDI} = R_{rs},NIR - (R_{rs},RE2 + (R_{rs}, SWIR1 - R_{rs}, RE2) * \\frac{(\\lambda_{NIR} - \\lambda_{RED})}{(\\lambda_{SWIR1} - \\lambda_{RED})} * 10) \\end{equation}`"
msgstr ""

#: 
msgid "where :math:`R_{rs,NIR}`, :math:`R_{rs, RE2}`, :math:`R_{rs, SWIR1}` are the reflectance values in the near infrared, red edge 2, and short-wave infrared bands, respectively, :math:`λ_i` are the wavelength with subscript band name."
msgstr ""

#: 
msgid "Note wavelength values are the central wavelengths from https://www.usgs.gov/centers/eros/science/usgs-eros-archive-sentinel-2"
msgstr ""

#: 
msgid "Normalized Difference Vegetation Index (NDVI): Although primarily designed for vegetation monitoring, the Normalized Difference Vegetation Index (NDVI) can be adapted to detect floating marine debris as well. Marine debris often exhibit spectral properties that distinguish them from natural features. By calculating the NDVI using Sentinel-2 imagery, we can leverage these spectral differences to identify potential marine debris locations. The NDVI quantifies the difference between the near-infrared and red spectral bands, providing an indication of the presence of marine debris based on their unique spectral responses. This allows us to distinguish marine debris from other materials in the image, aiding in the detection and characterization of floating plastic debris."
msgstr ""

#: 
msgid "Normalized Difference Vegetation Index (NDVI)"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{NDVI} =  \\frac{R_{rs},NIR - R_{rs},RED}{R_{rs},NIR + R_{rs},RED} \\end{equation}`"
msgstr ""

#: 
msgid "where :math:`R_{rs,NIR}`, :math:`R_{rs, RED}` are the reflectance values in the near infrared, and red bands, respectively."
msgstr ""

#: 
msgid "This code defines the affine and CRS (Coordinate Reference System) variables of the dataset ds_masked_coastline, which are required for plotting the data. It then creates a new dataset ds_fdi which contains the FDI values obtained from the previous step."
msgstr ""

#: 
msgid "The output plot can be used to visualize the distribution of floating debris in water bodies over time."
msgstr ""

#: 
msgid "Select and apply threshold"
msgstr ""

#: 
msgid "The best threshold for identifying debris from the FDI will depend on the characteristics of your data and the specific application you are working on."
msgstr ""

#: 
msgid "One way to determine the best threshold is to create a histogram of the FDI values and visually inspect it to identify a threshold value that separates the distribution into two distinct groups, one representing marine debris and the other representing non-marine debris."
msgstr ""

#: 
msgid "Threshold for each timestamp and plot histograms"
msgstr ""

#: 
msgid "The 3-sigma rule is a statistical method used to determine if a data point is an outlier, which means it is significantly different from the other data points. In this case, we used it to identify pixels in the satellite imagery that were likely to be marine debris."
msgstr ""

#: 
msgid "To do this, we first calculated the mean and standard deviation of values for all pixels in the satellite imagery. We then set a threshold at 3 standard deviations above the mean, which means any pixel with a value above this threshold was classified as a marine debris."
msgstr ""

#: 
msgid "Plot histograms of the FDI and NDVI values for each timestamp, with the threshold value plotted as a vertical red dashed line. This is a good way to visualize the distribution of the FDI and NDVI values and how the threshold value relates to the data."
msgstr ""

#: 
msgid "Create and plot FDI and NDVI binary masks"
msgstr ""

#: 
msgid "This code creates a series of binary masks for a dataset of satellite imagery at different time steps. The masks are created based on a threshold value calculated for each time step, and the resulting areas of the masks that correspond to marine debris pollution are calculated and stored in a list. The number of marine debris within the area of interest for each time step is also calculated and stored in a separate list. The masks are then plotted as subplots in a grid format with custom colors. The code also removes any unused subplots and adjusts the spacing between subplots. The final output is a figure showing the masks for each time step and the corresponding marine debris area and number of marine debris."
msgstr ""

#: 
msgid "Create a single binary map of pixels that are classified as debris using both FDI and NDVI."
msgstr ""

#: 
msgid "Vectorise the identified marine debris pixels for a timestamp of choice"
msgstr ""

#: 
msgid "**This notebook uses the NASA Marine Debris Dataset for Object Detection in Planetscope Imagery dataset as validation data for the area of interest (timestamp: (2018-10-31)).** The dataset, provided in geojson format, is sourced from the `Supplementary_data <../Supplementary_data/Floating_marine_debris/nasa_marine_debris_labels_ghana.geojson>`__ folder. It encompasses annotated vector data, including bounding boxes and geographical coordinates, serving as ground truth for marine debris object detection."
msgstr ""

#: 
msgid "In the accuracy assessment, it is essential to acknowledge that the floating marine debris observed in the Sentinel image used may have moved between its acquisition time and the acquisition of the PlanetScope imagery used to create the NASA Marine Debris Dataset for Object Detection in Planetscope Imagery dataset. Due to the temporal gap and the dynamic nature of floating objects, it is challenging to determine the exact positions of the debris at the time of both image acquisitions. To account for this uncertainty, a buffer has been introduced around the validation dataset, allowing for potential movement of the debris during the time lapse between the two datasets. This approach acknowledges the possibility of displacement and provides a more comprehensive assessment of accuracy by considering the potential shifts in the positions of the floating marine debris."
msgstr ""

#: 
msgid "The plot above illustrates that the predicted marine debris and the validation data are not perfectly aligned, which is expected due to the movement of floating marine objects. To account for this, introducing buffers around the validation data is necessary, considering the potential movement of marine debris between the time of the Sentinel image capture and the Planetscope Imagery used for validation. These buffers allow for a more robust analysis, accommodating the dynamic behavior of marine debris and enabling a comprehensive examination of potential marine debris locations."
msgstr ""

#: 
msgid "In this accuracy assessment, we sought to evaluate the performance of marine debris detection in satellite imagery by comparing it with the marine dataset buffers representing potential marine debris areas. To ensure accuracy, we assigned unique identifiers to each buffer and marine debris polygon. By conducting a spatial join operation, we identified the areas of overlap between the buffers and detected marine debris. The goal was to determine how many of the marine dataset buffers contained marine debris. Through this approach, we avoided overcounting buffers with multiple marine debris, as each buffer was counted only once, regardless of the number of intersecting marine debris."
msgstr ""

#: 
msgid "**Disclaimer:** It is important to note that the accuracy assessment results are dependent on the size of the buffer defined. In this case, the buffer size was selected arbitrarily and not based on specific criteria or scientific guidelines. Therefore, the accuracy percentage obtained should be interpreted within the context of the chosen buffer size. Different buffer sizes may yield different accuracy outcomes."
msgstr ""

#: 
msgid "The accuracy assessment of marine debris identification within a 100m buffer zone of marine dataset buffers revealed promising results. Although the buffers and the detected marine debris did not overlap perfectly due to movement and natural variations, visual examination indicated a discernible pattern of marine debris presence that aligned with our method of identification. While the accuracy rate of 70.59% indicates that our approach captured a significant portion of the actual marine debris within the buffers, it is important to consider the visual evidence that supports the effectiveness of our method. The offset observed between the detected marine debris and the buffers is expected due to the dynamic nature of marine debris dispersion in marine environments. Overall, the visual observations strengthen our confidence in the accuracy assessment, highlighting the ability of our method to identify marine debris even when perfect spatial alignment is not achieved."
msgstr ""

#: 
msgid "Biermann, L., Clewley, D., Martinez-Vicente, V., Topouzelis, K., 2020. Finding Plastic Patches in Coastal Waters using Optical Satellite Data. Sci. Rep. 10, 1–10. https://doi.org/10.1038/s41598-020-62298-z"
msgstr ""

#: 
msgid "Themistocleous, K., Papoutsa, C., Michaelides, S., Hadjimitsis, D., 2020. Investigating detection of floating plastic litter from space using sentinel-2 imagery. Remote Sens. 12. https://doi.org/10.3390/RS12162648"
msgstr ""

#: 
msgid "Topouzelis, K., Papageorgiou, D., Karagaitanakis, A., Papakonstantinou, A., Ballesteros, M.A., 2020. Remote sensing of sea surface artificial floating plastic targets with Sentinel2 and unmanned aerial systems (plastic litter project 2019). Remote Sens. 12. https://doi.org/10.3390/rs12122013"
msgstr ""

#: 
msgid "Topouzelis, K., Papakonstantinou, A., Garaba, S.P., 2019. Detection of floating plastics from satellite and unmanned aerial systems (Plastic Litter Project 2018). Int. J. Appl. Earth Obs. Geoinf. 79, 175–183. https://doi.org/10.1016/j.jag.2019.03.011"
msgstr ""

#: 
msgid "Forecasting cropland vegetation condition"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel 2`, :index:`data used; crop_mask`, :index: `data methods; forecasting`, :index: `data methods; autoregression`"
msgstr ""

#: 
msgid "This notebook conducts time-series forecasting of vegetation condition (NDVI) using SARIMAX, a variation on `autoregressive-moving-average (ARMA) <https://en.wikipedia.org/wiki/Autoregressive%E2%80%93moving-average_model#ARMAX>`__ models which includes an integrated (I) component to difference the timeseries so it becomes stationary, a seasonal (S) component, and has the capacity to consider exogenous (X) variables."
msgstr ""

#: 
msgid "In this example, we will conduct a forecast on a univariate NDVI timeseries. That is, our forecast will be built on temporal patterns in NDVI. Conversely, multivariate approaches can account for influences of variables such as soil moisture and rainfall."
msgstr ""

#: 
msgid "In this notebook, we generate a NDVI timeseries from Sentinel-2, then use it develop a forecasting algorithm."
msgstr ""

#: 
msgid "The following steps are taken:"
msgstr ""

#: 
msgid "Load Sentinel-2 data and calculate NDVI."
msgstr ""

#: 
msgid "Mask NDVI to cropland using the crop mask."
msgstr ""

#: 
msgid "Iterate through SARIMAX parameters and conduct model selection based on cross-validation."
msgstr ""

#: 
msgid "Inspect model diagnostics"
msgstr ""

#: 
msgid "Forecast NDVI into the future and visualise the result."
msgstr ""

#: 
msgid "**Important note:** Scipy has updated and has some incompatibilities with old versions of statsmodels. If the loading packages cell below returns an error, try running ``pip install statsmodels`` or ``pip install statsmodels --upgrade`` in a code cell, then load the packages again."
msgstr ""

#: 
msgid "``lat``, ``lon``: The central latitude and longitude to analyse. In this example we'll use an agricultural area in Ethiopia."
msgstr ""

#: 
msgid "``products``: The satellite data to load, in the example we will use Sentinel-2."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse. The longer the date-range, the more data the model has to derive patterns in the NDVI timeseries."
msgstr ""

#: 
msgid "``freq``: The frequency we want to resample the time-series to e.g. for monthly time steps use ``'1M'``, for fortinightly use ``'2W'``."
msgstr ""

#: 
msgid "``forecast_length``: The length of time beyond the latest observation in the dataset that we want the model to forecast, expressed in units of resample frequency ``freq``. A longer ``forecast_length`` means greater forecast uncertainty."
msgstr ""

#: 
msgid "``resolution``: The pixel resolution (in metres) to use for loading Sentinel-2 data."
msgstr ""

#: 
msgid "``dask_chunks``: How to chunk the datasets to work with dask."
msgstr ""

#: 
msgid "Display analysis area on an interactive map"
msgstr ""

#: 
msgid "Load the satellite data"
msgstr ""

#: 
msgid "Using the parameters we defined above."
msgstr ""

#: 
msgid "Load the cropland mask over the region of interest. The default region we're analysing is in Ethiopia, so we need to load either the `crop_mask <https://explorer.digitalearth.africa/products/crop_mask>`__ product which covers the entire African continent, or the `crop_mask_eastern <https://explorer.digitalearth.africa/products/crop_mask_eastern/extents>`__ product, which cover the countries of Ethiopia, Kenya, Tanzania, Rwanda, and Burundi. If you change the analysis region from the default one, you may need to load a different crop mask - see the `docs page <https://docs.digitalearthafrica.org/en/latest/data_specs/Cropland_extent_specs.html>`__ to find out more."
msgstr ""

#: 
msgid "Now we will use the cropland map to mask the regions in the Sentinel-2 data that only have cropping."
msgstr ""

#: 
msgid "Calculate NDVI and clean the time-series"
msgstr ""

#: 
msgid "After calculating NDVI, we will smooth and interpolate the data to ensure we are working with a consistent time-series. This is a very important step in the workflow and there are many ways to smooth, interpolate, gap-fill, remove outliers, or curve-fit the data to ensure a consistent time-series. If not using the default example, you may have to define additional methods to those used here."
msgstr ""

#: 
msgid "To do this we take two steps:"
msgstr ""

#: 
msgid "Resample the data to monthly time-steps using the mean"
msgstr ""

#: 
msgid "Calculate a rolling mean with a window of 4 steps"
msgstr ""

#: 
msgid "Reduce the time-series to one dimension"
msgstr ""

#: 
msgid "In this example, we're generating a forecast on a simple 1D timeseries. This time-series represents the spatially averaged NDVI at each time-step in the series."
msgstr ""

#: 
msgid "In this step, all the calculations above are triggered and the dataset is brought into memory so this step can take a few minutes to complete."
msgstr ""

#: 
msgid "Plot the NDVI timeseries"
msgstr ""

#: 
msgid "Split data and fit a model"
msgstr ""

#: 
msgid "Cross-validation is a common method for evaluating model performance. It involves dividing data into a training set on which the model is trained, and test (or validation) set, to which the model is applied to produce predictions which are compared against actual values (that weren't used in model training)."
msgstr ""

#: 
msgid "Iteratively find the best parameters for the SARIMAX model"
msgstr ""

#: 
msgid "SARIMAX models are fitted with parameters for both the trend and seasonal components of the timeseries. The parameters can be defined as: \\* Trend elements \\* **p**: Autoregression order. This is the number of immediately preceding values in the series that are used to predict the value at the present time. \\* **d**: Difference order. The number of times that differencing is performed is called the difference order. \\* **q**: Moving average order. The size of the moving average window. \\* Seasonal elements are as above, but for the seasonal component of the timeseries. \\* **P** \\* **D** \\* **Q** \\* We also need to define the length of season. \\* **s**: In this case we use 6, which is in units of resample frequency so refers to 6 months."
msgstr ""

#: 
msgid "In the cell below, initial values and a range are given for the parameters above. Using ``range(0, 3)`` means the values 0, 1, and 2 are iterated through for each of p, d, q and P, D, Q. This means that there are :math:`3^2 \\times 3^2 = 81` possible combinations."
msgstr ""

#: 
msgid "Now will will run the function above for every iteration of parameters we have defined. Depending on the number of iterations, this can take a few minutes to run. A progress bar is printed below."
msgstr ""

#: 
msgid "Model selection"
msgstr ""

#: 
msgid "The root-mean-square error (RMSE) is a common metric used to evaluate model or forecast performance. It is the standard deviation of residuals (difference between forecast and actual value) expressed in units of the variable of interest e.g. NDVI. We can calculate RMSE of our forecast because we withheld some observations as test or validation data."
msgstr ""

#: 
msgid "We can also use either the `Akaike information criterion (AIC) <https://en.wikipedia.org/wiki/Akaike_information_criterion>`__ or `Bayesian information criterion (BIC) <https://en.wikipedia.org/wiki/Bayesian_information_criterion>`__ for model selection. Both these criteria aim to optimise the trade-off between goodness of fit and model simplicity. We are aiming to find the model that can explain the most variation in the timeseries with the least complexity, as added complexity may lead to overfitting. The BIC penalises additional parameters (greater complexity) more than the AIC."
msgstr ""

#: 
msgid "There are different schools of thought on which criterion to use. A general rule of thumb is that the BIC should be used for inference and interpretation whereas the AIC should be used for prediction. As our goal is prediction (forecasting), we could select the model with the lowest AIC, though this approach is often reserved for when there is no test data available for cross-validation."
msgstr ""

#: 
msgid "The cell below presents the top 15 models based on AIC and the RMSE on the cross-validation."
msgstr ""

#: 
msgid "Select model and predict"
msgstr ""

#: 
msgid "In the cell below. We wil select a model from the list above. In this case we've selected model ``0`` as it has the lowest RMSE, though you can select any model by setting the index number in the cell below using the ``model_sel_index`` parameter."
msgstr ""

#: 
msgid "Plot model diagnostics"
msgstr ""

#: 
msgid "There are some typical plots we can use to evaluate our model."
msgstr ""

#: 
msgid "**Standardised residuals (top-left)** The standardised residuals are plotted against x (time) values. This allows us to check that variance (distance of residuals from 0) is constant across time values. There should be no obvious patterns."
msgstr ""

#: 
msgid "**Histogram and estimated density (top-right)** A kernel density estimation (KDE) is an estimated probability density function fitted on the actual distribution (histogram) of standardised residuals. A normal distribution (N (0,1)) is shown for reference. This plot shows that the distribution of our standardised residuals is close to normally distributed."
msgstr ""

#: 
msgid "**Normal quantile-quantile (Q-Q) plot (bottom-left)** This plot shows 'expected' or 'theoretical' quantiles drawn from a normal distribution on the x-axis against quantiles taken from the sample of residuals on the y-axis. If the observations in blue match the 1:1 line in red, then we can conclude that our residuals are normally distributed."
msgstr ""

#: 
msgid "**Correlogram (bottom-right)** The correlations for lags greater than 0 should not be statistically significant. That is, they should not be outside the blue ribbon."
msgstr ""

#: 
msgid "Note: The Q-Q plot and correlogram generated for model ``0`` show there is some pattern in the residuals. That is, there is remaining variation in the data which the model has not accounted for. You could experiment with different parameter values or model selection in the prior steps to see if this can be addressed."
msgstr ""

#: 
msgid "Backtest forecast"
msgstr ""

#: 
msgid "We saved the last 10 observations as test data above. Now we can use our model to predict NDVI for those time-steps and compare those predictions with actual values. We can do this visually in the graph below and also quantify the error with the root-mean-square error (RMSE)."
msgstr ""

#: 
msgid "Plot the result of our forecast"
msgstr ""

#: 
msgid "To forecast NDVI into the future, we'll run a model on the entire time series so we can include the latest observations. We can see that the forecast uncertainty, expressed as the 95% confidence interval, increases with time."
msgstr ""

#: 
msgid "Our forecast looks reasonable in the context of the timeseries above."
msgstr ""

#: 
msgid "**License:** The code in this notebook is licensed under the `Apache License, Version 2.0 <https://www.apache.org/licenses/LICENSE-2.0>`__. Digital Earth Australia data is licensed under the `Creative Commons by Attribution 4.0 <https://creativecommons.org/licenses/by/4.0/>`__ license."
msgstr ""

#: 
msgid "**Contact:** If you need assistance, please post a question on the `Open Data Cube Slack channel <http://slack.opendatacube.org/>`__ or on the `GIS Stack Exchange <https://gis.stackexchange.com/questions/ask?tags=open-data-cube>`__ using the ``open-data-cube`` tag (you can view previously asked questions `here <https://gis.stackexchange.com/questions/tagged/open-data-cube>`__). If you would like to report an issue with this notebook, you can file one on `Github <https://github.com/GeoscienceAustralia/dea-notebooks>`__."
msgstr ""

#: 
msgid "**Last modified:** January 2022"
msgstr ""

#: 
msgid "Monitoring changes in forest extent"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; Global Forest Change`"
msgstr ""

#: 
msgid "Forests worldwide are in a state of flux, with accelerating losses in some regions and gains in others `(Hansen et al., 2013) <https://doi.org/10.1126/science.1244693>`__. The Global Forest Change 2000-2021 dataset characterizes the global forest extent and change from 2000 to 2021."
msgstr ""

#: 
msgid "For this dataset: - Forest loss is defined as stand-replacement disturbance, or a change from a forest to non-forest state - Forest gain is defined as the inverse of as the inverse of loss, or a non-forest to forest change entirely within the study period - Tree cover is defined as canopy closure for all vegetation taller than 5m in height."
msgstr ""

#: 
msgid "The Year of gross forest cover loss event (``lossyear``) layer shows the forest loss during the period 2000 to 2021. Forest loss is encoded as either 0 (no loss) or else a value in the range 1-20, representing loss detected primarily in the year 2001-2021, respectively."
msgstr ""

#: 
msgid "The Tree canopy cover for year 2000 (``treecover2000``) layer shows the tree cover in the year 2000."
msgstr ""

#: 
msgid "The Global forest cover gain 2000–2012 (``gain``) layer shows the forest gain during the period 2000 to 2012. Forest gain is encoded as either 1 (gain) or 0 (no gain)."
msgstr ""

#: 
msgid "This notebook provide an interactive tool for selecting, loading and plotting the Global Forest Change \"``lossyear``\", \"``treecover2000``\" and \"``gain``\" layers in order to monitor forests."
msgstr ""

#: 
msgid "Digital Earth Africa forest monitoring app"
msgstr ""

#: 
msgid "Run the ``forestmonitoring.forest_monitoring_app()`` cell below to launch the interactive application that is used to select the area to load and plot the Global Forest Change layer."
msgstr ""

#: 
msgid "Selecting parameters"
msgstr ""

#: 
msgid "On the left of the map, you will see a list of basemaps you can use for plotting and a list of Global Forest Change layers you can load:"
msgstr ""

#: 
msgid "Global Forest Change layers available"
msgstr ""

#: 
msgid "**Year of gross forest cover loss event**"
msgstr ""

#: 
msgid "Shows forest loss during the period 2000–2021"
msgstr ""

#: 
msgid "**Global forest cover gain 2000–2012**"
msgstr ""

#: 
msgid "Shows forest gain during the period 2000-2012"
msgstr ""

#: 
msgid "**Tree canopy cover for year 2000**"
msgstr ""

#: 
msgid "Show the tree canopy cover for the year 2000"
msgstr ""

#: 
msgid "**All layers**"
msgstr ""

#: 
msgid "Show the forest loss during the period 2000–2021, forest gain during the period 2000-2012 and the tree canopy cover for the year 2000"
msgstr ""

#: 
msgid "Use the ``Forest Cover Loss Time Range`` slider to set the time range for which to load the **Year of gross forest cover loss event** layer. Tick the ``Override maximum size limit`` box to override the app's default 500 square kilometres area limit. This can be used to load larger areas of imagery, but should be used with caution as it can lead to memory issues or crashes."
msgstr ""

#: 
msgid "Selecting a location to plot"
msgstr ""

#: 
msgid "Zoom into the map to a location you wish to plot. Select the ``Draw a rectangle`` tool or the ``Draw a polygon tool`` on the left of the map, and draw a shape around the forest area you are interested in. When you are ready, press the blue ``Generate plot`` button on the bottom left to plot the Global Forest Change layer selected for the area drawn on the map."
msgstr ""

#: 
msgid "**Optional:** Upload a GeoJSON or ESRI Shapefile containing the area of interest geometry using the ``Upload`` button (uploaded files should be less than 5 megabytes in size)."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings above. This will demonstrate how the analysis works and provide meaningful results."
msgstr ""

#: 
msgid "When you have exported your first plot, select a different area and rerun the analysis by clicking ``Generate plot``."
msgstr ""

#: 
msgid "Exporting satellite imagery animations"
msgstr ""

#: 
msgid "**Products used:** `ls5_sr <https://explorer.digitalearth.africa/products/ls5_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/products/ls7_sr>`__, `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/products/ls9_sr>`__, `s2_l2a <https://explorer.digitalearth.africa/products/s2_l2a>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`data used; landsat 9`, :index:`data used; sentinel 2`, :index:`animation`,"
msgstr ""

#: 
msgid "Most of the case studies in this repository focus on quantitatively analysing satellite data to obtain insights into Africa's changing environment. However, satellite imagery can also be used as a powerful tool for visualisation, particularly within dynamic environments that have changed significantly over the past ~30 years."
msgstr ""

#: 
msgid "Animations produced from satellite images can help explain dynamic physical processes, highlight change over time, or provide valuable context to better understand the impacts of recent environmental events such as flooding or fire. Satellite animations can also be processed to create images of the landscape based on invisible wavelengths of light (e.g. false colour images), allowing us to obtain richer insights into features and processes that would otherwise be invisible to the human eye."
msgstr ""

#: 
msgid "**Digital Earth Africa** provides over three decades of satellite imagery across the entire continent of Africa. Satellite data from the `NASA/USGS Landsat program <https://www.usgs.gov/land-resources/nli/landsat>`__ allow us to produce fortnightly images of Africa's diverse natural and artificial landscapes at any time since 1986. More recently, the `Copernicus Sentinel-2 mission <https://sentinel.esa.int/web/sentinel/missions/sentinel-2>`__ has provided even higher resolution imagery as frequently as every 5 days since 2015."
msgstr ""

#: 
msgid "This notebook provides an interactive tool for selecting, loading, processing and exporting satellite imagery as high quality animated MP4 and GIF files. This can be used in combination with the interactive `Digital Earth Africa Maps <https://maps.digitalearth.africa/>`__ platform to identify an image of interest, then download it using this notebook for use in other applications."
msgstr ""

#: 
msgid "Digital Earth Africa satellite imagery animation app"
msgstr ""

#: 
msgid "Run the ``animations.animation_app()`` cell below to launch the interactive application that is used to select the area to load and export satellite imagery animations."
msgstr ""

#: 
msgid "On the left of the map, you will see a date selector, and a list of satellite imagery you can load:"
msgstr ""

#: 
msgid "**\"Landsat\"**"
msgstr ""

#: 
msgid "Data from the Landsat 5, 7, 8 and 9 satellites"
msgstr ""

#: 
msgid "Data from the Sentinel-2A and 2B satellites"
msgstr ""

#: 
msgid "Satellite imagery can be viewed and exported in two colour styles:"
msgstr ""

#: 
msgid "You can also modify the brightness and contrast of the output image by dragging the ``Colour percentile stretch`` slider, and select the output image format from ``.MP4`` (smaller file sizes, higher quality, fast processing speeds) to ``.GIF`` (larger file sizes, lower quality, slower processing)."
msgstr ""

#: 
msgid "Tick the ``Apply rolling median`` box to produce a smooth animation that reduces the influence of cloud and noise. The larger the rolling median window, the smoother the output (at the expense of potentially removing short-lived events from the animation)."
msgstr ""

#: 
msgid "Selecting a location to export"
msgstr ""

#: 
msgid "Zoom into the map to a location you wish to animate. Select the ``Draw a rectangle`` tool on the left of the map, and draw a shape around the area you are interested in. When you are ready, press the green ``Generate animation`` button on the bottom left to start the animation generation."
msgstr ""

#: 
msgid "To keep load times reasonable, the app is restricted to image exports **smaller than 50000 hectares** in size. This limit can be overuled in the ``Advanced`` settings."
msgstr ""

#: 
msgid "Advanced settings"
msgstr ""

#: 
msgid "The animation tool supports several advanced features. To access these, click on the ``Advanced`` tab in the menu to the left of the map to expand it: \\* ``Frame interval``: The frame rate used to animate the satellite data. Values are in milliseconds - larger values will produce a longer, slower animation. \\* ``Resolution``: The spatial resolution to load data (in metres). By default, the tool will automatically set the best possible resolution depending on the satellites selected (i.e. 30 m for Landsat, 10 m for Sentinel-2). Increasing this (e.g. to ``100``) can be useful for loading large spatial extents. \\* ``Width of output animation``: The width of the animation MP4 or GIF file in pixels. This can be used to produce a HD video, but won't increase the resolution of the input satellite imagery (setting a high value will produce a larger animation, but may introduce unwanted pixelation). \\* ``Apply temporal resampling``: Whether to combine multiple satellite images into time period median composite images. Available options are ``None``, ``monthly``, ``quarterly`` and ``annually``. \\* ``Mask out cloudy pixels``: Whether to mask out cloudy pixels with ``nodata`` to remove them from the animation. This is best used in combination with a rolling median or temporal resampling, as otherwise it will introduce large areas of black ``nodata`` pixels in the animation. \\* ``Add DE Africa Coastlines overlay``: Whether to add annual shoreline vectors from the Digital Earth Africa Coastlines product as an overlay on top of the animation. \\* ``Apply power transformation``: Raises imagery by a power to reduce bright features and enhance dark features. This can add extra definition over areas with extremely bright features like snow, beaches or salt pans. \\* ``Apply unsharp masking`` Whether to apply unsharp masking to increase the sharpness of the output image. If activated, you can specify both the radius (in pixels) and the amount/strength of the sharpening. \\* ``Override maximum size limit``: Whether to override the app's default 500 square km area limit. This can be used to load larger areas of satellite imagery, but should be used with caution as it can lead to memory issues or crashes."
msgstr ""

#: 
msgid "Downloading exported animation"
msgstr ""

#: 
msgid "The animation will be completed when ``Finished exporting animation`` appears, and a preview of your animation is shown below the map."
msgstr ""

#: 
msgid "The animation file (MP4 or GIF) will be saved to the same location you are running this notebook from (e.g. typically ``Real_world_examples``). In JupyterLab, use the file browser to locate the image file with a name in the following format:"
msgstr ""

#: 
msgid "``landsat_bitillifoundihaut-mbomou_2019-07-06_2022-07-06_truecolour_30m.mp4``"
msgstr ""

#: 
msgid "If you are using the **DE Africa Analysis Sandbox**, you can download the animation to your PC by right clicking on the image file and selecting ``Download``."
msgstr ""

#: 
msgid "When you have exported your first animation, modify some parameters and rerun the analysis by clicking ``Generate animation``. For example, you could try:"
msgstr ""

#: 
msgid "Applying a rolling median to produce a smooth animation that highlights long-term change over time."
msgstr ""

#: 
msgid "Generate an animation for new dates using the date selectors."
msgstr ""

#: 
msgid "Changing the satellite data to ``\"Sentinel-2\"`` to export a Sentinel-2 animation instead of Landsat."
msgstr ""

#: 
msgid "Selecting the ``\"False colour\"`` style to export a false colour view of the landscape that highlights growing vegetation and water."
msgstr ""

#: 
msgid "Specify a custom resolution in the ``Advanced`` tab, e.g. ``100``."
msgstr ""

#: 
msgid "Experiment with different colour percentile stretches and the ``Advanced`` tab unsharp masking and power transformation functionality to alter the appearance of the resulting image."
msgstr ""

#: 
msgid "Modelling intertidal elevation using tidal data"
msgstr ""

#: 
msgid "**Prerequisites:** For more information about the tidal modelling step of this analysis, refer to the `Tidal modelling notebook <../Frequently_used_code/Tidal_modelling.ipynb>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`water; tide modelling`, :index:`water; waterline extraction`, :index:`band index; NDWI`, `data methods; compositing`"
msgstr ""

#: 
msgid "Intertidal environments support important ecological habitats (e.g. sandy beaches and shores, tidal flats and rocky shores and reefs), and provide many valuable benefits such as storm surge protection, carbon storage and natural resources for recreational and commercial use. However, intertidal zones are faced with increasing threats from coastal erosion, land reclamation (e.g. port construction), and sea level rise. Accurate elevation data describing the height and shape of the coastline is needed to help predict when and where these threats will have the greatest impact. However, this data is expensive and challenging to map across the entire intertidal zone of a continent the size of Africa."
msgstr ""

#: 
msgid "The rise and fall of the tide can be used to reveal the three-dimensional shape of the coastline by mapping the boundary betweeen water and land across a range of known tides (e.g. from low tide to high tide). Assuming that the land-water boundary is a line of constant height relative to mean sea level (MSL), elevations can be modelled for the area of coastline located between the lowest and highest observed tide."
msgstr ""

#: 
msgid "Imagery from satellites such as the NASA/USGS Landsat program is available for free for the entire planet, making satellite imagery a powerful and cost-effective tool for modelling the 3D shape and structure of the intertidal zone at regional or national scale."
msgstr ""

#: 
msgid "Reference: `Bishop-Taylor et al. 2019 <https://doi.org/10.1016/j.ecss.2019.03.006>`__, the first 3D model of Australia's entire coastline: the National Intertidal Digital Elevation Model."
msgstr ""

#: 
msgid "In this example, we demonstrate a simplified version of the National Intertidal Digital Elevation Model (NIDEM) method that combines data from the Landsat 5, 7 and 8 satellites with tidal modelling, image compositing and spatial interpolation techniques. We first map the boundary between land and water from low to high tide, and use this information to generate smooth, continuous 3D elevation maps of the intertidal zone. The resulting data may assist in mapping the habitats of threatened coastal species, identifying areas of coastal erosion, planning for extreme events such as storm surges and flooding, and improving models of how sea level rise will affect the coastline. This worked example takes users through the code required to:"
msgstr ""

#: 
msgid "Load in a cloud-free Landsat time series."
msgstr ""

#: 
msgid "Compute a water index (NDWI)."
msgstr ""

#: 
msgid "Tag and sort satellite images by tide height."
msgstr ""

#: 
msgid "Create \"summary\" or composite images that show the distribution of land and water at discrete intervals of the tidal range (e.g. at low tide, high tide)."
msgstr ""

#: 
msgid "Extract and visualise the topography of the intertidal zone as depth contours."
msgstr ""

#: 
msgid "Interpolate depth contours into a smooth, continuous Digital Elevation Model (DEM) of the intertidal zone."
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``11.228``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``-15.860``)."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2000', '2019')``)"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example generates an intertidal elevation model for an area off the coast of Guinea Bissau."
msgstr ""

#: 
msgid "To ensure that the tidal modelling part of this analysis works correctly, please make sure the **centre of the study area is located over water** when setting ``lat`` and ``lon``."
msgstr ""

#: 
msgid "Load cloud-masked Landsat data"
msgstr ""

#: 
msgid "The first step in this analysis is to load in Landsat data for the ``lat_range``, ``lon_range`` and ``time_range`` we provided above. The code below uses the ``load_ard`` function to load in data from the Landsat 5, 7 and 8 satellites for the area and time specified. For more infmation, see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__. The function will also automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data:"
msgstr ""

#: 
msgid "To visualise the data, use the pre-loaded ``rgb`` utility function to plot a true colour image for a given time-step. White areas indicate where clouds or other invalid pixels in the image have been masked."
msgstr ""

#: 
msgid "Change the value for ``timestep`` and re-run the cell to plot a different timestep (timesteps are numbered from ``0`` to ``n_time - 1`` where ``n_time`` is the total number of timesteps; see the ``time`` listing under the ``Dimensions`` category in the dataset print-out above)."
msgstr ""

#: 
msgid "Compute Normalised Difference Water Index"
msgstr ""

#: 
msgid "To extract intertidal depth contours, we need to be able to seperate water from land in our study area. To do this, we can use our Landsat data to calculate a water index called the ``Normalised Difference Water Index``, or NDWI. This index uses the ratio of green and near-infrared radiation to identify the presence of water. The formula is:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDWI} &= \\frac{(\\text{Green} - \\text{NIR})}{(\\text{Green} + \\text{NIR})}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "where ``Green`` is the green band and ``NIR`` is the near-infrared band."
msgstr ""

#: 
msgid "When it comes to interpreting the index, **High values (greater than 0, blue colours) typically represent water pixels**, while **low values (less than 0, red colours) represent land**. You can use the cell below to calculate and plot one of the images after calculating the index."
msgstr ""

#: 
msgid "How does the plot of the index compare to the optical image from earlier? Was there water or land anywhere you weren't expecting?"
msgstr ""

#: 
msgid "Model tide heights"
msgstr ""

#: 
msgid "The location of the shoreline can vary greatly from low to high tide. In the code below, we aim to calculate the height of the tide at the exact moment each Landsat image was acquired. This will allow us to built a sorted time series of images taken at low tide to high tide, which we will use to generate the intertidal elevation model."
msgstr ""

#: 
msgid "The ``tidal_tag`` function below uses the `OTPS TPXO8 tidal model <https://www.tpxo.net/global/tpxo8-atlas>`__ to calculate the height of the tide at the exact moment each satellite image in our dataset was taken, and adds this as a new ``tide_m`` attribute in our dataset (for more information about this function, refer to the `Tidal modelling notebook <../Frequently_used_code/Tidal_modelling.ipynb>`__)."
msgstr ""

#: 
msgid "**Note:** this function can only model tides correctly if the centre of your study area is located over water. If this isn't the case, you can specify a custom tide modelling location by passing a coordinate to ``tidepost_lat`` and ``tidepost_lon`` (e.g. ``tidepost_lat=11.228, tidepost_lon=-15.860``)."
msgstr ""

#: 
msgid "Now that we have modelled tide heights, we can plot them to visualise the range of tide that was captured by Landsat across our time series:"
msgstr ""

#: 
msgid "Create water index summary images from low to high tide"
msgstr ""

#: 
msgid "Using these tide heights, we can sort our Landsat dataset by tide height to reveal which parts of the landscape are inundated or exposed from low to high tide."
msgstr ""

#: 
msgid "Individual remote sensing images can be affected by noise, including clouds, sunglint and poor water quality conditions (e.g. sediment). To produce cleaner images that can be compared more easily between tidal stages, we can create 'summary' images or composites that combine multiple images into one image to reveal the 'typical' or median appearance of the landscape at different tidal stages. In this case, we use the median as the summary statistic because it prevents strong outliers (like stray clouds) from skewing the data, which would not be the case if we were to use the mean."
msgstr ""

#: 
msgid "In the code below, we take the time series of images, sort by tide and categorise each image into 9 discrete tidal intervals, ranging from the lowest (tidal interval 1) to the highest tides observed by Landsat (tidal interval 9). For more information on this method, refer to `Sagar et al. 2018 <https://www.sciencedirect.com/science/article/pii/S0034425717301591>`__."
msgstr ""

#: 
msgid "We can plot the boundaries between the nine tidal intervals on the same plot we generated earlier:"
msgstr ""

#: 
msgid "Now that we have a dataset where each image is classified into a discrete range of the tide, we can combine our images into a set of nine individual images that show where land and water is located from low to high tide. **This step can take several minutes to process.**"
msgstr ""

#: 
msgid "The plot above should make it clear how the shape and structure of the coastline changes significantly from low to high tide as low-lying tidal flats are quickly inundated by increasing water levels."
msgstr ""

#: 
msgid "Extract depth contours from imagery"
msgstr ""

#: 
msgid "We now want to extract an accurate boundary between land and water for each of the tidal intervals above. The code below identifies the depth contours based on the boundary between land and water by tracing a line along pixels with a water index value of ``0`` (the boundary between land and water water index values). It returns a ``geopandas.GeoDataFrame`` with one depth contour for each tidal interval that is labelled with tide heights in metres relative to Mean Sea Level."
msgstr ""

#: 
msgid "The above plot is a basic visualisation of the depth contours returned by the ``subpixel_contours`` function. **Deeper contours (in m relative to Mean Sea Level) are coloured in yellow; more shallow contours are coloured in red.** Now have the shapefile, we can use a more complex function to make an interactive plot for viewing the topography of the intertidal zone."
msgstr ""

#: 
msgid "Plot interactive map of depth contours coloured by time"
msgstr ""

#: 
msgid "The next cell provides an interactive map with an overlay of the depth contours identified in the previous cell. Run it to view the map."
msgstr ""

#: 
msgid "Zoom in to the map below to explore the resulting set of depth contours. Using this data, we can easily identify areas of the coastline which are only exposed in the lowest of tides, or other areas that are only covered by water during high tides."
msgstr ""

#: 
msgid "Interpolate contours into a Digital Elevation Model (DEM)"
msgstr ""

#: 
msgid "While the contours above provide valuable information about the topography of the intertidal zone, we can extract additional information about the 3D structure of the coastline by converting them into an elevation raster (i.e. a Digital Elevation Model or DEM)."
msgstr ""

#: 
msgid "In the cell below, we convert the shapefile above into an array of points with X, Y and Z coordinates, where the Z coordinate is the point's elevation relative to Mean Sea Level. We then use these XYZ points to interpolate smooth, continuous elevations across the intertidal zone using linear interpolation."
msgstr ""

#: 
msgid "You can see in the output above that our interpolation results are very messy. This is because the interpolation extends across areas of our study area that are not affected by tides (e.g. areas of water located beyond the lowest observed tide, and on land). To clean up the data, we can restrict the DEM to only the area between the lowest and highest observed tides:"
msgstr ""

#: 
msgid "Export intertidal DEM as a GeoTIFF"
msgstr ""

#: 
msgid "As a final step, we can take the intertidal DEM we created and export it as a GeoTIFF that can be loaded in GIS software like QGIS or ArcMap (to download the dataset from the Sandbox, locate it in the file browser to the left, right click on the file, and select \"Download\")."
msgstr ""

#: 
msgid "When you are done, return to the \"Set up analysis\" cell, modify some values (e.g. ``time_range``, ``lat`` and ``lon``) and rerun the analysis."
msgstr ""

#: 
msgid "If you're going to change the location, you'll need to make sure Landsat 5, 7 and 8 data is available for the new location, which you can check at the `DEAfrica Explorer <https://explorer.digitalearth.africa/products>`__ (use the drop-down menu to view all Landsat products)."
msgstr ""

#: 
msgid "National Intertidal Digital Elevation Model"
msgstr ""

#: 
msgid "For more information about the science behind this notebook, please refer to the scientific article outlining the application of this approach to the entire Australian coastline: `Bishop-Taylor et al. 2019 Between the tides: Modelling the elevation of Australia's exposed intertidal zone at continental scale <https://doi.org/10.1016/j.ecss.2019.03.006>`__."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; Sentinel-2`, :index:`water; tide modelling`, :index:`water; waterline extraction`, :index:`band index; NDWI`, `data methods; compositing`"
msgstr ""

#: 
msgid "Imagery from satellites such as the Copernicus Sentinel-2 program is available for free for the entire planet, making satellite imagery a powerful and cost-effective tool for modelling the 3D shape and structure of the intertidal zone at regional or national scale."
msgstr ""

#: 
msgid "In this example, we demonstrate a simplified version of the National Intertidal Digital Elevation Model (NIDEM) method that combines data from Sentinel-2 satellite with tidal modelling, image compositing and spatial interpolation techniques. We first map the boundary between land and water from low to high tide, and use this information to generate smooth, continuous 3D elevation maps of the intertidal zone. The resulting data may assist in mapping the habitats of threatened coastal species, identifying areas of coastal erosion, planning for extreme events such as storm surges and flooding, and improving models of how sea level rise will affect the coastline. This worked example takes users through the code required to:"
msgstr ""

#: 
msgid "Load in a cloud-free Sentinel-2 time series."
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``-11.384``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``43.287``)."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2017', '2022')``)"
msgstr ""

#: 
msgid "Load cloud-masked Sentinel-2 data"
msgstr ""

#: 
msgid "The first step in this analysis is to load in Sentinel-2 data for the ``lat_range``, ``lon_range`` and ``time_range`` we provided above. The code below uses the ``load_ard`` function to load in Sentinel-2 analysis-ready data for the area and time specified. For more infmation, see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__. The function will also automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data:"
msgstr ""

#: 
msgid "To extract intertidal depth contours, we need to be able to seperate water from land in our study area. To do this, we can use our Sentinel-2 data to calculate a water index called the ``Normalised Difference Water Index``, or NDWI. This index uses the ratio of green and near-infrared radiation to identify the presence of water. The formula is:"
msgstr ""

#: 
msgid "The location of the shoreline can vary greatly from low to high tide. In the code below, we aim to calculate the height of the tide at the exact moment each Sentinel-2 image was acquired. This will allow us to built a sorted time series of images taken at low tide to high tide, which we will use to generate the intertidal elevation model."
msgstr ""

#: 
msgid "Using these tide heights, we can sort our Sentinel-2 dataset by tide height to reveal which parts of the landscape are inundated or exposed from low to high tide."
msgstr ""

#: 
msgid "In the code below, we take the time series of images, sort by tide and categorise each image into 9 discrete tidal intervals, ranging from the lowest (tidal interval 1) to the highest tides observed by Sentinel-2 (tidal interval 9). For more information on this method, refer to `Sagar et al. 2018 <https://www.sciencedirect.com/science/article/pii/S0034425717301591>`__."
msgstr ""

#: 
msgid "If you're going to change the location, you'll need to make sure Sentinel-2 data is available for the new location, which you can check at the `DEAfrica Explorer <https://explorer.digitalearth.africa/products>`__."
msgstr ""

#: 
msgid "Identifying active irrigated cropping"
msgstr ""

#: 
msgid "**Products used:** `ls8_st <https://explorer.digitalearth.africa/ls8_st>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__, `ERA5 Climate Data <https://registry.opendata.aws/ecmwf-era5/>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 8`, :index:`datasets; landsat 8`, :index:`surface temperature`, :index:`data used; ERA5`, :index:`datasets; ERA5`, :index:`climate`, :index:`temperature`"
msgstr ""

#: 
msgid "One of the well-known measures of plant health is canopy temperature. In conditions with limited water, it can be assumed transpiration decreases and plant temperature subsequently increases. This can often happen during periods of moisture stress in dryland (rainfed) cropping systems but can be overcome by water application in irrigated cropping systems."
msgstr ""

#: 
msgid "In the field, canopy temperatures can be measured by handheld radiometers. This sort of data is used at a small scale to examine crop health and yield under a variety of conditions. At larger scales, an alternative method is to use surface temperature detected by satellites such as Landsat 8 to calculate similar metrics. In this notebook, we will use :math:`\\Delta T` to differentiate between dryland and irrigated cropland, where :math:`\\Delta T` is:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\Delta T = T_c - T_a \\end{equation}`"
msgstr ""

#: 
msgid "where"
msgstr ""

#: 
msgid ":math:`T_c` is crop canopy temperature"
msgstr ""

#: 
msgid ":math:`T_a` is air temperature"
msgstr ""

#: 
msgid "Lower :math:`\\Delta T` is associated with higher rates of transpiration as evaporative cooling from transpiration cools the canopy, while higher :math:`\\Delta T` indicates lower rates of transpiration and thereby moisture stress."
msgstr ""

#: 
msgid "In this case, we will use measurements of air temperature modelled by ERA5 to approximate :math:`T_a` and the Landsat surface temperature product to approximate :math:`T_c`."
msgstr ""

#: 
msgid "In this notebook, we calculate :math:`\\Delta T` and visualise over irrigated areas."
msgstr ""

#: 
msgid "Load Landsat 8 Surface Temperature data"
msgstr ""

#: 
msgid "Load ERA5 \"Air temperature at 2 metres\" data for the same area of interest"
msgstr ""

#: 
msgid "Calculate :math:`\\Delta T`"
msgstr ""

#: 
msgid "Visualise :math:`\\Delta T`"
msgstr ""

#: 
msgid "Use a simple cluster analysis to differentiate between irrigated and dryland cropping."
msgstr ""

#: 
msgid "Map irrigated cropping within the area of interest."
msgstr ""

#: 
msgid "This analysis focuses on cropland in Sudan. The western portion of the area of interest appear irrigated, as it is serviced by canals on close inspection, and vegetation is greener than surrounding landscape features. The eastern portion of the area is mostly dryland cropping."
msgstr ""

#: 
msgid "Convert to celsius and resample to annual means"
msgstr ""

#: 
msgid "Load ERA5 Air Temperature data"
msgstr ""

#: 
msgid "While Landsat 8 will observe a given location once every few days, ERA5 provides hourly observations. As such, the next step calculates the monthly average air temperature from ERA5, using the ``resample`` and ``reduce_func`` arguments. The load_era5 function returns the temperature in Kelvin, so it must be converted to Celcius using the offset."
msgstr ""

#: 
msgid "After calculating this, the last step is to take the average of the monthly means to get a seasonal mean air temperature, which will be used for the analysis."
msgstr ""

#: 
msgid "The above plots show the data has loaded correctly. Note that ERA5 has a much lower spatial resolution than Landsat 8 (approximately 31km compared to 30m) but has a much higher temporal resolution."
msgstr ""

#: 
msgid "It is also expected that land temperature will be higher than 2 metre air temperature."
msgstr ""

#: 
msgid "Note the land temperature estimated by Landsat 8 can seem quite high; here, it is shown in excess of 40 degrees Celsius. In this notebook, we do not have the means to validate the dataset so it is difficult to tell if the readings are accurate, or exaggerated due to inherent instrumentation error. Regardless, this is mitigated by :math:`\\Delta T` which looks at the difference between temperatures instead of absolute values."
msgstr ""

#: 
msgid "As noted in the introduction, for this exercise we estimate :math:`\\Delta T` using the loaded temperature datasets in lieu of in-situ data. This can be broken down into the following steps:"
msgstr ""

#: 
msgid "Resample the air temperature to match the spatial resolution of Landsat. This is done using the ``xr_reproject`` function."
msgstr ""

#: 
msgid "Calculate the difference (:math:`\\Delta T`) between :math:`T_c` (land temperature) and :math:`T_a` (air temperature)"
msgstr ""

#: 
msgid "Calculate :math:`\\Delta T`:"
msgstr ""

#: 
msgid "Load Landsat-8 Surface Reflectance data and calculate NDVI"
msgstr ""

#: 
msgid "Use the Cropland extent product for masking cropping regions"
msgstr ""

#: 
msgid "We can use :math:`\\Delta T` to differentiate between irrigated and dryland cropping, but to do this we need to restrict our analysis to cropland and exclude other landscape features. We can do this using the cropland extent product, which we load below."
msgstr ""

#: 
msgid "Load crop mask"
msgstr ""

#: 
msgid "Identify clusters for classification"
msgstr ""

#: 
msgid "We have two variables (NDVI and :math:`\\Delta T`) that we'd like to use to split dryland and irrigated cropland."
msgstr ""

#: 
msgid "We can use a cluster technique to assign the data to these classes. In this case, we'll use k-means clustering to identify two clusters (irrigated and rainfed)."
msgstr ""

#: 
msgid "As the two variables have quite different units, we'll need to rescale them before running the cluster analysis. This is shown in the cell below."
msgstr ""

#: 
msgid "Plot the clusters"
msgstr ""

#: 
msgid "The plot below shows the 2D histogram of the NDVI-\\ :math:`\\Delta T` pairs (conveying the density of points), as well as a scatter plot showing which cluster each pair was assigned to. Both plots display the centre of each cluster."
msgstr ""

#: 
msgid "The density shows two distinct clusters that the k-means algorithm has identified in the data. We assume to cluster to the bottom-right (higher NDVI and lower :math:`\\Delta T`) is the irrigated cropland."
msgstr ""

#: 
msgid "Apply clusters to the spatial data"
msgstr ""

#: 
msgid "Load semi-annual geomedian to compare classification to a true-colour image."
msgstr ""

#: 
msgid "Plot result"
msgstr ""

#: 
msgid "The following produces a three-panel plot, showing the geomedian for reference, then the total cropland extent, and finally, areas classified as active irrigation in yellow."
msgstr ""

#: 
msgid "This method of calculating :math:`\\Delta T` is based on several key assumptions:"
msgstr ""

#: 
msgid "Air temperature is reasonably approximated by ERA5"
msgstr ""

#: 
msgid "Land temperature is reasonably approximated by Landsat 8 Surface Temperature"
msgstr ""

#: 
msgid "The cluster based differentiation of irrigated and dryland cropping is reliant on these two features being related these variables. This approach may be less effective in some scenarios, such as:"
msgstr ""

#: 
msgid "Wet seasons where dryland crops are experiencing low levels of moisture stress and high canopy greenness."
msgstr ""

#: 
msgid "Cold times when :math:`\\Delta T` may not be a good indicator of crop moisture stress."
msgstr ""

#: 
msgid "As always, results should be interpreted with context and care."
msgstr ""

#: 
msgid "Jackson, Ray D., Kustas, William P., and Choudhury, Bhaskar J. 1988. 'A Reexamination of the Crop Water Stress Index'. *Irrig Sci* 9:309-317"
msgstr ""

#: 
msgid "Machine learning with the Open Data Cube"
msgstr ""

#: 
msgid "**Special requirements:** A shapefile of labelled data is required to use this notebook. An example dataset is provided."
msgstr ""

#: 
msgid "**Prerequisites:** A basic understanding of supervised learning techniques is required."
msgstr ""

#: 
msgid "`Introduction to statistical learning <https://link.springer.com/book/10.1007/978-1-0716-1418-1>`__ is a useful resource to begin with - it can be downloaded for free `here <https://hastie.su.domains/ISLR2/ISLRv2_website.pdf>`__."
msgstr ""

#: 
msgid "The `Scikit-learn <https://scikit-learn.org/stable/supervised_learning.html>`__ documentation provides information on the available models and their parameters."
msgstr ""

#: 
msgid "This `article <https://www.tandfonline.com/doi/full/10.1080/01431161.2018.1433343>`__ provides a nice review of machine learning in the context of remote sensing."
msgstr ""

#: 
msgid "**Note**: For a more detailed exploration of machine learning on the ODC, see the notebook series: **Scalable machine learning in the ODC** in the ``Real_world_examples/Scalable_machine_learning/`` folder."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2 geomedian`, index:`data used; MADs`, :index:`urban`, :index:`landcover`, :index:`data methods; machine learning`, :index:`machine learning; supervised classification`"
msgstr ""

#: 
msgid "This notebook demonstrates a potential workflow using functions from the `deafrica_tools.classification <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.classification.html>`__ script to implement a ``supervised learning`` landcover classifier within the `ODC (Open Data Cube) <https://www.opendatacube.org/>`__ framework. The notebook uses a default shapefile of training data (provided for demonstration purposes only) to classify ``urban areas`` in Kampala, Uganda"
msgstr ""

#: 
msgid "**Note**: Users who have their own training data can directly import their own shapefile by uploading their shapefile into the Sandbox and adjusting the ``path`` parameter."
msgstr ""

#: 
msgid "Train a simple decision tree model and adjust parameters"
msgstr ""

#: 
msgid "Predict urban areas using the trained model on new data"
msgstr ""

#: 
msgid "Evaluate the output of the classification using quantitative metrics"
msgstr ""

#: 
msgid "Plot the results and visually assess the classification"
msgstr ""

#: 
msgid "Export the results as a geotiff"
msgstr ""

#: 
msgid "``lat``, ``long`` & ``buffer``: The centre location and buffer for your area of interest, this will define the box from which we extract satellite data to classify when we make the prediction."
msgstr ""

#: 
msgid "``path``: The path to the input shapefile. A default shapefile is provided."
msgstr ""

#: 
msgid "``field``: This is the name of column in your shapefile attribute table that contains the class labels"
msgstr ""

#: 
msgid "``product``: The name of the product to extract. In this example we use a Sentinel-2 geomedian composite from 2019, ``'ga_s2_gm'``"
msgstr ""

#: 
msgid "``time``: The time range you wish to extract data for, typically the same date the labels were created."
msgstr ""

#: 
msgid "``zonal_stats``: This is an option to calculate the ``'mean'``, ``'median'``, ``'max'``, or ``'min'`` of the pixel values within each polygon feature, setting it to ``None`` will result in all pixels being extracted."
msgstr ""

#: 
msgid "``resolution``: The spatial resolution, in metres, to resample the satellite data too e.g. if working with Landsat data, then this should be ``(-10,10)``"
msgstr ""

#: 
msgid "If you decide to change any of the parameters below, then these changes will need to be reflected in the ``Prediction`` section. For the prediction section to work, it requires loading the same data as is loaded in the training data. The user needs to update the prediction section manually."
msgstr ""

#: 
msgid "Automatically detect the number of cpus"
msgstr ""

#: 
msgid "Extract training data using a shapefile"
msgstr ""

#: 
msgid "**Training data** is the most important part of any machine learning workflow. The quality of the training data has a greater impact of the classification than the algorithm used. Large and accurate training data sets are preferable: increasing the training sample size results in increased classification accuracy (Huang, Davis and Townsend 2002)."
msgstr ""

#: 
msgid "When creating training data, be sure to capture the ``spectral variability`` of the class, and to use imagery from the time period you want to classify (rather than relying on basemap composites). The best way to create training data is using a GIS platform."
msgstr ""

#: 
msgid "Another common problem with training data is ``class imbalance``. This can occur when one of your classes is relatively rare and therefore the rare class will comprise a smaller proportion of the training set. When imbalanced data is used, it is common that the final classification will under-predict less abundant classes relative to their true proportion."
msgstr ""

#: 
msgid "**Note**: The training data provided by default is *for demonstration purposes only* and should not be relied upon for real world analysis."
msgstr ""

#: 
msgid "Firstly, let's open our input data and visualise it using the function ``map_shapefile``. We can also check the shapefile by plotting and inspecting it. Note: The polygons are very small so you will need to zoom in to see them."
msgstr ""

#: 
msgid "Defining feature layers"
msgstr ""

#: 
msgid "To create the desired feature layers, we pass instructions to ``collect_training_data`` through the ``feature_func`` parameter."
msgstr ""

#: 
msgid "``feature_func``: A function for generating feature layers that is applied to the data within the bounds of the input geometry. The ``feature_func`` must accept a ``dc_query`` object, and return a single ``xarray.Dataset`` or ``xarray.DataArray`` containing 2D coordinates (i.e x, y - no time dimension). e.g."
msgstr ""

#: 
msgid "Below, we will define a feature layer function. We will load all the layers of the annual sentinel-2 `GeoMAD <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/master/Datasets/GeoMAD.ipynb>`__, and then calculate some band indices."
msgstr ""

#: 
msgid "To train our model, we need to obtain satellite data that corresponds with the labelled input data locations."
msgstr ""

#: 
msgid "The function ``collect_training_data`` takes our shapefile, containing class labels, and extracts traning data from the datacube over the location specified by the input geometries. The function will also pre-process our training data by stacking the arrays into a useful format and removing an ``NaN`` (not-a-number) values. Before we run the training data function, we first need to set up a dictionary with the satellite query parameters:"
msgstr ""

#: 
msgid "**The following cell can take several minutes to run.** The class labels will be contained in the first column of the output array. If you set ``ncpus > 1``, then this function will be run in parallel across the specified number of processes."
msgstr ""

#: 
msgid "So that we can assess the accuracy of our classification, we split our data into training and testing data. 80% is used for training with 20% held back for testing. When splitting our data, we stratify the training data by the distributions of class membership. This sampling method leads to a similar distribution of class membership in the training data."
msgstr ""

#: 
msgid "Model preparation"
msgstr ""

#: 
msgid "This section automatically creates a list of varaible names and their respective indices for each of the training data variables."
msgstr ""

#: 
msgid "**Note:** To use a custom subset of the satellite bands loaded above to train our data, you can replace ``column_names[1:]`` with a list of selected band names (e.g. ``['red', 'green', 'blue']``)"
msgstr ""

#: 
msgid "A **decision tree model** is chosen as it is one of the simplest supervised machine learning models we can implement."
msgstr ""

#: 
msgid "Its strengths are its explainability and cheap computational cost."
msgstr ""

#: 
msgid "Parameter tuning can be conducted in the model initialisation below by adding or changing variables in the ``classifier_params`` below - details on how the different parameters will affect the model are `here <https://scikit-learn.org/stable/modules/tree.html#tips-on-practical-use>`__."
msgstr ""

#: 
msgid "Train model"
msgstr ""

#: 
msgid "The model is fitted / trained using the prepared training data. The fitting process uses the decision tree approach to create a generalised representation of reality based on the training data. This fitted / trained model can then be used to predict which class new data belongs to."
msgstr ""

#: 
msgid "Optionally save the model"
msgstr ""

#: 
msgid "Running this cell will export the classifier as a binary\\ ``.joblib`` file. This will allow for importing the model in other scripts should we wish to use the same model to classify a different region."
msgstr ""

#: 
msgid "To import a saved model, execute the following code snippet:"
msgstr ""

#: 
msgid "Evaluating Classifier"
msgstr ""

#: 
msgid "The following cells will help you examine the classifier and improve the results. We can do this by: \\* Determining our overall accuracy, \\* Finding out which features (bands in the input data) are most useful for classifying, and which are not, \\* Plotting the Decision Tree to help us understand which thresholds are used to seperate the classes."
msgstr ""

#: 
msgid "Overall Accuracy"
msgstr ""

#: 
msgid "We can use the 20% sample of test data we partitioned earlier to test the accuracy of the trained model on this new, \"unseen\" data."
msgstr ""

#: 
msgid "An accuracy value of 1.0 indicates that the model was able to correctly predict 100% of the classes in the test data."
msgstr ""

#: 
msgid "Determine Feature Importance"
msgstr ""

#: 
msgid "Extract classifier estimates of the relative importance of each band/variable for training the classifier. Useful for potentially selecting a subset of input bands/variables for model training/classification (i.e. optimising feature space). Results will be presented in descending order with the most important features listed first. Importance is reported as a relative fraction between 0 and 1."
msgstr ""

#: 
msgid "Plot the Decision Tree"
msgstr ""

#: 
msgid "This decision tree representation visualises the trained model. Here we can see that the model decides which landcover class to assign based on the value of the important variables in the plot above."
msgstr ""

#: 
msgid "The **gini** (or **entropy**) value shown in the tree represents the decrease in node impurity. This can also be understood as how heterogeneous the labels are (small values indicating better results). This metric is used by the decision tree to determine how to split the data into smaller groups."
msgstr ""

#: 
msgid "This step can take a long time if using ``feature_stats = None``"
msgstr ""

#: 
msgid "If the graph is small double-click to enlarge it. Double-click again to return to initial size."
msgstr ""

#: 
msgid "Prediction"
msgstr ""

#: 
msgid "Now that we have a trained model, we can load new data and use the ``predict_xr`` function to predict landcover classes."
msgstr ""

#: 
msgid "The trained model can technically be used to classify any dataset or product with the same bands as the data originally used to train the data. However, it is typically highly advisable to classify data from the same product that the data was originally trained on."
msgstr ""

#: 
msgid "If you changed any of the parameters in the ``Analysis Parameters`` section from their default values, then these changes will need to be reflected in the code below. For the prediction section to work, it requires loading the same data as is loaded in the training data. The user needs to update this section manually."
msgstr ""

#: 
msgid "Plotting"
msgstr ""

#: 
msgid "To qualitatively evaluate how well the classification performed, we can plot the classifed/predicted data next to our input satellite imagery."
msgstr ""

#: 
msgid "**Note:** The output below is unlikely to be optimal the first time the classification is run. The model training process is one of experimentation and assumption checking that occurs in an iterative cycle - Use the ``Evaluate Classifier`` steps below to help you improve the model"
msgstr ""

#: 
msgid "Exporting classification"
msgstr ""

#: 
msgid "We can now export the predicted landcover out to a GeoTIFF ``.tif`` file. This file can be loaded into GIS software (e.g. QGIS, ArcMap) to be inspected more closely."
msgstr ""

#: 
msgid "Monitoring Mangrove Extents"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `gmw <https://explorer.digitalearth.africa/gmw>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2`, :index:`data used; external`, :index:`mangroves`, :index:`band index; NDVI`"
msgstr ""

#: 
msgid "`Global Mangrove Watch (GMW) <https://www.globalmangrovewatch.org/>`__ is an initiative to track global mangrove extents. Using ALOS PALSAR and Landsat (optical) data to form a baseline extent of mangroves for the years 1996, 2007, 2008, 2009, 2010, 2015, and 2016 . More detailed information on the initiative can be found `here <http://data.unep-wcmc.org/datasets/45>`__. This dataset has been rasterized and indexed into DE Africa's Open Data Cube, for more information on how to load this dataset check out the `GMW Datasets <../Datasets/Global_Mangrove_Watch.ipynb>`__ notebook."
msgstr ""

#: 
msgid "The goal of this notebook is to monitor the changing extent of mangroves, using the GMW layers as a baseline mask."
msgstr ""

#: 
msgid "The process begins with retrieving Sentnel-2 data for a specific area in a time series. This dataset is then compressed into a `median <../Frequently_used_code/Generating_composites.ipynb>`__ composite for each year. From the composite, we then calculate the NDVI values of each pixel in each year. The dataset is then masked, and the NDVI threshold is applied for mangrove classification. The following image shows the decision tree for the classification."
msgstr ""

#: 
msgid "After classification, we can perform a variety of analyses on the data: - We can estimate the change in mangrove areas by counting all the classified pixels for each year and plotting the trend line of the count. - We can also visualize the mangrove areas by plotting each classified pixel a certain color."
msgstr ""

#: 
msgid "**To run this analysis**, run all the cells in the notebook, starting with the `Load packages <#Load-packages>`__ cell."
msgstr ""

#: 
msgid "**After finishing the analysis**, return to the `Analysis parameters <#Analysis-parameters>`__ cell, modify some values (e.g. choose a your own mangrove shapefile or time period to analyse) and re-run the analysis."
msgstr ""

#: 
msgid "Connect to the datacube database and set up a processing cluster."
msgstr ""

#: 
msgid "``product_name``: The name of the satellite product to use."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``(\"2017\", \"2020\")``)."
msgstr ""

#: 
msgid "``tide_range``: The minimum and maximum proportion of the tidal range to include in the analysis. For example, ``tide_range = (0.25, 0.75)`` will select all satellite images taken during mid-tide conditions (i.e. 25th to 75th percentile range). This allows us to remove any impact of tides on the classification of mangrove extent. Also, because Sentinel-2 is a sun-synchronoous sensor, the mid-tide is observed more than low and high tides, therefore it is advantageous to use the mid-tide extent as we will retain more satellite images."
msgstr ""

#: 
msgid "The code below uses the ``load_ard`` function to load in data from the Sentinel-2 satellites for the area and time specified. For more information, see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__. The function will also automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data:"
msgstr ""

#: 
msgid "Load in the Global Mangrove Watch"
msgstr ""

#: 
msgid "Below we load the latest GMW layer, which is from 2016"
msgstr ""

#: 
msgid "The location of the shoreline can vary greatly from low to high tide, which may impact the NDVI values of pixels where water and mangroves intermingle. In the code below, we aim to reduce the effect of tides by modelling tide height data, and keeping only the satellite images that were taken at specific tidal conditions. For example, if ``tide_range = (0.00, 0.50)``, we are telling the analysis to focus only on satellite images taken when the tide was between the lowest tidal conditions and the median (50th percentile) conditions."
msgstr ""

#: 
msgid "The tidal_tag function below uses the `OTPS TPXO8 tidal model <https://www.tpxo.net/global/tpxo8-atlas>`__ to calculate the height of the tide at the exact moment each satellite image in our dataset was taken, and adds this as a new tide_m attribute in our dataset."
msgstr ""

#: 
msgid "**Important note**: this function can only model tides correctly if the centre of your study area is located over water. If this isn't the case, you can specify a custom tide modelling location by passing a coordinate to ``tidepost_lat`` and ``tidepost_lon`` (e.g. tidepost_lat=14.283, tidepost_lon=-16.921). If you are not running the default analysis, then either change the ``tidepost_lat`` and ``tidepost_lon`` below to a location over the ocean near your study-area, or try setting them to ``None`` and see if the code can infer the location of your study-area"
msgstr ""

#: 
msgid "Filter satellite images by tide height"
msgstr ""

#: 
msgid "Here we take the dataset and only keep the images with tide heights we want to analyse (i.e. tides within the heights given by ``tide_range``). This will result in a smaller number of images."
msgstr ""

#: 
msgid "In the code below, we take the time series of images and combine them into single images for each year using the ``median NDVI``. The *Normalised Difference Vegetation Index* (NDVI) shows vegetation and is used for mangrove classification within the mangrove mask."
msgstr ""

#: 
msgid "For more information on indices, see the `Calculating Band Indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ notebook."
msgstr ""

#: 
msgid "Note: This step can take several minutes to load if the study area is large. We recommend opening the Dask processing window to view the different computations that are being executed; to do this, see the Dask dashboard in DE Africa section of the Dask notebook."
msgstr ""

#: 
msgid "Mangrove classification"
msgstr ""

#: 
msgid "Apply a mask of the mangrove area"
msgstr ""

#: 
msgid "We will use the mangrove mask from the Global Mangrove Watch dataset so we can work with only the pixels in the mangrove area."
msgstr ""

#: 
msgid "Calculating regular and closed mangroves"
msgstr ""

#: 
msgid "Using the `mangrove decision tree <#Description>`__ above, we can classify the pixels as:"
msgstr ""

#: 
msgid "**mangroves:** pixels in the mangrove area with an ``NDVI > 0.4``"
msgstr ""

#: 
msgid "**regular mangroves:** mangroves with ``NDVI <= 0.7``"
msgstr ""

#: 
msgid "**closed mangroves:** mangroves with ``NDVI > 0.7``"
msgstr ""

#: 
msgid "Plot the mangrove types"
msgstr ""

#: 
msgid "Again we will combine the mangrove types for easier plotting."
msgstr ""

#: 
msgid "Mangrove change"
msgstr ""

#: 
msgid "Plot the change of mangrove classification in area over time"
msgstr ""

#: 
msgid "Monitoring change in mangroves"
msgstr ""

#: 
msgid "We can calculate the growth and loss of mangroves between the first and last year in our timeseries"
msgstr ""

#: 
msgid "Plot the change"
msgstr ""

#: 
msgid "Determine the net change between years"
msgstr ""

#: 
msgid "Advanced: Compare Recent Mangrove Extent to GMW 1996"
msgstr ""

#: 
msgid "In the previous plots, we were calculating the change in mangrove extent from the start of the Sentinel-2 time series (2017) until now (2021). However, the baseline mangrove extent map, the Global Mangrove Watch (GMW) layer goes all the way back to 1996. Thus, the mangrove extent may have change significantly between 1996 and the beginning of the Sentinel-2 archive. We can use the GMW layer to inspect how mangrove extent has changed since the development of the 2016 product that we examined above."
msgstr ""

#: 
msgid "A word of caution here, the GMW product was developed using a different methodology to the one used here, so differences in mangrove extent may be attributable to the different methods. Nevertheless, this should still provide us with a reasonable indication of the changes that have occurred between 1996 and the beginning of the Sentinel-2 archive in 2017."
msgstr ""

#: 
msgid "Load the earliest GMW layer"
msgstr ""

#: 
msgid "Determine change between 1996 and 2017"
msgstr ""

#: 
msgid "Determine the net change between 1996 and 2017"
msgstr ""

#: 
msgid "What are the causes of mangrove growth and loss?"
msgstr ""

#: 
msgid "Generating NDVI animations"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ndvi anomaly`, :index:`agriculture`"
msgstr ""

#: 
msgid "This notebook shows how to generate an animation to visualise the NDVI across space, mean NDVI through time, and NDVI anomalies. It also generates a similar animation for monthly rainfall and rainfall anomalies."
msgstr ""

#: 
msgid "Animations can help visualise changes in patterns through time. The visualisation of both mean values and anomalies means that seasonal and inter-annual aspects of time can be assessed. Complementing this with spatial images enhances interpretability of earth observation data."
msgstr ""

#: 
msgid "The workflow for generating an animation progresses through the following steps: 1. Select an area of interest. 2. Load DE Africa Mean NDVI and Anomalies product. 3. Mask to cropland. 4. Generate NDVI animation. 5. Generate rainfall animation. \\**\\*"
msgstr ""

#: 
msgid "To run this analysis, run all the cells in the notebook, starting with the \"Load packages and apps\" cell."
msgstr ""

#: 
msgid "Connect to the datacube."
msgstr ""

#: 
msgid "The default area is cropland in Madagascar."
msgstr ""

#: 
msgid "We will define the start and end date as the beginning and end of our year of interest."
msgstr ""

#: 
msgid "Below, the analysis parameters are used to construct a query which loads the DE Africa mean NDVI and anomalies product."
msgstr ""

#: 
msgid "Load cropland mask"
msgstr ""

#: 
msgid "This is an optional step for masking the NDVI data to cropland. In this instance, we are interested in inspecting crop vegetation patterns only, so we use the mask to do this."
msgstr ""

#: 
msgid "Mask NDVI to cropland"
msgstr ""

#: 
msgid "We mask the NDVI data to the cropland extent shown above."
msgstr ""

#: 
msgid "Prepare animation data"
msgstr ""

#: 
msgid "We need to prepare three objects for the animation: 1. Mean NDVI with spatial attributes. 2. Mean NDVI through time, aggregated as an average across space. 3. NDVI anomalies for each month, aggregated as an average across space."
msgstr ""

#: 
msgid "Run animation"
msgstr ""

#: 
msgid "To create the animation, the cell below follows a few key steps: 1. Define the layout of the three axes and their size. 2. Set axis parameters (titles etc) 3. Start each axis with the first image of the animation (Januray). 4. Define an update function which adds each month sequentially to each of the three charts. 5. Run the animation."
msgstr ""

#: 
msgid "Note the animation renders in its own window. The bottom right toggle enables download of the animation."
msgstr ""

#: 
msgid "Make an NDVI animation with rainfall"
msgstr ""

#: 
msgid "The animation above summarises cropland NDVI in space and time, within a period of interest. We can add associated information to this visualisation, such as rainfall. The next few steps demonstrate how to load rainfall data and calculate anomalies for plotting."
msgstr ""

#: 
msgid "Rainfall anomaly parameters"
msgstr ""

#: 
msgid "We need to set some parameters for calculating the rainfall anomaly. The ``time_m`` period is a baseline period while ``time_x`` is the year of interest."
msgstr ""

#: 
msgid "Below, we calculate the monthly mean rainfall and anomaly."
msgstr ""

#: 
msgid "As for the NDVI animation above, we need to prepare dataframes for the rainfall animation."
msgstr ""

#: 
msgid "Run the animation"
msgstr ""

#: 
msgid "We follow the steps listed for the NDVI animation above to produce the rainfall animation."
msgstr ""

#: 
msgid "The animations enable us to inspect how vegetation changes within a year, and by showing anomalies, how the year of interest compares to a historical baseline."
msgstr ""

#: 
msgid "This kind of analysis can assist in assessment of crop production in a given year, and can feed into early warning systems and forecasts on crop production and food security."
msgstr ""

#: 
msgid "Vegetation Phenology"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/s2_l2a>`__, `crop_mask <https://explorer.digitalearth.africa/products/crop_mask>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2`, :index:`data used; crop_mask`, :index:`band index; NDVI`, :index:`band index; EVI`, :index:`phenology`, :index:`analysis; time series`"
msgstr ""

#: 
msgid "Phenology is the study of plant and animal life cycles in the context of the seasons. It can be useful in understanding the life cycle trends of crops and how the growing seasons are affected by changes in climate. For more information, see the `USGS page on deriving phenology from NDVI time-series <https://www.usgs.gov/land-resources/eros/phenology/science/deriving-phenological-metrics-ndvi?qt-science_center_objects=0#qt-science_center_objects>`__."
msgstr ""

#: 
msgid "This notebook demonstrates how to calculate vegetation phenology statistics using the DE Africa function `xr_phenology <../Tools/deafrica_tools/temporal.py>`__. To detect changes in plant life for Sentinel-2, the script uses either the **Normalized Difference Vegetation Index (NDVI)** or the **Enhanced Vegetation Index (EVI)**, which are common proxies for vegetation growth and health."
msgstr ""

#: 
msgid "The outputs of this notebook can be used to assess spatio-temporal differences in the growing seasons of agriculture fields or native vegetation."
msgstr ""

#: 
msgid "This notebook demonstrates the following steps:"
msgstr ""

#: 
msgid "Load cloud-masked Sentinel 2 data for an area of interest."
msgstr ""

#: 
msgid "Calculate a vegetation proxy index (NDVI or EVI)."
msgstr ""

#: 
msgid "Generate a zonal time series of vegetation health."
msgstr ""

#: 
msgid "Complete and smooth the vegetation timeseries to remove gaps and noise."
msgstr ""

#: 
msgid "Calculate phenology statistics on a simple 1D vegetation time series."
msgstr ""

#: 
msgid "Calculate per-pixel phenology statistics."
msgstr ""

#: 
msgid "Optional: Calculating generic temporal statistics usng the hdstats library."
msgstr ""

#: 
msgid "The following cell sets important parameters for the analysis:"
msgstr ""

#: 
msgid "``veg_proxy``: Band index to use as a proxy for vegetation health e.g. ``'NDVI'`` or ``'EVI'``."
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. ``-10.6996``)."
msgstr ""

#: 
msgid "``lon``: The central longitude to analyse (e.g. ``35.2708``)."
msgstr ""

#: 
msgid "``time_range``: The year range to analyse (e.g. ``('2019-01', '2019-06')``)."
msgstr ""

#: 
msgid "The first step is to load Sentinel-2 data for the specified area of interest and time range. The ``load_ard`` function is used here to load data that has been masked for cloud, shadow and quality filters, making it ready for analysis."
msgstr ""

#: 
msgid "**Once the load is complete**, we can plot some of the images as as a true-colour image using the ``rgb`` function."
msgstr ""

#: 
msgid "This study measures the presence of vegetation through either the ``normalised difference vegetation index (NDVI)`` or the ``enhanced vegetation index (EVI)``. The index that will be used is dictated by the ``veg_proxy`` parameter that was set in the \"Analysis parameters\" section."
msgstr ""

#: 
msgid "The normalised difference vegetation index (NDVI) requires the ``red`` and ``nir`` (near-infra red) bands. The formula is"
msgstr ""

#: 
msgid "The Enhanced Vegetation Index requires the ``red``, ``nir`` and ``blue`` bands. The formula is"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{EVI} & = \\frac{2.5 \\times (\\text{NIR} - \\text{Red})}{(\\text{NIR} + 6 \\times \\text{Red} - 7.5 \\times \\text{Blue} + 1)} \\\\\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "Both indices are available through the `calculate_indices <../Frequently_used_code/Calculating_band_indices.ipynb>`__ function, imported from `deafrica_tools.bandindices <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.bandindices.html>`__. Here, we use ``satellite_mission='s2'`` since we're working with Sentinel-2 data."
msgstr ""

#: 
msgid "The vegetation proxy index should now appear as a data variable, along with the loaded measurements, in the ``ds`` object."
msgstr ""

#: 
msgid "Plot the vegetation index over time"
msgstr ""

#: 
msgid "To get an idea of how the vegetation health changes throughout the year(s), we can plot a zonal time series over the region of interest. First we will do a simple plot of the zonal mean of the data."
msgstr ""

#: 
msgid "Smoothing/Interpolating vegetation time-series"
msgstr ""

#: 
msgid "Here, we will smooth and interpolate the data to ensure we working with a consistent time-series. This is a very important step in the workflow and there are many ways to smooth, interpolate, gap-fill, remove outliers, or curve-fit the data to ensure a useable time-series. If not using the default example, you may have to define additional methods to those used here."
msgstr ""

#: 
msgid "Resample the data to fortnightly time-steps using the fortnightly median"
msgstr ""

#: 
msgid "Alternatively, lets complete the timeseries using the DE Africa function ``deafrica_temporal_statistics.fast_complete()``"
msgstr ""

#: 
msgid "Calculate phenology statistics using ``xr_phenology``"
msgstr ""

#: 
msgid "The DE Africa function ``xr_phenology`` can calculate a number of land-surface phenology statistics that together describe the characteristics of a plant's lifecycle. The function can calculate the following statistics on either a zonal timeseries (like the one above), or on a per-pixel basis:"
msgstr ""

#: 
msgid "By default the function will return all the statistics as an ``xarray.Dataset``, to return only a subset of these statistics pass a list of the desired statistics to the function e.g. ``stats=['SOS', 'EOS', 'ROG']``."
msgstr ""

#: 
msgid "The ``xr_phenology`` function also allows for interpolating and/or smoothing the time-series in the same way as we did above, the interpolating/smoothing will occur before the statistics are calculated."
msgstr ""

#: 
msgid "See the `deafrica_tools.temporal <../Tools/deafrica_tools/temporal.py>`__ script for more information on each of the parameters in ``xr_phenology``."
msgstr ""

#: 
msgid "Zonal phenology statistics"
msgstr ""

#: 
msgid "To help us understand what these statistics refer too, lets first pass the simpler zonal mean (mean of all pixels in the image) time-series to the function and plot the results on the same curves as above."
msgstr ""

#: 
msgid "First, provide a list of statistics to calculate with the parameter, ``pheno_stats``."
msgstr ""

#: 
msgid "``method_sos`` : If 'first' then vSOS is estimated as the first positive slope on the greening side of the curve. If 'median', then vSOS is estimated as the median value of the postive slopes on the greening side of the curve."
msgstr ""

#: 
msgid "``method_eos`` : If 'last' then vEOS is estimated as the last negative slope on the senescing side of the curve. If 'median', then vEOS is estimated as the 'median' value of the negative slopes on the senescing side of the curve."
msgstr ""

#: 
msgid "Plot the results with our statistcs annotated on the plot"
msgstr ""

#: 
msgid "Per-pixel phenology statistics"
msgstr ""

#: 
msgid "We can now calculate the statistics for every pixel in our time-series and plot the results."
msgstr ""

#: 
msgid "The phenology statistics have been calculated seperately for every pixel in the image. Let's plot each of them to see the results."
msgstr ""

#: 
msgid "Below, pick a year from the phenology results to plot."
msgstr ""

#: 
msgid "At the top if the plotting code we re-mask the phenology results with the crop-mask. This is because ``xr_phenology``\\ has methods for handling pixels with only NaNs (such as those regions outside of the polygon mask), so the results can have phenology results for regions outside the mask. We will therefore have to mask the data again."
msgstr ""

#: 
msgid "In the example above, we can see these four fields are following the same cropping schedule and are therefore likely the same species of crop. We can also observe intra-field differences in the rates of growth, and in the NDVI values at different times of the season, which may be attributable to differences in soil quality, watering intensity, or other farming practices."
msgstr ""

#: 
msgid "Phenology statistics are a powerful way to summarise the seasonal cycle of a plant's life. Per-pixel plots of phenology can help us understand the timing of vegetation growth and sensecence across large areas and across diverse plant species as every pixel is treated as an independent series of observations. This could be important, for example, if we wanted to assess how the growing seasons are shifting as the climate warms."
msgstr ""

#: 
msgid "Advanced: Calculating generic temporal statistics"
msgstr ""

#: 
msgid "In addition to the ``xr_phenology`` function, the DE Africa `deafrica_tools.temporal <../Tools/deafrica_tools/temporal.py>`__ script contains another function for calculating generic time-series statistics, ``temporal_statistics``. This function is built upon the `hdstats library <https://github.com/daleroberts/hdstats>`__ (a library of multivariate and high-dimensional statistics algorithms). This function accepts a 2 or 3D time-series of, for example, NDVI, and computes a number of summary statistics including: - discordance - discrete fourier transform coefficients (mean, std, and median) - median change - absolute change - complexity - central difference - number of peaks (very slow to run)"
msgstr ""

#: 
msgid "Below we will calculate a number of these statistics and plot them."
msgstr ""

#: 
msgid "When you're done, if you wish to run this code for another region, return to the \"Analysis parameters\" cell, modify some values (e.g. ``time_range``, or ``lat``/``lon``) and rerun the analysis."
msgstr ""

#: 
msgid "For advanced users, ``xr_phenology`` could be used for generating phenology feature layers in a machine learning classifier (see `Machine Learning with ODC <../Real_world_examples/Machine_learning_with_ODC.ipynb>`__ for example of running ML models with ODC data). ``xr_phenology`` can be passed inside of the ``custom_func`` parameter in the ``deafrica_classificationtools.collect_training_data()`` function, allowing phenological statistics to be computed during the collection of training data. An example would look like this:"
msgstr ""

#: 
msgid "Radar vegetation phenology using Sentinel-1"
msgstr ""

#: 
msgid "**Products used:** `s1_rtc <https://explorer.digitalearth.africa/s1_rtc>`__, `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-1`, :index:`data used; crop_mask`, :index:`band index; RVI`, :index:`phenology`, :index:`analysis; time series`"
msgstr ""

#: 
msgid "Phenology is the study of plant and animal life cycles in the context of the seasons. It can be useful in understanding the life cycle trends of crops and how the growing seasons are affected by changes in climate. However, in cloudy regions optical satellites may not view the vegetation cycle during key moments of growth (e.g. during the peak of the growing sesaon) leading to inaccurate estimates of vegetation phenology variables. The Sentinel-1 radar satellite 'sees' through clouds and can, in theory, view the entire life cycle of plants. This notebook will use Sentinel-1 to derive key phenology statistics. You can compare these results with the results from the `Sentinel-2 vegetation phenology notebook <Phenology_optical.ipynb>`__ which relies on optical data to calculate phenology over the same region as this notebook"
msgstr ""

#: 
msgid "This notebook demonstrates how to calculate vegetation phenology statistics over cropping regions using the DE Africa function `xr_phenology <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/gen/deafrica_tools.temporal.xr_phenology.html>`__. To detect changes in plant life for Sentinel-1, the script uses the **Radar Vegetation Index**"
msgstr ""

#: 
msgid "Load Sentinel 1 data for an area of interest."
msgstr ""

#: 
msgid "Calculate the radar vegetation index."
msgstr ""

#: 
msgid "Plot false colour images of the region."
msgstr ""

#: 
msgid "Compute the radar vegetation index"
msgstr ""

#: 
msgid "Smooth the vegetation timeseries to minimize noise."
msgstr ""

#: 
msgid "Calculate phenology statistics on a simple 1D vegetation time series"
msgstr ""

#: 
msgid "Calculate per-pixel phenology statistics"
msgstr ""

#: 
msgid "``time_range``: The year range to analyse (e.g. ``('2019-01', '2020-12')``)."
msgstr ""

#: 
msgid "Load Sentinel-1 data"
msgstr ""

#: 
msgid "The first step is to load Sentinel-1 data for the specified area of interest and time range. The ``load_ard`` function is used here to load data that has been masked using quality filters, making it ready for analysis."
msgstr ""

#: 
msgid "Now we will use the cropland map to mask the regions in the Sentinel-1 data that only have cropping."
msgstr ""

#: 
msgid "False colour RGB plots"
msgstr ""

#: 
msgid "Now can plot some of the Sentinel-1 images as false colour images using the ``rgb`` function. Notice that the backscatter intensity of the cropping regions is changing throughout the year as the plants in the fields go through their growth and senescence cycle."
msgstr ""

#: 
msgid "This study measures the presence of vegetation through either the ``Radar vegetation index (RVI)``."
msgstr ""

#: 
msgid "RVI is available through the ``dualpol_indices`` function, imported from `deafrica_tools.bandindices <../Tools/deafrica_tools/bandindices.py>`__."
msgstr ""

#: 
msgid "Plot the smoothed and interpolated time-series"
msgstr ""

#: 
msgid "In the example above, we can see most of the fields are following a similar cropping schedule and are therefore likely the same species of crop. We can also observe that some fields have not followed this schedule (e.g. the EOY plot shows some fields didn't follow this schedule, probably because they either remained fallow during the year, or because there were two peaks during the year which may have confused the phenology stats). Differences in the rates of growth, and in the RVI values at different times of the season, may be attributable to differences in soil quality, watering intensity, or other farming practices."
msgstr ""

#: 
msgid "Urban area mapping using Sentinel 1 data"
msgstr ""

#: 
msgid "**Products used:** `s1_rtc <https://explorer.digitalearth.africa/products/s1_rtc>`__,"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel 1`,:index:`SAR`,:index:`urban`, :index:`analysis;"
msgstr ""

#: 
msgid "Urban areas account for a small proportion of global land cover, but support daily human life and exert a great influence on environmental and ecological changes (`Xia et al. 2019 <https://doi.org/10.3390/rs11121470>`__). This means that constant monitoring of the built environment is crucial for sustainable development. There are different techniques used to classify urban areas using both optical and radar data, one of the simplest is k-means clustering (unsupervised machine learning)."
msgstr ""

#: 
msgid "While urban areas can be mapped using optical data, the image quality is strongly affected by weather conditions such as cloud cover. This limits the temporal avaliability of clear images in tropical areas that experience very cloudy weather and heavy rains. The image quality of radar data is independent of daylight and weather conditions, which makes it more suitable for urban area mapping. For more information, see the `Sentinel-1 <../Datasets/Sentinel_1.ipynb>`__ notebook."
msgstr ""

#: 
msgid "This notebook uses k-means clustering to classify land as 'urban' then compares those results with the ESA WorldCover global land cover product for the year 2020."
msgstr ""

#: 
msgid "The choice of the number of clusters to use for the k-means clustering and the pixel value that represents the urban land cover class can be informed by comparing the prediction images with the \"ground truth\" dataset."
msgstr ""

#: 
msgid "This notebook contains the following steps:"
msgstr ""

#: 
msgid "Select a location and time range for the analysis."
msgstr ""

#: 
msgid "Load Sentinel-1 backscatter data for the area of interest."
msgstr ""

#: 
msgid "Convert the digital numbers to dB values for analysis."
msgstr ""

#: 
msgid "Generate a median VH and VV polarization composite image from the Sentinel 1 data."
msgstr ""

#: 
msgid "Perform k-means clustering on the median composite image."
msgstr ""

#: 
msgid "Show the k-means clustering urbanization prediction image."
msgstr ""

#: 
msgid "Load and show the \"ground truth\" ESA Worldcover data for the year 2020."
msgstr ""

#: 
msgid "Compare the urbanization prediction with the \"ground truth\" data visually and statistically."
msgstr ""

#: 
msgid "Import the Python packages that are used for the analysis."
msgstr ""

#: 
msgid "Connect to the datacube so we can access the Digital Earth Africa data. The ``app`` parameter is a unique name for the analysis which is based on the notebook file name."
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis. The parameters are: \\* ``lat``: The central latitude of the area of interest to analyse. \\* ``lon``: The central longitude of the area of interest to analyse. \\* ``buffer``: The number of square degrees to load around the central latitude and longitude. For reasonable loading times, set this as ``0.1`` or lower. \\* ``time_range``: The time range for your analysis, e.g.\\ ``('2020')`` if you wanted data from all of the year 2020."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers part of Nairobi County, Kenya."
msgstr ""

#: 
msgid "Load and view the Sentinel-1 data"
msgstr ""

#: 
msgid "We will create a dictionary that will contain the parameters that will be used to load the Sentinel 1 data from the Digital Earth Africa datacube."
msgstr ""

#: 
msgid "Load the Sentinel 1 data"
msgstr ""

#: 
msgid "The first step in the analysis is to load Sentinel-1 backscatter data for the specified area of interest. This uses the pre-defined `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ utility function. The ``load_ard`` function is used here to load an analysis ready dataset free of shadow, and missing data."
msgstr ""

#: 
msgid "Convert the Digital Number (DN) values to Decibel values (dB)"
msgstr ""

#: 
msgid "The Sentinel-1 backscatter data is provided as digital number (DN), which can be converted to backscatter in decibel unit (dB) using the function:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} 10 * \\log_{10}\\left(\\text{DN} \\right) \\end{equation}`"
msgstr ""

#: 
msgid "It is often useful to convert the backscatter to decible (dB) for analysis because the backscatter in dB unit has a more symmetric noise profile and less skewed value distribution for easier statistical evaluation."
msgstr ""

#: 
msgid "View the Sentinel 1 data"
msgstr ""

#: 
msgid "Generate a median value composite image"
msgstr ""

#: 
msgid "We will combine all the VH and VV observations in our Sentinel 1 ``ds`` ``xarray.Dataset`` into a single, complete (or near complete) image representing the median of the time period."
msgstr ""

#: 
msgid "Note, here we will ``.compute()`` the median, which will bring our data into memory. This will take a couple of minutes to run."
msgstr ""

#: 
msgid "Classification using K-means Clustering"
msgstr ""

#: 
msgid "In the next cell we will create a set of functions which will together be used to perform k-means clustering on our median value composite image. This functions are adapted from the ones used `here <https://ml-gis-service.com/index.php/2020/10/14/data-science-unsupervised-classification-of-satellite-images-with-k-means-algorithm/>`__."
msgstr ""

#: 
msgid "In the next cell, we will use a range of clusters to perform k-means classification on our median composite dataset."
msgstr ""

#: 
msgid "Below, **enter a list of bands to include in the classification**"
msgstr ""

#: 
msgid "Now we will run the k-means classification, and then plot the results"
msgstr ""

#: 
msgid "Decide which model and class to assign as 'urban'"
msgstr ""

#: 
msgid "From the plotted predicted images above the best number of clusters to use is ``3`` clusters. In this image, the most likely pixel value to represent the urban/buit up land cover class is the pixel value ``1``."
msgstr ""

#: 
msgid "Note: this may change depending on the area of interest and number of clusters used. In this example, the initial state has been arbitrarily defined using the ``random_state`` argument in the ``kmeans_clustering`` function."
msgstr ""

#: 
msgid "Set the ``key`` and the ``pixel_value`` representing the model and value, respectively, that you want to assign as urban areas"
msgstr ""

#: 
msgid "Validation of the k-means clustering classification"
msgstr ""

#: 
msgid "We will compare the performance of the urban area k-means clustering classification result against a built area (urban area) map for the study area derived from the ESA World Cover, global 10 m land use/land cover data from 2020."
msgstr ""

#: 
msgid "Obtain the validation dataset"
msgstr ""

#: 
msgid "Plot the ESA land use land cover product."
msgstr ""

#: 
msgid "We're only interested in the built-up areas, so we can use the flags definition on the dataset to isolate just the ``built-up`` class"
msgstr ""

#: 
msgid "Plot the ESA urban areas alongside the k-means estimate from S1"
msgstr ""

#: 
msgid "Accuracy assessment metrics"
msgstr ""

#: 
msgid "We will use functions from the ``sklearn.metrics`` module to evaluate the k-means clustering classification. Accuracy is used when the True Positives and True negatives are more important while F1-score is used when the False Negatives and False Positives are crucial."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{Overall Accuracy (OA)} = \\frac{\\text{True Positive} + \\text{True Negative}}{\\text{Total Pixels}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{Producer's Accuracy (PA) or Precision} = \\frac{\\text{True Positive}}{\\text{True Positive} + \\text{False Positive}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{User's accuracy (UA) or  Recall} = \\frac{\\text{True Positive}}{\\text{True Positive} + \\text{False Negative}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{F1 Score} = 2*\\frac{\\text{Recall}*\\text{Precision}}{\\text{Recall} + \\text{Precision}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The ``dstack`` calls provide the ``imshow`` calls with RGB array inputs. For the plotted image, the first channel (red) is the actual (ground truth, ESA Worldcover) values, and both the second and third channels (green, blue) are the predicted values (green + blue = cyan)."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-1`,:index:`SAR`, :index:`water`"
msgstr ""

#: 
msgid "Over 40% of the world’s population lives within 100 km of the coastline. However, coastal environments are constantly changing, with erosion and coastal change presenting a major challenge to valuable coastal infrastructure and important ecological habitats. Updating data on the position of the coastline is essential for coastal managers to be able to identify and minimise the impacts of coastal change and erosion. The coastal regions are also home to many wetlands. Monitoring of water extent helps to understand and protect these dynamic and productive ecosystems."
msgstr ""

#: 
msgid "While coastlines and water extents can be mapped using optical data (demonstrated in the `Coastal Erosion notebook <../Real_world_examples/Coastal_erosion.ipynb>`__), these images can be strongly affected by the weather, especially through the presence of clouds, which obscure the land and water below. This can be a particular problem in cloudy regions or areas where clouds in wet season prevent optical satellites from taking clear images for many months of the year."
msgstr ""

#: 
msgid "Radar observations are largely unaffected by cloud cover. The two Sentinel-1 satellites, operated by ESA as part of the Copernicus program, provide all-weather observations every 6 to 12 days over Africa. By developing a process to classify the observed pixels as either water or land, it is possible to identify the shoreline and map the dynamic water extents using radar data. For more information, see the `Sentinel-1 <../Datasets/Sentinel_1.ipynb>`__ notebook."
msgstr ""

#: 
msgid "In this example, we use data from the Sentinel-1 satellites to build a classifier that can determine whether a pixel is a water or land. Specifically, this notebook uses analysis-ready radar backscatter, which describes the strength of the signal received by the satellite."
msgstr ""

#: 
msgid "Load Sentinel-1 backscatter data for an area of interest and visualize the returned data"
msgstr ""

#: 
msgid "Applying speckle filter and converting the digital numbers to dB values for analysis"
msgstr ""

#: 
msgid "Use histogram analysis to determine the threshold for water classification"
msgstr ""

#: 
msgid "Design a classifier to distinguish land and water"
msgstr ""

#: 
msgid "Apply the classifier to the area of interest and interpret the results"
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis. The parameters are"
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2020')``)"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers the coast of Ziguinchor, Gambia."
msgstr ""

#: 
msgid "Load and view Sentinel-1 data"
msgstr ""

#: 
msgid "The first step in the analysis is to load Sentinel-1 backscatter data for the specified area of interest. This uses the pre-defined `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ utility function."
msgstr ""

#: 
msgid "**Once the load is complete**, examine the data by printing it in the next cell. The ``Dimensions`` argument reveals the number of time steps in the data set, as well as the number of pixels in the ``x`` (longitude) and ``y`` (latitude) dimensions."
msgstr ""

#: 
msgid "Visualize the time series"
msgstr ""

#: 
msgid "Coastal and wetlands are highly dynamic, so cloud-free assessment using radar is valuable to capture change in all seasons. In the next few cells, Sentinel-1 observations in different polarisations are plotted for selected dates. Noting VV backscatter is usually significantly higher than VH. Signals from the two polarizations are dominated by different scattering mechanisms therefore respond differently to surface characeristics."
msgstr ""

#: 
msgid "Both polarizations show siginficant surface cover change over time. Open water is characterized by low backscatter due to specular reflection. Water area with standing vegetation leads to high backscatter and will not be mapped using the thresholding method below. This may result in differenct water extent measurement compared to methods using optical data."
msgstr ""

#: 
msgid "Backscatter measurements can be combined in visualization to highlight the different polarization signatures. For the RGB visualization below, the ratio between VH and VV is added as a third measurement band."
msgstr ""

#: 
msgid "Significant changes in color pattern are visible from month to month. Open water and smooth bare surface appear dark blue because all measurements are low. Tree cover appears cyan because of the relatively higher VH signal from volume scattering. Areas in bright red are likely water with standing vegetation. Urban area is shown in bright yellow at the bottom of the images."
msgstr ""

#: 
msgid "Apply speckle filtering"
msgstr ""

#: 
msgid "Radar observations appear speckly due to random interference of coherent signals from target scatters. The speckle noise can be reduced by averaging pixel values over an area or over time. However, averaging over a fixed window smoothes out real local spatial variation and leads to reduced spatial resolution. An adaptive approach that takes into account local homogeneity is therefore preferred."
msgstr ""

#: 
msgid "Below, we apply the Lee filter, one of the popular adaptive speckle filters."
msgstr ""

#: 
msgid "Now that we've defined the filter, we can run it on the VV and VH data. You might have noticed that the function takes a size argument. This will change how blurred the image becomes after smoothing. We've picked a default value for this analysis, but you can experiement with this if you're interested."
msgstr ""

#: 
msgid "Convert the digital numbers to dB"
msgstr ""

#: 
msgid "While Sentinel-1 backscatter is provided as linear intensity, it is often useful to convert the backscatter to decible (dB) for analysis. Backscatter in dB unit has a more symmetric noise profile and less skewed value distribution for easier statistical evaluation."
msgstr ""

#: 
msgid "Histogram analysis for Sentinel-1"
msgstr ""

#: 
msgid "Backscatter distributions are plotted below as histograms."
msgstr ""

#: 
msgid "Build and apply the classifier"
msgstr ""

#: 
msgid "The histogram for VH backscatter shows a bimodal distribution with low values over water and high values over land. The VV histogram has multiple peaks and less obvious seperation between water and land."
msgstr ""

#: 
msgid "We therefore build a classifier based on VH backscatter. We choose a threshold to separate land and water: pixels with values below the threshold are water, and pixels with values above the threshold are not water (land)."
msgstr ""

#: 
msgid "There are several ways to determine the threshold. Here, we use the ``threshod_minimum`` function implemented in the ``skimage`` package to determine the threshold from the *VH* histogram automatically. This method computes the histogram for all backscatter values, smooths it until there are only two maxima and find the minimum in between as the threshold."
msgstr ""

#: 
msgid "Visualise threshold"
msgstr ""

#: 
msgid "To check if our chosen threshold reasonably divides the two distributions, we can add the threshold to the histogram plots we made earlier."
msgstr ""

#: 
msgid "Define the classifier"
msgstr ""

#: 
msgid "This threshold is used to write a function to only return the pixels that are classified as water. The basic steps that the function will perform are:"
msgstr ""

#: 
msgid "Find all pixels that have filtered values lower than the threshold; these are the ``water`` pixels."
msgstr ""

#: 
msgid "Return a data set containing the ``water`` pixels."
msgstr ""

#: 
msgid "Now that we have defined the classifier function, we can apply it to the data. After running the classifier, we will able to view the classified data product by running ``print(S1.water)``."
msgstr ""

#: 
msgid "Assessment with mean"
msgstr ""

#: 
msgid "We can now view the image with our classification. The classifier returns either ``True`` or ``False`` for each pixel. To detect the boundaries of water features, we want to check which pixels are always water and which are always land. Conveniently, Python encodes ``True = 1`` and ``False = 0``."
msgstr ""

#: 
msgid "If we plot the average classified pixel value, pixels that are always water will have an average value of ``1`` and pixels that are always land will have an average of ``0``. Pixels that are sometimes water and sometimes land will have an average between these values. In this case study, these pixels are associated with seasonally inundated wetland areas."
msgstr ""

#: 
msgid "The following cell plots the average classified pixel value, or the frequency of water detection, over time."
msgstr ""

#: 
msgid "You can see that the selected threshold has done a good job of separating the water pixels (in blue) and land pixels (in red) as well as ephemeral water features in between."
msgstr ""

#: 
msgid "You should be able to see that the shoreline takes on a mix of values between ``0`` and ``1``, highlighting pixels that are sometimes land and sometimes water. This is likely due to the effect of rising and falling tides, with some radar observations being captured at low tide, and others at high tide."
msgstr ""

#: 
msgid "Assessment with standard deviation"
msgstr ""

#: 
msgid "Given that we've identified the shoreline as the pixels that are classified sometimes as land and sometimes as water, we can also see if the standard deviation of each pixel over time is a reasonable way to determine if a pixel is a shoreline or not."
msgstr ""

#: 
msgid "Similar to how we calculated and plotted the mean above, you can calculate and plot the standard deviation by using the ``std`` function in place of the ``mean`` function."
msgstr ""

#: 
msgid "If you'd like to see the results using a different colour scheme, you can also try substituting ``cmap=\"Greys\"`` or ``cmap=\"Blues\"`` in place of ``cmap=\"viridis\"``."
msgstr ""

#: 
msgid "The standard deviation we calculated above gives us an idea of how variable a pixel has been over the entire period of time that we looked at. From the image above, you should be able to see that the land and water pixels almost always have a standard deviation of ``0``, meaning they didn't change over the time we sampled. The shoreline and wetlands however have a higher standard deviation, indicating that they change frequently between water and non-water."
msgstr ""

#: 
msgid "An important thing to recognise is that the standard deviation might not be able to detect the difference between noise, tides, and ongoing change, since a pixel that frequently alternates between land and water (noise) could have the same standard deviation as a pixel that is land for some time, then becomes water for the remaining time (ongoing change or tides)."
msgstr ""

#: 
msgid "When you are done, return to the \"Analysis parameters\" section, modify some values (e.g. lat and lon) and rerun the analysis. You can use the interactive map in the \"View the selected location\" section to find new central latitude and longitude values by panning and zooming, and then clicking on the area you wish to extract location values for. You can also use Google maps to search for a location you know, then return the latitude and longitude values by clicking the map."
msgstr ""

#: 
msgid "Rainfall anomalies from Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS)"
msgstr ""

#: 
msgid "**Products used:** `rainfall_chirps_monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__"
msgstr ""

#: 
msgid "Rainfall anomalies are deviations of rainfall from long-run averages. They are useful for identifying wet and dry periods which can be linked to climatically influenced patterns such as flooding, river flows, and agricultural production."
msgstr ""

#: 
msgid "In this real world example we will calculate rainfall anomalies for a selected African country using the CHIRPS monthly rainfall dataset. Standardised anomaly is calculated as:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{Standardised anomaly }=\\frac{x-m}{s} \\end{equation}`"
msgstr ""

#: 
msgid "**x** is the seasonal mean, **m** is the long-term mean, and **s** is the long-term standard deviation."
msgstr ""

#: 
msgid "This means we need a long-term reference period (m) and a period of interest (x) for which we'll calculate the anomalies. This notebook names datasets ``ds_rf_m`` and ``ds_rf_x`` accordingly."
msgstr ""

#: 
msgid "The notebook outlines:"
msgstr ""

#: 
msgid "Loading a shapefile for African countries and selecting a single country"
msgstr ""

#: 
msgid "Loading and rainfall data and masking it to the selected country."
msgstr ""

#: 
msgid "Calculating monthly rainfall anomalies and plotting the result, aggregated over space, as a bar chart."
msgstr ""

#: 
msgid "Calculating and plotting monthly rainfall anomalies spatially."
msgstr ""

#: 
msgid "Dask can be used to better manage memory use and conduct the analysis in parallel. For an introduction to using Dask with Digital Earth Africa, see the `Dask notebook <../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "``country``: In this analysis, we'll select an African country to mask the dataset and analysis."
msgstr ""

#: 
msgid "``time_m``: CHIRPS monthly rainfall is available from 1981. The long-term mean for rainfall anomalies is often calculated on a 30-year period, so we'll use 1981 to 2011 in this example."
msgstr ""

#: 
msgid "``time_x``: This is the period for which we want to calculate anomalies."
msgstr ""

#: 
msgid "``resolution``: We'll use 5,000 m, which is approximately equal to the default resolution shown above."
msgstr ""

#: 
msgid "``dask_chunks``: the size of the dask chunks, dask breaks data into manageable chunks that can be easily stored in memory, e.g. dict(x=1000,y=1000)"
msgstr ""

#: 
msgid "Standardised anomaly is calculated as:"
msgstr ""

#: 
msgid ":math:`x` is the seasonal mean, :math:`m` is the long-term mean, and :math:`s` is the long-term standard deviation."
msgstr ""

#: 
msgid "This shapefile contains polygons for the boundaries of African countries and will allows us to calculate rainfall anomalies within a chosen country"
msgstr ""

#: 
msgid "The country selected needs to be transformed into a geometry object to be used in the ``dc.load()`` function."
msgstr ""

#: 
msgid "First, let's have a look at the product information for CHIRPS rainfall. We can see that it is stored in monthly timestamps and its native resolution is approximately 0.05 degrees."
msgstr ""

#: 
msgid "Load data for long-term climatology (m)"
msgstr ""

#: 
msgid "Using the analysis parameters defined above, we will load CHIRPS monthly rainfall data for the 30-year reference period (m)."
msgstr ""

#: 
msgid "Mask the rainfall dataset using the country boundary"
msgstr ""

#: 
msgid "Below, the country polygon is rasterized so the rainfall dataset is masked within that raster."
msgstr ""

#: 
msgid "Calculate monthly rainfall climatology"
msgstr ""

#: 
msgid "We want to capture both the monthly mean (i.e. each month averaged over thirty years) and the monthly standard deviation of rainfall within the country polygon for each year from 1981 to 2011. Firstly, rainfall is grouped by month and a mean is calculated, then the standard devation in rainfall total for each month is calculated"
msgstr ""

#: 
msgid "Now we can plot the rainfall mean climatology, this is the average rainfall (over 30 years) for each month"
msgstr ""

#: 
msgid "Load data for the anomaly period"
msgstr ""

#: 
msgid "Using the analysis parameters defined above, we will load CHIRPS rainfall data for the period over which we want to calculate anomalies (x). We also need to mask this dataset to the country polygon."
msgstr ""

#: 
msgid "We can visualise the anomalies spatially and see if they are associated with certain landscape features."
msgstr ""

#: 
msgid "Do the spatial anomalies shown in the plots below align with the aggregated anomalies shown above?"
msgstr ""

#: 
msgid "Plot average rainfall anomalies across the country"
msgstr ""

#: 
msgid "Below, we plot a bar graph that will show the average rainfall anomaly across the country"
msgstr ""

#: 
msgid "Per-pixel plots of rainfall anomalies"
msgstr ""

#: 
msgid "Average anomalies across the entire country obscure details on how rainfall anomalies are spatially distrbuted within the country. Below, enter a ``start`` and ``end`` date (in format ``'YYYY-MM'``) that is within the ``time_x`` range you entered in the ``Analysis parameters`` section to plot per-pixel anomalies for the range of dates you specify."
msgstr ""

#: 
msgid "Plot the per-pixel anomalies"
msgstr ""

#: 
msgid "Scalable Supervised Machine Learning on the Open Data Cube"
msgstr ""

#: 
msgid "**Prerequisites:** This notebook series assumes some familiarity with machine learning, statistical concepts, and python programming. Beginners should consider working through the earlier notebooks in the `deafrica-sandbox-notebooks <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks>`__ repository before attempting to run through this notebook series."
msgstr ""

#: 
msgid "Classification of satellite images using supervised machine learning (ML) techniques has become a common occurence in the remote sensing literature. Machine learning offers an effective means for identifying complex land cover classes in a relatively efficient manner. However, sensibly implementing machine learning classifiers is not always straighforward owing to the training data requirements, the computational requirements, and the challenge of sorting through a proliferating number of software libraries. Add to this the complexity of handling large volumes of satellite data and the task can become unwieldy at best."
msgstr ""

#: 
msgid "This series of notebooks aims to lessen the difficulty of running machine learning classifiers on satellite imagery by guiding the user through the steps necessary to classify satellite data using the `Open Data Cube <https://www.opendatacube.org/>`__ (ODC). This is achieved in two ways. Firstly, the critical steps in a ML workflow (in the context of the ODC) are broken down into discrete notebooks which are extensively documented. And secondly, a number of custom python functions have been written to ease the complexity of running ML on the ODC. These include (among others) ``collect_training_data``, and ``predict_xr``, both of which are contained in the `deafrica_tools.classification <https://docs.digitalearthafrica.org/en/latest/sandbox/notebooks/Tools/gen/deafrica_tools.classification.html#module-deafrica_tools.classification>`__ package. These functions are introduced and explained further in the relevant sections of the notebooks."
msgstr ""

#: 
msgid "There are four primary notebooks in this notebook series (along with an optional fifth notebook), that each represent a critical step in a ML workflow. 1. ``Extract_training_data.ipynb`` explores how to extract training data (feature layers) from the ODC using geometries within a shapefile (or geojson). The goal of this notebook is to familarise users with the ``collect_training_data`` function so you can extract the appropriate data for your use-case. 2. ``Inspect_training_data.ipynb``: After having extracted training data from the ODC, its important to inspect the data using a number of statistical methods to aid in understanding if our feature layers are useful for distinguishing between classes. 3. ``Evaluate_optimize_fit_classifier.ipynb``: Using the training data extracted in the first notebook, this notebook first evaluates the accuracy of a given ML model (using nested, k-fold cross validation), performs a hyperparameter optimization, and then fits a model on the training data. 4. ``Classify_satellite_data.ipynb``: This is where we load in satellite data and classify it using the model created in the previous notebook. The notebook initially asks you to provide a number of small test locations so we can observe visually how well the model is going at classifying real data. The last part of the notebook attempts to classify a much larger region."
msgstr ""

#: 
msgid "5. ``Object-based_filtering.ipynb``: This notebook is provided as an optional extra. It guides you through converting your pixel-based classification into an object-based classification using image segmentation."
msgstr ""

#: 
msgid "The default example in the notebooks uses a training dataset containing \"crop\" and \"non-crop\" labels (labelled as 1 and 0 in the geojson file, respectively) from Egypt. The training data is called ``\"crop_training_egypt.geojson\"``, and is located in the ``'data/'`` folder. By the end of this notebook series we will have produced a model for identifying cropland areas in Egypt, and we will output a cropland mask (as a geotiff) for the region around the city of Faiyum, Egypt."
msgstr ""

#: 
msgid "If you wish to begin running your own classification workflow, the first step is to replace this training data with your own in the ``Extract_training_data.ipynb`` notebook. Though of course its best to run through the default example first to ensure you understand the content before altering the notebooks for your specific use case."
msgstr ""

#: 
msgid "**Important notes** \\* There are many different methods for running ML models and the approach used here may not suit your own classification problem. This is especially true for the ``Evaluate_optimize_fit_classifier.ipynb`` notebook, which has been crafted to suit the default training data. It's advisable to research the different methods for evaluating and training a model to determine which approach is best for you. Remember, the first step of any scientific pursuit is to precisely define the problem. \\* The word \"**Scalable**\" in the title *Scalable ML on the ODC* refers to scalability within the contraints of the machine you're running. These notebooks rely on `dask <https://dask.org/>`__ (and `dask-ml <https://ml.dask.org/>`__) to manage memory and distribute the computations across mulitple cores. However, the notebooks are set up for the case of running on a single machine. For example, if your machine has 2 cores and 16 Gb of RAM (these are the specs on the default Sandbox), then you'll only be able to load and classify data up to that 16 Gb limit (and parallelization will be limited to 2 cores). Access to larger machines is required to scale analyses to very large areas. Its unlikley you'll be able to use these notebooks to classify satellite data at the country-level scale using laptop sized machines. To better understand how we use dask, have a look at the `dask notebook <../../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "**Helpful Resources** \\* There are many online courses that can help you understand the fundamentals of machine learning with python e.g. `edX <https://www.edx.org/course/machine-learning-with-python-a-practical-introduct>`__, `coursera <https://www.coursera.org/learn/machine-learning-with-python>`__. \\* The `Scikit-learn <https://scikit-learn.org/stable/supervised_learning.html>`__ documentation provides information on the available models and their parameters. \\* This `review article <https://www.tandfonline.com/doi/full/10.1080/01431161.2018.1433343>`__ provides a nice overview of machine learning in the context of remote sensing. \\* The stand alone notebook, `Machine_learning_with_ODC.ipynb <../Machine_learning_with_ODC.ipynb>`__, in the ``Real_world_examples/`` folder is a companion piece to these notebooks and provides a more succint (but less descriptive) version of the workflow demonstrated here."
msgstr ""

#: 
msgid "To begin working through the notebooks in this ``Scalable ML on the ODC`` workflow, go to the first notebook ``Extract_training_data.ipynb``."
msgstr ""

#: 
msgid "`Extract_training_data <1_Extract_training_data.ipynb>`__"
msgstr ""

#: 
msgid "`Inspect_training_data <2_Inspect_training_data.ipynb>`__"
msgstr ""

#: 
msgid "`Evaluate_optimize_fit_classifier <3_Evaluate_optimize_fit_classifier.ipynb>`__"
msgstr ""

#: 
msgid "`Classify_satellite_data <4_Classify_satellite_data.ipynb>`__"
msgstr ""

#: 
msgid "`Object-based_filtering <5_Object-based_filtering.ipynb>`__"
msgstr ""

#: 
msgid "**Last modified:** Feb 2021"
msgstr ""

#: 
msgid "Extracting training data from the ODC"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2 geomedian`, index:`data used; MADs`, :index:`data methods; machine learning`"
msgstr ""

#: 
msgid "**Training data** is the most important part of any supervised machine learning workflow. The quality of the training data has a greater impact on the classification than the algorithm used. Large and accurate training data sets are preferable: increasing the training sample size results in increased classification accuracy (`Maxell et al 2018 <https://www.tandfonline.com/doi/full/10.1080/01431161.2018.1433343>`__). A review of training data methods in the context of Earth Observation is available `here <https://www.mdpi.com/2072-4292/12/6/1034>`__"
msgstr ""

#: 
msgid "When creating training labels, be sure to capture the **spectral variability** of the class, and to use imagery from the time period you want to classify (rather than relying on basemap composites). Another common problem with training data is **class imbalance**. This can occur when one of your classes is relatively rare and therefore the rare class will comprise a smaller proportion of the training set. When imbalanced data is used, it is common that the final classification will under-predict less abundant classes relative to their true proportion."
msgstr ""

#: 
msgid "There are many platforms to use for gathering training labels, the best one to use depends on your application. GIS platforms are great for collection training data as they are highly flexible and mature platforms; `Geo-Wiki <https://www.geo-wiki.org/>`__ and `Collect Earth Online <https://collect.earth/home>`__ are two open-source websites that may also be useful depending on the reference data strategy employed. Alternatively, there are many pre-existing training datasets on the web that may be useful, e.g. `Radiant Earth <https://www.radiant.earth/>`__ manages a growing number of reference datasets for use by anyone."
msgstr ""

#: 
msgid "This notebook will extract training data (feature layers) from the ``open-data-cube`` using geometries within a geojson. The default example will use the crop/non-crop labels within the ``'data/crop_training_egypt.geojson'`` file."
msgstr ""

#: 
msgid "To do this, we rely on a custom ``deafrica-sandbox-notebooks`` function called ``collect_training_data``, contained within the `deafrica_tools.classification <../../Tools/deafrica_tools/classification.py>`__ script. The principal goal of this notebook is to familarise users with this function so they can extract the appropriate data for their use-case. The default example also highlights extracting a set of useful feature layers for generating a cropland mask for Egypt."
msgstr ""

#: 
msgid "Preview the polygons in our training data by plotting them on a basemap"
msgstr ""

#: 
msgid "Define a feature layer function to pass to ``collect_training_data``"
msgstr ""

#: 
msgid "Extract training data from the datacube using ``collect_training_data``"
msgstr ""

#: 
msgid "Export the training data to disk for use in subsequent scripts"
msgstr ""

#: 
msgid "``path``: The path to the input vector file from which we will extract training data. A default geojson is provided."
msgstr ""

#: 
msgid "``field``: This is the name of column in your shapefile attribute table that contains the class labels. **The class labels must be integers**"
msgstr ""

#: 
msgid "Find the number of CPUs"
msgstr ""

#: 
msgid "Preview input data"
msgstr ""

#: 
msgid "We can load and preview our input data shapefile using ``geopandas``. The shapefile should contain a column with class labels (e.g. 'class'). These labels will be used to train our model."
msgstr ""

#: 
msgid "Remember, the class labels **must** be represented by ``integers``."
msgstr ""

#: 
msgid "Extracting training data"
msgstr ""

#: 
msgid "The function ``collect_training_data`` takes our geojson containing class labels and extracts training data (features) from the datacube over the locations specified by the input geometries. The function will also pre-process our training data by stacking the arrays into a useful format and removing any ``NaN`` or ``inf`` values."
msgstr ""

#: 
msgid "The below variables can be set within the ``collect_training_data`` function:"
msgstr ""

#: 
msgid "``zonal_stats``: An optional string giving the names of zonal statistics to calculate across each polygon (if the geometries in the vector file are polygons and not points). Default is None (all pixel values are returned). Supported values are 'mean', 'median', 'max', and 'min'."
msgstr ""

#: 
msgid "In addition to the ``zonal_stats`` parameter, we also need to set up a datacube query dictionary for the Open Data Cube query such as ``measurements`` (the bands to load from the satellite), the ``resolution`` (the cell size), and the ``output_crs`` (the output projection). These options will be added to a ``query`` dictionary that will be passed into ``collect_training_data`` using the parameter ``collect_training_data(dc_query=query, ...)``. The query dictionary will be the only argument in the **feature layer function** which we will define and describe in a moment."
msgstr ""

#: 
msgid "Note: ``collect_training_data`` also has a number of additional parameters for handling ODC I/O read failures, where polygons that return an excessive number of null values can be resubmitted to the multiprocessing queue. Check out the `docs <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/83116e80ebb4f8744e3de74e7a713aadd0a7577a/Tools/deafrica_tools/classification.py#L565>`__ to learn more."
msgstr ""

#: 
msgid "Generate a datacube query object from the parameters above:"
msgstr ""

#: 
msgid "``feature_func``: A function for generating feature layers that is applied to the data within the bounds of the input geometry. The ``feature_func`` must accept a ``dc_query`` dictionary, and return a single ``xarray.Dataset`` or ``xarray.DataArray`` containing 2D coordinates (i.e x, y - no time dimension). e.g."
msgstr ""

#: 
msgid "Below, we will define a more complicated feature layer function than the brief example shown above. We will calculate some band indices on the Sentinel-2 `geoMAD <../../Datasets/GeoMAD.ipynb>`__ and append a slope dataset."
msgstr ""

#: 
msgid "Now let's run the ``collect_training_data`` function."
msgstr ""

#: 
msgid "**Note**: With supervised classification, its common to have many, many labelled geometries in the training data. ``collect_training_data`` can parallelize across the geometries in order to speed up the extracting of training data. Setting ``ncpus>1`` will automatically trigger the parallelization. However, its best to set ``ncpus=1`` to begin with to assist with debugging before triggering the parallelization. You can also limit the number of polygons to run when checking code. For example, passing in ``gdf=input_data[0:5]`` will only run the code over the first 5 polygons."
msgstr ""

#: 
msgid "The function returns a list (``column_names``) contains a list of the names of the feature layers we've computed:"
msgstr ""

#: 
msgid "The second object returned by the function is a numpy.array (``model_input``) and contains the data from our labelled geometries. The first item in the array is the class integer (e.g. in the default example 1. 'crop', or 0. 'noncrop'), the second set of items are the values for each feature layer we computed:"
msgstr ""

#: 
msgid "Export training data"
msgstr ""

#: 
msgid "Once we've collected all the training data we require, we can write the data to disk. This will allow us to import the data in the next step(s) of the workflow."
msgstr ""

#: 
msgid "To continue working through the notebooks in this ``Scalable Machine Learning on the ODC`` workflow, go to the next notebook ``2_Inspect_training_data.ipynb``."
msgstr ""

#: 
msgid "**Extracting_training_data (this notebook)**"
msgstr ""

#: 
msgid "Inspecting training data"
msgstr ""

#: 
msgid "**Keywords** :index:`data methods; principal component analysis`, :index:`data methods; violin plots`, :index:`data methods; machine learning`, :index:`data methods; feature importance`"
msgstr ""

#: 
msgid "Prior to training a machine learning classifier, it can be useful to understand which of our feature layers are most useful for distinguishing between classes. The feature layers the models are trained on form the **knowledge base** of the algorithm. We can explore this knowledge base using class-specific `violin plots <https://en.wikipedia.org/wiki/Violin_plot#:~:text=A%20violin%20plot%20is%20a,by%20a%20kernel%20density%20estimator.>`__, and through a dimensionality reduction approach called `principal component analysis <https://builtin.com/data-science/step-step-explanation-principal-component-analysis>`__. The latter transforms our large dataset with lots of variables into a smaller dataset with fewer variables (while still preserving much of the variance), this allows us to visualise a very complex dataset in a relatively intuitive and straightforward manner."
msgstr ""

#: 
msgid "By exploring our training data we can learn more about the land cover classes we are interested in mapping (e.g is NDVI a good way to distinguish between crop and non-crop areas?), decide if we have enough training data and the right features for our models to be able to accurately map the classes (are there distinct differences in the feature layers values between classes?), and position ourselves to improve the model should the results be unsatisfactory (what kinds of features can we discard that might be confusing the model?)."
msgstr ""

#: 
msgid "Using the training data written to file in the previous notebook, `1_Extract_training_data <1_Extract_training_data.ipynb>`__, this notebook will:"
msgstr ""

#: 
msgid "Plot class-specific violin plots for each of the feature layers in the training data"
msgstr ""

#: 
msgid "Plot the importance of each feature after applying a model to the data."
msgstr ""

#: 
msgid "Calculate the first two and three prinicpal components of the dataset and plot them as 2D and 3D scatter plots"
msgstr ""

#: 
msgid "Analysis Parameters"
msgstr ""

#: 
msgid "``training_data``: Name and location of the training data ``.txt`` file output from runnning ``1_Extract_training_data.ipynb``"
msgstr ""

#: 
msgid "``class_dict``: A dictionary mapping the 'string' name of the classes to the integer values that represent our classes in the training data (e.g. ``{'crop': 1., 'noncrop': 0.}``)"
msgstr ""

#: 
msgid "``field``: This is the name of the column in the original training data shapefile that contains the class labels. This is provided simply so we can remove this attribute before we plot the data"
msgstr ""

#: 
msgid "Import training data"
msgstr ""

#: 
msgid "Data Wrangling"
msgstr ""

#: 
msgid "This cell extracts each class in the training data array and assigns it to a dictionary, this step will allow for cleanly plotting our data"
msgstr ""

#: 
msgid "Feature layer violin plots"
msgstr ""

#: 
msgid "As you can see, a number of our features show good separation between the crop and non-crop classes. For example, the red, green, blue, swir, red edge 1, NDVI, and MNDWI features all have very different distributions between the classes. This is a good indication that our model will possess the right features for distinguishing between crop and non-crop later on in the workflow."
msgstr ""

#: 
msgid "Feature Importance"
msgstr ""

#: 
msgid "Here we extract classifier estimates of the relative importance of each feature for training the classifier. This is useful for potentially selecting a subset of input bands/variables for model training/classification (i.e. optimising feature space). However, in this case, we are not selecting a subset of features, but rather just trying to understand the importance of each feature. This can help us not only understand our classes better (e.g. what kinds of measurements are indicative of cropland areas), but can also lead to further improvements to the model."
msgstr ""

#: 
msgid "Sklearn has good documentation on different methods for `feature selection <https://scikit-learn.org/stable/modules/feature_selection.html>`__."
msgstr ""

#: 
msgid "Results will be presented in ascending order with the most important features listed last. Importance is reported as a relative fraction between 0 and 1. These importances are based on how much a given feature, on average, decreases the weighted Gini impurity."
msgstr ""

#: 
msgid "According to the the feature importance method of the ``RandomForestClassifier`` we fitted to our data, the LAI, NDVI and swir_2 band are our most important features for discriminating between crop and non-crop samples in Egypt."
msgstr ""

#: 
msgid "Principal Component Analysis"
msgstr ""

#: 
msgid "The code below will calculate and plot the first two principal components of our training dataset. This will transform our dataset with lots of variables (16 features) into a dataset with fewer variables, this allows us to visualise our dataset in a relatively intuitive and straightforward manner."
msgstr ""

#: 
msgid "The first step is to standardise our data to express each feature layer in terms of mean and standard deviation. This is necessary because principal component analysis is quite sensitive to the variances of the initial variables. If there are large differences between the ranges of initial variables, those variables with larger ranges will dominate over those with small ranges (For example, a variable that ranges between 0 and 100 will dominate over a variable that ranges between 0 and 1), which will lead to biased results. So, transforming the data to comparable scales can prevent this problem. We do this using sklearn's ``StandardScalar`` function which will normalise the values in an array to the array's mean and standard deviation via the formula:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{align*} z = \\frac{x-u}{s} \\end{align*}`"
msgstr ""

#: 
msgid "where :math:`u` is the mean and :math:`s` is the standard deviation."
msgstr ""

#: 
msgid "Conduct the PCAs"
msgstr ""

#: 
msgid "Now we can print the amount of variance explained by the two- and three-component PCAs."
msgstr ""

#: 
msgid "Plot both 2 & 3 principal components"
msgstr ""

#: 
msgid "The purpose of this notebook was to inspect our training data to determine its appropriateness for classifying cropland areas. The excellent separation between our two datasets shown in the violin and PCA plots above suggests we have enough training data and the right feature layers to proceed with our classification problem."
msgstr ""

#: 
msgid "To continue working through the notebooks in this ``Scalable Machine Learning on the ODC`` workflow, go to the next notebook ``3_Train_fit_evaluate_classifier.ipynb``."
msgstr ""

#: 
msgid "`Extracting_training_data <1_Extract_training_data.ipynb>`__"
msgstr ""

#: 
msgid "**Inspect_training_data (this notebook)**"
msgstr ""

#: 
msgid "Evaluate, optimize, and fit a classifier"
msgstr ""

#: 
msgid "**Keywords** :index:`data methods; machine learning`, :index:`data methods; cross validation`, :index:`data methods; hyperparameters`"
msgstr ""

#: 
msgid "Now that we've extracted training data from the ODC, and inspected it to ensure the features we selected are appropriate and useful, we can train a machine learning model. The first step is to decide which machine learning model to use. Deciding which one to pick depends on the classification task at-hand. The table below provides a useful summary of the pros and cons of different models (all of which are available through `scikit-Learn <https://scikit-learn.org/stable/>`__). This sckit-learn `cheat sheet <https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html>`__ may also help."
msgstr ""

#: 
msgid "*Table 1: Some of the pros and cons of different classifiers available through scikit-learn*"
msgstr ""

#: 
msgid "The approach to evaluating, optimizing, and training the supervised machine learning model demonstrated in this notebook has been developed to suit the default training dataset provided. The training dataset is small, contains geospatial data, and contains only two classes (crop and non-crop)."
msgstr ""

#: 
msgid "Because the dataset is very small (``n=156`` as shown in the `Extracting_training_data <1_Extract_training_data.ipynb>`__ notebook), splitting the data into a training and testing set, and only training the model on the smaller training set would likely substantially degrade the quality of the model. Thus we will fit the final model on *all* the training data."
msgstr ""

#: 
msgid "Because we are fitting the model on all the data, we won't have a testing set left over to estimate the model's prediction accuracy. We therefore rely on a method called **nested k-fold cross-validation** to estimate the prediction ability of our model. This method is described further in the markdown before the code."
msgstr ""

#: 
msgid "And because we are generating a binary prediction (crop/non-crop), the metrics used to evaluate the classifier are those which are well suited to binary classifications."
msgstr ""

#: 
msgid "While the approach described above works well for the default training data provided, it may not suit your own classification problem. It is advisable to research the different methods for evaluating and training a model to determine which approach is best for you."
msgstr ""

#: 
msgid "This notebook runs through evaluating, optimizing, and fitting a machine learning classifier (in the default example, a Random Forest model is used). Under each of the sub-headings you will find more information on how and why each method is used. The steps are as follows:"
msgstr ""

#: 
msgid "Set up some parameters and import the training data"
msgstr ""

#: 
msgid "Calculate an unbiased performance estimate via nested cross-validation"
msgstr ""

#: 
msgid "Optimize the hyperparameters of the model"
msgstr ""

#: 
msgid "Fit a model to all the training data using the best hyperparameters identified in the previous step"
msgstr ""

#: 
msgid "Save the model to disk for use in the subsequent notebook, ``4_Classify_satellite_data.ipynb``"
msgstr ""

#: 
msgid "``Classifier``: This parameter refers to the scikit-learn classification model to use, first uncomment the classifier of interest in the ``Load Packages`` section and then enter the function name into this parameter ``e.g. Classifier = SVC``"
msgstr ""

#: 
msgid "``metric`` : A single string that denotes the scorer used to find the best parameters for refitting the estimator to evaluate the predictions on the test set. See the scoring parameter page `here <https://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter>`__ for a pre-defined list of options. e.g. ``metric='balanced_accuracy'``"
msgstr ""

#: 
msgid "K-Fold Cross Validation Analysis Parameters"
msgstr ""

#: 
msgid "``outer_cv_splits`` : The number of cross validation splits to use for the outer loop of the nested CV. These splits are used to estimate the accuracy of the classifier. A good default number is 5-10"
msgstr ""

#: 
msgid "``inner_cv_splits`` : The number of cross validation splits to use for the inner loop of the nested CV - the inner loop splits are used for optimizing the hyperparameters. A good default number is 5."
msgstr ""

#: 
msgid "``test_size`` : This will determine what fraction of the dataset will be set aside as the testing dataset. There is a trade-off here between having a larger test set that will help us better determine the quality of our classifier, and leaving enough data to train the classifier. A good deafult is to set 10-20 % of your dataset aside for testing purposes."
msgstr ""

#: 
msgid "Find the number of cpus"
msgstr ""

#: 
msgid "K-fold `cross-validation <https://en.wikipedia.org/wiki/Cross-validation_(statistics)>`__ is a statistical method used to estimate the performance of machine learning models when making predictions on data not used during training. It is a popular method because it is conceptually straightforward and because it generally results in a less biased or less optimistic estimate of the model skill than other methods, such as a simple train/test split."
msgstr ""

#: 
msgid "This procedure can be used both when optimizing the hyperparameters of a model on a dataset, and when comparing and selecting a model for the dataset. However, when the same cross-validation procedure and dataset are used to both tune and select a model, it is likely to lead to an optimistically biased evaluation of the model performance."
msgstr ""

#: 
msgid "One approach to overcoming this bias is to nest the hyperparameter optimization procedure under the model selection procedure. This is called **nested cross-validation**. The paper `here <https://jmlr.csail.mit.edu/papers/v11/cawley10a.html>`__ provides more context to this issue. The image below depicts how the nested cross-validation works."
msgstr ""

#: 
msgid "The result of our nested cross-validation will be a set of accuracy scores that show how well our classifier is doing at recognising unseen data points. The default example is set up to show the ``balanced_accuracy``, and ``f1`` scores, along the ``Receiver-Operating Curve, Area Under the Curve (ROC-AUC)``. This latter metric is a robust measure of a classifier's prediction ability. `This article <https://towardsdatascience.com/understanding-auc-roc-curve-68b2303cc9c5>`__ has a good explanation on ROC-AUC, which is a common machine learning metric."
msgstr ""

#: 
msgid "All measures return a value between 0 and 1, with a value of 1 indicating a perfect score."
msgstr ""

#: 
msgid "To conduct the nested cross-validation, we first need to define a grid of parameters to be used in the optimization: \\* ``param_grid``: a dictionary of model specific parameters to search through during hyperparameter optimization."
msgstr ""

#: 
msgid "**Note**: the parameters in the ``param_grid`` object depend on the classifier being used. The default example is set up for a Random Forest classifier, to adjust the parameters to suit a different classifier, look up the important parameters under the relevant `sklearn documentation <https://scikit-learn.org/stable/supervised_learning.html>`__."
msgstr ""

#: 
msgid "Print the results of our model evaluation"
msgstr ""

#: 
msgid "These scores represent a robust estimate of the accuracy of our classifier. However, because we are using only a subset of data to fit and optimize the models, and the total amount of training data we have is small (only 156 samples in the default example) it is reasonable to expect these scores are an under-estimate of the final model's accuracy."
msgstr ""

#: 
msgid "Also, the *map* accuracy will likely differ from the accuracies reported here since the training data is often not a perfect representation of the data in the real world. For example, we may have purposively over-sampled from hard-to-classify regions, or the proportions of classes in our dataset may not match the proportions in the real world."
msgstr ""

#: 
msgid "Optimize hyperparameters"
msgstr ""

#: 
msgid "Machine learning models require certain 'hyperparameters': model parameters that can be tuned to increase the prediction ability of a model. Finding the best values for these parameters is a 'hyperparameter search' or an 'hyperparameter optimization'."
msgstr ""

#: 
msgid "To optimize the parameters in our model, we use `GridSearchCV <https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html>`__ to exhaustively search through a set of parameters and determine the combination that will result in the highest accuracy based upon the accuracy metric defined."
msgstr ""

#: 
msgid "We'll search the same set of parameters that we definied earlier, ``param_grid``."
msgstr ""

#: 
msgid "Fit a model"
msgstr ""

#: 
msgid "Using the best parameters from our hyperparmeter optimization search, we now fit our model on all the data."
msgstr ""

#: 
msgid "Save the model"
msgstr ""

#: 
msgid "Running this cell will export the classifier as a binary\\ ``.joblib`` file. This will allow for importing the model in the subsequent script, ``4_Classify_satellite_data.ipynb``"
msgstr ""

#: 
msgid "To continue working through the notebooks in this ``Scalable Machine Learning on the ODC`` workflow, go to the next notebook ``4_Classify_satellite_data.ipynb.ipynb``."
msgstr ""

#: 
msgid "**Evaluate_optimize_fit_classifier (this notebook)**"
msgstr ""

#: 
msgid "`Object-based_filtering <5_Object-based_filtering.ipynb>`__\\ (optional)"
msgstr ""

#: 
msgid "Classifying satellite data"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; sentinel-2 geomedian`, :index:`data methods; classification`, :index:`data methods; machine learning`"
msgstr ""

#: 
msgid "Having succesfully run the ``3_Evaluate_optimize_fit_classifier`` notebook, we can now use our classification model to predict values on new satellite data. This notebook will guide you through loading satellite data from the ODC, computing the same feature layers as we did in the first notebook when we extracted training data from the ODC, and using our model to classify the satellite data. Initially we classify a few small regions to visualize how well our model is performing. The notebook will then attempt to classify a much larger region and save the results to disk as a Cloud-Optimized GeoTIFF (COG)."
msgstr ""

#: 
msgid "The steps are as follows: 1. Open the model we output in the previous notebook, ``3_Evaluate_optimize_fit_classifier`` 2. Redefine the feature layer function that we used to extract training data from the ODC in the first notebook, ``1_Extract_training_data`` 3. Loop through a set of small test locations extracting satellite data from the ODC, then compute the feature layers and classify the data using our model. 4. Plot the results of classifying our small test locations 5. Define a new, much larger location to load from the ODC and classify using the same model 6. Save our results to disk as a COG"
msgstr ""

#: 
msgid "This will help keep our memory use down and conduct the analysis in parallel. If you'd like to view the dask dashboard, click on the hyperlink that prints below the cell. You can use the dashboard to monitor the progress of calculations."
msgstr ""

#: 
msgid "``model_path``: The path to the location where the model exported from the previous notebook is stored"
msgstr ""

#: 
msgid "``testing_locations``: A dictionary with values containing latitude and longitude points, and keys representing a unique ID to identify the locations. The ``lat`` and ``lon`` points define the center of the satellite images we will load for running small test classifications"
msgstr ""

#: 
msgid "``buffer``: The size, in decimal degrees, to load around the central latitude and longitude points in ``locations``. This number here will depend on the compute/RAM available on the Sandbox instance, and the type and number of feature layers calculated. A value of ``0.1`` (which results in a 0.2 x 0.2 degree analysis extent) usually works well on the default Sandbox instance."
msgstr ""

#: 
msgid "``dask_chunks``: Dask works by breaking up large datasets into chunks, which can be read individually. This parameter specifies the size of the chunks in numbers of pixels, e.g. ``{'x':1000,'y':1000}``"
msgstr ""

#: 
msgid "``results``: A folder location to store the classified GeoTIFFs"
msgstr ""

#: 
msgid "Import the model"
msgstr ""

#: 
msgid "The code below will also re-open the training data we exported from ``3_Evaluate_optimize_fit_classifier.ipynb`` and grab the column names (features we selected)."
msgstr ""

#: 
msgid "Making a prediction"
msgstr ""

#: 
msgid "Redefining the feature layer function"
msgstr ""

#: 
msgid "Because we elected to use all the features extracted in ``1_Extract_training_data.ipynb``, we can simply copy-and-paste the ``feature_layers`` function from the first notebook `Extracting_training_data <1_Extract_training_data.ipynb>`__ into the cell below (this has already been done for you)."
msgstr ""

#: 
msgid "If you're using this notebook to run your own classifications (i.e. not running the default example), then you'll need to redefine your feature layer function below, taking care to match the features in the trained model. For example, if you conducted feature selection and removed features from the model, then you'll need to mimic that process here by removing features in the prediction data. In short, the features in the model must precisely match those in the data you're classifying."
msgstr ""

#: 
msgid "**Note:** Because we are using dask to help us scale the operations, we need to add a ``dask_chunks`` parameter to the ``slope`` layer so this layer will interact with the dask arrays in the satellite data. As ``slope`` is a 2D layer, we don't need 'time' in the chunks argument, only 'x' and 'y'."
msgstr ""

#: 
msgid "Set up datacube query"
msgstr ""

#: 
msgid "These query options should match the query params in ``1_Extract_training_data.ipynb``, unless there are measurements that no longer need to be loaded because they were dropped during a feature selection process (which has not been done in the default example)."
msgstr ""

#: 
msgid "Loop through test locations and predict"
msgstr ""

#: 
msgid "For every location we listed in the ``test_locations`` dictionary, we calculate the feature layers, and then use the DE Africa function `predict_xr <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/83116e80ebb4f8744e3de74e7a713aadd0a7577a/Tools/deafrica_tools/classification.py#L237>`__ to classify the data."
msgstr ""

#: 
msgid "The ``predict_xr`` function is an xarray wrapper around the sklearn estimator ``.predict()`` and ``.predict_proba()`` methods, and relies on `dask-ml <https://ml.dask.org/>`__ `ParallelPostfit <https://ml.dask.org/modules/generated/dask_ml.wrappers.ParallelPostFit.html>`__ to run the predictions with dask. ``Predict_xr`` can compute predictions, prediction probabilites, and return the input feature layers. Read the `documentation <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/83116e80ebb4f8744e3de74e7a713aadd0a7577a/Tools/deafrica_tools/classification.py#L247>`__ for more insights into this function's capabilities."
msgstr ""

#: 
msgid "Plotting results"
msgstr ""

#: 
msgid "In the plots below you'll see on the left the classified image (green = crop, white = non-crop), in the centre a true-colour image of the region, and on the right an image of the prediction probabilities. Because we are using a Random Forest Classifier, the prediction probabilities refer to the percentage of trees that voted for the resulting classification. For example, if the model had 200 decision trees in the random forest, and 150 of the trees voted 'crop', the prediction probability is **150 / 200 x 100 = 75 %**"
msgstr ""

#: 
msgid "Large scale classification"
msgstr ""

#: 
msgid "If you're happy with the results of the test locations, then attempt to classify a large region by re-entering a new latitude, longitude and larger buffer size. You may need to adjust the ``dask_chunks`` size to optimize for the larger region. If you do change the chunk size, then remember to adjust the chunks in the feature layer function above (i.e. in the default example ``feature_layers``)"
msgstr ""

#: 
msgid "The cell directly below will first clear the test location results from memory, so we have enough RAM to run a much larger prediction."
msgstr ""

#: 
msgid "Enter a new set of coordinates and larger buffer size below. You can use the ``display_map()`` cell to see an outline of the area you'll be classifying. The default example is centred on the city of Faiyum, Egypt. Try to keep the buffer size below 0.5, any larger than this and the default sandbox will begin running out of RAM, which interrupts the calculation."
msgstr ""

#: 
msgid "We will now classify the region specified above:"
msgstr ""

#: 
msgid "Write the results to GeoTIFFs"
msgstr ""

#: 
msgid "Our predictions and prediction probabilites are written to disk as Cloud-Optimised GeoTIFFs. In addition to exporting the predictions, we will also export one of the feature layers, NDVI. In the next notebook, ``5_Object-based_filtering``, we will look at using image segmentation to clean up the pixel-based results. The NDVI layer will provide an input to the image segmentation algorithm."
msgstr ""

#: 
msgid "Below, we will plot our pixel based cropland mask for the region around the city of Faiyum, Egypt."
msgstr ""

#: 
msgid "**Note:** This could crash the kernel if the region is very large, but should be fine if you're using the default example."
msgstr ""

#: 
msgid "Congratulations, you have successfully created a cropland extent model for Egypt! If you're perfectly happy with the results, then this pixel-based classification can be the final point in your workflow. However, in reality, ML workflows like the one you've just been through are an **iterative process**. If we weren't happy with the classifications, then we have a few options to improve the model:"
msgstr ""

#: 
msgid "Conduct feature selection to remove features that might be confounding our model."
msgstr ""

#: 
msgid "Consider adding new features to the model. This would require editing and re-running the ``collect_training_data`` function in the `Extracting_training_data <1_Extract_training_data.ipynb>`__ notebook to add new features to our training dataset."
msgstr ""

#: 
msgid "Try using a different model (e.g. instead of using a Random Forest Classifier we could use a Support Vector Machine - this will require editing and re-running the `Evaluate_optimize_fit_classifier <3_Evaluate_optimize_fit_classifier.ipynb>`__ notebook)."
msgstr ""

#: 
msgid "Collect more training data in the regions where our classifier is doing poorly. This can be done through the platforms suggested in `Extracting_training_data <1_Extract_training_data.ipynb>`__."
msgstr ""

#: 
msgid "We can also potentially improve our classifications by moving to the next notebook in this series. The next notebook explores converting the pixel-based classification into an object-based classification using an image segmentation algorithm."
msgstr ""

#: 
msgid "To continue working through the notebooks in this ``Scalable Machine Learning on the ODC`` workflow, go to the next notebook ``5_Object-based_filtering.ipynb``."
msgstr ""

#: 
msgid "**Classify_satellite_data (this notebook)**"
msgstr ""

#: 
msgid "Object-based filtering of pixel classifications"
msgstr ""

#: 
msgid "**Keywords** :index:`data methods; image segmentation`, :index:`data methods; GEOBIA`"
msgstr ""

#: 
msgid "Geographic Object-Based Image Analysis (GEOBIA), aims to group pixels together into meaningful image-objects. There are two advantages to a GEOBIA workflow: one, we can reduce the 'salt and pepper' effect typical of classifying pixels; and two, we can increase the computational efficiency of our workflow by grouping pixels into fewer, larger, but more meaningful objects. A review of the emerging trends in GEOBIA can be found in `Chen et al. (2017) <https://www.tandfonline.com/doi/abs/10.1080/15481603.2018.1426092>`__."
msgstr ""

#: 
msgid "In this notebook, we take the pixel-based classifications generated in the ``4_Classify_satellite_data.ipynb`` notebook, and filter the classifications by image-objects. To do this, we first need to conduct image segmentation using the function ``skimage.segmentation.quickshift``. The image segmentation is conducted on the ``NDVI`` layer output in the previous notebook. To filter the pixel observations, we assign to each segment the majority (mode) pixel classification using the ``scipy.ndimage.measurements import _stats`` module."
msgstr ""

#: 
msgid "Run the image segmentation"
msgstr ""

#: 
msgid "Visualize the segments"
msgstr ""

#: 
msgid "Calculate the **mode** statistic for each segment"
msgstr ""

#: 
msgid "Write the new object-based classification to disk as a COG"
msgstr ""

#: 
msgid "``pred_tif``: The path and name of the prediction GeoTIFF output in the previous notebook."
msgstr ""

#: 
msgid "``tif_to_seg``: The geotiff to use as an input to the image segmentation, in the default example this was an NDVI layer output in the last notebook."
msgstr ""

#: 
msgid "``results``: A folder location to store the classified GeoTIFFs."
msgstr ""

#: 
msgid "Generate an object-based classification"
msgstr ""

#: 
msgid "Run image segmentation"
msgstr ""

#: 
msgid "Visualise segments"
msgstr ""

#: 
msgid "To help us visualize the segments, we can calculate the zonal mean NDVI for each segment and then we'll plot a zoomed in section of the region"
msgstr ""

#: 
msgid "Open pixel-based predictions"
msgstr ""

#: 
msgid "Calculate mode"
msgstr ""

#: 
msgid "Within each segment, the majority classification is calculated and assigned to that segment."
msgstr ""

#: 
msgid "Write result to disk"
msgstr ""

#: 
msgid "Below we plot the the pixel-based classification alongside the newly created object-based classification. You can see the 'salt and pepper' effect of individual pixels being classified as crop has been removed in the object based classification, resulting in a 'cleaner' classification."
msgstr ""

#: 
msgid "This is the last notebook in the ``Scalable Machine Learning on the ODC`` workflow! To revist any of the other notebooks, use the links below."
msgstr ""

#: 
msgid "**Object-based_filtering (this notebook)**"
msgstr ""

#: 
msgid "Scalable Supervised Machine Learning"
msgstr ""

#: 
msgid "This workflow covers training a machine learning model to classify satellite data."
msgstr ""

#: 
msgid "Identifying ships with Sentinel-1"
msgstr ""

#: 
msgid "**Products used:** `s1_rtc <https://explorer.digitalearth.africa/products/s1_rtc>`__ `ga_ls8c_wofs_2_annual_summary <https://explorer.digitalearth.africa/products/ga_ls8c_wofs_2_annual_summary>`__"
msgstr ""

#: 
msgid "Being able to spot ships and shipping lanes from satellite imagery can be useful for gaining a holistic picture of maritime traffic. The properties of radar data can be utilised to detect where ships appear over time, as well as highlighting the presence of shipping lanes."
msgstr ""

#: 
msgid "When working with radar data, water commonly appears dark due to its relatively smooth surface resulting in very low backscatter, and consequently, low intensities are recorded by the satellite in both polarisation bands. However, if a large ship is on the water, the backscatter at the ship's location will be much higher than the water due to double-bounce scattering effects."
msgstr ""

#: 
msgid "The ESA/EC Copernicus Sentinel-1 mission (Sentinel-1A and 1B) has a frequent revisit time of a few days. This helps to build a large catalogue of observations that can be leveraged to identify shipping lanes."
msgstr ""

#: 
msgid "In this example, we attempt to identify ships around the Suez Canal in Egypt during March 2021. Significant changes in the number and distribution pattern of the ships are detected, showing the impact of a blockage. More about the event can be found in `this thread <https://twitter.com/thesheetztweetz/status/1374760229116682247?s=20>`__ on Twitter."
msgstr ""

#: 
msgid "Ships are identified by taking advantage of the fact that ships on the water result in a large radar backscatter signal."
msgstr ""

#: 
msgid "The steps demonstrated in this notebook include:"
msgstr ""

#: 
msgid "Loading Sentinel-1 backscatter image for an area of interest."
msgstr ""

#: 
msgid "Extracting open water mask using the Water Observations from Space (WOfS) annual summary."
msgstr ""

#: 
msgid "Counting the number of vessels before and after the event and save the results."
msgstr ""

#: 
msgid "Visualiinge the maximum backscatter values from a time series to identify shipping lanes."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2021')``)"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers the Suez Canel in Egypt during March 2021."
msgstr ""

#: 
msgid "The first step in the analysis is to load Sentinel-1 backscatter data for the specified area of interest."
msgstr ""

#: 
msgid "Optional speckle filtering"
msgstr ""

#: 
msgid "Specke filtering is not applied in this example because there is a high contrast between water and ship signals. Applying speckle filtering with a small smoothing window may help improve sensitivity for smaller ships."
msgstr ""

#: 
msgid "An example of how to apply a speckle filter can be found in the `radar water detection notebook <Radar_water_detection.ipynb>`__."
msgstr ""

#: 
msgid "Convert data to decibels (dB)"
msgstr ""

#: 
msgid "Sentinel-1 backscatter data has two measurements, *VV* and *VH*, which correspond to the polarisation of the light sent and received by the satellite. *VV* refers to the satellite sending out vertically-polarised light and receiving vertically-polarised light back, whereas *VH* refers to the satellite sending out vertically-polarised light and receiving horizontally-polarised light back. These two measurement bands can tell us different information about the area we're studying."
msgstr ""

#: 
msgid "When working with radar backscatter, it is common to work with the data in units of decibels (dB), rather than linear intensity. To convert from recorded Digital Number (DN) to dB in Sentinel-1 imagery, we use the following formula:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{dB} = 10 \\times \\log_{10}(\\text{DN}).\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "Visualise data before and after the event"
msgstr ""

#: 
msgid "We focus on the first and the last observations within this period of time. The ship blockage incident started on 23 March 2021 and lasted almost a week, so we inspect one image from before the event, and one during."
msgstr ""

#: 
msgid "Images below show a high constrast between dark water surface and bright ships."
msgstr ""

#: 
msgid "Extract open water area"
msgstr ""

#: 
msgid "Surface water can be mapped by thresholding radar backscatter. An detailed example is provided in the `radar water detection notebook <Radar_water_detection.ipynb>`__. To eliminate the impact of ships and waves, both causing elevated backscatter, minimum backscatter values detected over time for each pixel can be used. e.g."
msgstr ""

#: 
msgid "``water_mask = S1.vv.min(dim=\"time\")<0.015``"
msgstr ""

#: 
msgid "For this notebook, however, we use another readily available product in DE Africa, namely the Water Observations from Space (WOfS) annual summary to extract the open water area."
msgstr ""

#: 
msgid "The water detection ``frequency`` measurement of WOfS annual summary from the latest available year is loaded to match the Sentinel-1 pixel grid using the option ``like`` in ``dc.load()`` and ``bilinear`` resampling."
msgstr ""

#: 
msgid "Open water surface is extracted where water has been detected more than 80% of the year. For an optimal result, the mask is further adjusted to remove gaps and small water bodies."
msgstr ""

#: 
msgid "Apply water mask and threshold for ship detection"
msgstr ""

#: 
msgid "In this example, a threshold of 0 dB is chosen. Ships are detected where backscatter values are higher than this threshold. The binary image is vectorised so pixels from the same ship are grouped as one object."
msgstr ""

#: 
msgid "Visual inspection confirms reasonable detection of large cargo ships. The threshold can be adjusted for different area and vessel types. With known ship locations, the threshold can be optimised using training data."
msgstr ""

#: 
msgid "Caveats and possible improvements"
msgstr ""

#: 
msgid "We have applied a simple thresholding method to idenfity ships in the above sections. Only VV backscatter has been used and no speckle filtering has been done. This method is based on the assumption that ships produce very high backscatter signals and all bright objects within the water area are ships."
msgstr ""

#: 
msgid "Additional analysis may be help improve the method: \\* Threshold for ship pixels are chosen based on visual assessment. The threshold is relatively high so smaller ships may be missed. This threshold may be optimzed with labeled training data for specific use cases. \\* It is not clear if all the bright objects near the piers are ships. The location and shape of the objects may be used to remove false positives. \\* Rigid structures onboard the ships may result in multiple disconnected bright spots over one ship. These smaller objects may be grouped to give more reliable ship count."
msgstr ""

#: 
msgid "Despite the above limitations, we demonstrate that with a few analysis steps, DE Africa's Sentinel-1 backscatter can be used to detect and count large ships."
msgstr ""

#: 
msgid "Identify shipping lanes"
msgstr ""

#: 
msgid "Ship locations detected across time can be used to map out popular routes."
msgstr ""

#: 
msgid "In the cells below, we load all Sentinel-1 observations from 2020. Plotting maximum backscatter values over time allows clear identification of the shipping lanes."
msgstr ""

#: 
msgid "Data is lazy-loaded using the ``dask_chunks`` options to reduce memory requirement."
msgstr ""

#: 
msgid "When you are done, return to the \"Set up analysis\" cell, modify some values (e.g. ``latitude`` and ``longitude``) and rerun the analysis."
msgstr ""

#: 
msgid "There are a number of key ports covered by Sentinel-1 data in Africa. The available data can be viewed on the `DEAfrica Explorer <https://explorer.digitalearth.africa/products/s1_rtc>`__, but we also list the latitude and longitude coordinates for a few key ports below."
msgstr ""

#: 
msgid "**Port of Durban in South Africa**"
msgstr ""

#: 
msgid "**Port of Dar Es Salaam in Tanzania**"
msgstr ""

#: 
msgid "**Port de Tanger Med in Morocco**"
msgstr ""

#: 
msgid "Timeseries analysis of temperature"
msgstr ""

#: 
msgid "**Products used:** `ERA5 <https://registry.opendata.aws/ecmwf-era5/>`__, `ls5_st <https://explorer.digitalearth.africa/ls5_st>`__, `ls8_st <https://explorer.digitalearth.africa/ls8_st>`__"
msgstr ""

#: 
msgid "The ERA5 dataset is external to the Digital Earth Africa platform."
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ERA5`, :index:`datasets; ERA5`, :index:`climate`, :index:`temperature`, :index:`surface temperature`"
msgstr ""

#: 
msgid "We may be interested in how an environmental variable has changed or trended over a medium or long-term period. Timeseries decomposition can help us visualise long-term trends in geospatial variables. The technique decomposes a timeseries into its cyclical (seasonal), trend, and residual error components."
msgstr ""

#: 
msgid "For this example, we will load air and surface temperature data. The spatial resolution of surface temperature data allows us to visualise spatial patterns between timepoints. Conversely, the temporal regularity of ERA5 air temperature data means it is better suited to analysis of a one-dimensional timeseries."
msgstr ""

#: 
msgid "Loading ERA5 air temperature and Landsat surface temperature data."
msgstr ""

#: 
msgid "Plot and inspect surface temperature at two time points."
msgstr ""

#: 
msgid "Decomposing a timeseries of air temperature data into trend, seasonal, and random error components."
msgstr ""

#: 
msgid "Plotting and interpreting seasonal and trend components of timeseries."
msgstr ""

#: 
msgid "We will load temperature data for a forty year period (1981-2021) for the default location of Cairo, Egypt."
msgstr ""

#: 
msgid "``lat``: range of latitude we wish to cover."
msgstr ""

#: 
msgid "``lon``: range of longitude we wish to cover."
msgstr ""

#: 
msgid "``time``: time period"
msgstr ""

#: 
msgid "Load temperature data"
msgstr ""

#: 
msgid "We will use the ``load_era5`` function to get air temperature at a height of 2m for the period and area of interest. We resample this dataset to monthly mean values as we load, so the dataset size is more manageable."
msgstr ""

#: 
msgid "We will also use ``load_ard`` to get land surface temperature from Landsats 5 and 8, and ``dc.load`` to retrieve Landsat geomedians so we can compare true colour images to surface temperature."
msgstr ""

#: 
msgid "Load air temperature"
msgstr ""

#: 
msgid "Load Landsat surface temperature and surface reflectance"
msgstr ""

#: 
msgid "Inspect changes in surface temperature"
msgstr ""

#: 
msgid "Plotting surface temperature alongside true colour images below shows how spatial patterns in surface temperature have changed between 1984 and 2020, and how they may relate to changes in land use and land cover. Addition of some vegetation and presumably irrigation in the eastern part of the area has produced lower surface temperature in 2020 compared with 1984. However, loss of vegetation and infrastructure development in other areas appears to have increased surface temperature."
msgstr ""

#: 
msgid "Inspect air temperature timeseries"
msgstr ""

#: 
msgid "Below, the observed timeseries of air temperature is plotted. Are there any noticeable trends or anomalies?"
msgstr ""

#: 
msgid "Timeseries decomposition"
msgstr ""

#: 
msgid "The next step is to decompose the observed timeseries into its seasonal and trend components. The ``seasonal_decompose`` function works best on pandas timeseries, so we will spatially aggregate our timeseries and convert it to a pandas dataframe."
msgstr ""

#: 
msgid "Now we can use the ``seasonal_decompose`` function on our timeseries. Details on the function are available in the `package notes <https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html>`__ and general timeseries decomposition is available `here <https://en.wikipedia.org/wiki/Decomposition_of_time_series>`__."
msgstr ""

#: 
msgid "The result of decomposition is plotted below which shows the observed timeseries (shown above), the trend component (note difference in y-axis scale), the seasonal (or cyclical) component, and the residual error."
msgstr ""

#: 
msgid "We can also plot individual components, such as the long term trend, as below, and make comparisons between air and surface temperature."
msgstr ""

#: 
msgid "Interpretation and next steps"
msgstr ""

#: 
msgid "The exploratory analysis conducted in this notebook allows us to visually examine trends and seasonal patterns. We would need to conduct further statistical test to determine whether any observed trends could be considered 'significant'."
msgstr ""

#: 
msgid "We are also unable to draw any causal inferences about observed trends from this analysis alone. We might hypothesise that the increasing air temperature trend is due to some combination of increasing atmospheric greenhouse gas concentration and the changes in land use and land cover observed."
msgstr ""

#: 
msgid "Further analysis would be required to attribute the trends to any of these factors."
msgstr ""

#: 
msgid "Detecting change in urban extent"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2 geomedian`, :index:`band index; ENDISI`, :index:`urban`, :index:`analysis; change detection`"
msgstr ""

#: 
msgid "The rate at which cities and towns grow, or the urbanisation rate, is an important indicator of the sustainability of towns and cities. Rapid, unplanned urbanisation can result in poor social, economic, and environmental outcomes due to inadequate and overburdened infrastructure and services creating congestion, worsening air pollution, and leading to a shortage of adequate housing."
msgstr ""

#: 
msgid "The first requirement for addressing the impacts of rapid urbanisation is to accurately and regularly monitor urban expansion in order to track urban development over time. Earth Observation datasets, such as those available through the Digital Earth Africa platform provide a cost-effective and accurate means of mapping the urban extent of cities."
msgstr ""

#: 
msgid "This notebook will use Sentinel-2 annual geomedians to examine the change in urban extent between a baseline period and a more recent period. The difference in urban extent (area is square kilometres) between the two periods is calculated, along with a map highlighting the location of urban growth hotspots."
msgstr ""

#: 
msgid "This notebook conducts the following analysis:"
msgstr ""

#: 
msgid "Load Sentinel-2 annual geomedians data over the city/region of interest"
msgstr ""

#: 
msgid "Calculate the Enhanced Normalised Difference Impervious Surfaces Index (ENDISI)"
msgstr ""

#: 
msgid "Threshold the ENDISI plots to delineate urban extent"
msgstr ""

#: 
msgid "Compare the urban extent in the baseline year to the more recent urban extent"
msgstr ""

#: 
msgid "``baseline_year``: The baseline year, to use as the baseline of urbanisation (e.g. ``2017``)"
msgstr ""

#: 
msgid "``analysis_year``: The analysis year to analyse the change in urbanisation (e.g. ``2020``)"
msgstr ""

#: 
msgid "Load Sentinel-2 annual geomedians"
msgstr ""

#: 
msgid "The first step in this analysis is to load in Sentinel-2 annual geomedians for the ``lat_range``, ``lon_range`` and ``time_range`` we provided above."
msgstr ""

#: 
msgid "Select the images from the baseline and analysis years"
msgstr ""

#: 
msgid "View the geomedian satellite data"
msgstr ""

#: 
msgid "We can plot the two years to visually compare them:"
msgstr ""

#: 
msgid "Calculate ENDISI"
msgstr ""

#: 
msgid "The Enhanced Normalized Difference Impervious Surfaces Index (ENDISI) is a recently developed urbanisation proxy that has been shown to work well in a variety of environments (`Chen et al. 2020 <https://www.tandfonline.com/doi/full/10.1080/22797254.2020.1820383>`__) . Like all normalised difference indicies, it has a range of [-1,1]. Note that ``MNDWI``, ``swir_diff`` and ``alpha`` are all part of the ENDISI calculation."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{MNDWI} = \\frac{\\text{GREEN} - \\text{SWIR1}}{\\text{GREEN} + \\text{SWIR1}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{swir_diff} = \\frac{\\text{SWIR1}}{\\text{SWIR2}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{alpha} = \\frac{2 * \\text{mean(BLUE)}}{\\text{mean(swir_diff) + mean(MNDWI}^2)}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{ENDISI} = \\frac{\\text{BLUE} - \\text{alpha}*(\\text{swir_diff} + \\text{MNDWI}^2)}\n"
"{\\text{BLUE} + \\text{alpha}*(\\text{swir_diff} + \\text{MNDWI}^2)}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "ENDISI calculations are built into the ``calculate_indices`` function. We are using the Sentinel-2 geomedian, so the ``satellite_mission`` will be ``s2``."
msgstr ""

#: 
msgid "Let's plot the ENDISI images so we can see if the urban areas are distinguishable"
msgstr ""

#: 
msgid "And now plot the histogram of all the pixels in the ENDISI array"
msgstr ""

#: 
msgid "Calculate urban extent"
msgstr ""

#: 
msgid "To define the urban extent, we need to threshold the ENDISI arrays. Values above this threshold will be labelled as 'Urban' while values below the trhehsold will be excluded from the urban extent. We can determine this threshold a number of ways (inluding by simply manually definining it e.g. ``threshold=-0.1``). Below, we use the `Otsu method <https://scikit-image.org/docs/dev/auto_examples/segmentation/plot_thresholding.html>`__ to automatically threshold the image."
msgstr ""

#: 
msgid "Firstly, we need to fill any ``NaN`` values we have in the dataset with the mean of the dataset, otherwise the otsu threshold function will complain:"
msgstr ""

#: 
msgid "Apply the threshold"
msgstr ""

#: 
msgid "We apply the threshold and plot both years side-by-side."
msgstr ""

#: 
msgid "Plotting the change in urban extent"
msgstr ""

#: 
msgid "We can convert the data above into a total area for each year, then plot a bar graph."
msgstr ""

#: 
msgid "Urban growth hotspots"
msgstr ""

#: 
msgid "If we subtract the ENDISI of the baseline year from the analysis year, we can highlight regions where urban growth is occurring."
msgstr ""

#: 
msgid "In this plot, we can see areas that have seen significant change, highlighting regions of urbanisation."
msgstr ""

#: 
msgid "When you are done, return to the `Analysis parameters <#Analysis-parameters>`__ section, modify some values (e.g. ``lat``, ``lon`` or ``time``) and rerun the analysis."
msgstr ""

#: 
msgid "You can use the interactive map in the `View the selected location <#View-the-selected-location>`__ section to find new central latitude and longitude values by panning and zooming, and then clicking on the area you wish to extract location values for. You can also use Google maps to search for a location you know, then return the latitude and longitude values by clicking the map."
msgstr ""

#: 
msgid "If you're going to change the location, you'll need to make sure Landsat 8 data is available for the new location, which you can check at the `Digital Earth Africa Explorer <https://explorer.digitalearth.africa/products/ls8_sr>`__."
msgstr ""

#: 
msgid "For more advanced methods of urban extent detection, see the `Machine Learning with ODC <../Real_world_examples/Machine_learning_with_ODC.ipynb>`__ notebook, which uses a decision tree to classify urban area."
msgstr ""

#: 
msgid "Urbanization Index Comparisons with Global Human Settlement (GHS)"
msgstr ""

#: 
msgid "**Products used:** `gm_ls8_annual <https://explorer.digitalearth.africa/gm_ls8_annual>`__, `wofs_ls_summary_alltime <https://explorer.digitalearth.africa/wofs_ls_summary_alltime>`__"
msgstr ""

#: 
msgid "**Tags**: :index:`band index; NDBI`, :index:`band index; ENDISI`, :index:`band index; ASI`, :index:`urban`"
msgstr ""

#: 
msgid "There are many different urbanization indices with different characteristics and use cases. It is often convenient to be able to compare the performance of several indicies for an area - determining which is the best for an area based on the outputs and a \"ground truth\" dataset of urbanization."
msgstr ""

#: 
msgid "This notebook uses several indices to classify land as \"urban\" and then compares those results with the `Global Human Settlement (GHS) product <https://ghsl.jrc.ec.europa.eu/ghs_bu2019.php>`__ which shows the extent of built-up area (urban extent) through to 2014. The indices tested here are the **Normalized Difference Buildup Index (NDBI)**, the **Enhanced Normalized Difference Impervious Surface Index (ENDISI)** and the **Artificial Surface Index (ASI)**."
msgstr ""

#: 
msgid "Load a geomedian image from the region of interest."
msgstr ""

#: 
msgid "Mask water using the WOfS All Time Summary"
msgstr ""

#: 
msgid "Calulate urban indices and show histograms for the indices."
msgstr ""

#: 
msgid "Select minimum and maximum threshold values for the indicies to determine urban pixels."
msgstr ""

#: 
msgid "Show the urbanization prediction images."
msgstr ""

#: 
msgid "Load and show the \"ground truth\" data (GHS) for the year 2014."
msgstr ""

#: 
msgid "Compare the urbanization predictions with the \"ground truth\" data visually and statistically."
msgstr ""

#: 
msgid "The choice of threshold values can be informed by the histograms and comparing the urbanization prediction images with the \"ground truth\" urbanization data."
msgstr ""

#: 
msgid "The following cell sets important parameters for the analysis. The parameters are:"
msgstr ""

#: 
msgid "``lat_buffer``: The number of degrees to load around the central latitude."
msgstr ""

#: 
msgid "``lon_buffer``: The number of degrees to load around the central longitude."
msgstr ""

#: 
msgid "``time_range``: The time range to analyze - in YYYY-MM-DD format (e.g. ``('2016-01-01', '2016-12-31')``)."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. The default area is Dakar, Senegal."
msgstr ""

#: 
msgid "Load the Landsat 8 Annual GeoMAD"
msgstr ""

#: 
msgid "We will load the Landsat 8 Annual GeoMAD from 2017."
msgstr ""

#: 
msgid "**Once the load is complete**, examine the data by printing it in the next cell. The ``Dimensions`` attribute revels the number of time steps in the data set, as well as the number of pixels in the ``longitude`` and ``latitude`` dimensions."
msgstr ""

#: 
msgid "Filter out water pixels using WOfS"
msgstr ""

#: 
msgid "Land Spectral Indices"
msgstr ""

#: 
msgid "We're going to be calculating NDBI, ENDISI and ASI as urbanization indices."
msgstr ""

#: 
msgid "NDBI"
msgstr ""

#: 
msgid "The Normalized Difference Built-Up Index (NDBI) is one of the most commonly used proxies of urbanization. Like all normalized difference indicies, it has a range of [-1,1]."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDBI} = \\frac{\\text{SWIR1} - \\text{NIR}}{\\text{SWIR1} + \\text{NIR}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "ENDISI"
msgstr ""

#: 
msgid "The Enhanced Normalized Difference Impervious Surfaces Index (ENDISI) is a more recently developed urbanization proxy. Like all normalized difference indicies, it has a range of [-1,1]. Note that ``MNDWI``, ``swir_diff`` and ``alpha`` are all part of the ENDISI calculation."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{alpha} = \\frac{\\text{2*mean(BLUE)}}{\\text{mean(swir_diff) + mean(MNDWI^2)}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{ENDISI} = \\frac{\\text{BLUE} - \\text{alpha}*(\\text{swir_diff} + \\text{MNDWI^2})}\n"
"{\\text{BLUE} + \\text{alpha}*(\\text{swir_diff} + \\text{MNDWI^2})}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "ASI"
msgstr ""

#: 
msgid "The Artificial Surface Index (ASI) has a range of [0, 1] . ASI is composed of four components:"
msgstr ""

#: 
msgid "The Artificial Surface Factor (AF):"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"  AF = \\frac{NIR - BLUE}{NIR + BLUE}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The Vegetation Suppressing Factor (VSF) which is includes the Normalized Difference Vegetation Index and the Modified Soil Adjusted Vegetation Index."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"  NDVI = \\frac{NIR - RED}{NIR + RED}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"  MSAVI = \\frac{2*NIR + 1 - \\sqrt{(2*NIR + 1)^2 − 8*(NIR - RED)}}{2}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"  VSF = 1 − NDVI * MSAVI\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "Soil Suppressing Factor (SSF) which includes the Modified Bare soil Index (MBI), Modified Normalized Difference Water Index (MNDWI), and Enhanced Modified Bare soil Index (EMBI)."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"  MBI = \\frac{SWIR1 - SWIR2 - NIR}{SWIR1 + SWIR2 + NIR} + 0.5\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{EMBI} = \\frac{MBI - MNDWI - 0.5}{MBI + MNDWI + 1.5}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{SSF} = 1 - EMBI\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "Modulation Factor (MF)"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{MF} = \\frac{(BLUE + GREEN) - (NIR + SWIR1)}{(BLUE + GREEN) + (NIR + SWIR1)}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The Artificial Surface Index (ASI) is finalized as:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} ASI = f(AF) × f(VSF) × f(SSF) × f(MF) \\end{equation}`"
msgstr ""

#: 
msgid ":math:`f` means the min–max normalization function based on the entire image, i.e., :math:`y = (x − x_{min})/(x_{max} − x_{min})`"
msgstr ""

#: 
msgid "Calculate NDBI, ENDISI and ASI"
msgstr ""

#: 
msgid "Plot the urban indices"
msgstr ""

#: 
msgid "Determining the thresholds for urbanization"
msgstr ""

#: 
msgid "These histogram plots show the distribution of values for each product. The urban threshold values are chosen using these histograms."
msgstr ""

#: 
msgid "If a highly urban area is being examined, there should be visible maximal values for these histograms. The ideal thresholds should usually include these values (see the x axes of the histograms) and some range of values less than and greater than these maximal values."
msgstr ""

#: 
msgid "Create Threshold Plots"
msgstr ""

#: 
msgid "First we will define a minimum threshold and a maximum threshold for each index. Then we will create plots that color the threshold region a single color (e.g. red)."
msgstr ""

#: 
msgid "Comparison Metrics"
msgstr ""

#: 
msgid "We will compare the performance of the urban index results against the GHS GeoTIFF product (shown below)."
msgstr ""

#: 
msgid "The GHS geotiff for the Senegal region is available by default in the ``Supplementary_data`` folder. To find and download GHS geotiffs for other regions, use the following link: https://ghsl.jrc.ec.europa.eu/download.php?ds=bu"
msgstr ""

#: 
msgid "Open and reproject dataset to match Landsat"
msgstr ""

#: 
msgid "Metric and Plotting Functions"
msgstr ""

#: 
msgid "The code below will calculate the true/false positive/negative sums and calculate values for a typical confusion matrix to assess the results. Accuracy is used when the True Positives and True negatives are more important while F1-score is used when the False Negatives and False Positives are crucial."
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{Accuracy} = \\frac{\\text{True Positive} + \\text{True Negative}}{\\text{Total Pixels}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{Precision} = \\frac{\\text{True Positive}}{\\text{True Positive} + \\text{False Positive}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{Recall} = \\frac{\\text{True Positive}}{\\text{True Positive} + \\text{False Negative}}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "Output Comparisons"
msgstr ""

#: 
msgid "The ``dstack`` calls provide the ``imshow`` calls with RGB array inputs. For each image, the first channel (red) is the actual (ground truth, GHS) values, and both the second and third channels (green, blue) are the predicted values (green + blue = cyan)."
msgstr ""

#: 
msgid "Next Steps"
msgstr ""

#: 
msgid "Machine learning can also be used to measure urbanisation. See `this notebook <../Real_world_examples/Machine_learning_with_ODC.ipynb>`__ for a guide on using machine learning in the context of the ODC."
msgstr ""

#: 
msgid "Monthly vegetation condition anomalies"
msgstr ""

#: 
msgid "**Products used:** `ndvi_climatology_ls <https://explorer.digitalearth.africa/ndvi_climatology_ls>`__, `crop_mask <https://explorer.digitalearth.africa/crop_mask>`__, `wofs_ls_summary_alltime <https://explorer.digitalearth.africa/wofs_ls_summary_alltime>`__, `s2_ls2 <https://explorer.digitalearth.africa/>`__, `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; ndvi_climatology_ls`, :index:`vegetation; anomalies`, :index:`band index; NDVI`;"
msgstr ""

#: 
msgid "Understanding how the vegetated landscape responds to longer-term environmental drivers such as the El Nino Southern Oscillation (ENSO) or climate change, requires the calculation of standardised anomalies. Standardised anomalies subtract the long-term mean from an observation of interest and then divide the result by the long-term standard deviation, thus removing seasonal variability and highlighting change related to longer-term drivers."
msgstr ""

#: 
msgid "This notebook will calculate monthly *standardised* NDVI anomalies for any given month and year, and relies on DE Africa's 30 metre resolution `NDVI climatology <https://docs.digitalearthafrica.org/en/latest/data_specs/NDVI_Climatology_specs.html>`__ product to define the baseline vegetation condition. Sentinel-2, and Landsat 8/9 are used to calculate the monthly mean NDVI for the month of interest. The standardised anaomaly is then calculated as:"
msgstr ""

#: 
msgid "where :math:`x` is NDVI for the month of interest, :math:`m` is the long-term mean, and :math:`s` is the long-term standard deviation."
msgstr ""

#: 
msgid "The following steps are taken in the notebook: 1. Load a polygon for the country of interest (a geojson with country boundaries is already provided) 2. Load cloud masked Sentinel-2 and Landsat satellite data 3. Preprocess the satellite data so we have one continuous, noise free time-series of NDVI. 4. Create mask of the country boundary 5. Load DE Africa's NDVI climatology product 6. Use WOfS to remove waterbodies from the region 7. Calculate standardised NDVI anomalies 8. Plot the result 9. Load DE Africa's crop-mask for the region 10. Plot NDVI anomalies for regions only within the crop-mask"
msgstr ""

#: 
msgid "**After finishing the analysis**, return to the \"Analysis parameters\" cell, modify some values (e.g. choose a different location or time period to analyse) and re-run the analysis."
msgstr ""

#: 
msgid "``country``: The country over which to load data, e.g. ``'Uganda'``. The full list of Africa countries can be found in cell ``[6]``"
msgstr ""

#: 
msgid "``year``: The year for which we will calculate the standardised anomaly, e.g. ``'2022'``"
msgstr ""

#: 
msgid "``month``: The month for which we will calculate the standardised anomaly, written as a lower-case three letter abbreviation e.g ``'jan'``,\\ ``'feb'`` etc. This is because the ``ndvi_climatology_ls`` product's measurements are stored as ``'mean_jan'``, ``'mean_feb'`` etc."
msgstr ""

#: 
msgid "``crop_mask``: Depending on where you are loading data, you can change the crop mask to load with this parameter. Use the `explorer <https://explorer.digitalearth.africa/products>`__ to find which crop mask covers which region of Africa."
msgstr ""

#: 
msgid "``resolution``: The x and y cell resolution of the satellite data and ``ndvi_climatology_ls`` data, e.g. ``(-30, 30)`` will load data at its native 30 x 30m resolution. If loading a large area, then increase the resolution so the data will fit into memory. For example, if trying to find the NDVI anomaly for a large country, consider increasing the resolution to ``(-210,210)``."
msgstr ""

#: 
msgid "``dask_chunks``: the size of the dask chunks, dask breaks data into manageable chunks that can be easily stored in memory, e.g. ``dict(x=1000,y=1000)``"
msgstr ""

#: 
msgid "This shapefile contains polygons for the boundaries of African countries and will allows us to calculate NDVI anomalies within a chosen country"
msgstr ""

#: 
msgid "Load and process cloud-masked satellite data"
msgstr ""

#: 
msgid "The first step in this analysis is to load in Landsat 8/9 and Sentinel-2 data for the country we've picked, and for the month of the anomaly we want to assess. The code below uses the ``load_ard`` function to load in data from Landsat 8/9 and Sentinel-2 satellites for the area and time specified. For more information, see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__."
msgstr ""

#: 
msgid "Firstly, we will set up a dictionary that maps the abbreviated month name, ``month`` to a string number, allowing us to load data for that month from the datacube. The second dictionary, ``query`` maps the parameters we provided above to the ``datacube.load()`` parameters."
msgstr ""

#: 
msgid "Now let's load the satellite data."
msgstr ""

#: 
msgid "Preprocess satellite data"
msgstr ""

#: 
msgid "Here we perform a number of steps to get the satellite data into the format we need for calculating an NDVI anomaly. 1. Rename the ``'nir_2'`` band in Sentinel-2 to ``'nir'`` so the ``calculate_indices`` function will understand to calculate NDVI using ``'nir_2'``. 2. Calculate NDVI on both Landsat and Sentinel-2 data, then we concatenate the two time-series together. 3. Now that we one continous time-series of NDVI, we can clean the time-series by removing data that is outside the range 0-1, and minimize the impact of noise/missed cloud by running a temporal rolling mean filter with a small window size. 4. Calculate the mean NDVI for the month."
msgstr ""

#: 
msgid "Note that this cell will take several minutes to run (depending on size and resolution of the datasets) as here we trigger all of the calculations we've listed up to this point with the ``.compute()`` method"
msgstr ""

#: 
msgid "Create a rasterized mask of the country boundary"
msgstr ""

#: 
msgid "Load DE Africa's NDVI climatologies"
msgstr ""

#: 
msgid "Make a quality assurance mask where clear observation count is low"
msgstr ""

#: 
msgid "Due to the inconsistent data availability of Landsat 5 over equatorial Africa, and due to persistent cloud coverage over these same regions, the quality of the long-term NDVI baseline is poor in in some parts of Africa. We recommend not using/relying on the product in locations where the clear obervation count is less than ~20-30 observations. Below this, the standard deviation layers are prone to data artefacts owing to temporal smoothing operations performing poorly on sparse datasets, and residual cloudy pixels not being sufficiently ‘averaged out’ by a decent volume of input data."
msgstr ""

#: 
msgid "Mask both datasets with country mask"
msgstr ""

#: 
msgid "Remove water bodies"
msgstr ""

#: 
msgid "This will constrain all the NDVI anomaly observations to just the land mass."
msgstr ""

#: 
msgid "Now we can calculate the standardised anomalies by subtracting the long-term mean and dividing by the long-term standard deviation."
msgstr ""

#: 
msgid "Incorporating DE Africa's cropland extent map"
msgstr ""

#: 
msgid "Plot NDVI climatolgies, monthly mean, and anomalies for cropping regions only"
msgstr ""

#: 
msgid "Below we mask out the regions that aren't cropping, revealing only the condition of the cropped regions."
msgstr ""

#: 
msgid "Vegetation Change Detection"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; landsat 8`, :index:`analysis; change detection`, :index:`band index; NDVI`, :index:`band index; EVI`, :index:`forestry`"
msgstr ""

#: 
msgid "Detecting regions of deforestation and afforestation in satellite imagery is complicated by the need to distinguish real land use changes from the natural changes introduced by climate variability. To determine regions that have undergone significant change, we can apply hypothesis testing techniques to stacks of remotely sensed satellite images to determine where change is statistically significant relative to the natural, background variability."
msgstr ""

#: 
msgid "In this example, we measure the presence of vegetation from Landsat imagery and apply a hypothesis test to identify areas of significant change (along with the direction of the change)."
msgstr ""

#: 
msgid "The worked example takes users through the code required to do the following: 1. Load cloud-free Landsat 8 images for an area of interest (AOI). 1. Calculate indices that indicate vegetation, such as the normalised difference vegetation index (NDVI) and enhanced vegetation index (EVI). 2. Apply a statistical hypothesis test to find areas of significant change. 3. Visualise the statistically significant areas."
msgstr ""

#: 
msgid "Load key Python packages and any supporting functions for the analysis."
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis over. There is also a parameter to define how the data is split in time; the split yields two non-overlapping samples, which is a requirement of the hypothesis test we want to run (more detail below). The parameters are:"
msgstr ""

#: 
msgid "``latitude``: The latitude at the centre of your AOI (e.g. ``0.02``)."
msgstr ""

#: 
msgid "``longitude``: The longitude at the centre of your AOI (e.g. ``35.425``)."
msgstr ""

#: 
msgid "``buffer``: The number of degrees to load around the central latitude and longitude. For reasonable loading times, set this as ``0.1`` or lower."
msgstr ""

#: 
msgid "``time``: The date range to analyse (e.g. ``('2015-01-01', '2019-09-01')``). For reasonable results, the range should span at least two years to prevent detecting seasonal changes."
msgstr ""

#: 
msgid "``time_baseline``: The date at which to split the total sample into two non-overlapping samples (e.g. ``'2015-12-01'``). For reasonable results, pick a date that is about halfway between the start and end dates specified in ``time``."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers part of the Northern Tindiret Forest Reserve, Kenya."
msgstr ""

#: 
msgid "The next cell will display the selected area on an interactive map. The red border represents the area of interest of the study. Zoom in and out to get a better understanding of the area of interest. Clicking anywhere on the map will reveal the latitude and longitude coordinates of the clicked point."
msgstr ""

#: 
msgid "Load and view Landsat data"
msgstr ""

#: 
msgid "The first step in the analysis is to load Landsat data for the specified area of interest and time range."
msgstr ""

#: 
msgid "The code below will create a query dictionary for our region of interest, find the correct ``crs`` object for the area of interest, and then load the Landsat data using the ``load_ard`` function. For more infmation, see the `Using load_ard notebook <../Frequently_used_code/Using_load_ard.ipynb>`__. The function will also automatically mask out clouds from the dataset, allowing us to focus on pixels that contain useful data. It will also exclude images where more than 70% of the pixels are masked, which is set using the ``min_gooddata`` parameter in the ``load_ard`` call."
msgstr ""

#: 
msgid "**Once the load is complete**, examine the data by printing it in the next cell. The ``Dimensions`` argument revels the number of time steps in the data set, as well as the number of pixels in the x (longitude) and y (latitude) dimensions."
msgstr ""

#: 
msgid "Plot example timesteps in true colour"
msgstr ""

#: 
msgid "Feel free to experiment with the values for the ``initial_timestep`` and ``final_timestep`` variables; re-run the cell to plot the images for the new timesteps. The values for the timesteps can be ``0`` to one fewer than the number of time steps loaded in the data set. The number of time steps is the same as the total number of observations listed as the output of the cell used to load the data."
msgstr ""

#: 
msgid "For this study, there are two indices that can be used as proxies for vegetation."
msgstr ""

#: 
msgid "The first is the normalised difference vegetation index (NDVI). This index uses the ratio of the red and near-infrared (NIR) bands to identify live green vegetation. The formula is:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}.\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The second is the enhanced vegetation index (EVI). This index uses the red, near-infrared (NIR) and blue bands to identify vegetation; it is particularly sensitive to high biomass regions. The formula is:"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{EVI} = \\frac{2.5 \\times (\\text{NIR} - \\text{Red})}{\\text{NIR} + 6 \\times \\text{Red} - 7.5 \\times \\text{Blue} + 1}.\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "When interpreting these indices, high values indicate vegetation."
msgstr ""

#: 
msgid "Using an index in this notebook"
msgstr ""

#: 
msgid "The cell below calculates the chosen index, adds it to the dataset, then creates a new object ``ds_index`` that only contains the calculated index, allowing it to be used throughout the rest of the notebook."
msgstr ""

#: 
msgid "To use ``NDVI``, run the following code in the cell below:"
msgstr ""

#: 
msgid "To use ``EVI``, run the following code in the cell below:"
msgstr ""

#: 
msgid "Visualising the index"
msgstr ""

#: 
msgid "The plots below show the chosen index values for the two selected timesteps used to make the true-colour images above. Use the plots to visually confirm whether the chosen index is a suitable for change detection."
msgstr ""

#: 
msgid "Perform hypothesis test"
msgstr ""

#: 
msgid "While it is possible to visually detect change between the two timesteps, it is important to consider how to rigorously check for both positive change in vegetation (afforestation) and negative change in vegetation (deforestation)."
msgstr ""

#: 
msgid "This can be done through hypothesis testing. In this case,"
msgstr ""

#: 
msgid "\\begin{aligned}\n"
"\\text{null hypothesis } (H_0) &: \\text{no change occurred,} \\\\\n"
"\\text{alternative hypothesis } (H_1) &: \\text{some change occurred.}\n"
"\\end{aligned}"
msgstr ""

#: 
msgid "The hypothesis test will indicate where there is evidence for rejecting the null hypothesis. From this, we may identify areas of signficant change, according to a given significance level (covered in more detail below)."
msgstr ""

#: 
msgid "Make samples"
msgstr ""

#: 
msgid "To perform the test, the total sample will be split in two: a ``baseline`` sample and a ``postbaseline`` sample, which respectively contain the data before and after the ``time_baseline`` date. Then, we can test for a difference in the average vegetation index (either ``NDVI`` or ``EVI``) between the samples for each pixel in the sample. In this step, we also make mean composites for both samples, which will be useful later on for visualising the comparison."
msgstr ""

#: 
msgid "The samples are made by filtering the index based on whether it was observed before or after the ``time_baseline`` date. The number of observations in each sample will be printed. If one sample is much larger than the other, consider changing the ``time_baseline`` parameter in the \"Analysis parameters\" cell, and then re-run this cell. Coordinates are recorded for later use."
msgstr ""

#: 
msgid "Test for change"
msgstr ""

#: 
msgid "To look for evidence that the average index value has changed between the two samples (either positively or negatively), we use Welch's t-test. This is used to test the hypothesis that two populations have equal averages. In this case, the populations are the area of interest before and after the ``time_baseline`` date, and the average being tested is the average index value. Welch's *t*-test is used (as opposed to Student's *t*-test) because the two samples in the study may not necessarily have equal variances."
msgstr ""

#: 
msgid "The test is run using the Scipy package's statistcs library, which provides the ``ttest_ind`` function for running *t*-tests. Setting ``equal_var=False`` means that the function will run Welch's *t*-test. The function returns the *t*-statistic and *p*-value for each pixel after testing the difference in the average index value. These are stored as ``t_stat`` and ``p_val`` inside the ``t_test`` dataset for use in the next section."
msgstr ""

#: 
msgid "Visualise change"
msgstr ""

#: 
msgid "From the test, we're interested in two conditions: whether the change is significant (rejection of the null hypothesis) and whether the change was positive (afforestation) or negative (deforestation)."
msgstr ""

#: 
msgid "The null hypothesis can be rejected if the :math:`p`-value (``p_val``) is less than the chosen significance level, which is set as ``sig_level = 0.01`` for this analysis. If the null hypothesis is rejected, the pixel will be classified as having undergone significant change."
msgstr ""

#: 
msgid "The direction of the change can be inferred from the difference in the average index of each sample, which is calculated as :math:`\\text{diff mean} = \\text{mean(post baseline)} - \\text{mean(baseline)}.`"
msgstr ""

#: 
msgid "This means that - if the average index value for a given pixel is **higher** in the ``post baseline`` sample compared to the ``baseline`` sample, then ``diff_mean`` for that pixel will be **positive**. - if the average index value for a given pixel is **lower** in the ``post baseline`` sample compared to the ``baseline`` sample, then ``diff_mean`` for that pixel will be **negative**."
msgstr ""

#: 
msgid "Run the cell below to plot the baseline and post-baseline composites, the differences that were marked as signficant, and the mask showing areas of significant deforestation."
msgstr ""

#: 
msgid "**Note:** For the plot showing areas of significant difference between the samples, positive change is shown in blue and negative change is shown in red."
msgstr ""

#: 
msgid "Calculate percentage change"
msgstr ""

#: 
msgid "In addition to producing visualisations of the change, we can also estimate the number and proportion of pixels that have undergone statistically significant change."
msgstr ""

#: 
msgid "Here are some questions to think about: - What has happened in the forest over the time covered by the dataset? - Were there any statistically significant changes that the test found that you didn't see in the true-colour images? - What kind of activities/events might explain the significant changes? - What kind of activities/events might explain non-significant changes? - What other information might you need to draw conclusions about the cause of the statistically significant changes?"
msgstr ""

#: 
msgid "Export the data"
msgstr ""

#: 
msgid "To explore the data further in a desktop GIS program, the data can be output as a GeoTiff. This requires data to be converted to an xarray and tagged with the appropriate coordinate reference system (``crs``). The ``diff_mean`` product will be saved as \"ttest_diff_mean.tif\", and the ``sig_diff_mean`` product will be saved as \"ttest_sig_diff_mean.tif\". These files can be downloaded from the file explorer to the left of this window (`see these instructions <https://jupyterlab.readthedocs.io/en/stable/user/files.html#uploading-and-downloading>`__)."
msgstr ""

#: 
msgid "**Note**: If you wish to save outputs for more than one index, make sure you change the filenames below after re-running the analysis with a different index."
msgstr ""

#: 
msgid "When you are done, return to the \"Analysis parameters\" section, modify some values (e.g. ``latitude``, ``longitude``, ``time`` or ``time_baseline``) and re-run the analysis. You can use the interactive map in the \"View the selected location\" section to find new central latitude and longitude values by panning and zooming, and then clicking on the area you wish to extract location values for. You can also use Google maps to search for a location you know, then return the latitude and longitude values by clicking the map."
msgstr ""

#: 
msgid "You could also return to the \"Compute band indices\" section and change which index you use. You may find it interesting to save the GeoTIFFs for both indices and compare them in a GIS program. > **Note**: remember to change the output file names when saving the GeoTIFFs if you want to keep multiple different outcomes."
msgstr ""

#: 
msgid "Mapping longer-term changes in water extent with WOfS"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls_summary_annual <https://explorer.digitalearth.africa/products/wofs_ls>`__,"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; WOfS`, :index:`water; extent`, :index:`analysis; time series`, :index:`visualisation; animation`"
msgstr ""

#: 
msgid "The United Nations have prescribed 17 \"Sustainable Development Goals\" (SDGs). This notebook attempts to monitor SDG Indicator 6.6.1 - change in the extent of water-related ecosystems. Indicator 6.6.1 has 4 sub-indicators: > i. The spatial extent of water-related ecosystems > ii. The quantity of water contained within these ecosystems > iii. The quality of water within these ecosystems > iv. The health or state of these ecosystems"
msgstr ""

#: 
msgid "This notebook primarily focuses on the first sub-indicator - spatial extents."
msgstr ""

#: 
msgid "The notebook demonstrates how to load, visualise, and analyse the `WOfS annual summary <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ product to gather insights into the longer-term extent of water bodies. It provides a compliment to the `Water_extent_sentinel_2 <Water_extent_sentinel_2.ipynb>`__ notebook which focussing on more recent water extents at seasonal time intervals."
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis over."
msgstr ""

#: 
msgid "The parameters are:"
msgstr ""

#: 
msgid "``lat``: The central latitude to analyse (e.g. 10.338)."
msgstr ""

#: 
msgid "``lon`` : The central longitude to analyse (e.g. -1.055)."
msgstr ""

#: 
msgid "``lat_buffer`` : The number of degrees to load around the central latitude."
msgstr ""

#: 
msgid "``lon_buffer`` : The number of degrees to load around the central longitude."
msgstr ""

#: 
msgid "``start_year`` and ``end_year``: The date range to analyse (e.g. ``('1990', '2020')``."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers part of the Lake Sulunga. Tanzania."
msgstr ""

#: 
msgid "View the area of Interest on an interactive map"
msgstr ""

#: 
msgid "Load WOfS annual summaries"
msgstr ""

#: 
msgid "Facet plot a subset of the annual WOfS summaries"
msgstr ""

#: 
msgid "Animating time series"
msgstr ""

#: 
msgid "In the next cell, we plot the dataset we loaded above as an animation GIF, using the ```xr_animation`` <../Frequently_used_code/Animated_timeseries.ipynb>`__ function. The ``output_path`` will be saved in the directory where the script is found and you can change the names to prevent files overwrite."
msgstr ""

#: 
msgid "Calculate the annual area of water extent"
msgstr ""

#: 
msgid "The number of pixels can be used for the area of the waterbody if the pixel area is known. Run the following cell to generate the necessary constants for performing this conversion."
msgstr ""

#: 
msgid "Threshold WOfS annual frequency to classify water/not-water"
msgstr ""

#: 
msgid "Calculates the area of pixels classified as water (if ``ds.frequency`` is > 0.20, then the pixel will be considered regular open water during the year)"
msgstr ""

#: 
msgid "Plot the annual area of open water"
msgstr ""

#: 
msgid "Determine minimum and maximum water extent"
msgstr ""

#: 
msgid "The next cell extract the Minimum and Maximum extent of water from the dataset using the ``min`` and ``max`` functions, we then add the dates to an ``xarray.DataArray``."
msgstr ""

#: 
msgid "Plot the dates when the min and max water extent occur"
msgstr ""

#: 
msgid "Plot water classified pixel for the two dates where we have the minimum and maximum surface water extent."
msgstr ""

#: 
msgid "Compare two time periods"
msgstr ""

#: 
msgid "The following cells determine the maximum extent of water for two different years. \\* ``baseline_year`` : The baseline year for the analysis \\* ``analysis_year`` : The year to compare to the baseline year"
msgstr ""

#: 
msgid "Plot water extent for the two chosen periods."
msgstr ""

#: 
msgid "Calculating the change for the two nominated periods"
msgstr ""

#: 
msgid "The cells below calculate the amount of water gain, loss and stable for the two periods"
msgstr ""

#: 
msgid "The cell below calculate the area of water extent for water_loss, water_gain, permanent water and land"
msgstr ""

#: 
msgid "The water variables are plotted to visualised the result"
msgstr ""

#: 
msgid "Return to the \"Analysis parameters\" section, modify some values (e.g. ``latitude``, ``longitude``, ``start_year``, ``end_year``) and re-run the analysis. You can use the interactive map in the \"View the selected location\" section to find new central latitude and longitude values by panning and zooming, and then clicking on the area you wish to extract location values for. You can also use Google maps to search for a location you know, then return the latitude and longitude values by clicking the map."
msgstr ""

#: 
msgid "Change the year also in \"Compare Two Time Periods - a Baseline and an Analysis\" section, (e.g. ``base_year``, ``analyse_year``) and re-run the analysis."
msgstr ""

#: 
msgid "Determining seasonal extent of waterbodies with Sentinel-2"
msgstr ""

#: 
msgid "**Products used:** `s2_l2a <https://explorer.digitalearth.africa/products/s2_l2a>`__,"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2`, :index:`water; extent`, :index:`analysis; time series`, :index:`band index; MNDWI`, :index:`visualisation; animation`"
msgstr ""

#: 
msgid "Load satellite data over the water body of interest"
msgstr ""

#: 
msgid "Calculate the water index MNDWI"
msgstr ""

#: 
msgid "Resample the time-series of MNDWI to seasonal medians"
msgstr ""

#: 
msgid "Generate an animation of the water extent time-series"
msgstr ""

#: 
msgid "Calculate and plot a time series of seassonal water extent (in square kilometres)"
msgstr ""

#: 
msgid "Find the minimum and maximum water extents in the time-series and plot them."
msgstr ""

#: 
msgid "Compare two nominated time-periods, and plot where the water-body extent has changed."
msgstr ""

#: 
msgid "To activate Dask, set up the local computing cluster using the cell below."
msgstr ""

#: 
msgid "``start_year`` and ``end_year``: The date range to analyse (e.g. ``('2017', '2020')``."
msgstr ""

#: 
msgid "Load cloud-masked satellite data"
msgstr ""

#: 
msgid "The code below will create a query dictionary for our region of interest, and then load Sentinel-2 satellite data. For more information on loading data, see the `Loading data notebook <../Beginners_guide/03_Loading_data.ipynb>`__."
msgstr ""

#: 
msgid "Calculate the MNDWI water index"
msgstr ""

#: 
msgid "Resample time series"
msgstr ""

#: 
msgid "Due to many factors (e.g. cloud obscuring the region, missed cloud cover in the fmask layer) the data will be gappy and noisy. Here, we will resample the data to ensure we working with a consistent time-series."
msgstr ""

#: 
msgid "To do this we resample the data to seasonal time-steps using medians"
msgstr ""

#: 
msgid "These calculations will take several minutes to complete as we will run .compute(), triggering all the tasks we scheduled above and bringing the arrays into memory."
msgstr ""

#: 
msgid "Facet plot the MNDWI time-steps"
msgstr ""

#: 
msgid "Calculate the area per pixel"
msgstr ""

#: 
msgid "Calculating the extent of water"
msgstr ""

#: 
msgid "Calculates the area of pixels classified as water (if MNDWI is > 0, then water)"
msgstr ""

#: 
msgid "Plot seasonal time series from the ``Start year`` to ``End year``"
msgstr ""

#: 
msgid "A new dataArray is created to store the new date from the ``maximum water extent`` for the two years"
msgstr ""

#: 
msgid "Plot water extent of the MNDWI product for the two chosen periods."
msgstr ""

#: 
msgid "Monitoring Water Quality"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `wofs_ls <https://explorer.digitalearth.africa/products/wofs_ls>`__"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; landsat 8`, :index:`data used; WOfS`, :index:`data methods; compositing`, :index:`dask`, :index:`water quality`"
msgstr ""

#: 
msgid "The UN `SDG 6.3.2 <https://www.sdg6monitoring.org/indicator-632/>`__ indicator is the \"proportion of bodies of water with good ambient water quality\". There are many ways to measure water quality using remote sensing based algorithms; this notebook compares several of them. They usually estimate the amount of suspended matter in water."
msgstr ""

#: 
msgid "This notebook shows results for three empirical algorithms and one spectral index addressing total suspended matter (TSM) in water. There are a number of caveats to be aware of when applying these algorithms:"
msgstr ""

#: 
msgid "These algorithms were developed for specific regions of the world and are not necessarily universally valid."
msgstr ""

#: 
msgid "Landsat-8 data is a surface reflectance product, and since water has a very low radiance, the accuracy of the results can be severaly impacted by small differences in atmospheric conditions, or differences in atmospheric correction algorithms."
msgstr ""

#: 
msgid "The colorbars for these results have been removed to avoid showing specific quantities for the TSM results. It is best to use these results to assess qualitative changes in water quality (e.g. low, medium, high). With improvements in analysis-ready data (e.g. water leaving radiance), and with in-situ sampling of water bodies for empirical modelling, it will be possible to increase the accuracy of these water quality results and even consider the numerical output."
msgstr ""

#: 
msgid "The showcased water quality algorithms are:"
msgstr ""

#: 
msgid "Lymburner Total Suspended Matter (TSM)"
msgstr ""

#: 
msgid "Suspended Particulate Model (SPM)"
msgstr ""

#: 
msgid "Normalized Difference Suspended Sediment Index (NDSSI)"
msgstr ""

#: 
msgid "Quang Total Suspended Solids (TSS)"
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers water quality in Lake Manyara."
msgstr ""

#: 
msgid "**To run the notebook for a different area**, make sure Landsat 8 data is available for the chosen area using the `DEAfrica Explorer <https://explorer.digitalearth.africa>`__. Use the drop-down menu to check Landsat 8 (``ls8_sr``)."
msgstr ""

#: 
msgid "**Lake Manyara, Tanzania**"
msgstr ""

#: 
msgid "**Weija Reservoir, Ghana**"
msgstr ""

#: 
msgid "**Lake Sulunga, Tanzania**"
msgstr ""

#: 
msgid "We can use the `load_ard <Using_load_ard.ipynb>`__ function to load data from multiple satellites (i.e. Landsat 7 and Landsat 8), and return a single ``xarray.Dataset`` containing only observations with a minimum percentage of good quality pixels."
msgstr ""

#: 
msgid "In the example below, we request that the function returns only observations which are 90% free of clouds and other poor quality pixels by specifying ``min_gooddata=0.90``."
msgstr ""

#: 
msgid "**Once the load is complete**, examine the data by printing it in the next cell. The ``Dimensions`` attribute revels the number of time steps in the data set, as well as the number of pixels in the ``x`` (longitude) and ``y`` (latitude) dimensions."
msgstr ""

#: 
msgid "Load WOfS"
msgstr ""

#: 
msgid "To make sure the algorithms for measuring water quality are only applied to areas with water, it is useful to extract the water extent from the `Water Observations from Space (WOfS) product <https://explorer.digitalearth.africa/wofs_ls>`__. The water extent can then be used to mask the geomedian composite so that the water quality indices are only shown for pixels that are water. Pixels that are water are selected using the condition that ``water == 128``. To learn more about working with WOfS bit flags, see the `Applying WOfS bitmasking notebook <Applying_WOfS_bitmasking.ipynb>`__."
msgstr ""

#: 
msgid "If the default settings were used, we should see that Lake Manyara appears to be significantly polluted in the northern half on February 16, 2016."
msgstr ""

#: 
msgid "Total Suspended Sediment Algorithms"
msgstr ""

#: 
msgid "First we will calculate the water quality using each of the algorithms, then we wil compare the approaches."
msgstr ""

#: 
msgid "(1) Lymburner Total Suspended Matter (TSM)"
msgstr ""

#: 
msgid "Paper: `Lymburner et al. 2016 <https://www.sciencedirect.com/science/article/abs/pii/S0034425716301560>`__"
msgstr ""

#: 
msgid "Units of mg/L concentration"
msgstr ""

#: 
msgid "TSM for Landsat 7:"
msgstr ""

#: 
msgid "LYM7 = 3983 \\cdot (\\frac{(\\text{Green} + \\text{Red}) * 0.0001}{2})^{1.6246}"
msgstr ""

#: 
msgid "TSM for Landsat 8:"
msgstr ""

#: 
msgid "LYM8 = 3957 \\cdot (\\frac{(\\text{Green} + \\text{Red}) * 0.0001}{2})^{1.6436}"
msgstr ""

#: 
msgid "Here, we're using Landsat 8, so we'll use the LYM8 function."
msgstr ""

#: 
msgid "(2) Suspended Particulate Model (SPM)"
msgstr ""

#: 
msgid "Paper: `Zhongfeng Qiu et.al. 2013 <https://www.researchgate.net/publication/260152686_A_simple_optical_model_to_estimate_suspended_particulate_matter_in_Yellow_River_Estuary>`__"
msgstr ""

#: 
msgid "Units of g/m^3 concentration"
msgstr ""

#: 
msgid "SPM for Landsat 8:"
msgstr ""

#: 
msgid "X = 2.26*(\\frac{\\text{Red}}{\\text{Green}})^3 -\n"
"           5.42*(\\frac{\\text{Red}}{\\text{Green}})^2 +\n"
"           5.58*(\\frac{\\text{Red}}{\\text{Green}}) - 0.72"
msgstr ""

#: 
msgid "SPM = 10^{X} - 1.43"
msgstr ""

#: 
msgid "(3) Normalized Difference Suspended Sediment Index (NDSSI)"
msgstr ""

#: 
msgid "Paper: `Hossain et al. 2010 <https://www.researchgate.net/publication/251236287_Development_of_Remote_Sensing_Based_Index_for_EstimatingMapping_Suspended_Sediment_Concentration_in_River_and_Lake_Environments>`__"
msgstr ""

#: 
msgid "NDSSI for Landsat 7 and 8:"
msgstr ""

#: 
msgid "NDSSI = \\frac{\\text{Blue}-\\text{NIR}}{\\text{Blue}+\\text{NIR}}"
msgstr ""

#: 
msgid "The NDSSI value ranges from -1 to +1. Values closer to +1 indicate higher concentration of sediment."
msgstr ""

#: 
msgid "(4) Quang Total Suspended Solids (TSS)"
msgstr ""

#: 
msgid "Paper: `Quang et al. 2017 <https://www.mdpi.com/2073-4441/9/8/570>`__"
msgstr ""

#: 
msgid "Quang8 = 380.32 * \\text{Red}*0.0001 - 1.7826"
msgstr ""

#: 
msgid "Compare the algorithms' outputs"
msgstr ""

#: 
msgid "If the default settings were used, we should see that all the indices reflect the appearance of the lake (where murky, the index is high) except NDSSI, though it does appear to be related to the others - mostly low where the others are high and vice versa."
msgstr ""

#: 
msgid "**Compatible ``datacube`` version:**"
msgstr ""

#: 
msgid "Turbidity in wetlands"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `ls9_sr <https://explorer.digitalearth.africa/ls9_sr>`__, `wofs_ls <https://explorer.digitalearth.africa/products/wofs_ls>`__"
msgstr ""

#: 
msgid "In this notebook, we calculate turbidity in wetland areas through the Normalised Difference Turbidity Index (NDTI). Turbidity refers to the optical clarity of the water. While it is not strictly correlated with suspended matter, chlorophyll content, or other metrics, it is often used in conjunction to provide a more holistic analysis of water quality."
msgstr ""

#: 
msgid "NDTI is a band index defined as:"
msgstr ""

#: 
msgid ":math:`\\text{NDTI} = \\frac{\\text{Red} - \\text{Green}}{\\text{Red} + \\text{Green}}`"
msgstr ""

#: 
msgid "`Lacaux et al, 2007 <https://www.sciencedirect.com/science/article/abs/pii/S0034425706002811>`__"
msgstr ""

#: 
msgid "Here, we investigate NDTI over wetland areas in a several-year time series, through both a seasonal animation and a time series plot."
msgstr ""

#: 
msgid "Load packages and connect to the datacube"
msgstr ""

#: 
msgid "Define area of interest and time range"
msgstr ""

#: 
msgid "Mask areas with water using WOfS"
msgstr ""

#: 
msgid "Plot and animate"
msgstr ""

#: 
msgid "Investigate wetlands extent over time"
msgstr ""

#: 
msgid "Load satellite data"
msgstr ""

#: 
msgid "The first step in the analysis is to load Landsat 8 and 9 data for the specified area of interest. This uses the pre-defined `load_ard <../Frequently_used_code/Using_load_ard.ipynb>`__ utility function. The ``load_ard`` function is used here to load an analysis ready dataset free of shadow, and missing data."
msgstr ""

#: 
msgid "Note that specifying the parameter ``min_gooddata=0.9`` reduces data from the middle of the year, when this area experiences maximum cloudy weather."
msgstr ""

#: 
msgid "Values of NDTI are relative and the index should only be applied to water. Including land in the area of interest will skew the colourmap. All-time WOfS is used here to threshold for areas pixels which are likely to be water."
msgstr ""

#: 
msgid "Inspect water extent"
msgstr ""

#: 
msgid "Plot NDTI"
msgstr ""

#: 
msgid "Here we calculate NDTI and add it to the loaded data set. It also generates an animation that is exported to the sandbox and can be saved by right-clicking the ``.gif`` and selecting \"Download\"."
msgstr ""

#: 
msgid "Investigate size of waterbodies"
msgstr ""

#: 
msgid "The animated timeseries and plots above show a distinct difference in NDTI between large watercourses which generally appear blue-white, and smaller waterbodies which appear more orange to brown in the colour scheme."
msgstr ""

#: 
msgid "We might hypothesise that smaller waterbodies generally have higher NDTI values than larger ones, meaning they are more turbid. The histogram below suggests this might be the case as there are two peaks evident. We can test this further by splitting the the waterbodies by size below."
msgstr ""

#: 
msgid "Vectorize waterbodies"
msgstr ""

#: 
msgid "We will split the waterbodies into two size classes, small and large, at a threshold of 50,000 square metres. You can adjust the threshold and test it in the plots below."
msgstr ""

#: 
msgid "The interactive plot below shows larger waterbodies in yellow and smaller ones in purple."
msgstr ""

#: 
msgid "Here, we rasterize polygons and mask NDTI to small and large waterbodies, then calculate mean and standard deviation timeseries. This allows us to plot the timeseries in the cell below. The plot confirms that smaller waterbodies have higher NDTI values than larger ones, and the two size classes follow the same pattern over time."
msgstr ""

#: 
msgid "Finally, we might hypothesise that the seasonal variation in turbidity seen above is related to rainfall. The plot of rainfall over the same time period, below, suggests this is the case. However, we would have to conduct further analysis to determine conditions that vary with turbidity."
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:99
msgid "Wetlands Insight Tool"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls <https://explorer.digitalearth.africa/products/wofs_ls>`__, `fc_ls <https://explorer.digitalearth.africa/products/fc_ls>`__, `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr>`__, `ls7_sr <https://explorer.digitalearth.africa/products/ls7_sr>`__, `ls5_sr <https://explorer.digitalearth.africa/products/ls5_sr>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; landsat 5`, :index:`data used; landsat 7`, :index:`data used; landsat 8`, :index:`data used; WOfS`, :index:`data used; fc_ls`, :index:`interactive`, :index:`analysis; Wetlands insight tool`, :index:`wetlands`"
msgstr ""

#: 
msgid "According to `Wetlands International <https://africa.wetlands.org/en/wetlands/what-are-wetlands/>`__, Africa’s wetlands ecosystems are estimated to cover 131 million hectares, and include some of the most productive and biodiverse ecosystems in the world. They provide a host of ecosystem services that contribute to human well-being through nutrition, water supply and purification, climate and flood regulation, coastal protection, feeding and nesting sites for animals, recreational opportunities and increasingly, tourism. As such, the health of wetland ecosystems has been identified as an important metric for the ``Sustainable Development Goals`` (`6.6.1 Change in the extent of water-related ecosystems over time <https://www.sdg6monitoring.org/indicator-661/>`__)."
msgstr ""

#: 
msgid "The ``Wetlands Insight Tool (WIT)`` provides insights into a wetland's seasonal and interannual dynamics. WIT is a spatiotemporal summary of a wetland that combines multiple datasets derived from the Landsat archive held within DE Africa. ``Fractional cover``, ``WOfS``, and ``Landsat surface reflectance`` data are retrieved from DE Africa's ODC and combined to produce a stack plot describing the percentage of a wetland polygon as vegetation fractional cover, open water, and wet vegetation through time. The figure below (on the right) summaries the classification logic of the Wetlands Insight Tool."
msgstr ""

#: 
msgid "The animation below shows an example of WIT over Lake Korienze in Mali. The WIT plot shows the percentage of the region that is covered (in order) in open water, wet soil, green vegetation, dry vegetation, and bare soil"
msgstr ""

#: 
msgid "Example of WIT over Lake Korienze, Mali"
msgstr ""

#: 
msgid "Classification logic of the Wetlands Insight Tool"
msgstr ""

#: 
msgid "Reference"
msgstr ""

#: 
msgid "`Dunn et al. (2019) <https://ieeexplore.ieee.org/document/8897806>`__ Developing a Tool for Wetland Characterization Using Fractional Cover, Tasseled Cap Wetness And Water Observations From Space"
msgstr ""

#: 
msgid "This interactive notebook will run the Wetlands Insight Tool for the area encompassed by a polygon drawn on the interactive map."
msgstr ""

#: 
msgid "Set the parameters for the Wetlands Insight Tool"
msgstr ""

#: 
msgid "Draw a polygon using the interactive jupyter widget"
msgstr ""

#: 
msgid "Run the WIT tool, resulting in a stacked plot of fractional cover, wetness, and water"
msgstr ""

#: 
msgid "Instructions for running the application"
msgstr ""

#: 
msgid "Make sure you read the ``Analysis Parameters`` section below so you undertand the different parameters of the Wetlands Insight Tool, then run the cell containing the ``wit_app()`` function to get started."
msgstr ""

#: 
msgid "Use the drop-down boxes to set the parameters, draw a polygon on the interactive map over the region of interest, and then hit the ``Run`` button to begin the anlaysis. Print statements will appear on the right hand side of the app signifying the progress of the anlaysis. For more detailed progress indicators use the **Dask Dashboard hyperlink** that appears after you hit the run button. Note, depending on the size of the polygon drawn, and the length of time of the analysis, WIT can take a long time to run. Once the analysis has finished, a stackplot will be plotted at the bottom of the application."
msgstr ""

#: 
msgid "If you wish to alter the parameters and re-run the analysis over the same polygon, simply change the parameters and hit the run button again (make sure the previous run has finished before you hit the run button a second time)."
msgstr ""

#: 
msgid "If anything goes wrong with the interactvive widget and/or errors start printing on the right-hand side of the app, then restart the notebook kernel: **Kernel --> Restart Kernel and Clear All Outputs**"
msgstr ""

#: 
msgid "``Map Overlay``: A number of overlay map layers, which can help guide polygon drawing. Options include ESRI World Imagery, the 2020 Sentinel-2 Geomedian, or the 2020 WOfS annual frequency summary. This parameter defaults to 'None'."
msgstr ""

#: 
msgid "``Start Date``: The starting date of the analysis, in format DD-MM-YYYY"
msgstr ""

#: 
msgid "``End Date``: The ending date of the analysis, in format DD-MM-YYYY"
msgstr ""

#: 
msgid "``Minimum Good Data``: A number between 0 and 1 (e.g. ``0.85``) indicating the minimum percentage of good quality pixels required for a satellite observation to be loaded and therefore included in the WIT plot. **This number should, at a minimum, be set to 0.85 to limit biases in the result if not resampling the time-series**. If resampling the data using the parameter ``Resample Frequency``, then setting this number to 0 (or a low float number) is acceptable."
msgstr ""

#: 
msgid "``Resampling Frequency``: Option for resampling time-series of input datasets. This option is useful for either smoothing the WIT plot, or because the area of analysis is larger than a scene width and therefore requires composites. Options include any string accepted by ``xarray.resample(time=)``; e.g. ``1M`` = 1 month, ``3M`` = 3 months, ``Q-DEC`` = quarterly starting in December. To turn off resampling set this parameter to ``None``. **The resampling method used is .max()**, hence the resulting plots will show the *maximum extent* of each variable during the resampled interval."
msgstr ""

#: 
msgid "``Output CSV``: To output a .csv file with the values of the WIT plot, enter a file name e.g. ``output_WIT.csv``"
msgstr ""

#: 
msgid "``Output Plot``: To output a .png copy of the WIT stackplot, enter a file name e.g. ``output_WIT.png``"
msgstr ""

#: 
msgid "Real World Examples"
msgstr ""

#: 
msgid "More complex workflows demonstrating how DE Africa can be used to address real-world problems."
msgstr ""

#: 
msgid "DE Africa Logo"
msgstr ""

#: 
msgid "SDG logo"
msgstr ""

#: 
msgid "Digital Earth Africa supports the Sustainable Development Goals"
msgstr ""

#: 
msgid "Digital Earth Africa Services and Tools for Sustainable Development Goals"
msgstr ""

#: 
msgid "The Sustainable Development Goals represent a data-driven, evidence-based approach to sustainable development `(The CEOS Earth Observation Handbook Special 2018 Edition) <http://www.eohandbook.com/sdg/files/CEOS_EOHB_2018_SDG.pdf>`__. The aim of the Sustainable Development Goals (SDG) framework is to end poverty, improve health and education, reduce inequality, design sustainable cities, support economic growth, tackle climate change and leave no one behind `(Andries et al. 2022) <https://doi.org/10.3390/su14031191>`__. The purpose of the Global Indicator Framework is to provide means by which to measure, monitor and report progress made in the implementation of the SDGs and their respective targets, for the follow up and review of the 2030 Agenda for Sustainable Development. The Global Indicator Framework is designed around 232 SDG Indicators."
msgstr ""

#: 
msgid "Earth Observation data is an essential tool in the development of the information required by many of the SDG Indicators given its cost-effectiveness pertaining to data acquisition on all scales and information richness. `(The CEOS Earth Observation Handbook Special 2018 Edition) <http://www.eohandbook.com/sdg/files/CEOS_EOHB_2018_SDG.pdf>`__, `(Ferreira, B., Iten, M. & Silva, R.G. 2020) <https://doi.org/10.1186/s12302-020-00397-4>`__."
msgstr ""

#: 
msgid "Digital Earth Africa (DE Africa) hosts data, services and Jupyter Notebooks that can be used to address real world problems and contribute to the Global Indicator Framework."
msgstr ""

#: 
msgid "Sustainable Development Indicators that Digital Earth Africa Notebooks contribute to"
msgstr ""

#: 
msgid "The notebooks linked below demonstrate how DE Africa data and services can be used to support Sustainable Development Goals."
msgstr ""

#: 
msgid "SDG Icon 2"
msgstr ""

#: 
msgid "Goal 2:"
msgstr ""

#: 
msgid "End hunger, achieve food security and improved nutrition and promote sustainable agriculture."
msgstr ""

#: 
msgid "**Indicator 2.4.1** Proportion of agricultural area under productive and sustainable agriculture"
msgstr ""

#: 
msgid "`Global Root-zone moisture Analysis & Forecasting System (GRAFS) <../Datasets/Soil_Moisture.ipynb>`__"
msgstr ""

#: 
msgid "`NDVI Climatology <../Datasets/NDVI_Climatology.ipynb>`__"
msgstr ""

#: 
msgid "`Rainfall estimates (CHIRPS) <../Datasets/Rainfall_CHIRPS.ipynb>`__"
msgstr ""

#: 
msgid "`Cropland extent maps for Africa <../Datasets/Cropland_extent.ipynb>`__"
msgstr ""

#: 
msgid "`Land Cover Classification datasets <../Datasets/Landcover_Classification.ipynb>`__"
msgstr ""

#: 
msgid "`Monitoring change through time using satellite imagery filmstrip plots <../Real_world_examples/Change_filmstrips.ipynb>`__"
msgstr ""

#: 
msgid "`Measuring crop health <../Real_world_examples/Crop_health.ipynb>`__"
msgstr ""

#: 
msgid "`Forecasting cropland vegetation condition <../Real_world_examples/Forecasting_vegetation_condition.ipynb>`__"
msgstr ""

#: 
msgid "`Identifying active irrigated cropping <../Real_world_examples/Irrigated_cropping.ipynb>`__"
msgstr ""

#: 
msgid "`Vegetation Phenology (Optical) <../Real_world_examples/Phenology_optical.ipynb>`__"
msgstr ""

#: 
msgid "`Vegetation Phenology (Radar) <../Real_world_examples/Phenology_radar.ipynb>`__"
msgstr ""

#: 
msgid "`Monthly vegetation condition anomalies <../Real_world_examples/Vegetation_anomalies_monthly.ipynb>`__"
msgstr ""

#: 
msgid "`Scalable Supervised Machine Learning on the Open Data Cube ReadME <../Real_world_examples/Scalable_machine_learning/0_README.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 2.c.1** Indicator of food price anomalies"
msgstr ""

#: 
msgid "`Rainfall anomalies from Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS) <../Real_world_examples/Rainfall_anomaly_CHIRPS.ipynb>`__"
msgstr ""

#: 
msgid "SDG Icon 6"
msgstr ""

#: 
msgid "Goal 6:"
msgstr ""

#: 
msgid "Ensure availability and sustainable management of water and sanitation for all."
msgstr ""

#: 
msgid "**Indicator 6.3.2** Proportion of bodies of water with good ambient water quality"
msgstr ""

#: 
msgid "`Monitoring Water Quality <../Frequently_used_code/Monitoring_water_quality.ipynb>`__"
msgstr ""

#: 
msgid "`Monitoring chlorophyll-\\ a in African waterbodies <../Real_world_examples/Chlorophyll_monitoring.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 6.4.2** Level of water stress: freshwater withdrawal as a proportion of available freshwater resources"
msgstr ""

#: 
msgid "`ERA5 climate data <../Datasets/Climate_Data_ERA5_AWS.ipynb>`__"
msgstr ""

#: 
msgid "`Determining seasonal extent of waterbodies with Sentinel-2 <../Real_world_examples/Water_extent_sentinel_2.ipynb>`__"
msgstr ""

#: 
msgid "`Mapping longer-term changes in water extent with WOfS <../Real_world_examples/Water_extent_WOfS.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 6.6.1** Change in the extent of water-related ecosystems over time"
msgstr ""

#: 
msgid "`Land Cover Classification Datasets <../Datasets/Landcover_Classification.ipynb>`__"
msgstr ""

#: 
msgid "`Water Observations from Space <../Datasets/Water_Observations_from_Space.ipynb>`__"
msgstr ""

#: 
msgid "`Extracting contour lines <../Frequently_used_code/Contour_extraction.ipynb>`__"
msgstr ""

#: 
msgid "`Water detection with Sentinel-1 <../Real_world_examples/Radar_water_detection.ipynb>`__"
msgstr ""

#: 
msgid "`Wetlands Insight Tool <../Real_world_examples/Wetlands_insight_tool.ipynb>`__"
msgstr ""

#: 
msgid "The Okavango Use Case Notebooks:"
msgstr ""

#: 
msgid "`Monitoring wetlands in the Okavango <../Use_cases/Okavango/0_Wetland_inundation_and_vegetation_dynamics.ipynb>`__"
msgstr ""

#: 
msgid "`Mapping long-term changes in the annual water extent of the Okavango Delta <../Use_cases/Okavango/1_Water_extent_longterm_WOfS.ipynb>`__"
msgstr ""

#: 
msgid "`Mapping the seasonal changes to the open water extent of the Okavango delta <../Use_cases/Okavango/2_Water_extent_seasonal_MNDWI.ipynb>`__"
msgstr ""

#: 
msgid "`Extracting historical climate (rainfall) data over selected basins <../Use_cases/Okavango/3_Historical_rainfall.ipynb>`__"
msgstr ""

#: 
msgid "`Visualising the correlation between rainfall, surface water extent, and discharge <../Use_cases/Okavango/4_Visualising_rainfall_discharge_water_extent.ipynb>`__"
msgstr ""

#: 
msgid "`Modelling discharge at Mohembo using uppercatchment rainfall <../Use_cases/Okavango/5_Rainfall_discharge_modelling.ipynb>`__"
msgstr ""

#: 
msgid "`Forecasting surface water extent in the Okavango delta <../Use_cases/Okavango/6_Forecasting_water_extent.ipynb>`__"
msgstr ""

#: 
msgid "The Monitoring Water Extent Use Case Notebooks:"
msgstr ""

#: 
msgid "`Mapping water extent and rainfall using Sentinel-1 and CHIRPS <../Use_cases/Monitoring_water_extent/Monitoring_water_extent_radar.ipynb>`__"
msgstr ""

#: 
msgid "`Mapping water extent and rainfall using WOfS and CHIRPS <../Use_cases/Monitoring_water_extent/Monitoring_water_extent_WOfS.ipynb>`__"
msgstr ""

#: 
msgid "SDG Icon 9"
msgstr ""

#: 
msgid "Goal 9:"
msgstr ""

#: 
msgid "Build resilient infrastructure, promote inclusive and sustainable industrialization and foster innovation."
msgstr ""

#: 
msgid "**Indicator 9.1.1** Proportion of the rural population who live within 2 km of an all-season"
msgstr ""

#: 
msgid "`Machine learning with the Open Data Cube <../Real_world_examples/Machine_learning_with_ODC.ipynb>`__"
msgstr ""

#: 
msgid "`Urban area mapping using Sentinel 1 data <../Real_world_examples/Radar_urban_area_mapping.ipynb>`__"
msgstr ""

#: 
msgid "`Urbanization Index Comparisons with Global Human Settlement (GHS) <../Real_world_examples/Urban_index_comparison.ipynb>`__"
msgstr ""

#: 
msgid "`Detecting change in urban extent <../Real_world_examples/Urban_change_detection.ipynb>`__"
msgstr ""

#: 
msgid "SDG Icon 11"
msgstr ""

#: 
msgid "Goal 11:"
msgstr ""

#: 
msgid "Make cities and human settlements inclusive, safe, resilient and sustainable."
msgstr ""

#: 
msgid "**Indicator 11.1.1** Proportion of urban population living in slums, informal settlements or inadequate housing"
msgstr ""

#: 
msgid "**Indicator 11.3.1** Ratio of land consumption rate to population growth rate"
msgstr ""

#: 
msgid "**Indicator 11.7.1** Average share of the built-up area of cities that is open space for public use for all, by sex, age and persons with disabilities"
msgstr ""

#: 
msgid "SDG Icon 13"
msgstr ""

#: 
msgid "Goal 13:"
msgstr ""

#: 
msgid "Take urgent action to combat climate change and its impacts."
msgstr ""

#: 
msgid "**Indicator 13.1.1** Number of deaths, missing persons and directly affected persons attributed to disasters per 100,000 population"
msgstr ""

#: 
msgid "`Digital Elevation Models <../Datasets/Digital_Elevation_Models.ipynb>`__"
msgstr ""

#: 
msgid "`Burnt Area Mapping <../Real_world_examples/Burnt_area_mapping.ipynb>`__"
msgstr ""

#: 
msgid "`Identifying ships with Sentinel-1 <../Real_world_examples/Ship_detection_with_radar.ipynb>`__"
msgstr ""

#: 
msgid "`Monitoring coastal erosion along Africa's coastline <../Real_world_examples/Coastal_erosion.ipynb>`__"
msgstr ""

#: 
msgid "SDG Icon 14"
msgstr ""

#: 
msgid "Goal 14:"
msgstr ""

#: 
msgid "Conserve and sustainably use the oceans, seas and marine resources for sustainable development."
msgstr ""

#: 
msgid "**Indicator 14.1.1** (a) Index of coastal eutrophication; and (b) plastic debris density"
msgstr ""

#: 
msgid "**Indicator 14.5.1** Coverage of protected areas in relation to marine areas"
msgstr ""

#: 
msgid "`Monitoring Mangrove Extents <../Real_world_examples/Mangrove_analysis.ipynb>`__"
msgstr ""

#: 
msgid "SDG Icon 15"
msgstr ""

#: 
msgid "Goal 15:"
msgstr ""

#: 
msgid "Protect, restore and promote sustainable use of terrestrial ecosystems, manage sustainably forests, combat desertification, and halt and reverse land degradation and halt biodiversity loss."
msgstr ""

#: 
msgid "**Indicator 15.1.1** Forest area as a proportion of total land area"
msgstr ""

#: 
msgid "`Global Mangrove Watch <../Datasets/Global_Mangrove_Watch.ipynb>`__"
msgstr ""

#: 
msgid "`Fractional Cover <../Datasets/Fractional_Cover.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 15.1.2** Proportion of important sites for terrestrial and freshwater biodiversity that are covered by protected areas, by ecosystem type"
msgstr ""

#: 
msgid "The Lake Baringo Use Case Notebooks:"
msgstr ""

#: 
msgid "`Vegetation phenology in the Ruko Conservancy <../Use_cases/Lake_baringo_grazing/Vegetation_phenology_1D.ipynb>`__"
msgstr ""

#: 
msgid "`Per-pixel vegetation phenology in the Ruko Conservancy <../Use_cases/Lake_baringo_grazing/Vegetation_phenology_perpixel.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 15.3.1** Proportion of land that is degraded over total land area"
msgstr ""

#: 
msgid "`Vegetation Change Detection <../Real_world_examples/Vegetation_change_detection.ipynb>`__"
msgstr ""

#: 
msgid "`Surface Mining Screening <../Use_cases/Surface_mining_screening/Surface_mining_screening.ipynb>`__"
msgstr ""

#: 
msgid "**Indicator 15.4.2** Mountain Green Cover Index"
msgstr ""

#: 
msgid "`Mountain Green Cover Index Notebook <Mountain_Green_Cover_Index/MGCI.ipynb>`__"
msgstr ""

#: 
msgid "Mountain Green Cover Index Notebook (SDG 15.4.2)"
msgstr ""

#: 
msgid "**Disclaimer**:  The notebook is work in progress. This workshop will be a good forum to get feedback to refine the notebook. Thank you."
msgstr ""

#: 
msgid "Sustainable Development Goal 15:"
msgstr ""

#: 
msgid "Protect, restore and promote sustainable use of terrestrial ecosystems, sustainably manage forests, combat desertification, and halt and reverse land degradation and halt biodiversity loss."
msgstr ""

#: 
msgid "Target 15.4"
msgstr ""

#: 
msgid "By 2030, ensure the conservation of mountain ecosystems, including their biodiversity, in order to enhance their capacity to provide benefits that are essential for sustainable development."
msgstr ""

#: 
msgid "Indicator 15.4.2: Mountain Green Cover Index"
msgstr ""

#: 
msgid "The Mountain Green Cover Index (MGCI) is designed to measure the extent and the changes of green vegetation in mountain areas - i.e. forest, shrubs, trees, pasture land, crop land, etc. – in order to monitor progress towards the mountain target. MGCI is defined as the percentage of green cover over the total surface of the mountain region of a given country and for a given reporting year. The aim of the index is to monitor the evolution of the green cover and thus assess the status of conservation of mountain ecosystems. More information on MGCI can be found `here <https://www.fao.org/sustainable-development-goals/indicators/1542/en/>`__."
msgstr ""

#: 
msgid "The methodology to calculate the Mountain Green Cover index was initially developed by FAO `(De Simone et al., 2021) <https://doi.org/10.3390/ijgi10070427>`__."
msgstr ""

#: 
msgid "The Mountain Green Cover index is calculated using two descriptor layers of information:"
msgstr ""

#: 
msgid "A mountain descriptor layer: mountains can be defined with reference to a variety of parameters, such as climate, elevation, ecology (Körner et al., 2011) (Karagulle et al., 2017). This methodology adheres to the UNEP- WCMC mountain definition, relying in turn on the mountain description proposed by Kapos et al. (2000)."
msgstr ""

#: 
msgid "A vegetation descriptor layer: The vegetation descriptor layer categorizes land cover into green and non-green areas. Green vegetation includes both natural vegetation and vegetation resulting from anthropic activity (e.g. crops, afforestation, etc.). Non-green areas include very sparsely vegetated areas, bare land, water, permanent ice/snow and urban areas. The vegetation description layer can be derived in different ways, but remote sensing based land cover maps are the most convenient data source for this purpose, as they provide the required information on green and non-green areas in a spatially explicit manner and allow for comparison over time through land cover change analysis."
msgstr ""

#: 
msgid "Currently, FAO uses the land cover time series produced by the European Space Agency (ESA) under the Climate Change Initiative (CCI) as a general solution. More information is provided `here <https://hqfao.maps.arcgis.com/home/item.html?id=701f5aea91d141adbc0c4aa0bacb8739>`__."
msgstr ""

#: 
msgid "The notebook does the following:"
msgstr ""

#: 
msgid "Calculate the Kapos Mountain Range class for the study area"
msgstr ""

#: 
msgid "Reclassify ESA CCI to IPCC Classification and Green and Non Green"
msgstr ""

#: 
msgid "Generate the Mountain Green Cover Index (MGCI)"
msgstr ""

#: 
msgid "Dask can be used to better manage memory use and conduct the analysis in parallel. For an introduction to using Dask with Digital Earth Africa, see the `Dask notebook <../../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "**Note**: We recommend opening the Dask processing window to view the different computations that are being executed; to do this, see the *Dask dashboard in DE Africa* section of the `Dask notebook <../../Beginners_guide/08_Parallel_processing_with_dask.ipynb>`__."
msgstr ""

#: 
msgid "``time`` : This is the time period of interest for the analysis."
msgstr ""

#: 
msgid "``output_crs`` : The coordinate reference system that the loaded data is to be reprojected to."
msgstr ""

#: 
msgid "``dask_chunks`` : the size of the dask chunks, dask breaks data into manageable chunks that can be easily stored in memory."
msgstr ""

#: 
msgid "``output_dir`` : The directory in which to store results from the analysis."
msgstr ""

#: 
msgid "Select a country"
msgstr ""

#: 
msgid "Load the African Countries GeoJSON. This file contains polygons for the boundaries of African countries."
msgstr ""

#: 
msgid "List the countries in the African Countries GeoJSON."
msgstr ""

#: 
msgid "From the countries above, you can choose any and type it at the country variable below."
msgstr ""

#: 
msgid "Load SRTM DEM dataset at 1000m resolution"
msgstr ""

#: 
msgid "### Neighborhood reduction operation"
msgstr ""

#: 
msgid "Calculating the local elevation range (LER)"
msgstr ""

#: 
msgid "Load SRTM DEM slope derivative dataset at 30m resolution"
msgstr ""

#: 
msgid "Upsampling dem_strm dataset at 1000m to 30m resolution"
msgstr ""

#: 
msgid "Generating Kapos range mountain classes"
msgstr ""

#: 
msgid "Plotting the Kapos Mountain range classes"
msgstr ""

#: 
msgid "Loading ESA Climate Change Initiative Land Cover dataset at 300m resolution"
msgstr ""

#: 
msgid "Reclassify CCI land Cover to IPCC Land Cover Classes"
msgstr ""

#: 
msgid "Plotting IPCC Classification"
msgstr ""

#: 
msgid "Reclassify IPCC Classification to Green and Non Green Classes"
msgstr ""

#: 
msgid "Plotting Green/Non Green Classification"
msgstr ""

#: 
msgid "Downsampling dem_strm dataset at 30m to 300m resolution"
msgstr ""

#: 
msgid "## Pixel Area Conversion"
msgstr ""

#: 
msgid "Calculating the Mountain Green Cover Index (MGCI)"
msgstr ""

#: 
msgid "Plotting Mountain Green Cover Index"
msgstr ""

#: 
msgid "deafrica\\_tools.app.animations"
msgstr ""

#: 
msgid "Satellite imagery animation widget, which can be used to interactively produce animations for multiple DE Africa products."
msgstr ""

#: 
msgid "Functions"
msgstr ""

#: 
msgid ":py:obj:`create_expanded_button <deafrica_tools.app.animations.create_expanded_button>`\\ \\(description\\, button\\_style\\)"
msgstr ""

#: 
msgid ":py:obj:`deacoastlines_overlay <deafrica_tools.app.animations.deacoastlines_overlay>`\\ \\(ds\\)"
msgstr ""

#: 
msgid ":py:obj:`extract_data <deafrica_tools.app.animations.extract_data>`\\ \\(self\\)"
msgstr ""

#: 
msgid ":py:obj:`make_box_layout <deafrica_tools.app.animations.make_box_layout>`\\ \\(\\)"
msgstr ""

#: 
msgid ":py:obj:`plot_data <deafrica_tools.app.animations.plot_data>`\\ \\(self\\, fname\\)"
msgstr ""

#: 
msgid ":py:obj:`update_map_layers <deafrica_tools.app.animations.update_map_layers>`\\ \\(self\\)"
msgstr ""

#: 
msgid "Updates map to add new DE Africa layers, styles or basemap when selected using menu options."
msgstr ""

#: 
msgid "Classes"
msgstr ""

#: 
msgid ":py:obj:`animation_app <deafrica_tools.app.animations.animation_app>`\\ \\(\\*\\*kwargs\\)"
msgstr ""

#: 
msgid "Updates map to add new DE Africa layers, styles or basemap when selected using menu options. Triggers data reload by resetting load params and output arrays."
msgstr ""

#: 
msgid "deafrica\\_tools.app.changefilmstrips"
msgstr ""

#: 
msgid "Loading and interacting with data in the change filmstrips notebook, inside the Real_world_examples folder."
msgstr ""

#: 
msgid ":py:obj:`run_filmstrip_app <deafrica_tools.app.changefilmstrips.run_filmstrip_app>`\\ \\(output\\_name\\, time\\_range\\, ...\\)"
msgstr ""

#: 
msgid "An interactive app that allows the user to select a region from a map, then load Digital Earth Africa Landsat data and combine it using the geometric median (\"geomedian\") statistic to reveal the median or 'typical' appearance of the landscape for a series of time periods."
msgstr ""

#: 
msgid "The results for each time period are combined into a 'filmstrip' plot which visualises how the landscape has changed in appearance across time, with a 'change heatmap' panel highlighting potential areas of greatest change."
msgstr ""

#: 
msgid "Last modified: April 2020"
msgstr ""

#: 
msgid "Parameters"
msgstr ""

#: 
msgid "A name that will be used to name the output filmstrip plot file."
msgstr ""

#: 
msgid "A tuple giving the date range to analyse (e.g. `time_range = ('1988-01-01', '2017-12-31')`)."
msgstr ""

#: 
msgid "This parameter sets the length of the time periods to compare (e.g. `time_step = {'years': 5}` will generate one filmstrip plot for every five years of data; `time_step = {'months': 18}` will generate one plot for each 18 month period etc. Time periods are counted from the first value given in `time_range`."
msgstr ""

#: 
msgid "An optional parameter that can be used to generate filmstrip plots based on specific ocean tide conditions. This can be valuable for analysing change consistently along the coast. For example, `tide_range = (0.0, 0.2)` will select only satellite images acquired at the lowest 20% of tides; `tide_range = (0.8, 1.0)` will select images from the highest 20% of tides. The default is `tide_range = (0.0, 1.0)` which will select all images regardless of tide."
msgstr ""

#: 
msgid "The spatial resolution to load data. The default is `resolution = (-30, 30)`, which will load data at 30 m pixel resolution. Increasing this (e.g. to `resolution = (-100, 100)`) can be useful for loading large spatial extents."
msgstr ""

#: 
msgid "This parameter can be used to exclude satellite images with excessive cloud. The default is `0.5`, which will keep all images with less than 50% cloud."
msgstr ""

#: 
msgid "An optional boolean indicating whether to include data from after the Landsat 7 SLC failure (i.e. SLC-off). Defaults to False, which removes all Landsat 7 observations > May 31 2003."
msgstr ""

#: 
msgid "An optional integer (in hectares) specifying the size limit for the data query. Queries larger than this size will receive a warning that he data query is too large (and may therefore result in memory errors)."
msgstr ""

#: 
msgid "Returns"
msgstr ""

#: 
msgid "**ds_geomedian** -- An xarray dataset containing geomedian composites for each timestep in the analysis."
msgstr ""

#: 
msgid "Return type"
msgstr ""

#: 
msgid "deafrica\\_tools.app.crophealth"
msgstr ""

#: 
msgid "Functions for loading and interacting with data in the crop health notebook,"
msgstr ""

#: 
msgid "inside the Real_world_examples folder."
msgstr ""

#: 
msgid ":py:obj:`load_crophealth_data <deafrica_tools.app.crophealth.load_crophealth_data>`\\ \\(lat\\, lon\\, buffer\\, date\\)"
msgstr ""

#: 
msgid "Loads Sentinel-2 analysis-ready data (ARD) product for the crop health case-study area over the last two years."
msgstr ""

#: 
msgid ":py:obj:`run_crophealth_app <deafrica_tools.app.crophealth.run_crophealth_app>`\\ \\(ds\\, lat\\, lon\\, buffer\\)"
msgstr ""

#: 
msgid "Plots an interactive map of the crop health case-study area and allows the user to draw polygons."
msgstr ""

#: 
msgid "Loads Sentinel-2 analysis-ready data (ARD) product for the crop health case-study area over the last two years. Last modified: April 2020"
msgstr ""

#: 
msgid "The central latitude to analyse"
msgstr ""

#: 
msgid "The central longitude to analyse"
msgstr ""

#: 
msgid "The number of square degrees to load around the central latitude and longitude. For reasonable loading times, set this as `0.1` or lower."
msgstr ""

#: 
msgid "The most recent date to show data for. The app will automatically load all data available for the two years prior to this date."
msgstr ""

#: 
msgid "**ds** -- data set containing combined, masked data Masked values are set to 'nan'"
msgstr ""

#: 
msgid "Plots an interactive map of the crop health case-study area and allows the user to draw polygons. This returns a plot of the average NDVI value in the polygon area. Last modified: January 2020"
msgstr ""

#: 
msgid "data set containing combined, masked data Masked values are set to 'nan'"
msgstr ""

#: 
msgid "The central latitude corresponding to the area of loaded ds"
msgstr ""

#: 
msgid "The central longitude corresponding to the area of loaded ds"
msgstr ""

#: 
msgid "deafrica\\_tools.app.geomedian"
msgstr ""

#: 
msgid "Geomedian widget: generates an interactive visualisation of the geomedian summary statistic."
msgstr ""

#: 
msgid ":py:obj:`run_app <deafrica_tools.app.geomedian.run_app>`\\ \\(\\)"
msgstr ""

#: 
msgid "An interactive app that allows users to visualise the difference between the median and geomedian time-series summary statistics."
msgstr ""

#: 
msgid "An interactive app that allows users to visualise the difference between the median and geomedian time-series summary statistics. By modifying the red-green-blue values of three timesteps for a given pixel, the user changes the output summary statistics."
msgstr ""

#: 
msgid "This allows a visual representation of the difference through the output values, RGB colour, as well as showing values plotted as a vector on a 3-dimensional  space."
msgstr ""

#: 
msgid "Last modified: December 2021"
msgstr ""

#: 
msgid "deafrica\\_tools.app.imageexport"
msgstr ""

#: 
msgid "Create an interactive map for selecting satellite imagery and exporting image files."
msgstr ""

#: 
msgid ":py:obj:`export_image_app <deafrica_tools.app.imageexport.export_image_app>`\\ \\(geopolygon\\, date\\, satellites\\)"
msgstr ""

#: 
msgid "Exports Digital Earth Africa satellite data as an image file based on the extent and time period selected using :func:`select_region_app`."
msgstr ""

#: 
msgid ":py:obj:`select_region_app <deafrica_tools.app.imageexport.select_region_app>`\\ \\(date\\, satellites\\[\\, size\\_limit\\]\\)"
msgstr ""

#: 
msgid "An interactive app that allows the user to select a region from a map using imagery from Sentinel-2 and Landsat."
msgstr ""

#: 
msgid "Exports Digital Earth Africa satellite data as an image file based on the extent and time period selected using :func:`select_region_app`. The function supports Sentinel-2 and Landsat data, creating True and False colour images."
msgstr ""

#: 
msgid "By default, files are named using:"
msgstr ""

#: 
msgid "``\"<product> - <YYYY-MM-DD> - <site, state> - <description>.png\"``"
msgstr ""

#: 
msgid "Set ``standardise_name=True`` for a machine-readable name:"
msgstr ""

#: 
msgid "``\"<product>_<YYYY-MM-DD>_<site-state>_<description>.png\"``"
msgstr ""

#: 
msgid "Last modified: September 2021"
msgstr ""

#: 
msgid "A datacube geopolygon providing the spatial bounds used to load satellite data."
msgstr ""

#: 
msgid "The exact date used to extract imagery (e.g. `date='1988-01-01'`)."
msgstr ""

#: 
msgid "The satellite data to be used to extract imagery. The following options are supported:      ``'Landsat-9'``: data from the Landsat 9 satellite     ``'Landsat-8'``: data from the Landsat 8 satellite     ``'Landsat-7'``: data from the Landsat 7 satellite     ``'Landsat-5'``: data from the Landsat 5 satellite     ``'Sentinel-2'``: data from Sentinel-2A and Sentinel-2B     ``'Sentinel-2 geomedian'``: data from the Sentinel-2 annual geomedian"
msgstr ""

#: 
msgid "The satellite data to be used to extract imagery. The following options are supported:"
msgstr ""

#: 
msgid "``'Landsat-9'``: data from the Landsat 9 satellite ``'Landsat-8'``: data from the Landsat 8 satellite ``'Landsat-7'``: data from the Landsat 7 satellite ``'Landsat-5'``: data from the Landsat 5 satellite ``'Sentinel-2'``: data from Sentinel-2A and Sentinel-2B ``'Sentinel-2 geomedian'``: data from the Sentinel-2 annual geomedian"
msgstr ""

#: 
msgid "The style used to produce the image. Two options are currently supported:      * ``'True colour'``: Creates a true colour image using the red,       green and blue satellite bands     * ``'False colour'``: Creates a false colour image using       short-wave infrared, infrared and green satellite bands.       The specific bands used vary between Landsat and Sentinel-2."
msgstr ""

#: 
msgid "The style used to produce the image. Two options are currently supported:"
msgstr ""

#: 
msgid "``'True colour'``: Creates a true colour image using the red, green and blue satellite bands"
msgstr ""

#: 
msgid "``'False colour'``: Creates a false colour image using short-wave infrared, infrared and green satellite bands. The specific bands used vary between Landsat and Sentinel-2."
msgstr ""

#: 
msgid "The spatial resolution to load data. By default, the tool will automatically set the best possible resolution depending on the satellites selected (i.e 30 m for Landsat, 10 m for Sentinel-2). Increasing this (e.g. to ``resolution=(-100, 100)``) can be useful for loading large spatial extents."
msgstr ""

#: 
msgid "The minimum and maximum surface reflectance values used to clip the resulting imagery to enhance contrast."
msgstr ""

#: 
msgid "An tuple of two floats (between 0.00 and 1.00) that can be used to clip the imagery to based on percentiles to get more control over the brightness and contrast of the image. The default is ``None``; ``(0.02, 0.98)`` is equivelent to ``robust=True``. If this parameter is used, ``vmin`` and ``vmax`` will have no effect."
msgstr ""

#: 
msgid "Raises imagery by a power to reduce bright features and enhance dark features. This can add extra definition over areas with extremely bright features like snow, beaches or salt pans."
msgstr ""

#: 
msgid "An optional list containing functions that will be applied to the output image. This can include image processing functions such as increasing contrast, unsharp masking, saturation etc. The function should take AND return a `numpy.ndarray` with shape ``[y, x, bands]``. If your function has parameters, you can pass in custom values using a lambda function, e.g.: ``[lambda x: skimage.filters.unsharp_mask(x, radius=5, amount=0.2)]``"
msgstr ""

#: 
msgid "The output file format of the image. Valid options include ``'jpg'`` and ``'png'``. Defaults to ``'jpg'``."
msgstr ""

#: 
msgid "Whether to export the image file with a machine-readable file name (e.g. ``<product>_<YYYY-MM-DD>_<site-state>_<description>.png``)"
msgstr ""

#: 
msgid "An interactive app that allows the user to select a region from a map using imagery from Sentinel-2 and Landsat. The output of this function is used as the input to :func:`export_image_app` to export high- resolution satellite images."
msgstr ""

#: 
msgid "The exact date used to plot imagery on the interactive map (e.g. ``date='1988-01-01'``)."
msgstr ""

#: 
msgid "The satellite data to plot on the interactive map. The following options are supported:      ``'Landsat-9'``: data from the Landsat 9 satellite     ``'Landsat-8'``: data from the Landsat 8 satellite     ``'Landsat-7'``: data from the Landsat 7 satellite     ``'Landsat-5'``: data from the Landsat 5 satellite     ``'Sentinel-2'``: data from Sentinel-2A and Sentinel-2B     ``'Sentinel-2 geomedian'``: data from the Sentinel-2 annual geomedian"
msgstr ""

#: 
msgid "The satellite data to plot on the interactive map. The following options are supported:"
msgstr ""

#: 
msgid "An optional size limit for the area selection in sq km. Defaults to 10000 sq km."
msgstr ""

#: 
msgid "* *A dictionary containing* --    * 'geopolygon' (defining the area to export imagery from),   * 'date' (date used to export imagery), and   * 'satellites' (the satellites from which to extract imagery). * These are passed to the :func:`export_image_app` function to export the image."
msgstr ""

#: 
msgid "*A dictionary containing* --"
msgstr ""

#: 
msgid "'geopolygon' (defining the area to export imagery from),"
msgstr ""

#: 
msgid "'date' (date used to export imagery), and"
msgstr ""

#: 
msgid "'satellites' (the satellites from which to extract imagery)."
msgstr ""

#: 
msgid "These are passed to the :func:`export_image_app` function to export the image."
msgstr ""

#: 
msgid "deafrica\\_tools.app.wetlandsinsighttool"
msgstr ""

#: 
msgid "Wetlands insight tool widget, which can be used to run an interactive version of the wetlands insight tool."
msgstr ""

#: 
msgid ":py:obj:`create_expanded_button <deafrica_tools.app.wetlandsinsighttool.create_expanded_button>`\\ \\(description\\, button\\_style\\)"
msgstr ""

#: 
msgid ":py:obj:`make_box_layout <deafrica_tools.app.wetlandsinsighttool.make_box_layout>`\\ \\(\\)"
msgstr ""

#: 
msgid ":py:obj:`wit_app <deafrica_tools.app.wetlandsinsighttool.wit_app>`\\ \\(\\*\\*kwargs\\)"
msgstr ""

#: 
msgid "deafrica\\_tools.app.widgetconstructors"
msgstr ""

#: 
msgid "Functions for easily defining widgets in the context of DE Africa notebooks."
msgstr ""

#: 
msgid "These are largely customised wrappers around existing widgets."
msgstr ""

#: 
msgid ":py:obj:`create_boundedfloattext <deafrica_tools.app.widgetconstructors.create_boundedfloattext>`\\ \\(value\\, min\\_val\\, ...\\)"
msgstr ""

#: 
msgid "Create a BoundedFloatText widget"
msgstr ""

#: 
msgid ":py:obj:`create_checkbox <deafrica_tools.app.widgetconstructors.create_checkbox>`\\ \\(value\\[\\, description\\, layout\\]\\)"
msgstr ""

#: 
msgid "Create a Checkbox widget"
msgstr ""

#: 
msgid ":py:obj:`create_datepicker <deafrica_tools.app.widgetconstructors.create_datepicker>`\\ \\(\\[description\\, value\\, layout\\]\\)"
msgstr ""

#: 
msgid "Create a DatePicker widget"
msgstr ""

#: 
msgid ":py:obj:`create_dea_wms_layer <deafrica_tools.app.widgetconstructors.create_dea_wms_layer>`\\ \\(product\\, date\\)"
msgstr ""

#: 
msgid "Create a Digital Earth Africa WMS layer to add to a map"
msgstr ""

#: 
msgid ":py:obj:`create_drawcontrol <deafrica_tools.app.widgetconstructors.create_drawcontrol>`\\ \\(\\[draw\\_controls\\, ...\\]\\)"
msgstr ""

#: 
msgid "Create a draw control widget to add to ipyleaflet maps"
msgstr ""

#: 
msgid ":py:obj:`create_dropdown <deafrica_tools.app.widgetconstructors.create_dropdown>`\\ \\(options\\, value\\[\\, ...\\]\\)"
msgstr ""

#: 
msgid "Create a Dropdown widget"
msgstr ""

#: 
msgid ":py:obj:`create_html <deafrica_tools.app.widgetconstructors.create_html>`\\ \\(value\\)"
msgstr ""

#: 
msgid "Create a HTML widget"
msgstr ""

#: 
msgid ":py:obj:`create_inputtext <deafrica_tools.app.widgetconstructors.create_inputtext>`\\ \\(value\\, placeholder\\[\\, ...\\]\\)"
msgstr ""

#: 
msgid "Create a Text widget"
msgstr ""

#: 
msgid ":py:obj:`create_map <deafrica_tools.app.widgetconstructors.create_map>`\\ \\(\\[map\\_center\\, zoom\\_level\\, ...\\]\\)"
msgstr ""

#: 
msgid "Create an interactive ipyleaflet map"
msgstr ""

#: 
msgid "Last modified: October 2021"
msgstr ""

#: 
msgid "initial value of the widget"
msgstr ""

#: 
msgid "minimum allowed value for the float"
msgstr ""

#: 
msgid "maximum allowed value for the float"
msgstr ""

#: 
msgid "allowed increment for the float"
msgstr ""

#: 
msgid "descirption label to attach"
msgstr ""

#: 
msgid "any layout commands for the widget"
msgstr ""

#: 
msgid "**float_text**"
msgstr ""

#: 
msgid "Last modified: July 2022"
msgstr ""

#: 
msgid "initial value of the widget; True or False"
msgstr ""

#: 
msgid "description label to attach"
msgstr ""

#: 
msgid "**dropdown**"
msgstr ""

#: 
msgid "**date_picker**"
msgstr ""

#: 
msgid "The Digital Earth Africa product to load (e.g. 'gm_s2_annual')"
msgstr ""

#: 
msgid "The date to load the product for"
msgstr ""

#: 
msgid "**time_wms**"
msgstr ""

#: 
msgid "List of draw controls to add to the map. Defaults to adding all Viable options are 'rectangle', 'polygon', 'circle', 'polyline', 'marker', 'circlemarker'"
msgstr ""

#: 
msgid "Options to customise the appearence of the relevant shape User can supply, or leave blank to get default DE Africa appearence"
msgstr ""

#: 
msgid "**draw_control**"
msgstr ""

#: 
msgid "a list of options for the user to select from"
msgstr ""

#: 
msgid "HTML text to display"
msgstr ""

#: 
msgid "**html**"
msgstr ""

#: 
msgid "placeholder text to display to the user before intput"
msgstr ""

#: 
msgid "**input_text**"
msgstr ""

#: 
msgid "A tuple containing the latitude and longitude to focus on. Defaults to center of Africa, (4, 20)"
msgstr ""

#: 
msgid "Zoom level for the map Defaults to 3 to view all of Africa"
msgstr ""

#: 
msgid "Basemap to use, can be any from https://ipyleaflet.readthedocs.io/en/latest/api_reference/basemaps.html Defaults to Open Street Map (basemaps.OpenStreetMap.Mapnik)"
msgstr ""

#: 
msgid "Layer name for the basemap"
msgstr ""

#: 
msgid "**m** -- interactive ipyleaflet map"
msgstr ""

#: 
msgid "deafrica\\_tools.bandindices"
msgstr ""

#: 
msgid "Functions for computing remote sensing band indices on Digital Earth Africa data."
msgstr ""

#: 
msgid ":py:obj:`calculate_indices <deafrica_tools.bandindices.calculate_indices>`\\ \\(ds\\[\\, index\\, collection\\, ...\\]\\)"
msgstr ""

#: 
msgid "Takes an xarray dataset containing spectral bands, calculates one of a set of remote sensing indices, and adds the resulting array as a new variable in the original dataset."
msgstr ""

#: 
msgid ":py:obj:`dualpol_indices <deafrica_tools.bandindices.dualpol_indices>`\\ \\(ds\\[\\, co\\_pol\\, cross\\_pol\\, ...\\]\\)"
msgstr ""

#: 
msgid "Takes an xarray dataset containing dual-polarization radar backscatter, calculates one or a set of indices, and adds the resulting array as a new variable in the original dataset."
msgstr ""

#: 
msgid "A two-dimensional or multi-dimensional array with containing the spectral bands required to calculate the index. These bands are used as inputs to calculate the selected water index."
msgstr ""

#: 
msgid "A string giving the name of the index to calculate or a list of strings giving the names of the indices to calculate:  * ``'ASI'``  (Artificial Surface Index, Yongquan Zhao & Zhe Zhu 2022) * ``'AWEI_ns'`` (Automated Water Extraction Index, no shadows, Feyisa 2014) * ``'AWEI_sh'`` (Automated Water Extraction Index, shadows, Feyisa 2014) * ``'BAEI'`` (Built-Up Area Extraction Index, Bouzekri et al. 2015) * ``'BAI'`` (Burn Area Index, Martin 1998) * ``'BSI'`` (Bare Soil Index, Rikimaru et al. 2002) * ``'BUI'`` (Built-Up Index, He et al. 2010) * ``'CMR'`` (Clay Minerals Ratio, Drury 1987) * ``'ENDISI'`` (Enhanced Normalised Difference for Impervious Surfaces Index, Chen et al. 2019) * ``'EVI'`` (Enhanced Vegetation Index, Huete 2002) * ``'FMR'`` (Ferrous Minerals Ratio, Segal 1982) * ``'IOR'`` (Iron Oxide Ratio, Segal 1982) * ``'LAI'`` (Leaf Area Index, Boegh 2002) * ``'MBI'`` (Modified Bare Soil Index, Nguyen et al. 2021) * ``'MNDWI'`` (Modified Normalised Difference Water Index, Xu 1996) * ``'MSAVI'`` (Modified Soil Adjusted Vegetation Index, Qi et al. 1994) * ``'NBI'`` (New Built-Up Index, Jieli et al. 2010) * ``'NBR'`` (Normalised Burn Ratio, Lopez Garcia 1991) * ``'NDBI'`` (Normalised Difference Built-Up Index, Zha 2003) * ``'NDCI'`` (Normalised Difference Chlorophyll Index, Mishra & Mishra, 2012) * ``'NDMI'`` (Normalised Difference Moisture Index, Gao 1996) * ``'NDSI'`` (Normalised Difference Snow Index, Hall 1995) * ``'NDTI'`` (Normalised Difference Turbidity Index, Lacaux et al. 2007) * ``'NDVI'`` (Normalised Difference Vegetation Index, Rouse 1973) * ``'NDWI'`` (Normalised Difference Water Index, McFeeters 1996) * ``'SAVI'`` (Soil Adjusted Vegetation Index, Huete 1988) * ``'TCB'`` (Tasseled Cap Brightness, Crist 1985) * ``'TCG'`` (Tasseled Cap Greeness, Crist 1985) * ``'TCW'`` (Tasseled Cap Wetness, Crist 1985) * ``'WI'`` (Water Index, Fisher 2016)"
msgstr ""

#: 
msgid "A string giving the name of the index to calculate or a list of strings giving the names of the indices to calculate:"
msgstr ""

#: 
msgid "``'ASI'``  (Artificial Surface Index, Yongquan Zhao & Zhe Zhu 2022)"
msgstr ""

#: 
msgid "``'AWEI_ns'`` (Automated Water Extraction Index, no shadows, Feyisa 2014)"
msgstr ""

#: 
msgid "``'AWEI_sh'`` (Automated Water Extraction Index, shadows, Feyisa 2014)"
msgstr ""

#: 
msgid "``'BAEI'`` (Built-Up Area Extraction Index, Bouzekri et al. 2015)"
msgstr ""

#: 
msgid "``'BAI'`` (Burn Area Index, Martin 1998)"
msgstr ""

#: 
msgid "``'BSI'`` (Bare Soil Index, Rikimaru et al. 2002)"
msgstr ""

#: 
msgid "``'BUI'`` (Built-Up Index, He et al. 2010)"
msgstr ""

#: 
msgid "``'CMR'`` (Clay Minerals Ratio, Drury 1987)"
msgstr ""

#: 
msgid "``'ENDISI'`` (Enhanced Normalised Difference for Impervious Surfaces Index, Chen et al. 2019)"
msgstr ""

#: 
msgid "``'EVI'`` (Enhanced Vegetation Index, Huete 2002)"
msgstr ""

#: 
msgid "``'FMR'`` (Ferrous Minerals Ratio, Segal 1982)"
msgstr ""

#: 
msgid "``'IOR'`` (Iron Oxide Ratio, Segal 1982)"
msgstr ""

#: 
msgid "``'LAI'`` (Leaf Area Index, Boegh 2002)"
msgstr ""

#: 
msgid "``'MBI'`` (Modified Bare Soil Index, Nguyen et al. 2021)"
msgstr ""

#: 
msgid "``'MNDWI'`` (Modified Normalised Difference Water Index, Xu 1996)"
msgstr ""

#: 
msgid "``'MSAVI'`` (Modified Soil Adjusted Vegetation Index, Qi et al. 1994)"
msgstr ""

#: 
msgid "``'NBI'`` (New Built-Up Index, Jieli et al. 2010)"
msgstr ""

#: 
msgid "``'NBR'`` (Normalised Burn Ratio, Lopez Garcia 1991)"
msgstr ""

#: 
msgid "``'NDBI'`` (Normalised Difference Built-Up Index, Zha 2003)"
msgstr ""

#: 
msgid "``'NDCI'`` (Normalised Difference Chlorophyll Index, Mishra & Mishra, 2012)"
msgstr ""

#: 
msgid "``'NDMI'`` (Normalised Difference Moisture Index, Gao 1996)"
msgstr ""

#: 
msgid "``'NDSI'`` (Normalised Difference Snow Index, Hall 1995)"
msgstr ""

#: 
msgid "``'NDTI'`` (Normalised Difference Turbidity Index, Lacaux et al. 2007)"
msgstr ""

#: 
msgid "``'NDVI'`` (Normalised Difference Vegetation Index, Rouse 1973)"
msgstr ""

#: 
msgid "``'NDWI'`` (Normalised Difference Water Index, McFeeters 1996)"
msgstr ""

#: 
msgid "``'SAVI'`` (Soil Adjusted Vegetation Index, Huete 1988)"
msgstr ""

#: 
msgid "``'TCB'`` (Tasseled Cap Brightness, Crist 1985)"
msgstr ""

#: 
msgid "``'TCG'`` (Tasseled Cap Greeness, Crist 1985)"
msgstr ""

#: 
msgid "``'TCW'`` (Tasseled Cap Wetness, Crist 1985)"
msgstr ""

#: 
msgid "``'WI'`` (Water Index, Fisher 2016)"
msgstr ""

#: 
msgid "Deprecated in version 0.1.7. Use `satellite_mission` instead.  Valid options are: * ``'c2'`` (for USGS Landsat Collection 2)     If 'c2', then `satellite_mission='ls'`. * ``'s2'`` (for Sentinel-2)     If 's2', then `satellite_mission='s2'`."
msgstr ""

#: 
msgid "Deprecated in version 0.1.7. Use `satellite_mission` instead."
msgstr ""

#: 
msgid "Valid options are: * ``'c2'`` (for USGS Landsat Collection 2)"
msgstr ""

#: 
msgid "If 'c2', then `satellite_mission='ls'`."
msgstr ""

#: 
msgid "``'s2'`` (for Sentinel-2)"
msgstr ""

#: 
msgid "If 's2', then `satellite_mission='s2'`."
msgstr ""

#: 
msgid "An string that tells the function which satellite mission's data is being used to calculate the index. This is necessary because different satellite missions use different names for bands covering a similar spectra.  Valid options are:   * ``'ls'`` (for USGS Landsat)  * ``'s2'`` (for Copernicus Sentinel-2)"
msgstr ""

#: 
msgid "An string that tells the function which satellite mission's data is being used to calculate the index. This is necessary because different satellite missions use different names for bands covering a similar spectra."
msgstr ""

#: 
msgid "Valid options are:"
msgstr ""

#: 
msgid "``'ls'`` (for USGS Landsat)"
msgstr ""

#: 
msgid "``'s2'`` (for Copernicus Sentinel-2)"
msgstr ""

#: 
msgid "By default, the original dataset will be returned with a new index variable named after `index` (e.g. 'NDVI'). To specify a custom name instead, you can supply e.g. `custom_varname='custom_name'`. Defaults to None, which uses `index` to name the variable."
msgstr ""

#: 
msgid "Some coefficient-based indices (e.g. ``'WI'``, ``'BAEI'``, ``'AWEI_ns'``, ``'AWEI_sh'``, ``'TCW'``, ``'TCG'``, ``'TCB'``, ``'EVI'``, ``'LAI'``, ``'SAVI'``, ``'MSAVI'``) produce different results if surface reflectance values are not scaled between 0.0 and 1.0 prior to calculating the index. Setting `normalise=True` first scales values to a 0.0-1.0 range by dividing by 10000.0. Defaults to True."
msgstr ""

#: 
msgid "Provides the option to drop the original input data, thus saving space. If `drop=True`, returns only the index and its values."
msgstr ""

#: 
msgid "If `deep_copy=False`, calculate_indices will modify the original array, adding bands to the input dataset and not removing them. If the calculate_indices function is run more than once, variables may be dropped incorrectly producing unexpected behaviour. This is a bug and may be fixed in future releases. This is only a problem when `drop=True`."
msgstr ""

#: 
msgid "**ds** -- The original xarray Dataset inputted into the function, with a new varible containing the remote sensing index as a DataArray. If drop = True, the new variable/s as DataArrays in the original Dataset."
msgstr ""

#: 
msgid "Last modified: July 2021"
msgstr ""

#: 
msgid "A two-dimensional or multi-dimensional array containing the two polarization bands."
msgstr ""

#: 
msgid "Measurement name for the co-polarization band. Default is 'vv' for Sentinel-1."
msgstr ""

#: 
msgid "Measurement name for the cross-polarization band. Default is 'vh' for Sentinel-1."
msgstr ""

#: 
msgid "A string giving the name of the index to calculate or a list of strings giving the names of the indices to calculate:  * ``'RVI'`` (Radar Vegetation Index for dual-pol, Trudel et al. 2012; Nasirzadehdizaji et al., 2019; Gururaj et al., 2019) * ``'VDDPI'`` (Vertical dual depolarization index, Periasamy 2018) * ``'theta'`` (pseudo scattering-type, Bhogapurapu et al. 2021) * ``'entropy'`` (pseudo scattering entropy, Bhogapurapu et al. 2021) * ``'purity'`` (co-pol purity, Bhogapurapu et al. 2021) * ``'ratio'`` (cross-pol/co-pol ratio)"
msgstr ""

#: 
msgid "``'RVI'`` (Radar Vegetation Index for dual-pol, Trudel et al. 2012; Nasirzadehdizaji et al., 2019; Gururaj et al., 2019)"
msgstr ""

#: 
msgid "``'VDDPI'`` (Vertical dual depolarization index, Periasamy 2018)"
msgstr ""

#: 
msgid "``'theta'`` (pseudo scattering-type, Bhogapurapu et al. 2021)"
msgstr ""

#: 
msgid "``'entropy'`` (pseudo scattering entropy, Bhogapurapu et al. 2021)"
msgstr ""

#: 
msgid "``'purity'`` (co-pol purity, Bhogapurapu et al. 2021)"
msgstr ""

#: 
msgid "``'ratio'`` (cross-pol/co-pol ratio)"
msgstr ""

#: 
msgid "By default, the original dataset will be returned with a new index variable named after `index` (e.g. 'RVI'). To specify a custom name instead, you can supply e.g. `custom_varname='custom_name'`. Defaults to None, which uses `index` to name the variable."
msgstr ""

#: 
msgid "deafrica\\_tools.classification"
msgstr ""

#: 
msgid "Machine learning functions for classification of remote sensing data contained in an Open Data Cube instance."
msgstr ""

#: 
msgid ":py:obj:`SKCV <deafrica_tools.classification.SKCV>`\\ \\(coordinates\\, n\\_splits\\, cluster\\_method\\, ...\\)"
msgstr ""

#: 
msgid "Generate spatial k-fold cross validation indices using coordinate data."
msgstr ""

#: 
msgid ":py:obj:`collect_training_data <deafrica_tools.classification.collect_training_data>`\\ \\(gdf\\, dc\\_query\\[\\, ...\\]\\)"
msgstr ""

#: 
msgid "This function provides methods for gathering training data from the ODC over geometries stored within a geopandas geodataframe."
msgstr ""

#: 
msgid ":py:obj:`fit_xr <deafrica_tools.classification.fit_xr>`\\ \\(model\\, input\\_xr\\)"
msgstr ""

#: 
msgid "Utilise our wrappers to fit a vanilla sklearn model."
msgstr ""

#: 
msgid ":py:obj:`predict_xr <deafrica_tools.classification.predict_xr>`\\ \\(model\\, input\\_xr\\[\\, chunk\\_size\\, ...\\]\\)"
msgstr ""

#: 
msgid "Using dask-ml ParallelPostfit(), runs  the parallel predict and predict_proba methods of sklearn estimators."
msgstr ""

#: 
msgid ":py:obj:`sklearn_flatten <deafrica_tools.classification.sklearn_flatten>`\\ \\(input\\_xr\\)"
msgstr ""

#: 
msgid "Reshape a DataArray or Dataset with spatial (and optionally temporal) structure into an np.array with the spatial and temporal dimensions flattened into one dimension."
msgstr ""

#: 
msgid ":py:obj:`sklearn_unflatten <deafrica_tools.classification.sklearn_unflatten>`\\ \\(output\\_np\\, input\\_xr\\)"
msgstr ""

#: 
msgid "Reshape a numpy array with no 'missing' elements (NaNs) and 'flattened' spatiotemporal structure into a DataArray matching the spatiotemporal structure of the DataArray"
msgstr ""

#: 
msgid ":py:obj:`spatial_clusters <deafrica_tools.classification.spatial_clusters>`\\ \\(coordinates\\[\\, method\\, ...\\]\\)"
msgstr ""

#: 
msgid "Create spatial groups on coorindate data using either KMeans clustering or a Gaussian Mixture model"
msgstr ""

#: 
msgid ":py:obj:`spatial_train_test_split <deafrica_tools.classification.spatial_train_test_split>`\\ \\(X\\, y\\, coordinates\\, ...\\)"
msgstr ""

#: 
msgid "Split arrays into random train and test subsets."
msgstr ""

#: 
msgid ":py:obj:`HiddenPrints <deafrica_tools.classification.HiddenPrints>`\\ \\(\\)"
msgstr ""

#: 
msgid "For concealing unwanted print statements called by other functions"
msgstr ""

#: 
msgid ":py:obj:`KMeans_tree <deafrica_tools.classification.KMeans_tree>`\\ \\(\\*args\\, \\*\\*kwargs\\)"
msgstr ""

#: 
msgid "A hierarchical KMeans unsupervised clustering model."
msgstr ""

#: 
msgid "A hierarchical KMeans unsupervised clustering model. This class is a clustering model, so it inherits scikit-learn's ClusterMixin base class."
msgstr ""

#: 
msgid "number of levels in the tree of clustering models."
msgstr ""

#: 
msgid "Number of clusters in each of the constituent KMeans models in the tree."
msgstr ""

#: 
msgid "Other keyword arguments to be passed directly to the KMeans initialiser."
msgstr ""

#: 
msgid "Fit the tree of KMeans models. All parameters mimic those of KMeans.fit()."
msgstr ""

#: 
msgid "Training instances to cluster. It must be noted that the data will be converted to C ordering, which will cause a memory copy if the given data is not C-contiguous."
msgstr ""

#: 
msgid "not used, present here for API consistency by convention."
msgstr ""

#: 
msgid "The weights for each observation in X. If None, all observations are assigned equal weight (default: None)"
msgstr ""

#: 
msgid "Send X through the KMeans tree and predict the resultant cluster. Compatible with KMeans.predict()."
msgstr ""

#: 
msgid "New data to predict."
msgstr ""

#: 
msgid "**labels** -- Index of the cluster each sample belongs to."
msgstr ""

#: 
msgid "This function wraps the ``SpatialShuffleSplit`` and ``SpatialKFold`` classes. These classes ingest coordinate data in the form of an ``np.array([[eastings, northings]])`` and assign samples to a spatial cluster using either a KMeans, Gaussain Mixture, or Agglomerative Clustering algorithm. This cross-validator is preferred over other sklearn.model_selection methods for spatial data to avoid overestimating cross-validation scores. This can happen because of the inherent spatial autocorrelation that is usually associated with this type of data."
msgstr ""

#: 
msgid "Last modified: Dec 2020"
msgstr ""

#: 
msgid "A numpy array of coordinate values e.g.::      np.array([[3337270.,  262400.],               [3441390., -273060.], ...])"
msgstr ""

#: 
msgid "A numpy array of coordinate values e.g.::"
msgstr ""

#: 
msgid "The number of test-train cross validation splits to generate."
msgstr ""

#: 
msgid "Which algorithm to use to separate data points. Either ``'KMeans'``, ``'GMM'``, or ``'Hierarchical'``"
msgstr ""

#: 
msgid "One of either ``'SpatialShuffleSplit'`` or ``'SpatialKFold'``. See the docs under class:_SpatialShuffleSplit and class:_SpatialKFold for more information on these options."
msgstr ""

#: 
msgid "If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If ``train_size`` is also None, it will be set to 0.15."
msgstr ""

#: 
msgid "if setting kfold_method to ``'SpatialShuffleSplit'``: int     The number of splits generated per iteration to try to balance the     amount of data in each set so that *test_size* and *train_size* are     respected. If 1, then no extra splits are generated (essentially     disabling the balacing). Must be >= 1.  if setting kfold_method to ``'SpatialKFold'``: bool     Whether or not to split clusters into fold with approximately equal     number of data points. If False, each fold will have the same number of     clusters (which can have different number of data points in them)."
msgstr ""

#: 
msgid "if setting kfold_method to ``'SpatialShuffleSplit'``: int"
msgstr ""

#: 
msgid "The number of splits generated per iteration to try to balance the amount of data in each set so that *test_size* and *train_size* are respected. If 1, then no extra splits are generated (essentially disabling the balacing). Must be >= 1."
msgstr ""

#: 
msgid "if setting kfold_method to ``'SpatialKFold'``: bool"
msgstr ""

#: 
msgid "Whether or not to split clusters into fold with approximately equal number of data points. If False, each fold will have the same number of clusters (which can have different number of data points in them)."
msgstr ""

#: 
msgid "The number of groups to create. This is passed as 'n_clusters=n_groups' for the KMeans algo, and 'n_components=n_groups' for the GMM. If using cluster_method='Hierarchical' then this parameter is ignored."
msgstr ""

#: 
msgid "If method is set to 'hierarchical' then maximum distance describes the maximum euclidean distances between all observations in a cluster. 'n_groups' is ignored in this case."
msgstr ""

#: 
msgid "If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size."
msgstr ""

#: 
msgid "If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by ``np.random``."
msgstr ""

#: 
msgid "Additional keyword arguments to pass to sklearn.cluster.Kmeans or sklearn.mixture.GuassianMixture depending on the cluster_method argument."
msgstr ""

#: 
msgid "This function provides methods for gathering training data from the ODC over geometries stored within a geopandas geodataframe. The function will return a 'model_input' array containing stacked training data arrays with all NaNs & Infs removed. In the instance where ncpus > 1, a parallel version of the function will be run (functions are passed to a mp.Pool()). This function can conduct zonal statistics if the supplied shapefile contains polygons. The 'feature_func' parameter defines what features to produce."
msgstr ""

#: 
msgid "geometry data in the form of a geopandas geodataframe"
msgstr ""

#: 
msgid "Datacube query object, should not contain lat and long (x or y) variables as these are supplied by the 'gdf' variable"
msgstr ""

#: 
msgid "The number of cpus/processes over which to parallelize the gathering of training data (only if ncpus is > 1). Use 'mp.cpu_count()' to determine the number of cpus available on a machine. Defaults to 1."
msgstr ""

#: 
msgid "If True, then the training data will contain two extra columns 'x_coord' and 'y_coord' corresponding to the x,y coordinate of each sample. This variable can be useful for handling spatial autocorrelation between samples later in the ML workflow."
msgstr ""

#: 
msgid "A function for generating feature layers that is applied to the data within the bounds of the input geometry. The 'feature_func' must accept a 'dc_query' object, and return a single xarray.Dataset or xarray.DataArray containing 2D coordinates (i.e x and y, without a third dimension). e.g.::      def feature_function(query):         dc = datacube.Datacube(app='feature_layers')         ds = dc.load(**query)         ds = ds.mean('time')         return ds"
msgstr ""

#: 
msgid "A function for generating feature layers that is applied to the data within the bounds of the input geometry. The 'feature_func' must accept a 'dc_query' object, and return a single xarray.Dataset or xarray.DataArray containing 2D coordinates (i.e x and y, without a third dimension). e.g.::"
msgstr ""

#: 
msgid "Name of the column in the gdf that contains the class labels"
msgstr ""

#: 
msgid "An optional string giving the names of zonal statistics to calculate for each polygon. Default is None (all pixel values are returned). Supported values are 'mean', 'median', 'max', 'min'."
msgstr ""

#: 
msgid "Whether or not to remove missing values in the training dataset. If True, training labels with any NaNs or Infs in the feature layers will be dropped from the dataset."
msgstr ""

#: 
msgid "Silent read fails on S3 during mulitprocessing can result in some rows of the returned data containing NaN values. The'fail_threshold' fraction specifies a % of acceptable fails. e.g. Setting 'fail_threshold' to 0.05 means if >5% of the samples in the training dataset fail then those samples will be returned to the multiprocessing queue. Below this fraction the function will accept the failures and return the results."
msgstr ""

#: 
msgid "A float between 0 and 1 that defines if a given training sample has failed. Default is 0.5, which means if 50 % of the measurements in a given sample return null values, and the number of total fails is more than the 'fail_threshold', the sample will be passed to the retry queue."
msgstr ""

#: 
msgid "Maximum number of times to retry collecting samples. This number is invoked if the 'fail_threshold' is not reached."
msgstr ""

#: 
msgid "* *Two objects are returned* * **`columns_names`** (*a list of variable (feature) names*) * **`model_input`** (*a numpy.array containing the data values for each feature extracted*)"
msgstr ""

#: 
msgid "*Two objects are returned*"
msgstr ""

#: 
msgid "**`columns_names`** (*a list of variable (feature) names*)"
msgstr ""

#: 
msgid "**`model_input`** (*a numpy.array containing the data values for each feature extracted*)"
msgstr ""

#: 
msgid "Last modified: September 2019"
msgstr ""

#: 
msgid "Must have a fit() method that takes numpy arrays."
msgstr ""

#: 
msgid "Must have dimensions 'x' and 'y', may have dimension 'time'."
msgstr ""

#: 
msgid "* **model** (*a scikit-learn model which has been fitted to the data in*) * *the pixels of input_xr.*"
msgstr ""

#: 
msgid "**model** (*a scikit-learn model which has been fitted to the data in*)"
msgstr ""

#: 
msgid "*the pixels of input_xr.*"
msgstr ""

#: 
msgid "Using dask-ml ParallelPostfit(), runs  the parallel predict and predict_proba methods of sklearn estimators. Useful for running predictions on a larger-than-RAM datasets."
msgstr ""

#: 
msgid "Last modified: September 2020"
msgstr ""

#: 
msgid "Must have a .predict() method that takes numpy arrays."
msgstr ""

#: 
msgid "Must have dimensions 'x' and 'y'"
msgstr ""

#: 
msgid "The dask chunk size to use on the flattened array. If this is left as None, then the chunks size is inferred from the .chunks method on the `input_xr`"
msgstr ""

#: 
msgid "If True, and proba=True, then 'input_xr' data will be loaded into distributed memory. This will ensure data is not loaded twice for the prediction of probabilities, but this will only work if the data is not larger than distributed RAM."
msgstr ""

#: 
msgid "If True, predict probabilities"
msgstr ""

#: 
msgid "If True, remove Infs and NaNs from input and output arrays"
msgstr ""

#: 
msgid "If True, then the data variables in the 'input_xr' dataset will be appended to the output xarray dataset."
msgstr ""

#: 
msgid "**output_xr** -- An xarray.Dataset containing the prediction output from model. if proba=True then dataset will also contain probabilites, and if return_input=True then dataset will have the input feature layers. Has the same spatiotemporal structure as input_xr."
msgstr ""

#: 
msgid "This flattening procedure enables DataArrays and Datasets to be used to train and predict with sklearn models."
msgstr ""

#: 
msgid "Must have dimensions 'x' and 'y', may have dimension 'time'. Dimensions other than 'x', 'y' and 'time' are unaffected by the flattening."
msgstr ""

#: 
msgid "**input_np** -- A numpy array corresponding to input_xr.data (or input_xr.to_array().data), with dimensions 'x','y' and 'time' flattened into a single dimension, which is the first axis of the returned array. input_np contains no NaNs."
msgstr ""

#: 
msgid "This enables an sklearn model's prediction to be remapped to the correct pixels in the input DataArray or Dataset."
msgstr ""

#: 
msgid "The first dimension's length should correspond to the number of valid (non-NaN) pixels in input_xr."
msgstr ""

#: 
msgid "**output_xr** -- An xarray.DataArray with the same dimensions 'x', 'y' and 'time' as input_xr, and the same valid (non-NaN) pixels. These pixels are set to match the data in output_np."
msgstr ""

#: 
msgid "The number of groups to create. This is passed as ``n_clusters=n_groups`` for the KMeans algo, and ``n_components=n_groups`` for the GMM. If using method=``'Hierarchical'`` then this parameter is ignored."
msgstr ""

#: 
msgid "Which algorithm to use to seperate data points. Either ``'KMeans'``, ``'GMM'``, or ``'Hierarchical'``. If using ``'Hierarchical'`` then must set max_distance."
msgstr ""

#: 
msgid "If method is set to ``'Hierarchical'`` then maximum distance describes the maximum euclidean distances between all observations in a cluster. 'n_groups' is ignored in this case."
msgstr ""

#: 
msgid "Additional keyword arguments to pass to ``sklearn.cluster.Kmeans`` or ``sklearn.mixture.GuassianMixture`` depending on the 'method' argument."
msgstr ""

#: 
msgid "Split arrays into random train and test subsets. Similar to `sklearn.model_selection.train_test_split` but instead works on spatial coordinate data. Coordinate data is grouped according to either a KMeans, Gaussain Mixture, or Agglomerative Clustering algorthim. Grouping by spatial clusters is preferred over plain random splits for spatial data to avoid overestimating validation scores due to spatial autocorrelation."
msgstr ""

#: 
msgid "Training data features"
msgstr ""

#: 
msgid "Training data labels"
msgstr ""

#: 
msgid "Which algorithm to use to seperate data points. Either ``'KMeans'``, ``'GMM'``, or ``'Hierarchical'``"
msgstr ""

#: 
msgid "One of either ``'SpatialShuffleSplit'`` or ``'SpatialKFold'``. See the docs under class:_SpatialShuffleSplit and class: _SpatialKFold for more information on these options."
msgstr ""

#: 
msgid "if setting kfold_method to ''`SpatialShuffleSplit`'': int     The number of splits generated per iteration to try to balance the     amount of data in each set so that *test_size* and *train_size* are     respected. If 1, then no extra splits are generated (essentially     disabling the balacing). Must be >= 1.  if setting kfold_method to ''`SpatialKFold`'': bool     Whether or not to split clusters into fold with approximately equal     number of data points. If False, each fold will have the same number of     clusters (which can have different number of data points in them)."
msgstr ""

#: 
msgid "if setting kfold_method to ''`SpatialShuffleSplit`'': int"
msgstr ""

#: 
msgid "if setting kfold_method to ''`SpatialKFold`'': bool"
msgstr ""

#: 
msgid "This parameter is invoked for the 'SpatialKFold' folding method, use this number to satisfy the train-test size ratio desired, as the 'test_size' parameter for the KFold method often fails to get the ratio right."
msgstr ""

#: 
msgid "RandomState instance or None, optional If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`."
msgstr ""

#: 
msgid "Contains four arrays in the following order:     X_train, X_test, y_train, y_test"
msgstr ""

#: 
msgid "Contains four arrays in the following order:"
msgstr ""

#: 
msgid "X_train, X_test, y_train, y_test"
msgstr ""

#: 
msgid "deafrica\\_tools.dask"
msgstr ""

#: 
msgid "Functions for simplifying the creation of a local dask cluster."
msgstr ""

#: 
msgid ":py:obj:`create_dask_gateway_cluster <deafrica_tools.dask.create_dask_gateway_cluster>`\\ \\(\\*args\\, \\*\\*kwargs\\)"
msgstr ""

#: 
msgid ":py:obj:`create_local_dask_cluster <deafrica_tools.dask.create_local_dask_cluster>`\\ \\(\\[spare\\_mem\\, ...\\]\\)"
msgstr ""

#: 
msgid "Using the datacube utils function `start_local_dask`, generate a local dask cluster."
msgstr ""

#: 
msgid "Using the datacube utils function `start_local_dask`, generate a local dask cluster. Automatically detects if on AWS or NCI."
msgstr ""

#: 
msgid "The amount of memory, in Gb, to leave for the notebook to run. This memory will not be used by the cluster. e.g '3Gb'"
msgstr ""

#: 
msgid "An optional boolean indicating whether to display a summary of the dask client, including a link to monitor progress of the analysis. Set to False to hide this display."
msgstr ""

#: 
msgid "An optional boolean indicating whether to return the dask client object."
msgstr ""

#: 
msgid "deafrica\\_tools.datahandling"
msgstr ""

#: 
msgid "Functions for loading and handling Digital Earth Africa data."
msgstr ""

#: 
msgid ":py:obj:`array_to_geotiff <deafrica_tools.datahandling.array_to_geotiff>`\\ \\(fname\\, data\\, geo\\_transform\\, ...\\)"
msgstr ""

#: 
msgid "Create a single band GeoTIFF file with data from an array."
msgstr ""

#: 
msgid ":py:obj:`choose_product <deafrica_tools.datahandling.choose_product>`\\ \\(ds\\_ls\\, ds\\_s2\\, ds\\_s1\\, ...\\)"
msgstr ""

#: 
msgid "Rule-based guide on choosing the best availabel dataset in a given time step and optionally within a coastal zone mask"
msgstr ""

#: 
msgid ":py:obj:`create_coastal_mask <deafrica_tools.datahandling.create_coastal_mask>`\\ \\(da\\, buffer\\_pixels\\)"
msgstr ""

#: 
msgid "Create a simplified coastal zone mask based on time series of Sentinel-2 MNDWI data"
msgstr ""

#: 
msgid ":py:obj:`dilate <deafrica_tools.datahandling.dilate>`\\ \\(array\\[\\, dilation\\, invert\\]\\)"
msgstr ""

#: 
msgid "Dilate a binary array by a specified nummber of pixels using a disk-like radial dilation."
msgstr ""

#: 
msgid ":py:obj:`download_unzip <deafrica_tools.datahandling.download_unzip>`\\ \\(url\\[\\, output\\_dir\\, remove\\_zip\\]\\)"
msgstr ""

#: 
msgid "Downloads and unzips a .zip file from an external URL to a local directory."
msgstr ""

#: 
msgid ":py:obj:`filter_obs_by_orbit <deafrica_tools.datahandling.filter_obs_by_orbit>`\\ \\(ds\\_s1\\)"
msgstr ""

#: 
msgid "Function to impliment per-pixel filtering of Sentinel-1 observations to keep only observations from the orbit (ascending/descending) with higher frequency over time."
msgstr ""

#: 
msgid ":py:obj:`first <deafrica_tools.datahandling.first>`\\ \\(array\\, dim\\[\\, index\\_name\\]\\)"
msgstr ""

#: 
msgid "Finds the first occuring non-null value along the given dimension."
msgstr ""

#: 
msgid ":py:obj:`get_mean_number_freq_valid_obs <deafrica_tools.datahandling.get_mean_number_freq_valid_obs>`\\ \\(da\\, mask\\, ...\\)"
msgstr ""

#: 
msgid "Calculate mean number of clear observations within each year/timestep in a masked zone"
msgstr ""

#: 
msgid ":py:obj:`last <deafrica_tools.datahandling.last>`\\ \\(array\\, dim\\[\\, index\\_name\\]\\)"
msgstr ""

#: 
msgid "Finds the last occuring non-null value along the given dimension."
msgstr ""

#: 
msgid ":py:obj:`lee_filter <deafrica_tools.datahandling.lee_filter>`\\ \\(da\\, size\\)"
msgstr ""

#: 
msgid "Function to apply lee filter of specified window size."
msgstr ""

#: 
msgid ":py:obj:`load_ard <deafrica_tools.datahandling.load_ard>`\\ \\(dc\\[\\, products\\, min\\_gooddata\\, ...\\]\\)"
msgstr ""

#: 
msgid "Loads analysis ready data."
msgstr ""

#: 
msgid ":py:obj:`load_best_available_ds <deafrica_tools.datahandling.load_best_available_ds>`\\ \\(dc\\, lat\\_range\\, ...\\)"
msgstr ""

#: 
msgid "Function to query, load and compare different products, select and return the best available product"
msgstr ""

#: 
msgid ":py:obj:`load_combined_ls_s2 <deafrica_tools.datahandling.load_combined_ls_s2>`\\ \\(dc\\, query\\)"
msgstr ""

#: 
msgid "function to query and load combined Landsat and Sentinel-2 data"
msgstr ""

#: 
msgid ":py:obj:`load_s1_by_orbits <deafrica_tools.datahandling.load_s1_by_orbits>`\\ \\(dc\\, query\\)"
msgstr ""

#: 
msgid "Function to query and load ascending and descending Sentinel-1 data and add a variable to denote acquisition orbits"
msgstr ""

#: 
msgid ":py:obj:`mostcommon_crs <deafrica_tools.datahandling.mostcommon_crs>`\\ \\(dc\\, product\\, query\\)"
msgstr ""

#: 
msgid "Takes a given query and returns the most common CRS for observations returned for that spatial extent."
msgstr ""

#: 
msgid ":py:obj:`nearest <deafrica_tools.datahandling.nearest>`\\ \\(array\\, dim\\, target\\[\\, index\\_name\\]\\)"
msgstr ""

#: 
msgid "Finds the nearest values to a target label along the given dimension, for all other dimensions."
msgstr ""

#: 
msgid ":py:obj:`pan_sharpen_brovey <deafrica_tools.datahandling.pan_sharpen_brovey>`\\ \\(band\\_1\\, band\\_2\\, band\\_3\\, ...\\)"
msgstr ""

#: 
msgid "Brovey pan sharpening on surface reflectance input using numexpr and return three xarrays. :param band_1: Three input multispectral bands, either as xarray.DataArrays or                numpy.arrays. These bands should have already been resampled to                the spatial resolution of the panchromatic band. :type band_1: xarray.DataArray or numpy.array :param band_2: Three input multispectral bands, either as xarray.DataArrays or                numpy.arrays. These bands should have already been resampled to                the spatial resolution of the panchromatic band. :type band_2: xarray.DataArray or numpy.array :param band_3: Three input multispectral bands, either as xarray.DataArrays or                numpy.arrays. These bands should have already been resampled to                the spatial resolution of the panchromatic band. :type band_3: xarray.DataArray or numpy.array :param pan_band: A panchromatic band corresponding to the above multispectral                  bands that will be used to pan-sharpen the data. :type pan_band: xarray.DataArray or numpy.array."
msgstr ""

#: 
msgid ":py:obj:`parallel_apply <deafrica_tools.datahandling.parallel_apply>`\\ \\(ds\\, dim\\, func\\, \\*args\\)"
msgstr ""

#: 
msgid "Applies a custom function in parallel along the dimension of an xarray.Dataset or xarray.DataArray."
msgstr ""

#: 
msgid ":py:obj:`preprocess_s1 <deafrica_tools.datahandling.preprocess_s1>`\\ \\(ds\\_s1\\[\\, filter\\_size\\, ...\\]\\)"
msgstr ""

#: 
msgid "Function to implement preprocessing on Sentinel-1 data, including speckle filtering (optional), filtering observations by orbit (optional) and conversion to dB"
msgstr ""

#: 
msgid ":py:obj:`wofs_fuser <deafrica_tools.datahandling.wofs_fuser>`\\ \\(dest\\, src\\)"
msgstr ""

#: 
msgid "Fuse two WOfS water measurements represented as `ndarray` objects."
msgstr ""

#: 
msgid "Because this works with simple arrays rather than xarray datasets from DEA, it requires geotransform info (`(upleft_x, x_size, x_rotation, upleft_y, y_rotation, y_size)`) and projection data (in \"WKT\" format) for the output raster. These are typically obtained from an existing raster using the following GDAL calls:"
msgstr ""

#: 
msgid "or alternatively, directly from an xarray dataset:"
msgstr ""

#: 
msgid "Output geotiff file path including extension"
msgstr ""

#: 
msgid "Input array to export as a geotiff"
msgstr ""

#: 
msgid "Geotransform for output raster; e.g. `(upleft_x, x_size, x_rotation, upleft_y, y_rotation, y_size)`"
msgstr ""

#: 
msgid "Projection for output raster (in \"WKT\" format)"
msgstr ""

#: 
msgid "Value to convert to nodata in the output raster; default 0"
msgstr ""

#: 
msgid "Optionally set the dtype of the output raster; can be useful when exporting an array of float or integer values. Defaults to `gdal.GDT_Float32`"
msgstr ""

#: 
msgid "Parameters: ds_ls: xarray.Dataset"
msgstr ""

#: 
msgid "Time series Landsat data"
msgstr ""

#: 
msgid "ds_s2: xarray.Dataset"
msgstr ""

#: 
msgid "Time series Sentinel-2 data"
msgstr ""

#: 
msgid "ds_s1: xarray.Dataset"
msgstr ""

#: 
msgid "Time series Sentinel-1 data"
msgstr ""

#: 
msgid "ds_ls_s2: xarray.Dataset or None"
msgstr ""

#: 
msgid "Time series of combined Landsat and Sentinel-2 data."
msgstr ""

#: 
msgid "time_step: string"
msgstr ""

#: 
msgid "Time step for temporal composition"
msgstr ""

#: 
msgid "**kwargs: A set of optional parameters including:"
msgstr ""

#: 
msgid "thresh_n_valid: integer"
msgstr ""

#: 
msgid "Threhold of minimum average number of valid observations within each time step"
msgstr ""

#: 
msgid "thresh_freq: float"
msgstr ""

#: 
msgid "Threshold of minimum frequency of valid observations within each time step"
msgstr ""

#: 
msgid "buffer_pixels: integer"
msgstr ""

#: 
msgid "Number of pixels to buffer coastal zone"
msgstr ""

#: 
msgid "coastal_masking: Boolean"
msgstr ""

#: 
msgid "whether to calculate a coastal zone mask and restrict the comparison of the products within the mask"
msgstr ""

#: 
msgid "Returns:"
msgstr ""

#: 
msgid "Xarray.Dataset of the best product String of the best product name: 'ls', 's2', 's1' or 'ls_s2'"
msgstr ""

#: 
msgid "Parameters: ds_summaries: xarray.DataArray"
msgstr ""

#: 
msgid "Time series of Sentinel-2 MNDWI data"
msgstr ""

#: 
msgid "Returns: coastal_mask: xarray.DataArray"
msgstr ""

#: 
msgid "A single time buffered coastal zone mask (0: non-coastal and 1: coastal)"
msgstr ""

#: 
msgid "By default, invalid (e.g. False or 0) values are dilated. This is suitable for applications such as cloud masking (e.g. creating a buffer around cloudy or shadowed pixels). This functionality can be reversed by specifying `invert=False`."
msgstr ""

#: 
msgid "The binary array to dilate."
msgstr ""

#: 
msgid "An optional integer specifying the number of pixels to dilate by. Defaults to 10, which will dilate `array` by 10 pixels."
msgstr ""

#: 
msgid "An optional boolean specifying whether to invert the binary array prior to dilation. The default is True, which dilates the invalid values in the array (e.g. False or 0 values)."
msgstr ""

#: 
msgid "An array of the same shape as `array`, with valid data pixels dilated by the number of pixels specified by `dilation`."
msgstr ""

#: 
msgid "A string giving a URL path to the zip file you wish to download and unzip"
msgstr ""

#: 
msgid "An optional string giving the directory to unzip files into. Defaults to None, which will unzip files in the current working directory"
msgstr ""

#: 
msgid "An optional boolean indicating whether to remove the downloaded .zip file after files are unzipped. Defaults to True, which will delete the .zip file."
msgstr ""

#: 
msgid "Each of the Sentinel-1 observations was acquired from either a descending or ascending orbit, which has impacts on the local incidence angle and backscattering value. Here we do the filtering to minimise the effects of inconsistent looking angle and obit direction for each individual pixel."
msgstr ""

#: 
msgid "Parameters: ds_s1: xarray.Dataset"
msgstr ""

#: 
msgid "Time-series observations of Sentinel-1 data, with two required variables: 'is_ascending' denoting orbit path and 'mask' to identify acquisition exent"
msgstr ""

#: 
msgid "Returns: ds_s1_filtered: xarray.Dataset"
msgstr ""

#: 
msgid "Filtered dataset"
msgstr ""

#: 
msgid "The array to search."
msgstr ""

#: 
msgid "The name of the dimension to reduce by finding the first non-null value."
msgstr ""

#: 
msgid "**reduced** -- An array of the first non-null values. The `dim` dimension will be removed, and replaced with a coord of the same name, containing the value of that dimension where the last value was found."
msgstr ""

#: 
msgid "Parameters: da: xarray.DataArray"
msgstr ""

#: 
msgid "Time series of a single satellite band/variable (e.g. MNDWI)"
msgstr ""

#: 
msgid "mask: xarray.DataArray or None"
msgstr ""

#: 
msgid "A mask where the calculation is restricted within"
msgstr ""

#: 
msgid "Pre-defined time step for temporal aggregation, e.g. '1Y'"
msgstr ""

#: 
msgid "Returns: n_valid_obs: xarray.DataArray"
msgstr ""

#: 
msgid "Average number of valid observations within the coastal zone and for each time step"
msgstr ""

#: 
msgid "freq_valid: xarray.DataArray"
msgstr ""

#: 
msgid "Average frequency of valid observations within the coastal zone and for each time step"
msgstr ""

#: 
msgid "The name of the dimension to reduce by finding the last non-null value."
msgstr ""

#: 
msgid "If given, the name of a coordinate to be added containing the index of where on the dimension the nearest value was found."
msgstr ""

#: 
msgid "**reduced** -- An array of the last non-null values. The `dim` dimension will be removed, and replaced with a coord of the same name, containing the value of that dimension where the last value was found."
msgstr ""

#: 
msgid "Function to apply lee filter of specified window size. Adapted from https://stackoverflow.com/questions/39785970/speckle-lee-filter-in-python"
msgstr ""

#: 
msgid "Parameters: da: Xarray.dataArray, input single-time image data size: integer, filtering size in pixels"
msgstr ""

#: 
msgid "Returns: numpy array of filtered image"
msgstr ""

#: 
msgid "Loads and combines Landsat USGS Collections 2, Sentinel-2, and Sentinel-1 for multiple sensors (i.e. ls5t, ls7e, ls8c and ls9 for Landsat; s2a and s2b for Sentinel-2), optionally applies pixel quality masks, and drops time steps that contain greater than a minimum proportion of good quality (e.g. non- cloudy or shadowed) pixels."
msgstr ""

#: 
msgid "The function supports loading the following DE Africa products:"
msgstr ""

#: 
msgid "Landsat:"
msgstr ""

#: 
msgid "ls5_sr ('sr' denotes surface reflectance)"
msgstr ""

#: 
msgid "ls7_sr"
msgstr ""

#: 
msgid "ls8_sr"
msgstr ""

#: 
msgid "ls9_sr"
msgstr ""

#: 
msgid "ls5_st ('st' denotes surface temperature)"
msgstr ""

#: 
msgid "ls7_st"
msgstr ""

#: 
msgid "ls8_st"
msgstr ""

#: 
msgid "ls9_st"
msgstr ""

#: 
msgid "Sentinel-2:"
msgstr ""

#: 
msgid "s2_l2a"
msgstr ""

#: 
msgid "Sentinel-1:"
msgstr ""

#: 
msgid "Last modified: Feb 2021"
msgstr ""

#: 
msgid "The Datacube to connect to, i.e. `dc = datacube.Datacube()`. This allows you to also use development datacubes if required."
msgstr ""

#: 
msgid "A list of product names to load data from. For example:  * Landsat C2: ``['ls5_sr', 'ls7_sr', 'ls8_sr', 'ls9_sr']`` * Sentinel-2: ``['s2_l2a']`` * Sentinel-1: ``['s1_rtc']``"
msgstr ""

#: 
msgid "A list of product names to load data from. For example:"
msgstr ""

#: 
msgid "Landsat C2: ``['ls5_sr', 'ls7_sr', 'ls8_sr', 'ls9_sr']``"
msgstr ""

#: 
msgid "Sentinel-2: ``['s2_l2a']``"
msgstr ""

#: 
msgid "Sentinel-1: ``['s1_rtc']``"
msgstr ""

#: 
msgid "An optional float giving the minimum percentage of good quality pixels required for a satellite observation to be loaded. Defaults to 0.0 which will return all observations regardless of pixel quality (set to e.g. 0.99 to return only observations with more than 99% good quality pixels)."
msgstr ""

#: 
msgid "An optional dictionary that is used to identify poor quality pixels for masking. This mask is used for both masking out low quality pixels (e.g. cloud or shadow), and for dropping observations entirely based on the `min_gooddata` calculation."
msgstr ""

#: 
msgid "An optional list of Sentinel-2 Scene Classification Layer (SCL) names that identify poor quality pixels for masking."
msgstr ""

#: 
msgid "An optional list of Sentinel-1 mask names that identify poor quality pixels for masking."
msgstr ""

#: 
msgid "Iterable tuples of morphological operations - (\"<operation>\", <radius>) to apply on mask, where:  operation: string, can be one of these morphological operations:     * ``'closing'``  = remove small holes in cloud - morphological closing     * ``'opening'``  = shrinks away small areas of the mask     * ``'dilation'`` = adds padding to the mask     * ``'erosion'``  = shrinks bright regions and enlarges dark regions  radius: int e.g. ``mask_filters=[('erosion', 5),(\"opening\", 2),(\"dilation\", 2)]``"
msgstr ""

#: 
msgid "Iterable tuples of morphological operations - (\"<operation>\", <radius>) to apply on mask, where:"
msgstr ""

#: 
msgid "operation: string, can be one of these morphological operations:"
msgstr ""

#: 
msgid "``'closing'``  = remove small holes in cloud - morphological closing"
msgstr ""

#: 
msgid "``'opening'``  = shrinks away small areas of the mask"
msgstr ""

#: 
msgid "``'dilation'`` = adds padding to the mask"
msgstr ""

#: 
msgid "``'erosion'``  = shrinks bright regions and enlarges dark regions"
msgstr ""

#: 
msgid "radius: int e.g. ``mask_filters=[('erosion', 5),(\"opening\", 2),(\"dilation\", 2)]``"
msgstr ""

#: 
msgid "An optional boolean indicating whether to apply the poor data mask to all observations that were not filtered out for having less good quality pixels than ``min_gooddata``. E.g. if ``min_gooddata=0.99``, the filtered observations may still contain up to 1% poor quality pixels. The default of ``False`` simply returns the resulting observations without masking out these pixels; ``True`` masks them and sets them to NaN using the poor data mask. This will convert numeric values to floating point values which can cause memory issues, set to False to prevent this."
msgstr ""

#: 
msgid "An optional boolean indicating whether to include data from after the Landsat 7 SLC failure (i.e. SLC-off). Defaults to ``True``, which keeps all Landsat 7 observations > May 31 2003."
msgstr ""

#: 
msgid "An optional function that can be passed in to restrict the datasets that are loaded by the function. A filter function should take a `datacube.model.Dataset` object as an input (i.e. as returned from `dc.find_datasets`), and return a boolean. For example, a filter function could be used to return True on only datasets acquired in January: ``dataset.time.begin.month == 1``"
msgstr ""

#: 
msgid "An optional parameter that controls the data type/dtype that layers are coerced to after loading. Valid values: ''`native`'', ``'auto'``, ``'float{16|32|64}'``. When ``'auto'`` is used, the data will be converted to ``'float32'`` if masking is used, otherwise data will be returned in the native data type of the data. Be aware that if data is loaded in its native dtype, nodata and masked pixels will be returned with the data's native nodata value (typically ``-999``), not ``NaN``. NOTE: If loading Landsat, the data is automatically rescaled so 'native' dtype will return a value error."
msgstr ""

#: 
msgid "If True, print progress statements during loading"
msgstr ""

#: 
msgid "A set of keyword arguments to ``dc.load`` that define the spatiotemporal query used to extract data. This typically includes ``measurements``, ``x`, ``y``, ``time``, ``resolution``, ``resampling``, ``group_by`` and ``crs``. Keyword arguments can either be listed directly in the ``load_ard`` call like any other parameter (e.g. ``measurements=['red']``), or by passing in a query kwarg dictionary (e.g. ``**query``). For a list of possible options, see the ``dc.load`` documentation: https://datacube-core.readthedocs.io/en/latest/dev/api/generate/datacube.Datacube.load.html"
msgstr ""

#: 
msgid "**combined_ds** -- An xarray dataset containing only satellite observations that contains greater than `min_gooddata` proportion of good quality pixels."
msgstr ""

#: 
msgid "Parameters: dc: connected datacube lat_range: range of latitudes in tuple or list lon_range: range of longitude in tuple or list time_range: range of time to query the data in tuple or list time_step: string, pre-defined time step for temporal aggregation, e.g. '1Y' **kwargs: A set of optional parameters on data query or comparison between products which may include: combine_ls_s2: A boolean value indicating whether to include merged/stacked Landsat and Sentinel-2 products as an option. Default to False. set_resolution: integer of spatial resolution in metres to query all products coastal_masking: A boolean value indicating whether to calculate a mask"
msgstr ""

#: 
msgid "and restrict the comparison of the products within the masked zone."
msgstr ""

#: 
msgid "set_product: Set this to only query and load a pre-selected product, 'ls','s2','ls_s2' or 's1'"
msgstr ""

#: 
msgid "i.e. no other products will be queried or compared."
msgstr ""

#: 
msgid "thresh_n_valid: Threhold of minimum average number of valid observations within each time step, integer thresh_freq: Threshold of minimum frequency of valid observations within each time step, float between 0~1 buffer_pixels: Number of pixels to buffer coastal zone, integer"
msgstr ""

#: 
msgid "Returns: ds_selected: selected product as xarray.Dataset product_name: name of selected product in string format, i.e. 'ls','s2','ls_s2','s1'"
msgstr ""

#: 
msgid "Parameters: dc: connected datacube query: a query dictionary to define spatial extent, time range, measurements and spatial resolution for both datasets"
msgstr ""

#: 
msgid "Returns: ds_combined: Combined data as xarray.Dataset"
msgstr ""

#: 
msgid "Parameters: dc: connected datacube query: a query dictionary to define spatial extent, measurements, time range and spatial resolution"
msgstr ""

#: 
msgid "Returns: Queried dataset with variable 'is_ascending' added to denote orbit path"
msgstr ""

#: 
msgid "Takes a given query and returns the most common CRS for observations returned for that spatial extent. This can be useful when your study area lies on the boundary of two UTM zones, forcing you to decide which CRS to use for your `output_crs` in `dc.load`."
msgstr ""

#: 
msgid "A product name to load CRSs from"
msgstr ""

#: 
msgid "A datacube query including x, y and time range to assess for the most common CRS"
msgstr ""

#: 
msgid "A EPSG string giving the most common CRS from all datasets returned by the query above"
msgstr ""

#: 
msgid "E.g. For a DataArray with dimensions ('time', 'x', 'y')"
msgstr ""

#: 
msgid "nearest_array = nearest(array, 'time', '2017-03-12')"
msgstr ""

#: 
msgid "will return an array with the dimensions ('x', 'y'), with non-null values found closest for each (x, y) pixel to that location along the time dimension."
msgstr ""

#: 
msgid "The returned array will include the 'time' coordinate for each x,y pixel that the nearest value was found."
msgstr ""

#: 
msgid "The name of the dimension to look for the target label."
msgstr ""

#: 
msgid "The value to look up along the given dimension."
msgstr ""

#: 
msgid "**nearest_array** -- An array of the nearest non-null values to the target label. The `dim` dimension will be removed, and replaced with a coord of the same name, containing the value of that dimension closest to the given target label."
msgstr ""

#: 
msgid "Brovey pan sharpening on surface reflectance input using numexpr and return three xarrays. :param band_1: Three input multispectral bands, either as xarray.DataArrays or"
msgstr ""

#: 
msgid "numpy.arrays. These bands should have already been resampled to the spatial resolution of the panchromatic band."
msgstr ""

#: 
msgid "Three input multispectral bands, either as xarray.DataArrays or numpy.arrays. These bands should have already been resampled to the spatial resolution of the panchromatic band."
msgstr ""

#: 
msgid "A panchromatic band corresponding to the above multispectral bands that will be used to pan-sharpen the data."
msgstr ""

#: 
msgid "**band_1_sharpen, band_2_sharpen, band_3_sharpen** -- Three numpy arrays equivelent to `band_1`, `band_2` and `band_3` pan-sharpened to the spatial resolution of `pan_band`."
msgstr ""

#: 
msgid "The function can be any function that can be applied to an individual xarray.Dataset or xarray.DataArray (e.g. data for a single timestep). The function should also return data in xarray.Dataset or xarray.DataArray format."
msgstr ""

#: 
msgid "This function is useful as a simple method for parallising code that cannot easily be parallised using Dask."
msgstr ""

#: 
msgid "xarray data with a dimension `dim` to apply the custom function along."
msgstr ""

#: 
msgid "The dimension along which the custom function will be applied."
msgstr ""

#: 
msgid "The function that will be applied in parallel to each array along dimension `dim`. The first argument passed to this function should be the array along `dim`."
msgstr ""

#: 
msgid "Any number of arguments that will be passed to `func`."
msgstr ""

#: 
msgid "A concatenated dataset containing an output for each array along the input `dim` dimension."
msgstr ""

#: 
msgid "Time-series of Sentinel-1 data, with variable 'vh' required"
msgstr ""

#: 
msgid "filter_size: integer or None"
msgstr ""

#: 
msgid "Speckle filtering size"
msgstr ""

#: 
msgid "s1_orbit_filtering: Boolean"
msgstr ""

#: 
msgid "Whether to filter Sentinel-1 observations by orbit"
msgstr ""

#: 
msgid "xarray.Dataset Preprocessed Sentinel-1 data"
msgstr ""

#: 
msgid "Note: this is a copy of the function located here: https://github.com/GeoscienceAustralia/digitalearthau/blob/develop/digitalearthau/utils.py"
msgstr ""

#: 
msgid "deafrica\\_tools.load\\_era5"
msgstr ""

#: 
msgid "Functions to retrieve ERA5 gridded climate data."
msgstr ""

#: 
msgid "Updated Apr 2020 to directly access Zarr format data in PDS"
msgstr ""

#: 
msgid "Previous code for downloading and loading netcdf adpated from scripts by Andrew Cherry and Brian Killough."
msgstr ""

#: 
msgid ":py:obj:`load_era5 <deafrica_tools.load_era5.load_era5>`\\ \\(var\\, lat\\, lon\\, time\\[\\, ...\\]\\)"
msgstr ""

#: 
msgid "Download and return an ERA5 variable for a defined time window."
msgstr ""

#: 
msgid "Name of the ERA5 climate variable to download, e.g \"air_temperature_at_2_metres\""
msgstr ""

#: 
msgid "Latitude range for query."
msgstr ""

#: 
msgid "Longitude range for query."
msgstr ""

#: 
msgid "Used to define starting and end date dates of the time window."
msgstr ""

#: 
msgid "lets you specify a function to apply to each day's worth of data. The default is np.mean, which computes daily average. To get a sum, use np.sum."
msgstr ""

#: 
msgid "Temporal resampling frequency to be used for xarray's resample function. The default is '1D', which is daily. Since this is applied on monthly ERA5 data, maximum resampling period is '1M'."
msgstr ""

#: 
msgid "deafrica\\_tools.load\\_soil\\_moisture"
msgstr ""

#: 
msgid ":py:obj:`load_soil_moisture <deafrica_tools.load_soil_moisture.load_soil_moisture>`\\ \\(lat\\, lon\\, time\\[\\, ...\\]\\)"
msgstr ""

#: 
msgid "deafrica\\_tools.plotting"
msgstr ""

#: 
msgid "Functions for plotting Digital Earth Africa data."
msgstr ""

#: 
msgid ":py:obj:`display_map <deafrica_tools.plotting.display_map>`\\ \\(x\\, y\\[\\, crs\\, margin\\, zoom\\_bias\\]\\)"
msgstr ""

#: 
msgid "Given a set of x and y coordinates, this function generates an interactive map with a bounded rectangle overlayed on Google Maps imagery."
msgstr ""

#: 
msgid ":py:obj:`map_shapefile <deafrica_tools.plotting.map_shapefile>`\\ \\(gdf\\, attribute\\[\\, continuous\\, ...\\]\\)"
msgstr ""

#: 
msgid "Plots a geopandas GeoDataFrame over an interactive ipyleaflet basemap, with features coloured based on attribute column values."
msgstr ""

#: 
msgid ":py:obj:`plot_lulc <deafrica_tools.plotting.plot_lulc>`\\ \\(lulc\\[\\, product\\, legend\\]\\)"
msgstr ""

#: 
msgid "Plot a LULC image."
msgstr ""

#: 
msgid ":py:obj:`plot_wofs <deafrica_tools.plotting.plot_wofs>`\\ \\(wofs\\[\\, legend\\]\\)"
msgstr ""

#: 
msgid "Plot a water observation bit flag image."
msgstr ""

#: 
msgid ":py:obj:`rgb <deafrica_tools.plotting.rgb>`\\ \\(ds\\[\\, bands\\, index\\, index\\_dim\\, robust\\, ...\\]\\)"
msgstr ""

#: 
msgid "Takes an xarray dataset and plots RGB images using three imagery bands (e.g ['red', 'green', 'blue'])."
msgstr ""

#: 
msgid ":py:obj:`xr_animation <deafrica_tools.plotting.xr_animation>`\\ \\(ds\\[\\, bands\\, output\\_path\\, ...\\]\\)"
msgstr ""

#: 
msgid "Takes an `xarray` timeseries and animates the data as either a three-band (e.g."
msgstr ""

#: 
msgid "Modified from function written by Otto Wagner available here: https://github.com/ceos-seo/data_cube_utilities/tree/master/data_cube_utilities"
msgstr ""

#: 
msgid "A tuple of x coordinates in (min, max) format."
msgstr ""

#: 
msgid "A tuple of y coordinates in (min, max) format."
msgstr ""

#: 
msgid "A string giving the EPSG CRS code of the supplied coordinates. The default is 'EPSG:4326'."
msgstr ""

#: 
msgid "A numeric value giving the number of degrees lat-long to pad the edges of the rectangular overlay polygon. A larger value results more space between the edge of the plot and the sides of the polygon. Defaults to -0.5."
msgstr ""

#: 
msgid "A numeric value allowing you to increase or decrease the zoom level by one step. Defaults to 0; set to greater than 0 to zoom in, and less than 0 to zoom out."
msgstr ""

#: 
msgid "* **folium.Map** (*A map centered on the supplied coordinate bounds. A*) * *rectangle is drawn on this map detailing the perimeter of the x, y* * *bounds.  A zoom level is calculated such that the resulting* * *viewport is the closest it can possibly get to the centered* * *bounding rectangle without clipping it.*"
msgstr ""

#: 
msgid "**folium.Map** (*A map centered on the supplied coordinate bounds. A*)"
msgstr ""

#: 
msgid "*rectangle is drawn on this map detailing the perimeter of the x, y*"
msgstr ""

#: 
msgid "*bounds.  A zoom level is calculated such that the resulting*"
msgstr ""

#: 
msgid "*viewport is the closest it can possibly get to the centered*"
msgstr ""

#: 
msgid "*bounding rectangle without clipping it.*"
msgstr ""

#: 
msgid "Plots a geopandas GeoDataFrame over an interactive ipyleaflet basemap, with features coloured based on attribute column values. Optionally, can be set up to print selected data from features in the GeoDataFrame."
msgstr ""

#: 
msgid "Last modified: February 2020"
msgstr ""

#: 
msgid "A GeoDataFrame containing the spatial features to be plotted over the basemap."
msgstr ""

#: 
msgid "An required string giving the name of any column in the GeoDataFrame you wish to have coloured on the choropleth."
msgstr ""

#: 
msgid "Whether to plot data as a categorical or continuous variable. Defaults to remapping the attribute which is suitable for categorical data. For continuous data set `continuous` to True."
msgstr ""

#: 
msgid "A string giving the name of a `matplotlib.cm` colormap that will be used to style the features in the GeoDataFrame. Features will be coloured based on the selected attribute. Defaults to the 'viridis' colormap."
msgstr ""

#: 
msgid "An optional `ipyleaflet.basemaps` object used as the basemap for the interactive plot. Defaults to `basemaps.Esri.WorldImagery`."
msgstr ""

#: 
msgid "An optional integer giving a default zoom level for the interactive ipyleaflet plot. Defaults to None, which infers the zoom level from the extent of the data."
msgstr ""

#: 
msgid "If True (the default), the function will print  values from the GeoDataFrame's `attribute` column above the interactive map when a user hovers over the features in the map. Alternatively, a custom shapefile field can be specified by supplying a string giving the name of the field to print. Set to False to prevent any attributes from being printed."
msgstr ""

#: 
msgid "Optional keyword arguments to pass to the `style` paramemter of the `ipyleaflet.Choropleth` function. This can be used to control the appearance of the shapefile, for example 'stroke' and 'weight' (controlling line width), 'fillOpacity' (polygon transparency) and 'dashArray' (whether to plot lines/outlines with dashes). For more information: https://ipyleaflet.readthedocs.io/en/latest/api_reference/choropleth.html"
msgstr ""

#: 
msgid "A DataArray containing LULC bit flags."
msgstr ""

#: 
msgid "'ESA', 'IO', 'CGLS', or 'CCI', 'ESRI'"
msgstr ""

#: 
msgid "Whether to plot a legend. Default True."
msgstr ""

#: 
msgid "Keyword arguments passed on to DataArray.plot."
msgstr ""

#: 
msgid "A DataArray containing water observation bit flags."
msgstr ""

#: 
msgid "Takes an xarray dataset and plots RGB images using three imagery bands (e.g ['red', 'green', 'blue']). The `index` parameter allows easily selecting individual or multiple images for RGB plotting. Images can be saved to file by specifying an output path using `savefig_path`. This function was designed to work as an easier-to-use wrapper around xarray's `.plot.imshow()` functionality."
msgstr ""

#: 
msgid "Last modified: April 2021"
msgstr ""

#: 
msgid "A two-dimensional or multi-dimensional array to plot as an RGB image. If the array has more than two dimensions (e.g. multiple observations along a 'time' dimension), either use `index` to select one (`index=0`) or multiple observations (`index=[0, 1]`), or create a custom faceted plot using e.g. `col=\"time\"`."
msgstr ""

#: 
msgid "A list of three strings giving the band names to plot. Defaults to '['red', 'green', 'blue']'. If the dataset does not contain bands named `'red', 'green', 'blue'`, then `bands` must be specified."
msgstr ""

#: 
msgid "`index` can be used to select one (`index=0`) or multiple observations (`index=[0, 1]`) from the input dataset for plotting. If multiple images are requested these will be plotted as a faceted plot."
msgstr ""

#: 
msgid "The dimension along which observations should be plotted if multiple observations are requested using `index`. Defaults to `time`."
msgstr ""

#: 
msgid "Produces an enhanced image where the colormap range is computed with 2nd and 98th percentiles instead of the extreme values. Defaults to True."
msgstr ""

#: 
msgid "An tuple of two floats (between 0.00 and 1.00) that can be used to clip the colormap range to manually specified percentiles to get more control over the brightness and contrast of the image. The default is None; '(0.02, 0.98)' is equivelent to `robust=True`. If this parameter is used, `robust` will have no effect."
msgstr ""

#: 
msgid "The number of columns allowed in faceted plots. Defaults to 4."
msgstr ""

#: 
msgid "The height (in inches) of each plot. Defaults to 6."
msgstr ""

#: 
msgid "Aspect ratio of each facet in the plot, so that aspect * size gives width of each facet in inches. Defaults to None, which will calculate the aspect based on the x and y dimensions of the input data."
msgstr ""

#: 
msgid "Path to export image file for the RGB plot. Defaults to None, which does not export an image file."
msgstr ""

#: 
msgid "A dict of keyword arguments to pass to `matplotlib.pyplot.savefig` when exporting an image file. For all available options, see: https://matplotlib.org/api/_as_gen/matplotlib.pyplot.savefig.html"
msgstr ""

#: 
msgid "Additional keyword arguments to pass to `xarray.plot.imshow()`. For example, the function can be used to plot into an existing matplotlib axes object by passing an `ax` keyword argument. For more options, see: http://xarray.pydata.org/en/stable/generated/xarray.plot.imshow.html"
msgstr ""

#: 
msgid "* *An RGB plot of one or multiple observations, and optionally an image* * *file written to file.*"
msgstr ""

#: 
msgid "*An RGB plot of one or multiple observations, and optionally an image*"
msgstr ""

#: 
msgid "*file written to file.*"
msgstr ""

#: 
msgid "Takes an `xarray` timeseries and animates the data as either a three-band (e.g. true or false colour) or single-band animation, allowing changes in the landscape to be compared across time."
msgstr ""

#: 
msgid "Animations can be customised to include text and date annotations or use specific combinations of input bands. Vector data can be overlaid and animated on top of imagery, and custom image processing functions can be applied to each frame. Supports .mp4 (ideal for Twitter/social media) and .gif (ideal for all purposes, but can have large file sizes) format files."
msgstr ""

#: 
msgid "Last modified: October 2020"
msgstr ""

#: 
msgid "An xarray dataset with multiple time steps (i.e. multiple observations along the `time` dimension)."
msgstr ""

#: 
msgid "An list of either one or three band names to be plotted, all of which must exist in `ds`."
msgstr ""

#: 
msgid "A string giving the output location and filename of the resulting animation. File extensions of '.mp4' and '.gif' are accepted. Defaults to 'animation.mp4'."
msgstr ""

#: 
msgid "An integer defining the output width in pixels for the resulting animation. The height of the animation is set automatically based on the dimensions/ratio of the input xarray dataset. Defaults to 500 pixels wide."
msgstr ""

#: 
msgid "An integer defining the milliseconds between each animation frame used to control the speed of the output animation. Higher values result in a slower animation. Defaults to 100 milliseconds between each frame."
msgstr ""

#: 
msgid "An optional tuple of two floats that can be used to clip one or three-band arrays by percentiles to produce a more vibrant, visually attractive image that is not affected by outliers/ extreme values. The default is `(0.02, 0.98)` which is equivalent to xarray's `robust=True`. This parameter is ignored completely if `vmin` and `vmax` are provided as kwargs to `imshow_kwargs`."
msgstr ""

#: 
msgid "An optional list containing functions that will be applied to each animation frame (timestep) prior to animating. This can include image processing functions such as increasing contrast, unsharp masking, saturation etc. The function should take AND return a `numpy.ndarray` with shape [y, x, bands]. If your function has parameters, you can pass in custom values using a lambda function: `image_proc_funcs=[lambda x: custom_func(x, param1=10)]`."
msgstr ""

#: 
msgid "Vector data (e.g. ESRI shapefiles or GeoJSON) can be optionally plotted over the top of imagery by supplying a `geopandas.GeoDataFrame` object. To customise colours used to plot the vector features, create a new column in the GeoDataFrame called 'colors' specifying the colour used to plot each feature: e.g. `gdf['colors'] = 'red'`. To plot vector features at specific moments in time during the animation, create new 'start_time' and/or 'end_time' columns in the GeoDataFrame that define the time range used to plot each feature. Dates can be provided in any string format that can be converted using the `pandas.to_datetime()`. e.g. `gdf['end_time'] = ['2001', '2005-01', '2009-01-01']`"
msgstr ""

#: 
msgid "An optional string or bool that defines how (or if) to plot date annotations for each animation frame. Defaults to '%d %b %Y'; can be customised to any format understood by strftime (https://strftime.org/). Set to False to remove date annotations completely."
msgstr ""

#: 
msgid "An optional string or list of strings with a length equal to the number of timesteps in `ds`. This can be used to display a static text annotation (using a string), or a dynamic title (using a list) that displays different text for each timestep. By default, no text annotation will be plotted."
msgstr ""

#: 
msgid "An optional boolean indicating whether to include a colourbar for single-band animations. Defaults to True."
msgstr ""

#: 
msgid "An optional dictionary of keyword arguments to customise the appearance of a `geopandas.GeoDataFrame` supplied to `show_gdf`. Keyword arguments are passed to `GeoSeries.plot` (see http://geopandas.org/reference.html#geopandas.GeoSeries.plot). For example: `gdf_kwargs = {'linewidth': 2}`."
msgstr ""

#: 
msgid "An optional dict of keyword arguments for controlling the appearance of  text annotations. Keyword arguments are passed to `plt.annotate` from `matplotlib`. (see https://matplotlib.org/api/_as_gen/matplotlib.pyplot.annotate.html for options). For example, `annotation_kwargs={'fontsize':20, 'color':'red', 'family':'serif'}`."
msgstr ""

#: 
msgid "An optional dict of keyword arguments for controlling the appearance of arrays passed to `matplotlib`'s `plt.imshow` (see https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html for options). For example, a green colour scheme and custom stretch could be specified using: `onebandplot_kwargs={'cmap':'Greens`, 'vmin':0.2, 'vmax':0.9}`. (some parameters like 'cmap' will only have an effect for single-band animations, not three-band RGB animations)."
msgstr ""

#: 
msgid "An optional dict of keyword arguments used to control the appearance of the colourbar. Keyword arguments are passed to `matplotlib.pyplot.tick_params` (see https://matplotlib.org/api/_as_gen/matplotlib.pyplot.tick_params.html for options). This can be used to customise the colourbar ticks, e.g. changing tick label colour depending on the background of the animation: `colorbar_kwargs={'colors': 'black'}`."
msgstr ""

#: 
msgid "An optional integer specifying how many animation frames to render (e.g. `limit=50` will render the first 50 frames). This can be useful for quickly testing animations without rendering the entire time-series."
msgstr ""

#: 
msgid "deafrica\\_tools.spatial"
msgstr ""

#: 
msgid "Spatial analyses functions for Digital Earth Africa data."
msgstr ""

#: 
msgid ":py:obj:`add_geobox <deafrica_tools.spatial.add_geobox>`\\ \\(ds\\[\\, crs\\]\\)"
msgstr ""

#: 
msgid "Ensure that an xarray DataArray has a GeoBox and .odc.* accessor using `odc.geo`."
msgstr ""

#: 
msgid ":py:obj:`contours_to_arrays <deafrica_tools.spatial.contours_to_arrays>`\\ \\(gdf\\, col\\)"
msgstr ""

#: 
msgid "This function converts a polyline shapefile into an array with three columns giving the X, Y and Z coordinates of each vertex."
msgstr ""

#: 
msgid ":py:obj:`interpolate_2d <deafrica_tools.spatial.interpolate_2d>`\\ \\(ds\\, x\\_coords\\, y\\_coords\\, z\\_coords\\)"
msgstr ""

#: 
msgid "This function takes points with X, Y and Z coordinates, and interpolates Z-values across the extent of an existing xarray dataset."
msgstr ""

#: 
msgid ":py:obj:`largest_region <deafrica_tools.spatial.largest_region>`\\ \\(bool\\_array\\, \\*\\*kwargs\\)"
msgstr ""

#: 
msgid "Takes a boolean array and identifies the largest contiguous region of connected True values."
msgstr ""

#: 
msgid ":py:obj:`reverse_geocode <deafrica_tools.spatial.reverse_geocode>`\\ \\(coords\\[\\, site\\_classes\\, ...\\]\\)"
msgstr ""

#: 
msgid "Takes a latitude and longitude coordinate, and performs a reverse geocode to return a plain-text description of the location in the form:"
msgstr ""

#: 
msgid ":py:obj:`subpixel_contours <deafrica_tools.spatial.subpixel_contours>`\\ \\(da\\[\\, z\\_values\\, crs\\, ...\\]\\)"
msgstr ""

#: 
msgid "Uses `skimage.measure.find_contours` to extract multiple z-value contour lines from a two-dimensional array (e.g."
msgstr ""

#: 
msgid ":py:obj:`sun_angles <deafrica_tools.spatial.sun_angles>`\\ \\(dc\\, query\\)"
msgstr ""

#: 
msgid "For a given spatiotemporal query, calculate mean sun azimuth and elevation for each satellite observation, and return these as a new `xarray.Dataset` with 'sun_elevation' and 'sun_azimuth' variables."
msgstr ""

#: 
msgid ":py:obj:`transform_geojson_wgs_to_epsg <deafrica_tools.spatial.transform_geojson_wgs_to_epsg>`\\ \\(geojson\\, EPSG\\)"
msgstr ""

#: 
msgid "Takes a geojson dictionary and converts it from WGS84 (EPSG:4326) to desired EPSG"
msgstr ""

#: 
msgid ":py:obj:`xr_rasterize <deafrica_tools.spatial.xr_rasterize>`\\ \\(gdf\\, da\\[\\, attribute\\_col\\, crs\\, ...\\]\\)"
msgstr ""

#: 
msgid "Rasterizes a vector ``geopandas.GeoDataFrame`` into a raster ``xarray.DataArray``."
msgstr ""

#: 
msgid ":py:obj:`xr_vectorize <deafrica_tools.spatial.xr_vectorize>`\\ \\(da\\[\\, attribute\\_col\\, crs\\, ...\\]\\)"
msgstr ""

#: 
msgid "Vectorises a raster ``xarray.DataArray`` into a vector ``geopandas.GeoDataFrame``."
msgstr ""

#: 
msgid ":py:obj:`zonal_stats_parallel <deafrica_tools.spatial.zonal_stats_parallel>`\\ \\(shp\\, raster\\, ...\\)"
msgstr ""

#: 
msgid "Summarizing raster datasets based on vector geometries in parallel."
msgstr ""

#: 
msgid "If `ds` is missing a Coordinate Reference System (CRS), this can be supplied using the `crs` param."
msgstr ""

#: 
msgid "Input xarray object that needs to be checked for spatial information."
msgstr ""

#: 
msgid "Coordinate Reference System (CRS) information for the input `ds` array. If `ds` already has a CRS, then `crs` is not required. Default is None."
msgstr ""

#: 
msgid "The input xarray object with added `.odc.x` attributes to access spatial information."
msgstr ""

#: 
msgid "This function converts a polyline shapefile into an array with three columns giving the X, Y and Z coordinates of each vertex. This data can then be used as an input to interpolation procedures (e.g. using a function like `interpolate_2d`."
msgstr ""

#: 
msgid "A GeoPandas GeoDataFrame of lines to convert into point coordinates."
msgstr ""

#: 
msgid "A string giving the name of the GeoDataFrame field to use as Z-values."
msgstr ""

#: 
msgid "* *A numpy array with three columns giving the X, Y and Z coordinates* * *of each vertex in the input GeoDataFrame.*"
msgstr ""

#: 
msgid "*A numpy array with three columns giving the X, Y and Z coordinates*"
msgstr ""

#: 
msgid "*of each vertex in the input GeoDataFrame.*"
msgstr ""

#: 
msgid "This function takes points with X, Y and Z coordinates, and interpolates Z-values across the extent of an existing xarray dataset. This can be useful for producing smooth surfaces from point data that can be compared directly against satellite data derived from an OpenDataCube query."
msgstr ""

#: 
msgid "Supported interpolation methods include 'linear', 'nearest' and 'cubic (using `scipy.interpolate.griddata`), and 'rbf' (using `scipy.interpolate.Rbf`)."
msgstr ""

#: 
msgid "A two-dimensional or multi-dimensional array from which x and y dimensions will be copied and used for the area in which to interpolate point data."
msgstr ""

#: 
msgid "Arrays containing X and Y coordinates for all points (e.g. longitudes and latitudes)."
msgstr ""

#: 
msgid "An array containing Z coordinates for all points (e.g. elevations). These are the values you wish to interpolate between."
msgstr ""

#: 
msgid "The method used to interpolate between point values. This string is either passed to `scipy.interpolate.griddata` (for 'linear', 'nearest' and 'cubic' methods), or used to specify Radial Basis Function interpolation using `scipy.interpolate.Rbf` ('rbf'). Defaults to 'linear'."
msgstr ""

#: 
msgid "An optional integer that can be used to subsample the spatial interpolation extent to obtain faster interpolation times, then up-sample this array back to the original dimensions of the data as a final step. For example, setting `factor=10` will interpolate data into a grid that has one tenth of the resolution of `ds`. This approach will be significantly faster than interpolating at full resolution, but will potentially produce less accurate or reliable results."
msgstr ""

#: 
msgid "Print debugging messages. Default False."
msgstr ""

#: 
msgid "Optional keyword arguments to pass to either `scipy.interpolate.griddata` (if `method` is 'linear', 'nearest' or 'cubic'), or `scipy.interpolate.Rbf` (is `method` is 'rbf')."
msgstr ""

#: 
msgid "**interp_2d_array** -- An xarray DataArray containing with x and y coordinates copied from `ds_array`, and Z-values interpolated from the points data."
msgstr ""

#: 
msgid "Takes a boolean array and identifies the largest contiguous region of connected True values. This is returned as a new array with cells in the largest region marked as True, and all other cells marked as False."
msgstr ""

#: 
msgid "A boolean array (numpy or xarray.DataArray) with True values for the areas that will be inspected to find the largest group of connected cells"
msgstr ""

#: 
msgid "Optional keyword arguments to pass to `measure.label`"
msgstr ""

#: 
msgid "**largest_region** -- A boolean array with cells in the largest region marked as True, and all other cells marked as False."
msgstr ""

#: 
msgid "Site, State"
msgstr ""

#: 
msgid "E.g.: `reverse_geocode(coords=(-35.282163, 149.128835))`"
msgstr ""

#: 
msgid "'Canberra, Australian Capital Territory'"
msgstr ""

#: 
msgid "A tuple of (latitude, longitude) coordinates used to perform the reverse geocode."
msgstr ""

#: 
msgid "A list of strings used to define the site part of the plain text location description. Because the contents of the geocoded address can vary greatly depending on location, these strings are tested against the address one by one until a match is made.  Defaults to:      ``['city', 'town', 'village', 'suburb', 'hamlet', 'county', 'municipality']``"
msgstr ""

#: 
msgid "A list of strings used to define the site part of the plain text location description. Because the contents of the geocoded address can vary greatly depending on location, these strings are tested against the address one by one until a match is made."
msgstr ""

#: 
msgid "Defaults to:"
msgstr ""

#: 
msgid "``['city', 'town', 'village', 'suburb', 'hamlet', 'county', 'municipality']``"
msgstr ""

#: 
msgid "A list of strings used to define the state part of the plain text location description. These strings are tested against the address one by one until a match is made. Defaults to: `['state', 'territory']`."
msgstr ""

#: 
msgid "* *If a valid geocoded address is found, a plain text location* * *description will be returned* -- 'Site, State' * *If no valid address is found, formatted coordinates will be returned* * *instead* -- 'XX.XX S, XX.XX E'"
msgstr ""

#: 
msgid "*If a valid geocoded address is found, a plain text location*"
msgstr ""

#: 
msgid "*description will be returned* -- 'Site, State'"
msgstr ""

#: 
msgid "*If no valid address is found, formatted coordinates will be returned*"
msgstr ""

#: 
msgid "*instead* -- 'XX.XX S, XX.XX E'"
msgstr ""

#: 
msgid "Uses `skimage.measure.find_contours` to extract multiple z-value contour lines from a two-dimensional array (e.g. multiple elevations from a single DEM), or one z-value for each array along a specified dimension of a multi-dimensional array (e.g. to map waterlines across time by extracting a 0 NDWI contour from each individual timestep in an xarray timeseries)."
msgstr ""

#: 
msgid "Contours are returned as a geopandas.GeoDataFrame with one row per z-value or one row per array along a specified dimension. The `attribute_df` parameter can be used to pass custom attributes to the output contour features."
msgstr ""

#: 
msgid "Last modified: May 2023"
msgstr ""

#: 
msgid "A two-dimensional or multi-dimensional array from which contours are extracted. If a two-dimensional array is provided, the analysis will run in 'single array, multiple z-values' mode which allows you to specify multiple `z_values` to be extracted. If a multi-dimensional array is provided, the analysis will run in 'single z-value, multiple arrays' mode allowing you to extract contours for each array along the dimension specified by the `dim` parameter."
msgstr ""

#: 
msgid "An individual z-value or list of multiple z-values to extract from the array. If operating in 'single z-value, multiple arrays' mode specify only a single z-value."
msgstr ""

#: 
msgid "If ``da``'s coordinate reference system (CRS) cannot be determined, provide a CRS using this parameter. (e.g. 'EPSG:3577')."
msgstr ""

#: 
msgid "The path and filename for the output shapefile."
msgstr ""

#: 
msgid "A pandas.Dataframe containing attributes to pass to the output contour features. The dataframe must contain either the same number of rows as supplied `z_values` (in 'multiple z-value, single array' mode), or the same number of rows as the number of arrays along the `dim` dimension ('single z-value, multiple arrays mode')."
msgstr ""

#: 
msgid "The minimum number of vertices required for a contour to be extracted. The default (and minimum) value is 2, which is the smallest number required to produce a contour line (i.e. a start and end point). Higher values remove smaller contours, potentially removing noise from the output dataset."
msgstr ""

#: 
msgid "The name of the dimension along which to extract contours when operating in 'single z-value, multiple arrays' mode. The default is 'time', which extracts contours for each array along the time dimension."
msgstr ""

#: 
msgid "The format used to convert `numpy.datetime64` values to strings if applied to data with a \"time\" dimension. Defaults to \"%Y-%m-%d\"."
msgstr ""

#: 
msgid "If 'raise', then any failed contours will raise an exception. If 'ignore' (the default), a list of failed contours will be printed. If no contours are returned, an exception will always be raised."
msgstr ""

#: 
msgid "Print debugging messages. Default is True."
msgstr ""

#: 
msgid "**output_gdf** -- A geopandas geodataframe object with one feature per z-value ('single array, multiple z-values' mode), or one row per array along the dimension specified by the `dim` parameter ('single z-value, multiple arrays' mode). If `attribute_df` was provided, these values will be included in the shapefile's attribute table."
msgstr ""

#: 
msgid "Parameters:"
msgstr ""

#: 
msgid "dc"
msgstr ""

#: 
msgid "datacube.Datacube object"
msgstr ""

#: 
msgid "Datacube instance used to load data."
msgstr ""

#: 
msgid "query"
msgstr ""

#: 
msgid "dict"
msgstr ""

#: 
msgid "A dictionary containing query parameters used to identify satellite observations and load metadata."
msgstr ""

#: 
msgid "sun_angles_ds"
msgstr ""

#: 
msgid "xarray.Dataset"
msgstr ""

#: 
msgid "An `xarray.set` containing a 'sun_elevation' and 'sun_azimuth' variables."
msgstr ""

#: 
msgid "a geojson dictionary containing a 'geometry' key, in WGS84 coordinates"
msgstr ""

#: 
msgid "numeric code for the EPSG coordinate referecnce system to transform into"
msgstr ""

#: 
msgid "**transformed_geojson** -- a geojson dictionary containing a 'coordinates' key, in the desired CRS"
msgstr ""

#: 
msgid "A ``geopandas.GeoDataFrame`` object containing the vector data you want to rasterise."
msgstr ""

#: 
msgid "The shape, coordinates, dimensions, and transform of this object are used to define the array that ``gdf`` is rasterized into. It effectively provides a spatial template."
msgstr ""

#: 
msgid "Name of the attribute column in ``gdf`` containing values for each vector feature that will be rasterized. If None, the output will be a boolean array of 1's and 0's."
msgstr ""

#: 
msgid "An optional name used for the output ``xarray.DataArray`."
msgstr ""

#: 
msgid "Provide an optional string file path to export the rasterized data as a GeoTIFF file."
msgstr ""

#: 
msgid "Print debugging messages. Default True."
msgstr ""

#: 
msgid "A set of keyword arguments to ``rasterio.features.rasterize``. Can include: 'all_touched', 'merge_alg', 'dtype'."
msgstr ""

#: 
msgid "**da_rasterized** -- The rasterized vector data."
msgstr ""

#: 
msgid "The input ``xarray.DataArray`` data to vectorise."
msgstr ""

#: 
msgid "Name of the attribute column in the resulting ``geopandas.GeoDataFrame``. Values from ``da`` converted to polygons will be assigned to this column. If None, the column name will default to 'attribute'."
msgstr ""

#: 
msgid "Data type  of  must be one of int16, int32, uint8, uint16, or float32"
msgstr ""

#: 
msgid "Provide an optional string file path to export the vectorised data to file. Supports any vector file formats supported by ``geopandas.GeoDataFrame.to_file()``."
msgstr ""

#: 
msgid "A set of keyword arguments to ``rasterio.features.shapes``. Can include `mask` and `connectivity`."
msgstr ""

#: 
msgid "**gdf**"
msgstr ""

#: 
msgid "Summarizing raster datasets based on vector geometries in parallel. Each cpu recieves an equal chunk of the dataset. Utilizes the perrygeo/rasterstats package."
msgstr ""

#: 
msgid "Path to shapefile that contains polygons over which zonal statistics are calculated"
msgstr ""

#: 
msgid "Path to the raster from which the statistics are calculated. This can be a virtual raster (.vrt)."
msgstr ""

#: 
msgid "list of statistics to calculate. e.g.     ['min', 'max', 'median', 'majority', 'sum']"
msgstr ""

#: 
msgid "list of statistics to calculate. e.g."
msgstr ""

#: 
msgid "['min', 'max', 'median', 'majority', 'sum']"
msgstr ""

#: 
msgid "Path to export shapefile containing zonal statistics."
msgstr ""

#: 
msgid "number of cores to parallelize the operations over."
msgstr ""

#: 
msgid "Any other keyword arguments to rasterstats.zonal_stats() See https://github.com/perrygeo/python-rasterstats for all options"
msgstr ""

#: 
msgid "Primary functions"
msgstr ""

#: 
msgid "deafrica\\_tools.temporal"
msgstr ""

#: 
msgid "Functions for calculating per-pixel temporal summary statistics on a timeseries stored in a xarray.DataArray."
msgstr ""

#: 
msgid "The key functions are:"
msgstr ""

#: 
msgid ":py:obj:`xr_phenology <deafrica_tools.temporal.xr_phenology>`"
msgstr ""

#: 
msgid "Obtain land surface phenology metrics from an xarray.DataArray containing a timeseries of a vegetation index like NDVI."
msgstr ""

#: 
msgid ":py:obj:`temporal_statistics <deafrica_tools.temporal.temporal_statistics>`"
msgstr ""

#: 
msgid "Calculate various generic summary statistics on any timeseries."
msgstr ""

#: 
msgid ":py:obj:`allNaN_arg <deafrica_tools.temporal.allNaN_arg>`\\ \\(da\\, dim\\, stat\\)"
msgstr ""

#: 
msgid "Calculate da.argmax() or da.argmin() while handling all-NaN slices."
msgstr ""

#: 
msgid ":py:obj:`temporal_statistics <deafrica_tools.temporal.temporal_statistics>`\\ \\(da\\, stats\\)"
msgstr ""

#: 
msgid ":py:obj:`xr_phenology <deafrica_tools.temporal.xr_phenology>`\\ \\(da\\[\\, stats\\, method\\_sos\\, ...\\]\\)"
msgstr ""

#: 
msgid "Calculate da.argmax() or da.argmin() while handling all-NaN slices. Fills all-NaN locations with an float and then masks the offending cells."
msgstr ""

#: 
msgid "Dimension over which to calculate argmax, argmin e.g. 'time'"
msgstr ""

#: 
msgid "The statistic to calculte, either 'min' for argmin() or 'max' for .argmax()"
msgstr ""

#: 
msgid "This function uses the hdstats temporal library: https://github.com/daleroberts/hdstats/blob/master/hdstats/ts.pyx"
msgstr ""

#: 
msgid "last modified June 2023"
msgstr ""

#: 
msgid "DataArray should contain a 3D time series."
msgstr ""

#: 
msgid "list of temporal statistics to calculate. Options include:  * 'discordance' = * 'f_std' = std of discrete fourier transform coefficients, returns     three layers: f_std_n1, f_std_n2, f_std_n3 * 'f_mean' = mean of discrete fourier transform coefficients, returns     three layers: f_mean_n1, f_mean_n2, f_mean_n3 * 'f_median' = median of discrete fourier transform coefficients, returns     three layers: f_median_n1, f_median_n2, f_median_n3 * 'mean_change' = mean of discrete difference along time dimension * 'median_change' = median of discrete difference along time dimension * 'abs_change' = mean of absolute discrete difference along time dimension * 'complexity' = * 'central_diff' = * 'num_peaks' : The number of peaks in the timeseries, defined with a local     window of size 10.  NOTE: This statistic is very slow"
msgstr ""

#: 
msgid "list of temporal statistics to calculate. Options include:"
msgstr ""

#: 
msgid "'discordance' ="
msgstr ""

#: 
msgid "'f_std' = std of discrete fourier transform coefficients, returns"
msgstr ""

#: 
msgid "three layers: f_std_n1, f_std_n2, f_std_n3"
msgstr ""

#: 
msgid "'f_mean' = mean of discrete fourier transform coefficients, returns"
msgstr ""

#: 
msgid "three layers: f_mean_n1, f_mean_n2, f_mean_n3"
msgstr ""

#: 
msgid "'f_median' = median of discrete fourier transform coefficients, returns"
msgstr ""

#: 
msgid "three layers: f_median_n1, f_median_n2, f_median_n3"
msgstr ""

#: 
msgid "'mean_change' = mean of discrete difference along time dimension"
msgstr ""

#: 
msgid "'median_change' = median of discrete difference along time dimension"
msgstr ""

#: 
msgid "'abs_change' = mean of absolute discrete difference along time dimension"
msgstr ""

#: 
msgid "'complexity' ="
msgstr ""

#: 
msgid "'central_diff' ="
msgstr ""

#: 
msgid "'num_peaks'"
msgstr ""

#: 
msgid "The number of peaks in the timeseries, defined with a local"
msgstr ""

#: 
msgid "window of size 10.  NOTE: This statistic is very slow"
msgstr ""

#: 
msgid "Dataset containing variables for the selected temporal statistics"
msgstr ""

#: 
msgid "DataArray should contain a 2D or 3D time series of a vegetation index like NDVI, EVI"
msgstr ""

#: 
msgid "list of phenological statistics to return. Regardless of the metrics returned, all statistics are calculated due to inter-dependencies between metrics. Options include:  * `SOS` = Date of start of season * `POS` = Date of peak of season * `EOS` = Date of end of season * `vSOS` = Value at start of season * `vPOS` = Value at peak of season * `vEOS` = Value at end of season * `Trough` = Minimum value of season * `LOS` = Length of season (Days) * `AOS` = Amplitude of season (in value units) * `ROG` = Rate of greening * `ROS` = Rate of senescence"
msgstr ""

#: 
msgid "list of phenological statistics to return. Regardless of the metrics returned, all statistics are calculated due to inter-dependencies between metrics. Options include:"
msgstr ""

#: 
msgid "`SOS` = Date of start of season"
msgstr ""

#: 
msgid "`POS` = Date of peak of season"
msgstr ""

#: 
msgid "`EOS` = Date of end of season"
msgstr ""

#: 
msgid "`vSOS` = Value at start of season"
msgstr ""

#: 
msgid "`vPOS` = Value at peak of season"
msgstr ""

#: 
msgid "`vEOS` = Value at end of season"
msgstr ""

#: 
msgid "`Trough` = Minimum value of season"
msgstr ""

#: 
msgid "`LOS` = Length of season (Days)"
msgstr ""

#: 
msgid "`AOS` = Amplitude of season (in value units)"
msgstr ""

#: 
msgid "`ROG` = Rate of greening"
msgstr ""

#: 
msgid "`ROS` = Rate of senescence"
msgstr ""

#: 
msgid "If 'first' then vSOS is estimated as the first positive slope on the greening side of the curve. If 'median', then vSOS is estimated as the median value of the postive slopes on the greening side of the curve."
msgstr ""

#: 
msgid "If 'last' then vEOS is estimated as the last negative slope on the senescing side of the curve. If 'median', then vEOS is estimated as the 'median' value of the negative slopes on the senescing side of the curve."
msgstr ""

#: 
msgid "Dataset containing variables for the selected phenology statistics"
msgstr ""

#: 
msgid "deafrica\\_tools.wetlands"
msgstr ""

#: 
msgid "Functions for working with the Wetlands Insight Tool (WIT)"
msgstr ""

#: 
msgid ":py:obj:`WIT_drill <deafrica_tools.wetlands.WIT_drill>`\\ \\(gdf\\, time\\[\\, min\\_gooddata\\, ...\\]\\)"
msgstr ""

#: 
msgid "The Wetlands Insight Tool run onver an extent covered by a polygon."
msgstr ""

#: 
msgid ":py:obj:`animated_timeseries_WIT <deafrica_tools.wetlands.animated_timeseries_WIT>`\\ \\(ds\\, df\\, output\\_path\\)"
msgstr ""

#: 
msgid "The Wetlands Insight Tool run onver an extent covered by a polygon. This function loads FC, WOfS, and Landsat data, and calculates tasseled cap wetness, in order to determine the dominant land cover class within a polygon at each satellite observation."
msgstr ""

#: 
msgid "The output is a pandas dataframe containing a timeseries of the relative fractions of each class at each time-step. This forms the input to produce a stacked line-plot."
msgstr ""

#: 
msgid "Last modified: Oct 2021"
msgstr ""

#: 
msgid "The dataframe must only contain a single row, containing the polygon you wish to interrograte."
msgstr ""

#: 
msgid "a tuple containing the time range over which to run the WIT. e.g. ('2015-01' , '2019-12')"
msgstr ""

#: 
msgid "A number between 0 and 1 (e.g 0.8) indicating the minimum percentage of good quality pixels required for a satellite observation to be loaded and therefore included in the WIT plot. This number should, at a minimum, be set to 0.80 to limit biases in the result if not resampling the time-series. If resampling the data using the parameter `resample_frequency`, then setting this number to 0 (or a low float number) is acceptable."
msgstr ""

#: 
msgid "The tasseled cap wetness threshold, beyond which a pixel will be considered 'wet'. Defaults to -0.035."
msgstr ""

#: 
msgid "Option for resampling time-series of input datasets. This option is useful for either smoothing the WIT plot, or because the area of analysis is larger than a scene width and therefore requires composites. Options include any str accepted by `xarray.resample(time=)`. The resampling method used is .max()"
msgstr ""

#: 
msgid "To save the returned pandas dataframe as a .csv file, pass a a location string (e.g. 'output/results.csv')"
msgstr ""

#: 
msgid "To lazily load the datasets using dask, pass a dictionary containing the dimensions over which to chunk e.g. {'time':-1, 'x':250, 'y':250}."
msgstr ""

#: 
msgid "If true, print statements are putput detailing the progress of the tool."
msgstr ""

#: 
msgid "For use with Dask progress bar"
msgstr ""

#: 
msgid "**df** -- A pandas dataframe containing the timeseries of relative fractions of each land cover class (WOfs, FC, TCW)"
msgstr ""

#: 
msgid "deafrica\\_tools.temporal.temporal\\_statistics"
msgstr ""

#: 
msgid "deafrica\\_tools.temporal.xr\\_phenology"
msgstr ""

#: 
msgid "DE Africa Tools Package"
msgstr ""

#: 
msgid "``deafrica_tools`` is a Python package contains several modules with functions to load, analyse and output data from Digital Earth Africa. It is automatically installed in the Digital Earth Africa Sandbox environment. More information on installing this package can be found on the `Tools <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/tree/master/Tools/>`_ section of the GitHub repository."
msgstr ""

#: 
msgid "Core modules"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.bandindices <deafrica_tools.bandindices>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.classification <deafrica_tools.classification>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.dask <deafrica_tools.dask>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.datahandling <deafrica_tools.datahandling>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.load_era5 <deafrica_tools.load_era5>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.load_soil_moisture <deafrica_tools.load_soil_moisture>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.plotting <deafrica_tools.plotting>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.spatial <deafrica_tools.spatial>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.temporal <deafrica_tools.temporal>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.wetlands <deafrica_tools.wetlands>`\\"
msgstr ""

#: 
msgid "Apps and widgets"
msgstr ""

#: 
msgid "``deafrica_tools`` app subpackages can be accessed through ``deafrica_tools.app``."
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.animations <deafrica_tools.app.animations>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.changefilmstrips <deafrica_tools.app.changefilmstrips>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.crophealth <deafrica_tools.app.crophealth>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.geomedian <deafrica_tools.app.geomedian>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.imageexport <deafrica_tools.app.imageexport>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.wetlandsinsighttool <deafrica_tools.app.wetlandsinsighttool>`\\"
msgstr ""

#: 
msgid ":py:obj:`deafrica_tools.app.widgetconstructors <deafrica_tools.app.widgetconstructors>`\\"
msgstr ""

#: 
msgid "The code in this module is licensed under the Apache License, Version 2.0 (https://www.apache.org/licenses/LICENSE-2.0)."
msgstr ""

#: 
msgid "Digital Earth Africa data is licensed under the Creative Commons by Attribution 4.0 license (https://creativecommons.org/licenses/by/4.0/)."
msgstr ""

#: 
msgid "Contact"
msgstr ""

#: 
msgid "If you need assistance, please post a question on the Open Data Cube Slack channel (http://slack.opendatacube.org/) or on the GIS Stack Exchange (https://gis.stackexchange.com/questions/ask?tags=open-data-cube) using the `open-data-cube` tag (you can view previously asked questions here: https://gis.stackexchange.com/questions/tagged/open-data-cube)."
msgstr ""

#: 
msgid "If you would like to report an issue with this script, you can file one on Github: https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/issues/new"
msgstr ""

#: 
msgid "Vegetation phenology in the Ruko Conservancy"
msgstr ""

#: 
msgid "Phenology is the study of plant and animal life cycles in the context of the seasons. It can be useful in understanding the life cycle trends of crops and how the growing seasons are affected by changes in climate. For more information, see the `USGS page on deriving phenology <https://www.usgs.gov/land-resources/eros/phenology/science/deriving-phenological-metrics-ndvi?qt-science_center_objects=0#qt-science_center_objects>`__."
msgstr ""

#: 
msgid "This notebook will produce annual, smoothed, **one-dimensional (zonal mean across a region)** time-series of a remote sensing vegetation indice, such as NDVI or EVI. In addition, basic phenology statistics are calculated, exported to disk as csv files, and annotated on a plot."
msgstr ""

#: 
msgid "A number of steps are required to produce the desired outputs:"
msgstr ""

#: 
msgid "Load satellite data for a region specified by an vector file (shapefile or geojson)"
msgstr ""

#: 
msgid "Buffer the cloud masking layer to better mask clouds in the data (Sentinel-2 cloud mask is quite poor)"
msgstr ""

#: 
msgid "Further prepare the data for analysis by removing bad values (infs), masking surafce water, and removing outliers in the vegetation index."
msgstr ""

#: 
msgid "Calculate a zonal mean across the study region (collapse the x and y dimension by taking the mean across all pixels for each time-step)."
msgstr ""

#: 
msgid "Interpolate and smooth the time-series to ensure a consistent dataset with all gaps and noise removed."
msgstr ""

#: 
msgid "Calculate phenology statistics, report the results, save the results to disk, and generate an annotated plot."
msgstr ""

#: 
msgid "``veg_proxy``: Band index to use as a proxy for vegetation health e.g. ``'NDVI'`` or ``'EVI'``"
msgstr ""

#: 
msgid "``product``: The satellite product to load. Either Sentinel-2: ``'s2_l2a'``, or Landsat-8: ``'ls8_cl2'``"
msgstr ""

#: 
msgid "``shapefile``: The path to the vector file delineating the analysis region. Can be a shapefile or a geojson"
msgstr ""

#: 
msgid "``time_range``: The year range to analyse (e.g. ``('2017-01-01', '2019-12-30')``)."
msgstr ""

#: 
msgid "``min_gooddata``: the fraction of good data (not cloudy) a scene must have before it is returned as a dataset"
msgstr ""

#: 
msgid "``resolution``: The pixel resolution, in metres, of the returned dataset"
msgstr ""

#: 
msgid "``dask_chunks``: The size, in number of pixel, for the dask chunks on each dimension."
msgstr ""

#: 
msgid "View the region of interest"
msgstr ""

#: 
msgid "The next cell will display the selected area on an web map."
msgstr ""

#: 
msgid "The cell directly below will create a query object using the first geometry in the shapefile, along with the parameters we defined in the Analysis Parameters section above."
msgstr ""

#: 
msgid "Load available data from S2. The cloud masking data for Sentinel-2 is less than perfect, and missed cloud in the data greatly impacts vegetation calculations. load_ard supports morphological operations on the cloud-masking bands to improve the masking of poor quality data."
msgstr ""

#: 
msgid "Mask the satellite data with shape"
msgstr ""

#: 
msgid "Calculate vegetation and water indices"
msgstr ""

#: 
msgid "Prepare data for analysis"
msgstr ""

#: 
msgid "Remove any NaN or infinite values, mask water, remove any outliers in the vegetation index. We then reduce the data to a 1D timeseries by calculating the mean across the x and y dimensions."
msgstr ""

#: 
msgid "We will also 'compute' the data on the dask cluster to speed up calculations later on. This step will take 5-10mins to run since we are now computing everything that came before."
msgstr ""

#: 
msgid "Smooth and interpolate time series"
msgstr ""

#: 
msgid "Due to many factors (e.g. cloud obscuring the region, missed cloud cover in the SCL layer) the data will be gappy and noisy. Here, we will smooth and interpolate the data to ensure we working with a consistent time-series."
msgstr ""

#: 
msgid "Plot the entire time-series"
msgstr ""

#: 
msgid "Compute basic phenology statistics"
msgstr ""

#: 
msgid "Below we specify the statistics to calculate, and the method we'll use for determining the statistics."
msgstr ""

#: 
msgid "The statistics acronyms are as follows: \\* ``SOS`` - Day of year of Start of Season \\* ``vSOS`` - value at Start of Season \\* ``POS`` - Day of year of Peak of Season \\* ``vPOS`` - value at Peak of Season \\* ``EOS`` - Day of year of End of Season \\* ``vEOS`` - value at End of Season \\* ``Trough`` - minimum value across the dataset timeframe \\* ``LOS`` - Length of Season, measured in days \\* ``AOS`` - Amplitude of Season, the difference between ``vPOS`` and ``Trough`` \\* ``ROG`` - Rate of Greening, rate of change from start to peak of season \\* ``ROS`` - Rate of Senescing, rae of change from peak to end of season"
msgstr ""

#: 
msgid "Options are 'first' & 'median' for ``method_sos``, and 'last' & 'median' for ``method_eos``."
msgstr ""

#: 
msgid "Print the phenology statistics for each year, and write the results to disk as a .csv"
msgstr ""

#: 
msgid "Annotate phenology on a plot"
msgstr ""

#: 
msgid "This image will be saved to disk in the ``results/`` folder"
msgstr ""

#: 
msgid "The basic phenology statistics are summarised in a more readable format below. We can compare the statistics at a high level. Further analysis should be conducted using the .csv exports in the ``/results`` folder."
msgstr ""

#: 
msgid "Per-pixel vegetation phenology in the Ruko Conservancy"
msgstr ""

#: 
msgid "This notebook will produce **two-dimensional (phenology per-pixel) plot for a given year.**"
msgstr ""

#: 
msgid "Further prepare the data for analysis byt removing bad values (infs), masking surafce water, and removing outliers in the vegetation index."
msgstr ""

#: 
msgid "Plot the results and export the plot to disk as a .png"
msgstr ""

#: 
msgid "``year``: Entire the year to anlayse, e.g. ``'2017'``"
msgstr ""

#: 
msgid "Load available data from S2:"
msgstr ""

#: 
msgid "Remove any NaN or infinite values, mask water, remove any outliers in the vegetation index. We then reduce the data to a 1D timeseries by calculting the mean across the x and y dimensions."
msgstr ""

#: 
msgid "This cell will take a couple of minutes to calculate since the ``water_mask`` needs to be brought into memory (we use this later to mask the phenology results)."
msgstr ""

#: 
msgid "Resample the data to fortnightly time-steps using the median"
msgstr ""

#: 
msgid "These calculations will take several minutes to complete as we will run ``.compute()``, triggering all the tasks we scheduled above and bringing the arrays into memory."
msgstr ""

#: 
msgid "Compute 2D phenology statistics"
msgstr ""

#: 
msgid "Below we specify the statistics to calculate, and the method we'll use for determining the statistics. Options are 'first' & 'median' for ``method_sos``, and 'last' & 'median' for ``method_eos``."
msgstr ""

#: 
msgid "Re-mask data"
msgstr ""

#: 
msgid "The phenology code has methods for handling pixels with only NaNs (such as those regions outside of the polygon mask), so the results can have phenology results for regions over water and outside the mask. We will therefore have to mask the data again."
msgstr ""

#: 
msgid "Plot the 2D phenology statistics"
msgstr ""

#: 
msgid "Mapping changing water extents through time"
msgstr ""

#: 
msgid "The United Nations have prescribed 17 \"Sustainable Development Goals\" (SDGs). This notebook attempts to monitor SDG Indicator 6.6.1 - change in the extent of water-related ecosystems. Indicator 6.6.1 has 4 sub-indicators:"
msgstr ""

#: 
msgid "The spatial extent of water-related ecosystems"
msgstr ""

#: 
msgid "The quantity of water contained within these ecosystems"
msgstr ""

#: 
msgid "The quality of water within these ecosystems"
msgstr ""

#: 
msgid "The health or state of these ecosystems"
msgstr ""

#: 
msgid "Water extent is estimated using Sentinel-2 satellite images and the Modified Normalised Difference Water Index (MNDWI)."
msgstr ""

#: 
msgid "The notebook loads Setinel-2 data for a given shapefile (the Ruko Conservancy in the default example) and calculates the changing water extent of Lake Baringo and surrounds."
msgstr ""

#: 
msgid "Load and view the analyis region as defined by the input vector file"
msgstr ""

#: 
msgid "Load cloud-masked Sentinel-2 satellite images"
msgstr ""

#: 
msgid "Buffer the S2 cloud mask to improve its quality"
msgstr ""

#: 
msgid "Mask the satellite data with the vector file"
msgstr ""

#: 
msgid "Calculate the MNDWI"
msgstr ""

#: 
msgid "Resample the time-series to seasonal medians to reduce noise and gaps in the data"
msgstr ""

#: 
msgid "Calculate and plot the water extent (in square kilometres) per time-step,"
msgstr ""

#: 
msgid "Determine the time when the maximum and minimum water extents occurred"
msgstr ""

#: 
msgid "Generate an animation of the seasonal MNDWI plots"
msgstr ""

#: 
msgid "Compare the ewater extent between two nominated time-periods and plot a map of the changes."
msgstr ""

#: 
msgid "``vector_file``: A shape file that defines the area to analyze."
msgstr ""

#: 
msgid "``products``: The products to load from the datacube, e.g. \\`'s2_l2a`\\`"
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2017', '2019')``."
msgstr ""

#: 
msgid "``min_gooddata``: This value sets the minimum amount of good data a scene must have before it will be loaded into memory e.g. ``0.75`` means only images with 75% good data will be retained."
msgstr ""

#: 
msgid "``measurements``: The spectral bands to load from the satellite product. MNDWI requires the green and swir1 bands, and cloud buffer requires the SCL band"
msgstr ""

#: 
msgid "``resolution``: The pixel resolution of the satellite data."
msgstr ""

#: 
msgid "``dask_chunks``: Chunk sizes to use for dask, the default values below are optimized for the Ruko Conservancy at 20m resolution."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The default area is the Ruko Conservancy."
msgstr ""

#: 
msgid "View the Area of Interest on an interative map"
msgstr ""

#: 
msgid "The next cell will first open the vector file and then display the selected area on an interactive map. Zoom in and out to get a better understanding of the area of interest."
msgstr ""

#: 
msgid "Now load the satellite data"
msgstr ""

#: 
msgid "Mask the satellite data with vector file"
msgstr ""

#: 
msgid "Then we'll remove the SCL band as we no longer require it, and convert the data back to float32 to conserve memory (running ``.where()`` operations converts data to float64 by default)."
msgstr ""

#: 
msgid "Due to many factors (e.g. cloud obscuring the region, missed cloud cover in the SCL layer) the data will be gappy and noisy. Here, we will resample the data to ensure we working with a consistent time-series."
msgstr ""

#: 
msgid "Calculate the water extent per time-step"
msgstr ""

#: 
msgid "Calculates the area of pixels classified as water (if MNDWI is > 0, the water)"
msgstr ""

#: 
msgid "Plot monthly time series of water area"
msgstr ""

#: 
msgid "The next cell extracts the date of the minimum and maximum extent of water from the dataset using the ``min`` and ``max`` functions, we then add the dates to an ``xarray.DataArray``."
msgstr ""

#: 
msgid "Compare water extent between two periods"
msgstr ""

#: 
msgid "``baseline_time`` : The baseline year for the analysis"
msgstr ""

#: 
msgid "``analysis_time`` : The year to compare to the baseline year"
msgstr ""

#: 
msgid "The water extent for the two time-periods are extracted from the datatset ``ds_valid_water_area``"
msgstr ""

#: 
msgid "Calculate the change between the two nominated periods"
msgstr ""

#: 
msgid "The cell below calculate the percentage of area of water extent for water_loss, water_gain, permanent water and land"
msgstr ""

#: 
msgid "Plot the changes"
msgstr ""

#: 
msgid "Lake Baringo Grazing"
msgstr ""

#: 
msgid "Mapping water extent and rainfall using WOfS and CHIRPS"
msgstr ""

#: 
msgid "**Products used:** `wofs_ls <https://explorer.digitalearth.africa/products/wofs_ls>`__, `rainfall_chirps_monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__"
msgstr ""

#: 
msgid "The notebook loads WOfS feature layers to map the spatial extent of water bodies. It also loads and plots monthly total rainfall from CHIRPS. The last section will compare the water extent between two periods to allow visulazing where change is occuring."
msgstr ""

#: 
msgid "Dask can be used to better manage memory use and conduct the analysis in parallel."
msgstr ""

#: 
msgid "Connect to Data Cube"
msgstr ""

#: 
msgid "Upload a vector file for your water extent and your catchment to the ``data`` folder."
msgstr ""

#: 
msgid "Set the time range you want to use."
msgstr ""

#: 
msgid "Set the resampling strategy. Possible options include:"
msgstr ""

#: 
msgid "``\"1Y\"`` - Annual resampling, use this option for longer term monitoring"
msgstr ""

#: 
msgid "``\"QS-DEC\"`` - Quarterly resampling from December"
msgstr ""

#: 
msgid "``\"3M\"`` - Three-monthly resampling"
msgstr ""

#: 
msgid "``\"1M\"`` - Monthly resampling"
msgstr ""

#: 
msgid "For more details on resampling timeframes, see the `xarray <https://xarray.pydata.org/en/v2022.03.0/generated/xarray.Dataset.resample.html>`__ and `pandas <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`__ documentation."
msgstr ""

#: 
msgid "Get waterbody and catchment geometries"
msgstr ""

#: 
msgid "The next cell will extract the waterbody and catchment geometries from the supplied vector files, which will be used to load Water Observations from Space and the CHIRPS rainfall products."
msgstr ""

#: 
msgid "Load Water Observation from Space for Waterbody"
msgstr ""

#: 
msgid "The first step is to load the Water Observations from Space product using the extent geometry."
msgstr ""

#: 
msgid "Identify water in each resampling period"
msgstr ""

#: 
msgid "The second step is to resample the observations to get a consistent measure of the waterbody, and then calculate the classified as water for each period."
msgstr ""

#: 
msgid "Plot the change in water area over time"
msgstr ""

#: 
msgid "Load CHIRPS monthly rainfall"
msgstr ""

#: 
msgid "Resample to estimate rainfall for each time period"
msgstr ""

#: 
msgid "This is done by taking calculating the average rainfall over the extent of the catchment, then summing these averages over the resampling period to estimate the total rainfall for the catchment."
msgstr ""

#: 
msgid "Compare waterbody area to catchment rainfall"
msgstr ""

#: 
msgid "This step plots the summed average rainfall for the catchment area over each period as a histogram, overlaid with the waterbody area calculated previously."
msgstr ""

#: 
msgid "Save the figure"
msgstr ""

#: 
msgid "Compare water extent for two different periods"
msgstr ""

#: 
msgid "For the next step, enter a baseline date, and an analysis date to construct a plot showing where water appeared, as well as disappeared, by comparing the two dates."
msgstr ""

#: 
msgid "Save figure"
msgstr ""

#: 
msgid "Mapping water extent and rainfall using Sentinel-1 and CHIRPS"
msgstr ""

#: 
msgid "**Products used:** `s1_rtc <https://explorer.digitalearth.africa/products/s1_rtc>`__, `rainfall_chirps_monthly <https://explorer.digitalearth.africa/products/rainfall_chirps_monthly>`__"
msgstr ""

#: 
msgid "The notebook loads Sentinel-1 data, and using the sentinel-water-index, maps the spatial extent of water bodies. It also loads and plots monthly total rainfall from CHIRPS. The last section will compare the water extent between two periods to allow visulazing where change is occuring."
msgstr ""

#: 
msgid "For more details on resampling timeframes, see the `xarray <https://xarray.pydata.org/en/v0.8.2/generated/xarray.Dataset.resample.html#r29>`__ and `pandas <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`__ documentation."
msgstr ""

#: 
msgid "Load Sentinel-1 for Waterbody"
msgstr ""

#: 
msgid "The first step is to load the Sentinel-1 data using the extent geometry."
msgstr ""

#: 
msgid "Convert the Sentinel-1 digital numbers to dB"
msgstr ""

#: 
msgid "While Sentinel-1 backscatter is provided as linear intensiy, it is often useful to convert the backscatter to decible (dB) for analysis. Backscatter in dB unit has a more symmetric noise profile and less skewed value distribution for easier statistical evaluation."
msgstr ""

#: 
msgid "The Sentinel-1 backscatter data is converted from digital number (DN) to backscatter in decibel unit (dB) using the function:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} 10 * \\log_{10}(\\text{DN}) \\end{equation}`"
msgstr ""

#: 
msgid "Calculate the SWI water index"
msgstr ""

#: 
msgid "The Sentinel-1A water index (SWI) is calculated as follows:"
msgstr ""

#: 
msgid ":nbsphinx-math:`\\begin{equation} \\text{SWI} = 0.1747 * \\beta _{vv} + 0.0082 * \\beta _{vh} * \\beta _{vv} + 0.0023 * \\beta _{vv}^{2} - 0.0015 * \\beta _{vh}^{2} + 0.1904 \\end{equation}`"
msgstr ""

#: 
msgid "where βvh and βvv represent the backscattering coefficient in VH polarization and VV polarization, respectively (`Tian et al., 2017 <https://doi.org/10.3390/rs9060521>`__)."
msgstr ""

#: 
msgid "Monitoring wetlands in the Okavango"
msgstr ""

#: 
msgid "**Products used:** `ls8_sr <https://explorer.digitalearth.africa/ls8_sr>`__, `wofs_ls <https://explorer.digitalearth.africa/wofs_ls>`__, `fc_ls <https://explorer.digitalearth.africa/fc_ls>`__"
msgstr ""

#: 
msgid "The ``Wetlands Insight Tool (WIT)`` provides insights into a wetland's seasonal and interannual dynamics. The WIT is a spatiotemporal summary of an wetland that combines multiple datasets derived from the Landsat archive held within DE Africa. ``Fractional cover``, ``WOfS``, and ``Landsat surface reflectance`` data are retrieved from DE Africa's ODC and combined to produce a stack plot describing the percentage of a wetland polygon as vegetation fractional cover, open water, and wet vegetation through time."
msgstr ""

#: 
msgid "``Detailed Explanation:`` The code calculates the Tasselled-Cap Wetness (TCW, or just 'wetness') from surface reflectance and takes the maximum Fractional cover fraction per pixel, masking Fractional cover with TCW, and masking TCW with open water. For each pixel inside or overlapping the polygon describing the wetland, WIT calculates the dominant fractional cover type. WIT selects the largest percentage value for each pixel as the dominant fractional cover type. Fractional cover was masked using WOfS and TCW to remove areas of water and wet vegetation from areas where fractional cover is calculated. This is necessary as the fractional cover algorithm erroneously classifies water as green vegetation (PV). The resulting output is a stacked plot of open water, wet vegetation, photosynthetic vegetation, non-photosynthetic vegetation, and bare soil for the wetland polygon through time."
msgstr ""

#: 
msgid "This notebook will run the Wetlands Insight Tool for the area encompassed by a polygon"
msgstr ""

#: 
msgid "Load in a shapefile"
msgstr ""

#: 
msgid "Run the Wetlands Insight Tool"
msgstr ""

#: 
msgid "Plot the results as a stacked line plot"
msgstr ""

#: 
msgid "**To run this analysis**, run all the cells in the notebook, starting with the \"Load packages\" cell. \\**\\*"
msgstr ""

#: 
msgid "``shp_path``: a location path to the vector file (e.g. ``folder/input.shp``)."
msgstr ""

#: 
msgid "``time_range``: The date range to analyse (e.g. ``('2015', '2019')``)"
msgstr ""

#: 
msgid "Load shapefile"
msgstr ""

#: 
msgid "We will also ensure the polygon is in WGS84 coordinates (``epsg=4326``) using the ``to_crs()`` method to make sure it can index the datacube correctly."
msgstr ""

#: 
msgid "Plot the polygon"
msgstr ""

#: 
msgid "This cell will plot the polygon over a basemap using the ``deafrica_tools.plotting`` function ``map_shapefile``"
msgstr ""

#: 
msgid "Even for small areas, this code can take a long time to run so you will need to be patient. This is because the tool loads three seperate datasets (Landsat SR, Fractional Cover, and WOfS), and calculates a tasselled cap index on the fly."
msgstr ""

#: 
msgid "If the region is large and/or the time-span is long, the cell below will take a long time to run. Use the ``Dask Dashboard`` to monitor the progress."
msgstr ""

#: 
msgid "Plot the results"
msgstr ""

#: 
msgid "If you would like to export the plot as a .png file, then set the variable below to ``True``, and give the plot a ``name`` (e.g. the wetland's name)"
msgstr ""

#: 
msgid "Mapping long-term changes in the annual water extent of the Okavango Delta"
msgstr ""

#: 
msgid "The notebook demonstrates how to load, visualise, and analyse the `WOfS annual summary <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ product to gather insights into the longer-term extent of the Okavango delta."
msgstr ""

#: 
msgid "``vector_file``: The path to the shapefile or geojson that will define the analysis area of the study"
msgstr ""

#: 
msgid "View the vector data of Interest on an interactive map"
msgstr ""

#: 
msgid "Calculates the area of pixels classified as water (i.e. if ``ds.frequency`` is > 0.1, then the pixel will be considered open water during the year)"
msgstr ""

#: 
msgid "Mapping the seasonal changes to the open water extent of the Okavango delta"
msgstr ""

#: 
msgid "**Products used:** `ls7_sr <https://explorer.digitalearth.africa/products/ls7_sr>`__, `ls8_sr <https://explorer.digitalearth.africa/products/ls8_sr>`__"
msgstr ""

#: 
msgid "The parameters are: \\* ``vector_file``: The path to the shapefile or geojson that will define the analysis area of the study \\* ``products``: The products to load from the datacube, e.g. :literal:`'s2_l2a``, or`'ls8_sr'``*``\\ time_range\\ ``: The date range to analyse (e.g.``\\ ('2017', '2019')``. *``\\ measurements\\ ``: The spectral bands to load from the satellite product.``\\ MNDWI\\ ``requires the``'green'``and``'swir_1'``bands *``\\ resolution\\ ``: The pixel resolution of the satellite data.``\\ (-30,30)``for Landsat or``\\ (-10,10)``for Sentinel-2 *``\\ dask_chunks`: Chunk sizes to use for dask, the default values below are optimized for the full Okavango delta"
msgstr ""

#: 
msgid "Load cloud-masked Satellite data"
msgstr ""

#: 
msgid "The first step is to load satellite data for the specified area of interest and time range."
msgstr ""

#: 
msgid "Calculate the wetness index"
msgstr ""

#: 
msgid "These calculations will take **nearly an hour** to complete as we will run ``.compute()``, triggering all the tasks we scheduled above and bringing the arrays into memory."
msgstr ""

#: 
msgid "Facet plot the water extent for every season"
msgstr ""

#: 
msgid "Calculating the extent of open water"
msgstr ""

#: 
msgid "Export time-series as csv"
msgstr ""

#: 
msgid "Plot a time series of open water area"
msgstr ""

#: 
msgid "Save the water extents as geotiffs"
msgstr ""

#: 
msgid "Both the 'analysis time' and the 'baseline time' water extents will be saved as cloud-opimtised geotiffs in the ``results/`` folder"
msgstr ""

#: 
msgid "Extracting historical climate (rainfall) data over selected basins"
msgstr ""

#: 
msgid "**Products used:** ERA5"
msgstr ""

#: 
msgid "Define areas of interest in the Okavango Basin"
msgstr ""

#: 
msgid "Retrieve historical rainfall data over all areas of interest"
msgstr ""

#: 
msgid "Create area mask for upstream and okavango regions"
msgstr ""

#: 
msgid "Calculate the total rainfall over each area"
msgstr ""

#: 
msgid "Export results as csv"
msgstr ""

#: 
msgid "Visualize historical rainfall and compare to water extent changes"
msgstr ""

#: 
msgid "Visualising the correlation between rainfall, surface water extent, and discharge"
msgstr ""

#: 
msgid "Read files"
msgstr ""

#: 
msgid "Process discharge data"
msgstr ""

#: 
msgid "Plot the raw data"
msgstr ""

#: 
msgid "Note the data density of discharge measurements declines in the later years"
msgstr ""

#: 
msgid "Plot the number of observations per year"
msgstr ""

#: 
msgid "As this is daily data, the maximum number of observations per year should be 365. Note the big decline in data density from 2010 onwards. **The discharge data is therefore largely unreliable from 2010 onwards**"
msgstr ""

#: 
msgid "Try gapfilling the discharge data"
msgstr ""

#: 
msgid "First resample the dataset to weekly means to create evenly spaced measurements, and then do a simple linear interpolation between points to gapfill weeks where there is no discharge data."
msgstr ""

#: 
msgid "Plot weekly upstream rainfall alongside weekly discharge"
msgstr ""

#: 
msgid "This will help highlight if the discharge data is reliable - if there are large gaps in the discharge data then, for example, the seasonal peak flow event might not be recorded. Where there is significant volumes of rainfall but a correspsonding peak in discharge is absent, this may indicate the discharge data simply missed recording peak flow."
msgstr ""

#: 
msgid "Resample discharge dataset to seasonal means"
msgstr ""

#: 
msgid "This will match the datasets we collected from ERA5 and Landsat"
msgstr ""

#: 
msgid "Merge into one dataframe"
msgstr ""

#: 
msgid "And expprt results as csv"
msgstr ""

#: 
msgid "Plot all seasonal datasets together"
msgstr ""

#: 
msgid "Modelling discharge at Mohembo using uppercatchment rainfall"
msgstr ""

#: 
msgid "The discharge data at Mohembo becomes much more sparse during the era of good quality satellite observations, making it unreliable for comparing discharge with surface water extent. This notebook will try to model the discharge at Mohembo using the upstream rainfall extracted from ERA5 in a previous notebook"
msgstr ""

#: 
msgid "This data has already been retrieved from ERA5 so we can simply pull in the csv on disk"
msgstr ""

#: 
msgid "No need to re-run this since the data has been saved in the ``results/`` folder"
msgstr ""

#: 
msgid "Import discharge data"
msgstr ""

#: 
msgid "Match discharge with rainfall"
msgstr ""

#: 
msgid "Resample seasonal or monthly cumulative totals"
msgstr ""

#: 
msgid "By intergrating rainfall over a longer time-period (months to seasons) we can better correlate cumulative upstream rainfall with discharge at Mohembo."
msgstr ""

#: 
msgid "Split dataset at 2010. That way we can build a model on the historical, complete dataset, and then predict on the incomplete record from 2010 onwards"
msgstr ""

#: 
msgid "Explore correlations with lags in rainfall"
msgstr ""

#: 
msgid "Regression modelling"
msgstr ""

#: 
msgid "Model the relationship between rainfall and discharge using the lag that corresponds with the highest correlation"
msgstr ""

#: 
msgid "Conduct a test/train split first to get an idea of the general accuracy of this approach"
msgstr ""

#: 
msgid "Predict Discharge at Mohembo"
msgstr ""

#: 
msgid "Grab the rainfall from the period we want to predict"
msgstr ""

#: 
msgid "Make a prediction using rainfall data"
msgstr ""

#: 
msgid "Plot the observed vs predicted discharge as a time series"
msgstr ""

#: 
msgid "Print mean absolute error"
msgstr ""

#: 
msgid "Plot rainfall"
msgstr ""

#: 
msgid "Save result to disk"
msgstr ""

#: 
msgid "Forecasting surface water extent in the Okavango delta"
msgstr ""

#: 
msgid "Using the results from our modelled discharge, upstream rainfall, and vector auto regression"
msgstr ""

#: 
msgid "Read in data"
msgstr ""

#: 
msgid "Test causation"
msgstr ""

#: 
msgid "The basis behind Vector AutoRegression is that each of the time series in the system influences each other. That is, you can predict the series with past values of itself along with other series in the system. Below, we conduct a Granger's Causality Test to see if the variables are related to each other. In the table that's printed after running the two cells belows shows a given p-value is < significance level (0.05), then, the corresponding X series (column) causes the Y (row)."
msgstr ""

#: 
msgid "Conduct iterative back-test to validate forecasting ability"
msgstr ""

#: 
msgid "Here we will conduct a forecast, but over an interval of the time-series that we already have observations for. This will allow us to test the model's forecasting ability"
msgstr ""

#: 
msgid "First, lets initiate a model"
msgstr ""

#: 
msgid "Find the best lag order using Akaike information criterion (AIC)"
msgstr ""

#: 
msgid "Create and fit a model on the data"
msgstr ""

#: 
msgid "Using the lag order defined above"
msgstr ""

#: 
msgid "Forecasting Water Extent"
msgstr ""

#: 
msgid "Okavango"
msgstr ""

#: 
msgid "Surface Mining Screening"
msgstr ""

#: 
msgid "**Products used:** `gm_s2_annual <https://explorer.digitalearth.africa/products/gm_s2_annual/extents>`__, `s1_rtc <https://explorer.digitalearth.africa/products/s1_rtc/extents>`__, `wofs_ls_summary_annual <https://explorer.digitalearth.africa/products/wofs_ls_summary_annual/extents>`__"
msgstr ""

#: 
msgid "**Keywords**: :index:`data used; sentinel-2 geomedian`, :index:`data used; WOfS`, :index:`analysis; change monitoring`, :index:`use case; surface mining`, :index:`data used; sentinel-1`"
msgstr ""

#: 
msgid "`Surface mining <https://americanmineservices.com/types-of-surface-mining>`__ refers to the removal of the terrain surface to access minerals underneath. In particular, surface mining is used to retrieve sand, gravel, stones, coal, iron and other metals. Surface mining is often more cost-effective than gouging tunnels and subterranean shafts to access minerals underground."
msgstr ""

#: 
msgid "Although surface mining contributes to the source of income for a country, these operations can result in deleterious impacts on farmlands, forests, and water bodies. Government officials are making efforts to identify areas of these mining activities."
msgstr ""

#: 
msgid "This notebook demonstrates a method for identifying areas of surface mining activity. The notebook combines methods based on vegetation loss and water detection. Although the notebook aids in detecting these areas, further verification by government agencies or institutions are required to validate the operations on the ground."
msgstr ""

#: 
msgid "Surface mining operations often result in the clearing of vegetation and the development of water from the land. Using remote sensing images from `Sentinel-2 GEOMAD <https://docs.digitalearthafrica.org/en/latest/data_specs/GeoMAD_specs.html>`__ or `Sentinel-1 <https://docs.digitalearthafrica.org/en/latest/data_specs/Sentinel-1_specs.html>`__, and DE Africa's `Water Observations from Space (WOfS) <https://docs.digitalearthafrica.org/en/latest/data_specs/Landsat_WOfS_specs.html>`__ product, this notebook screen areas where there is a possibility of surface mining."
msgstr ""

#: 
msgid "The notebook uses Normalised Difference Vegetation Index (for sentinel-2) or the Radar Vegetation Index (for sentinel-1) to determine vegetation loss, where loss occurs if the change in vegetation index is negative. DE Africa's WOfS product is used to identify water."
msgstr ""

#: 
msgid "The final product identifies pixels that exhibit vegetation loss, and the presence of water. In most cases, these algorithms can be used to identify clusters of pixels that have experienced change and allow targeted investigation of those areas by local or regional governments."
msgstr ""

#: 
msgid "Load data for a given location and time period"
msgstr ""

#: 
msgid "Calculate the vegetation change"
msgstr ""

#: 
msgid "Calculate the presence of water"
msgstr ""

#: 
msgid "Combine vegetation change and water extent change into one plot to show possible mining areas"
msgstr ""

#: 
msgid "The following cell sets the parameters, which define the area of interest and the length of time to conduct the analysis over. The area of interest must be defined with a shapefile (``.shp``), a geojosn (``.geojson``), or a KML file (``.kml``)."
msgstr ""

#: 
msgid "``start_year``: The year to start the analysis"
msgstr ""

#: 
msgid "``end_year``: The year to end the analysis"
msgstr ""

#: 
msgid "``product`` : whether oto use Sentinel-2 or sentinel-1 for the analysis, acceptable values are ``'s2'`` or ``'s1'``"
msgstr ""

#: 
msgid "``threhold``: The threshold to use for indentifying vegetaton loss, this can either be a float e.g. ``-0.15``, or ``'otsu'``, in which case the threshold will be automatically identified using the otsu method."
msgstr ""

#: 
msgid "``vector_file``: The file path and name of a vector file containing the extent. Can be a ``.kml`` file, or a ``.shp`` file."
msgstr ""

#: 
msgid "**If running the notebook for the first time**, keep the default settings below. This will demonstrate how the analysis works and provide meaningful results. The example covers part of the Essen Apam Forest Reserve, Ghana, and uses the shapefile provided in **Supplementary Data**."
msgstr ""

#: 
msgid "View the area of interest defined by the vector file"
msgstr ""

#: 
msgid "Load and process data"
msgstr ""

#: 
msgid "This analysis uses two datasets:"
msgstr ""

#: 
msgid "Sentinel-2 geomedians or Sentinel-1 backscatter for identifying vegetation loss"
msgstr ""

#: 
msgid "Water Observations from Space (WOfS) for identifying water"
msgstr ""

#: 
msgid "If an area has experienced both vegetation loss and water presence, it may be related to surface mining activity."
msgstr ""

#: 
msgid "The function below loads Sentinel-2 or sentinel-1 and WOfS for the area of interest and does a number of cleaning and processing steps. The function will also plot an RGB image for each year in the analysis"
msgstr ""

#: 
msgid "Note, if the product used is Sentinel-1, this cell can take a few minutes to run as annual medians are calculated on-the-fly"
msgstr ""

#: 
msgid "Calculate vegetation loss"
msgstr ""

#: 
msgid "The next function determines whether NDVI (or RVI) decreased between one year and the next. If so, the area experienced vegetation loss. Significant vegetation loss is determined using the ``threshold`` defined in ``Analysis Parameters``. You may want to tune this threshold to better delineate the areas experiencing vegetation loss."
msgstr ""

#: 
msgid "The function returns the annual vegetation loss (in square kilometres) and the total vegetation loss over all years of the analysis. It then plots the annual vegetation loss."
msgstr ""

#: 
msgid "Determine possible mining areas"
msgstr ""

#: 
msgid "When water (WOfS) and vegetation loss are coincident, the area is classified as high-potential mining site."
msgstr ""

#: 
msgid "Areas within 250 metres of a high-potential mining site where there was only vegetation loss are also considered to be possible mining sites."
msgstr ""

#: 
msgid "Examine vegetation loss from possible mining each year"
msgstr ""

#: 
msgid "The final function compares the vegetation loss from possible mining to all vegetation loss each year, and builds a spatial plot showing the vegetation loss from possible mining each year."
msgstr ""

#: 
msgid "Use Cases"
msgstr ""

#: 
msgid "These use cases are used by Digital Earth Africa to provide analyses to decision makers for a particular area."
msgstr ""

#: 
msgid "Notebooks in this collection are developed for specific use-cases of the Digital Earth Africa platform and may not run as seamlessly as notebooks in the other folders of this repository. Notebooks may contain less descriptive markdown, contain more complicated or bespoke analysis, and may take a long time to run. However, they contain useful analysis procedures and provide further examples for advanced users."
msgstr ""

#: 
msgid "Vectorise and analyse waterbodies in Kenya"
msgstr ""

#: 
msgid "**Keywords** :index:`data used; wofs_ls_summary_annual`"
msgstr ""

#: 
msgid "This notebook detects waterbodies in a given area based on a threshold % of water observations. It then vectorises these waterbodies and exports the results as a shapefile. This can be used for inspecting and investigating the waterbodies in an area. Finally, a timeseries of the average frequency (% of the time) water is observed across years is shown for a selected waterbody."
msgstr ""

#: 
msgid "Define parameters for waterbody detection."
msgstr ""

#: 
msgid "Load the area of interest- a region in Kenya."
msgstr ""

#: 
msgid "Load WOfS for the region."
msgstr ""

#: 
msgid "Vectorise and export waterbodies to shapefile."
msgstr ""

#: 
msgid "Inspect a specific waterbody and plot a timeseries."
msgstr ""

#: 
msgid "Threshold for waterbody detection"
msgstr ""

#: 
msgid "Create a ``minimum_wet_percentage`` value corresponding to the proportion of wet counts above which an area will be classified as a waterbody. This percentage refers to time, i.e. the percentage of time a pixel is wet. It will be applied to the average frequency (%) calculated across the years 2000 to 2021."
msgstr ""

#: 
msgid "We now define the range of area (m2) we want the waterbodies to fall within. We will use the values to filter the waterbodies detected."
msgstr ""

#: 
msgid "We can also threshold the minimum valid observations we need to determine that wet observations are waterbodies. Again, will be applied to the average count of clear observations, ``count_clear``, calculated across the years 2000 to 2021. The default value is an average of 5 valid observations per year."
msgstr ""

#: 
msgid "Load and plot area of interest"
msgstr ""

#: 
msgid "We have a geojson file which defines a polygon for the area of interest for this analysis. We can see the county name and other details below. We can then plot the bounds of the area and map the shapefile to see the area we are working on."
msgstr ""

#: 
msgid "Set up export directory"
msgstr ""

#: 
msgid "We need to set up a folder to export our shapefile results into. We will create a base filename that can be referred to when writing files and store a filepath object to the export folder."
msgstr ""

#: 
msgid "The cell below clears the export directory if it already exists, then makes a new directory for storing waterbody outputs."
msgstr ""

#: 
msgid "Generate query and load WOfS"
msgstr ""

#: 
msgid "Define the query that we will use to load the WOfS data. We will use 2000 to 2021 so our analysis is based on a recent time period."
msgstr ""

#: 
msgid "The ``wofs_ls_summary_annual`` gives summary water observations on an annual basis."
msgstr ""

#: 
msgid "Aggregate to mean across the period of interest"
msgstr ""

#: 
msgid "Calculate the annual average of ``count_wet``, ``count_clear``, and ``frequency`` across the period 2000 to 2021."
msgstr ""

#: 
msgid "Mask to area of interest"
msgstr ""

#: 
msgid "Vectorise polygons where average frequency exceeds the threshold"
msgstr ""

#: 
msgid "Now we can identify areas where the average ``frequency`` of wet observations exceeds the threshold (``minimum_wet_percentage``) and convert them to polygons using ``xr_vectorize``. Polygons that overlap are merged, then finally the shapefile of all waterbodies detected is exported in the directory we created."
msgstr ""

#: 
msgid "Combine overlapping polygons based on minimum and maximum areas"
msgstr ""

#: 
msgid "Now we will use the ``min_area_m2`` and ``max_area_m2`` values we defined above to filter the waterbodies collection. This workflow was originally designed for continental applications so some aspects related to very large polygons are less relevant to this use case, though we will leave the code in the workflow for completeness."
msgstr ""

#: 
msgid "The reads the waterbodies we exported back into the notebook then filters waterbodies that exceed or fall below our area thresholds. It then identifies small waterbodies that fall below the area threshold but overlap with other waterbodies, and adds them to the final dataset."
msgstr ""

#: 
msgid "Summary statistics (area, perimeter, and `Polsby-Popper <https://en.wikipedia.org/wiki/Polsby%E2%80%93Popper_test>`__) are added to the dataset before it is exported again and overwrites the previous shapefiles."
msgstr ""

#: 
msgid "Load and inspect merged waterbodies"
msgstr ""

#: 
msgid "Now we can load the waterbodies we stored above and inspect the results. The cell below reads the shapefile we exported and displays the summary statistics, geometry, and ID column which we can use to access specific waterbodies."
msgstr ""

#: 
msgid "We can plot the shapefile to visualise the waterbodies, or we can explore with a satellite basemap."
msgstr ""

#: 
msgid "The cell below shows most waterbodies follow a river system."
msgstr ""

#: 
msgid "Mapping the shapefile with the code below displays the waterbodies in blue over a satellite basemap. Zooming in shows the analysis has captured the river system."
msgstr ""

#: 
msgid "Select a waterbody for further analysis"
msgstr ""

#: 
msgid "We can use the ``.explore()`` function to find and select a waterbody for further analysis. Although most waterbodies follow the river system, we can see there is an isolated waterbody at ``0.513, 36.989``."
msgstr ""

#: 
msgid "Inspecting the exploration map below, we can see that this is waterbody with ``ID`` = ``0`` and a perimeter of 600m, located near Tura."
msgstr ""

#: 
msgid "We can select the waterbody we identified above for further analysis using index selection."
msgstr ""

#: 
msgid "We can mask the WOfS annual summary to the selected polygon."
msgstr ""

#: 
msgid "We can inspect the distribution of frequency; the proportion of times in each year the pixel was observed as wet, across each year for our selected waterbody."
msgstr ""

#: 
msgid "This shows that the middle of the waterbody was consistently wet between 2007 and 2010, but the wettest part of the waterbody was only wet for around 60-70% of the time in 2021."
msgstr ""

#: 
msgid "Finally, we can collapse the space dimension and plot the average frequency shown above over a timeseries."
msgstr ""

#: 
msgid "DE Africa Sandbox Terms and Conditions"
msgstr ""

#: 
msgid "These are the terms and conditions (\"Terms of Use\") of your use of the Digital Earth Africa (DE Africa) Sandbox. When you create a DE Africa Sandbox account or use the DE Africa Sandbox, you agree to these terms."
msgstr ""

#: 
msgid "The DE Africa Sandbox is part of the DE Africa suite of analysis tools, provided to you by Geoscience Australia. These Terms of Use therefore constitute an agreement between you and Geoscience Australia."
msgstr ""

#: 
msgid "The DE Africa Sandbox provides users opportunities to try out DE Africa Open Data Cube interface, experiment with DE Africa's Earth Observation datasets and develop proof-of-concept applications. It is not developed as a production environment and therefore is a volatile space that we are actively working with our users to improve, so please submit your feedback on your user experience to Helpdesk@digitalearthafrica.org."
msgstr ""

#: 
msgid "**Rights**"
msgstr ""

#: 
msgid "You have the right to export your files from the Sandbox at any time."
msgstr ""

#: 
msgid "You can close your account at any time by emailing the DE Africa team (Helpdesk@digitalearthafrica.org)."
msgstr ""

#: 
msgid "Your files will not be intentionally shown to other users or shared with third parties."
msgstr ""

#: 
msgid "Your personal data, including your files, email address and identity will not be shared with anyone without your consent."
msgstr ""

#: 
msgid "You can view the current system status on the website `status.digitalearth.africa <https://status.digitalearth.africa/>`_.  If you are experiencing an issue with the Sandbox that is not identified on the status page, please submit this issue to Helpdesk@digitalearthafrica.org."
msgstr ""

#: 
msgid "**Responsibilities**"
msgstr ""

#: 
msgid "You agree not to use this service to knowingly run malicious code. You agree not to exploit the platform by running applications that are not related to Earth observation data exploration."
msgstr ""

#: 
msgid "We define an account as inactive after no usage for 3 months."
msgstr ""

#: 
msgid "We reserve the right to remove the data of inactive accounts. After this data is removed, new logins will result in a fresh environment."
msgstr ""

#: 
msgid "In the event that a user’s environment becomes unstable, it will be replaced with a fresh environment and all work/data may be lost."
msgstr ""

#: 
msgid "We reserve the right to change the features and datasets offered in response to user feedback and future assessments of budget and security,"
msgstr ""

#: 
msgid "We reserve the right to email you at your user email address to notify you of any major changes to the infrastructure or your account."
msgstr ""

#: 
msgid "We reserve the right to remove your files at any time without warning. If you need files hosted in the Sandbox you should download or export them regularly."
msgstr ""

#: 
msgid "We reserve the right to restrict or close accounts at our own discretion."
msgstr ""

#: 
msgid "Planet NICFI"
msgstr ""

#: 
msgid "**Date modified**: July 2024"
msgstr ""

#: 
msgid "Norway’s International Climate and Forests Initiative (NICFI) is an international development fund to help save the world’s tropical forests while improving the livelihoods of those who live off, in, and near the forests. In September 2020, the Norwegian Ministry of Climate and Environment awarded an international contract to Kongsberg Satellite Services (KSAT), with partners Planet and Airbus, to provide comprehensive access to high-resolution satellite monitoring of the tropics. As part of this Program, Planet partners with NICFI in making high-resolution satellite imagery of the tropics available free of charge to users advancing the NICFI Purpose of reducing and reversing tropical forest loss, combating climate change, conserving biodiversity, and facilitating sustainable development. Additional information on the program can be found on the `NICFI program website <https://www.planet.com/nicfi/>`__."
msgstr ""

#: 
msgid "Digital Earth Africa has enabled users to view NICFI's latest monthly and biannual high-resolution (<5m) mosaics through the Maps platform. These visual mosaics offer optimised true colour imagery ideal for visual display and interpretation. Archival visual mosaics and analytic products can be accessed directly from Planet following instructions on the program website"
msgstr ""

#: 
msgid "The Planet NICFI dataset is external to the Digital Earth Africa Open Data Cube."
msgstr ""

#: 
msgid "For more information on the Planet NICFI, see the `Planet NICFI <https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf>`__."
msgstr ""

#: 
msgid "A `Jupyter Notebook <https://github.com/digitalearthafrica/deafrica-sandbox-notebooks/blob/main/Datasets/Planet_basemap.ipynb>`__ which demonstrates loading and using Planet NICFI data in the Sandbox is also available."
msgstr ""

#: 
msgid "**Table 1: Planet Monthly Mosaic product specifications**"
msgstr ""

#: 
msgid "Resolution (m) :math:`\\dagger`"
msgstr ""

#: 
msgid "4.77"
msgstr ""

#: 
msgid "2020-09 - Date"
msgstr ""

#: 
msgid "2015-12 – 2020-08"
msgstr ""

#: 
msgid "Red, Green, Blue (3-band)"
msgstr ""

#: 
msgid "Latency"
msgstr ""

#: 
msgid "5 days"
msgstr ""

#: 
msgid "https://api.digitalearth.africa/planet/tiles/basemaps/v1/planet-tiles/planet_medres_visual_year-month_mosaic/gmap/{z}/{x}/{y}.png"
msgstr ""

#: 
msgid "Example image"
msgstr ""

#: 
msgid "**Figure 1:Planet Image for Dakar, Senegal**."
msgstr ""

#: 
msgid "planet image"
msgstr ""

#: 
msgid "The Planet NICFI product is provided under a free of charge."
msgstr ""

#: 
msgid "Planet NICFI is produced by the Norway’s International Climate and Forests Initiative (NICFI)."
msgstr ""

#: 
msgid "Land and water"
msgstr ""

#: 
msgid "Coastal"
msgstr ""

#: 
msgid "Elevation"
msgstr ""

#: 
msgid "External Datasets"
msgstr ""

#: 
msgid "About the data"
msgstr ""

#: 
msgid "Data Catalogue"
msgstr ""

#: 
msgid "Digital Earth Africa hosts a repository of Earth observation datasets spanning continental Africa."
msgstr ""

#: 
msgid "Satellite images"
msgstr ""

#: 
msgid "Surface reflectance"
msgstr ""

#: 
msgid ":doc:`Landsat_C2_SR_specs`"
msgstr ""

#: 
msgid "Daily satellite images from Landsat 5, 7, 8 and 9."
msgstr ""

#: 
msgid ":doc:`More <Landsat_C2_SR_specs>`"
msgstr ""

#: 
msgid ":doc:`Sentinel-2_Level-2A_specs`"
msgstr ""

#: 
msgid "Daily satellite images from Sentinel-2."
msgstr ""

#: 
msgid ":doc:`More <Sentinel-2_Level-2A_specs>`"
msgstr ""

#: 
msgid ":doc:`GeoMAD_specs`"
msgstr ""

#: 
msgid "Cloud-free mosaics from Landsat and Sentinel-2 satellites."
msgstr ""

#: 
msgid ":doc:`More <GeoMAD_specs>`"
msgstr ""

#: 
msgid "Surface temperature"
msgstr ""

#: 
msgid ":doc:`Landsat_C2_ST_specs`"
msgstr ""

#: 
msgid "Surface Temperature from Landsat 5, 7, 8 and 9."
msgstr ""

#: 
msgid ":doc:`More <Landsat_C2_ST_specs>`"
msgstr ""

#: 
msgid "Radar backscatter"
msgstr ""

#: 
msgid ":doc:`Sentinel-1_specs`"
msgstr ""

#: 
msgid "Synthetic Aperture Radar from Sentinel-1."
msgstr ""

#: 
msgid ":doc:`More <Sentinel-1_specs>`"
msgstr ""

#: 
msgid ":doc:`ALOS_PALSAR_annual_mosaic_specs`"
msgstr ""

#: 
msgid "Synthetic Aperture Radar annual mosaics from JAXA."
msgstr ""

#: 
msgid ":doc:`More <ALOS_PALSAR_annual_mosaic_specs>`"
msgstr ""

#: 
msgid ":doc:`Landsat_WOfS_specs`"
msgstr ""

#: 
msgid "Individual, annual and historic water observations."
msgstr ""

#: 
msgid ":doc:`More <Landsat_WOfS_specs>`"
msgstr ""

#: 
msgid ":doc:`Cropland_extent_specs`"
msgstr ""

#: 
msgid "Estimated location of croplands."
msgstr ""

#: 
msgid ":doc:`More <Cropland_extent_specs>`"
msgstr ""

#: 
msgid ":doc:`Fractional_Cover_specs`"
msgstr ""

#: 
msgid "Green vegetation, non-green vegetation and bare soil for every Landsat image."
msgstr ""

#: 
msgid ":doc:`More <Fractional_Cover_specs>`"
msgstr ""

#: 
msgid ":doc:`NDVI_Climatology_specs`"
msgstr ""

#: 
msgid "Long-term average vegetation condition (NDVI) for every Landsat pixel over the African continent."
msgstr ""

#: 
msgid ":doc:`More <NDVI_Climatology_specs>`"
msgstr ""

#: 
msgid ":doc:`NDVI_Anomaly_specs`"
msgstr ""

#: 
msgid "Monthly mapping of vegetation condition against the long-term baseline."
msgstr ""

#: 
msgid ":doc:`More <NDVI_Anomaly_specs>`"
msgstr ""

#: 
msgid ":doc:`CHIRPS_specs`"
msgstr ""

#: 
msgid "Daily and monthly rainfall estimates from rain gauge and satellite observations."
msgstr ""

#: 
msgid ":doc:`More <CHIRPS_specs>`"
msgstr ""

#: 
msgid ":doc:`CGLS_LULC_specs`"
msgstr ""

#: 
msgid "Copernicus Global Land Service annual land cover layers at 100 m spatial resolution."
msgstr ""

#: 
msgid ":doc:`More <CGLS_LULC_specs>`"
msgstr ""

#: 
msgid ":doc:`IO_LULC_specs`"
msgstr ""

#: 
msgid "ESRI 10-meter resolution global land use land cover time series."
msgstr ""

#: 
msgid ":doc:`More <IO_LULC_specs>`"
msgstr ""

#: 
msgid ":doc:`iSDA_Soil_Data`"
msgstr ""

#: 
msgid "iSDA soil variables at 30 m resolution."
msgstr ""

#: 
msgid ":doc:`More <iSDA_Soil_Data>`"
msgstr ""

#: 
msgid ":doc:`ESA_WorldCover_specs`"
msgstr ""

#: 
msgid "ESA WorldCover global land cover map at 10 m resolution."
msgstr ""

#: 
msgid ":doc:`More <ESA_WorldCover_specs>`"
msgstr ""

#: 
msgid ":doc:`CCI_Landcover_specs`"
msgstr ""

#: 
msgid "ESA Climate Change Initiative Land Cover at 300 m resolution."
msgstr ""

#: 
msgid ":doc:`More <CCI_Landcover_specs>`"
msgstr ""

#: 
msgid ":doc:`Global_Mangrove_Watch_specs`"
msgstr ""

#: 
msgid ":doc:`More <Global_Mangrove_Watch_specs>`"
msgstr ""

#: 
msgid ":doc:`Waterbodies_specs`"
msgstr ""

#: 
msgid "A continental collection of African water bodies locations and surface area change at a 30m resolution from 1987 to present."
msgstr ""

#: 
msgid ":doc:`More <Waterbodies_specs>`"
msgstr ""

#: 
msgid ":doc:`World_Settlement_Footprint_specs`"
msgstr ""

#: 
msgid "The World Settlement Footprint WSF is a 10m-resolution binary mask outlining the extent of human settlements globally for the years 2015 and 2019 based on multiple datasets, and the World Settlement Footprint Evolution shows the annual growth of human settlements globally at 30m-resolution."
msgstr ""

#: 
msgid ":doc:`More <World_Settlement_Footprint_specs>`"
msgstr ""

#: 
msgid ":doc:`Coastlines_specs`"
msgstr ""

#: 
msgid "Annual shorelines and rates of coastal change along the entire African coastline at a 30 m resolution from 2000 to 2021."
msgstr ""

#: 
msgid ":doc:`More <Coastlines_specs>`"
msgstr ""

#: 
msgid ":doc:`COP_DEM_specs`"
msgstr ""

#: 
msgid "Corpenicus Digital Elevation Model with limited worldwide coverage at 30 metres and global coverage at 90 metres spatial resolution."
msgstr ""

#: 
msgid ":doc:`More <COP_DEM_specs>`"
msgstr ""

#: 
msgid ":doc:`SRTM_DEM_specs`"
msgstr ""

#: 
msgid "NASA version 3.0 Shuttle Radar Topography Mission (SRTM) global 1 arc second (~30 metre) DEM and Digital Earth Africa SRTM DEM Derivatives."
msgstr ""

#: 
msgid ":doc:`More <SRTM_DEM_specs>`"
msgstr ""

#: 
msgid ":doc:`ERA5_Climate_Data_specs`"
msgstr ""

#: 
msgid "ERA5 global climate reanalysis product by the Copernicus Climate Change Service (C3S) at the ECMWF."
msgstr ""

#: 
msgid ":doc:`More <ERA5_Climate_Data_specs>`"
msgstr ""

#: 
msgid ":doc:`GRAFS_specs`"
msgstr ""

#: 
msgid "Global Root-zone moisture Analysis & Forecasting System (GRAFS) by the ANU Centre for Water and Landscape Dynamics."
msgstr ""

#: 
msgid ":doc:`More <GRAFS_specs>`"
msgstr ""

#: 
msgid ":doc:`Planet_NICFI_specs`"
msgstr ""

#: 
msgid "Planet NICFI visual mosaics provide optimized, true-color imagery, making them ideal for visual display and interpretation."
msgstr ""

#: 
msgid ":doc:`More <Planet_NICFI_specs>`"
msgstr ""

#: 
msgid ":doc:`Landsat_tiers`"
msgstr ""

#: 
msgid "How Landsat Collection 2 data tiers are used in Digital Earth Africa."
msgstr ""

#: 
msgid ":doc:`More <Landsat_tiers>`"
msgstr ""

#: 
msgid "If you have any feedback for the DE Africa data and services, please contact us at helpdesk@digitalearthafrica.org."
msgstr ""

#: 
msgid "Global Mangrove Watch global baseline map of mangroves for 2010 and change maps for 1996, 2007, 2008, 2009, 2015 - 2020."
msgstr ""

#: 
msgid "Exporting to Google Drive from the Sandbox"
msgstr ""

#: 
msgid "To connect to the Google Drive API from the Sandbox using a service account, a ``service account`` is created in the Google Cloud Console. Users then need to download its JSON key file, and configure permissions on both Google Drive and the service account. This approach bypasses user authentication and allows server-to-server interactions, making it suitable for automated tasks or applications where user interaction is not required. The service account JSON key is securely stored and used by Python code within Jupyter notebooks to authenticate and authorize API requests, enabling seamless integration of Google Drive functionalities directly into data science workflows without user intervention."
msgstr ""

#: 
msgid "Detailed instructions on integrating Google Drive are `documented in the DE Africa user guide <https://docs.digitalearthafrica.org/en/latest/platform_tools/googledrive_access.html>`__."
msgstr ""

#: 
msgid "**Security considerations:** Users should take care to ensure the security of credentials uploaded into the Sandbox, including by ensuring they are not incidentally included in uploads to public repositories like GitHub."
msgstr ""

#: 
msgid "This notebook provides a brief introduction to accessing and using Digital Earth Africa's sandbox with Google Drive:"
msgstr ""

#: 
msgid "The packages to load up"
msgstr ""

#: 
msgid "How to use the list files in the google drive"
msgstr ""

#: 
msgid "How to upload file files in the google drive"
msgstr ""

#: 
msgid "To use this notebook, make sure to follow these steps `here <https://docs.digitalearthafrica.org/en/latest/platform_tools/googledrive_access.html>`__ before proceeding to the next cell."
msgstr ""

#: 
msgid "List Files in Google Drive"
msgstr ""

#: 
msgid "``list_gdrive`` function list the files and folder within the service account drive."
msgstr ""

#: 
msgid "Upload to Google Drive"
msgstr ""

#: 
msgid "``upload_to_gdrive`` function uploads the files to google drive. it takes two parameter"
msgstr ""

#: 
msgid "``file_path`` : path to the file to upload"
msgstr ""

#: 
msgid "Create a text file on your desktop and remane it to ``googledrive_id.txt``"
msgstr ""

#: 
msgid "Open the text file and paste the text copied from the Google Drive folder url earlier on."
msgstr ""

#: 
msgid "Upload the ``googledrive_id.txt`` file in the ``DriveCredentials`` folder. if you want to use another folder in google drive,update the id in the ``googledrive_id.txt`` file."
msgstr ""

#: 
msgid "|bc763979005c4991b30f6174f36957f8|"
msgstr ""

#: 
msgid "|c032e3f009cd43eb8226d55afcda9ae1|"
msgstr ""

#: 
msgid "|213cc51350dd47909be0ccfde7925c41|"
msgstr ""

#: 
msgid "|7853efd2391947cdb8eede274d09239d|"
msgstr ""

#: 
msgid "|30949673d6144ef29ef0c50aced651ca|"
msgstr ""

#: 
msgid "|2a0bbf62f092431b805e8b546f983aac|"
msgstr ""

#: 
msgid "|15cfcb5dcab041fc8e5470b656804928|"
msgstr ""

#: 
msgid "|595aa56d93314c4b80a9572953c362ee|"
msgstr ""

#: 
msgid "|eafad6c436f44628900a7a9d799efd5d|"
msgstr ""

#: 
msgid "|9ae036b9560244a2b37181c76c04872b|"
msgstr ""

#: 
msgid "|87a5cbb77cec48dab85b405f8a92ff99|"
msgstr ""

#: 
msgid "|1e4c49f044114db98e29872d9d41e05b|"
msgstr ""

#: 
msgid "|67451dcd26e94eceb11bbebfb70effbd|"
msgstr ""

#: 
msgid "|2875f5bfa81a4f529918dd43b4ac8422|"
msgstr ""

#: 
msgid "|4a0c13b17d2a4b8da2b3872c95f13c02|"
msgstr ""

#: 
msgid "|9a78f6403f5a4ebeb8fcb2115f31ad84|"
msgstr ""

#: 
msgid "|473af82db18848a5ae570d9385c77687|"
msgstr ""

#: 
msgid "|fe54c8cb0458408cbfab61d300d23b61|"
msgstr ""

#: 
msgid "fe54c8cb0458408cbfab61d300d23b61"
msgstr ""

#: 
msgid "|2d9bf267adf24e05a1f427e4df4098e1|"
msgstr ""

#: 
msgid "2d9bf267adf24e05a1f427e4df4098e1"
msgstr ""

#: 
msgid "|562d175534bc4751ac14697a48a3b6ca|"
msgstr ""

#: 
msgid "562d175534bc4751ac14697a48a3b6ca"
msgstr ""

#: 
msgid "|381870ead22340af816df6733a2be5b4|"
msgstr ""

#: 
msgid "381870ead22340af816df6733a2be5b4"
msgstr ""

#: 
msgid "|33a053eba4434860aa4ab10b722cb6ca|"
msgstr ""

#: 
msgid "33a053eba4434860aa4ab10b722cb6ca"
msgstr ""

#: 
msgid "|3d43ae4d61ae414f88174076d1b2ca2e|"
msgstr ""

#: 
msgid "3d43ae4d61ae414f88174076d1b2ca2e"
msgstr ""

#: 
msgid "|8b750c78e58b4cfe8891585fb783aea8|"
msgstr ""

#: 
msgid "8b750c78e58b4cfe8891585fb783aea8"
msgstr ""

#: 
msgid "|80d83a278bc2449595df4ae4c519e74d|"
msgstr ""

#: 
msgid "80d83a278bc2449595df4ae4c519e74d"
msgstr ""

#: 
msgid "|6c7f49bb37cc43f9be65b07e11120587|"
msgstr ""

#: 
msgid "6c7f49bb37cc43f9be65b07e11120587"
msgstr ""

#: 
msgid "|08860a992588496b902c5aebb7816bb5|"
msgstr ""

#: 
msgid "08860a992588496b902c5aebb7816bb5"
msgstr ""

#: 
msgid "|0a10b48cf19141cab61b73a67e04f898|"
msgstr ""

#: 
msgid "0a10b48cf19141cab61b73a67e04f898"
msgstr ""

#: 
msgid "|35ff26e3d5aa46b7a31349c44162c9c1|"
msgstr ""

#: 
msgid "35ff26e3d5aa46b7a31349c44162c9c1"
msgstr ""

#: 
msgid "|7065a650126042c6ae47717dc1081d36|"
msgstr ""

#: 
msgid "7065a650126042c6ae47717dc1081d36"
msgstr ""

#: 
msgid "|4ddb068fb98f4fe48799f6afc73f4de2|"
msgstr ""

#: 
msgid "|861eca348eda433f904d094deeb3f5f0|"
msgstr ""

#: 
msgid "|c924821436a74a39ad77a192d5a72ac6|"
msgstr ""

#: 
msgid "|33f7692ed87b49caa8fd86279616aaac|"
msgstr ""

#: 
msgid "|f14431bcfa1e49ebacb88c85e436c930|"
msgstr ""

#: 
msgid "|97598ead135e480f8d10ab3a01790e76|"
msgstr ""

#: 
msgid "|8afbe0fe622a4b46a74165c47e45ee0f|"
msgstr ""

#: 
msgid "8afbe0fe622a4b46a74165c47e45ee0f"
msgstr ""

#: 
msgid "|d6a694cb00b54947a3e38878711107a9|"
msgstr ""

#: 
msgid "|12197f949a44402e8def354c294e5f9f|"
msgstr ""

#: 
msgid "|7a5713df0f934c429018795c30e70a3b|"
msgstr ""

#: 
msgid "|454001afd32e417db67189542a0a1ea6|"
msgstr ""

#: 
msgid "|a52571646a1d4571a09c28d3b2540347|"
msgstr ""

#: 
msgid "|3414435b5b214b508baf4acc5cf1260e| |93ad0d6c50bc4b5fb8c39815833bc261|"
msgstr ""

#: 
msgid "|0233a7cbc7b549a3991f87053ffa77a0| |ccdb05f4cbf74849955328c1b126cb40|"
msgstr ""

#: 
msgid "0233a7cbc7b549a3991f87053ffa77a0"
msgstr ""

#: 
msgid "ccdb05f4cbf74849955328c1b126cb40"
msgstr ""

#: 
msgid "|644db232cbe840c28942273ff87f926d|"
msgstr ""

#: 
msgid "|015b8c62a4f0499c9b65881caa66e5eb|"
msgstr ""

#: 
msgid "|0d09ae8789a14c3885cdc4c9405c169e|"
msgstr ""

#: 
msgid "|2e3c621e3fec4120b26b8dcd9a48f2af|"
msgstr ""

#: 
msgid "|1a6d7e4fe0f44314b007da96960439ec|"
msgstr ""

#: 
msgid "1a6d7e4fe0f44314b007da96960439ec"
msgstr ""

#: 
msgid "|7afb336274e44ba7bf5f7c3c81298629|"
msgstr ""

#: 
msgid "7afb336274e44ba7bf5f7c3c81298629"
msgstr ""

#: 
msgid "|040ddd134e4c4d33b6fe4080f1db1639|"
msgstr ""

#: 
msgid "040ddd134e4c4d33b6fe4080f1db1639"
msgstr ""

#: 
msgid "|4fc5d35978074b3ba3f4b8b53f206734|"
msgstr ""

#: 
msgid "|95757897e7bd4ae1b344274ecddb9db1|"
msgstr ""

#: 
msgid "|e9635919d9db4790b7f5808386c70388|"
msgstr ""

#: 
msgid "|a101f5bbea834f7a8bf3cefd6023a3f2|"
msgstr ""

#: 
msgid "|39cbd2efb1764a3585aca3841f871af8|"
msgstr ""

#: 
msgid "|902beff5584447ea91ccf83d254c43b9|"
msgstr ""

#: 
msgid "|cd58bf2d5bd24a778cf1ea0e23e51a31|"
msgstr ""

#: 
msgid "|8f68edf30ded44a5a13f6747a82058eb|"
msgstr ""

#: 
msgid "|3c8a8dfc53174ed88c068dd61980b85e|"
msgstr ""

#: 
msgid "|f4a600cf6fb84ce2a3ac25445bd18dde|"
msgstr ""

#: 
msgid "|559439b2174b4444acdefb238f2fce68|"
msgstr ""

#: 
msgid "|a681b1e96c504e5eafc8ea781f8eb84b|"
msgstr ""

#: 
msgid "|8f0257206e5c41b0b2baa9e4e2163f5b|"
msgstr ""

#: 
msgid "|8c8cb1e5ecd84868ab7149b736400d79|"
msgstr ""

#: 
msgid "|8cfc5630b6474ff7a82ffaf1376a6115|"
msgstr ""

#: 
msgid "|3a13855d53704d789156af22faea9c69|"
msgstr ""

#: 
msgid "|2df5f6ada175491d8550b664b275fc95|"
msgstr ""

#: 
msgid "|7b76d8d1dcd2492c9c987713d1e3903d|"
msgstr ""

#: 
msgid "|798926a61d434e18a39f319b57e5c024|"
msgstr ""

#: 
msgid "798926a61d434e18a39f319b57e5c024"
msgstr ""

#: 
msgid "|ccf662b733a346e9b04a4c70eb673c44|"
msgstr ""

#: 
msgid "ccf662b733a346e9b04a4c70eb673c44"
msgstr ""

#: 
msgid "|f46688f95f38467089787384fdbb1807|"
msgstr ""

#: 
msgid "f46688f95f38467089787384fdbb1807"
msgstr ""

#: 
msgid "|60d9cc49fb054b2bae1d340918b71a88|"
msgstr ""

#: 
msgid "60d9cc49fb054b2bae1d340918b71a88"
msgstr ""

#: 
msgid "|77550c7ab9084499a687aec9d8f7678d|"
msgstr ""

#: 
msgid "77550c7ab9084499a687aec9d8f7678d"
msgstr ""

#: 
msgid "|5f567954cc8147e1972a79460812395b|"
msgstr ""

#: 
msgid "5f567954cc8147e1972a79460812395b"
msgstr ""

#: 
msgid "|0b2bb706e44f41299caa5464e1e73806|"
msgstr ""

#: 
msgid "0b2bb706e44f41299caa5464e1e73806"
msgstr ""

#: 
msgid "|68d387c9c5164688964a180e7d2cbfed|"
msgstr ""

#: 
msgid "68d387c9c5164688964a180e7d2cbfed"
msgstr ""

#: 
msgid "|ebdae8f318944353948b8221111e4e6b|"
msgstr ""

#: 
msgid "ebdae8f318944353948b8221111e4e6b"
msgstr ""

#: 
msgid "|475ebf543d6a44f29f6ca5bef83e1271|"
msgstr ""

#: 
msgid "|f4215994cd074666aa3e7974aa099eae|"
msgstr ""

#: 
msgid "|38d563d0f70e48799ba4cbac53448a11|"
msgstr ""

#: 
msgid "|3356f084b60c4160937a854dfff23860|"
msgstr ""

#: 
msgid "|3de4311d0c0a46b1a96adfbcc7f3efa2|"
msgstr ""

#: 
msgid "|66d75cf411e3414881fa7a316158fb8c|"
msgstr ""

#: 
msgid "|edfd957330ce45ecbe4c8dd7e3de99f2|"
msgstr ""

#: 
msgid "|963c1cddedbc4d30a422210837a307ee|"
msgstr ""

#: 
msgid "|38fe8e4cbb224fffa9c5bf3605546421|"
msgstr ""

#: 
msgid "|a14d77c2a7674b8f88f26d11c1279ee1|"
msgstr ""

#: 
msgid "|a0f2b6313c644c44ad5879bcd5eb447d|"
msgstr ""

#: 
msgid "|4fce535bee2944ca96982e64869f4b8a|"
msgstr ""

#: 
msgid "|b9760e73eeac41cb960b87b6f8390ba9|"
msgstr ""

#: 
msgid "|e0862c671d7e4f219f7be65b54b556ed|"
msgstr ""

#: 
msgid "|a7f03c8c92f243c1885f94c140ee12c8|"
msgstr ""

#: 
msgid "|6d63639c734a48cda77eabff4f949a25|"
msgstr ""

#: 
msgid "|4d931aca13184769b8a723f712e27306|"
msgstr ""

#: 
msgid "|a7e3b06acb8e4771b81b5e977ca47fd1|"
msgstr ""

#: 
msgid "|d4eebf2eadc04bb4aa83f75876ae5e74|"
msgstr ""

#: 
msgid "|0ea23d5e99f24e5eb36113ec91627ebf|"
msgstr ""

#: 
msgid "|54c07e27a8ba490d931dbf8905c70016|"
msgstr ""

#: 
msgid "|34e67b5fc4e9406fb75d0fa489771fe2|"
msgstr ""

#: 
msgid "|2ea248f8182744829d6f24dda043a76c|"
msgstr ""

#: 
msgid "|50854ceab409426daaa17d6f8ec501d6|"
msgstr ""

#: 
msgid "|996ef5725e134fefafb5dd4e409a7bec|"
msgstr ""

#: 
msgid "|9df1cb7fc135459b9417710fbc0d8689|"
msgstr ""

#: 
msgid "|6dec59108b6947668c3d7492eac46060|"
msgstr ""

#: 
msgid "|9455b371044f4ba9a8fec370a80a88f4|"
msgstr ""

#: 
msgid "|09efa3a09adf49a58e638fb66257de93|"
msgstr ""

#: 
msgid "|40543ddc6ff34fc48f3bb6eafeed1ed9|"
msgstr ""

#: 
msgid "|b5a746300f65419c869be5d42c00c96e|"
msgstr ""

#: 
msgid "|8d256fcebf794de4a267cbd705514346|"
msgstr ""

#: 
msgid "|df1e03450cfb44ae9cfc2b2836a3253c|"
msgstr ""

#: 
msgid "|d858a86e7686469987566b999dafa095|"
msgstr ""

#: 
msgid "|b5be69dc6e2b410099c57049ec0a02f9|"
msgstr ""

#: 
msgid "|a5123b5255cc45c6bc8957e148a0856e|"
msgstr ""

#: 
msgid "|25b48634d86943f3ac192b4f646ca2d3|"
msgstr ""

#: 
msgid "|a4af4a3eb60c449a822286b994696754|"
msgstr ""

#: 
msgid "|09c272f5f3384a329b9c9f349c6ea970|"
msgstr ""

#: 
msgid "|9a499c9cf5ca4ee6bb47bc3d77dfbf06|"
msgstr ""

#: 
msgid "|1cf73424f6164860ac510ac83f99ffa8|"
msgstr ""

#: 
msgid "|e323ee67c49144df9dfb8f4892dd72d0|"
msgstr ""

#: 
msgid "|571a312a5bfe4994af8a558352eafbce|"
msgstr ""

#: 
msgid "|c909981240a44e48816367bc610257d5|"
msgstr ""

#: 
msgid "|527cbeeb3ff74805bc773c50e1ef45bf|"
msgstr ""

#: 
msgid "|c19334b3a6e8482e9e8b0f78b2863264|"
msgstr ""

#: 
msgid "|c414df54bbe54393832a8c13017d4d71|"
msgstr ""

#: 
msgid "|58e90943bb714124a7ec4721317e9141|"
msgstr ""

#: 
msgid "|0ee9b379355640e1aea64b85c01ffcd4|"
msgstr ""

#: 
msgid "0ee9b379355640e1aea64b85c01ffcd4"
msgstr ""

#: 
msgid "|9e6f26636a074948bf027d7244c6d19e|"
msgstr ""

#: 
msgid "|7cef0b2560434278b2b7e9a815337e81|"
msgstr ""

#: 
msgid "|a855242fd4ed4f5089bd3a1b986a860f|"
msgstr ""

#: 
msgid "|2c0c4cebd0384ac7a43475984216cc37|"
msgstr ""

#: 
msgid "|aa8b3ce8016c4682837d5bd958bf83a9|"
msgstr ""

#: 
msgid "|4497f67f6f93499cbb7270eb8d3c8bae|"
msgstr ""

#: 
msgid "|5c1d27bc288148d1a9a7a8221e472774|"
msgstr ""

#: 
msgid "|58049f75788445b89b0ced57961b53d8|"
msgstr ""

#: 
msgid "|ccddd408aed5456ab2a9670ac359bb1e|"
msgstr ""

#: 
msgid "|2ca2dde4b10c453d92412a2e1b290812|"
msgstr ""

#: 
msgid "|f012d9732d7c4e9c8a836ec735803b15|"
msgstr ""

#: 
msgid "|a62bb5cd4fe14267ab6075717770d503|"
msgstr ""

#: 
msgid "|ca847263e4094702b2bf01c20ee806d4|"
msgstr ""

#: 
msgid "|a4145d626df74622a83f7f2d568df102|"
msgstr ""

#: 
msgid "|29cab07aa4e248528f54bf7568831abe|"
msgstr ""

#: 
msgid "|8112307d999148e3983981b126faa9ad|"
msgstr ""

#: 
msgid "|1d783e1d645947b38cd0d5d87f7ff53c|"
msgstr ""

#: 
msgid "|e52182bd526a4600b85526cc5c452530|"
msgstr ""

#: 
msgid "|ccbfb433c8184a3ab70f7a3cfe55ef30|"
msgstr ""

#: 
msgid "|a6b2c59884aa4a428bf4a79d79aa54a6|"
msgstr ""

#: 
msgid "|9aaf1379f8064bfb8d5faf03813b04ca|"
msgstr ""

#: 
msgid "|97113819c3f8425789f5c37833c939c6|"
msgstr ""

#: 
msgid "|2235ddd2968742428bee80ff3220cea8|"
msgstr ""

#: 
msgid "|817b5ca67fca43deb2f153c7004abb6c|"
msgstr ""

#: 
msgid "|1586b46c762a4361b9f1587f296d49a4|"
msgstr ""

#: 
msgid "|fa42175d2e7a4edfb9c004cb47e774bd|"
msgstr ""

#: 
msgid "|a159ed0162564660a74d32a411ee53e9|"
msgstr ""

#: 
msgid "|57a3007b8efa414e8ba015e0a2365d61|"
msgstr ""

#: 
msgid "|a12f784193f641c49a61252469528df5|"
msgstr ""

#: 
msgid "|49a88aa4c74741e19ecd2474b102696d|"
msgstr ""

#: 
msgid "|d63d21b01b694c288025ae5b54c4e7ca|"
msgstr ""

#: 
msgid "|409451cfafe4480f8fa123816a246a57|"
msgstr ""

#: 
msgid "|79948ffd99e84deaba4abbdf67e9642e|"
msgstr ""

#: 
msgid "|72c6be2716ca4099aba0b6b877804de1|"
msgstr ""

#: 
msgid "|a6a14fc481824b55914e5a429dbd6759|"
msgstr ""

#: 
msgid "|656ecbec30fb47b2863ae000b4120fd3|"
msgstr ""

#: 
msgid "|89751f8666db432ea9fc0dec57d05d87|"
msgstr ""

#: 
msgid "|6b4699f18cf94ff789ea70ffe0c3a0a0|"
msgstr ""

#: 
msgid "|76837006f2ea44eb9f6bfc3ab7054a4e|"
msgstr ""

#: 
msgid "|148ddf17a11848bda35c48b1f15b75e1|"
msgstr ""

#: 
msgid "|8b91bbc05375421a8736cdc28d99fee1|"
msgstr ""

#: 
msgid "|5cbb02bf8f7e4c5ba08c45489f341ed0|"
msgstr ""

#: 
msgid "|160023bc3a2f4c2184d3f12c16740dac|"
msgstr ""

#: 
msgid "|72099e382a99401a812ecc13029a616e|"
msgstr ""

#: 
msgid "|9cd3cf7b718445c6abe91447eacfb936|"
msgstr ""

#: 
msgid "|e55cfc49867d42e0833966c1049535e2|"
msgstr ""

#: 
msgid "|6674dda569c243d997bd3096b71cdbb4|"
msgstr ""

#: 
msgid "|326dd78f6bf5484d8c6f8369ceee8697|"
msgstr ""

#: 
msgid "|603d5810964248ce8b92a66847fcf48a|"
msgstr ""

#: 
msgid "|7cfabb4c03bc4354b6f39eb17e678273|"
msgstr ""

#: 
msgid "|116536810d234c0ebd150f7aca42fada|"
msgstr ""

#: 
msgid "|fb6666a1bbf347bf90beadf6854a858d|"
msgstr ""

#: 
msgid "|cb07bf6be8024eabae28ed3b2a1cdce6|"
msgstr ""

#: 
msgid "In the **Overlay** gallery, under **Dynamic test**, click **Map Time**. |a7969a5275384c718d4756ced286e750|"
msgstr ""

#: 
msgid "*The expression created a single label, rather than a start and end time, and formats it display the year ratheer than a full date* |150854c94f684dff8c74fbdb5c0f8f93|"
msgstr ""

#: 
msgid "|685ca85350e54996892a9427d37c111e|"
msgstr ""

#: 
msgid "Then click **Export**. |bf0fe4ffb8184260923d3bb47a18847a|"
msgstr ""

#: 
msgid "|3f82251d06104822bca937e9a4248eb6|"
msgstr ""

#: 
msgid "|a6184eae8b244985af8031b4eedc155e|"
msgstr ""

#: 
msgid "|f5d234ee18ca4e95980bb389f9144b80|"
msgstr ""

#: 
msgid "|8397f200a8c24e7bb64f9b9cf48ea92b|"
msgstr ""

#: 
msgid "|0b0e31784d9045a091dc58459ba464e4|"
msgstr ""

#: 
msgid "|9ab34de5e3924e0c8abdb197efb8fa45|"
msgstr ""

#: 
msgid "|24688dd63afb45bf97f0f007b8b44dc0|"
msgstr ""

#: 
msgid "|99da61615457466484d3a4c18f88222b|"
msgstr ""

#: 
msgid "|bc2152810ba84bd4b5e80bb7be8db7fe|"
msgstr ""

#: 
msgid "|7abb4be6405d4b518b6d42a9bc5b7b67|"
msgstr ""

#: 
msgid "|9b9cd6ef2e134e10a9d730bd10dec21e|"
msgstr ""

#: 
msgid "|803672c0a7674d7f92c74799d91f22a5|"
msgstr ""

#: 
msgid "|d34d4cb62e4647bca598b2ea3d389572|"
msgstr ""

#: 
msgid "|10f040249f2040019526c4e3943112de|"
msgstr ""

#: 
msgid "|9ebf728139e84d6b95acee629df98751|"
msgstr ""

#: 
msgid "|5e72df90fb024a29881bc55a86fe49cc|"
msgstr ""

#: 
msgid "|d4b52d8c1db74370822983331e8d5cb7|"
msgstr ""

#: 
msgid "|ed0b8737693b4d87845379c149c28d80|"
msgstr ""

#: 
msgid "|aaa4efc180974613a9c83c2e234e99a9|"
msgstr ""

#: 
msgid "|a7aff8120b414a3fbc3d78747e17b842|"
msgstr ""

#: 
msgid "|042bfc2d1aa245e6a1f6c772064abad3|"
msgstr ""

#: 
msgid "|59bf3c6ddec44e3ca4861681f084eb81|"
msgstr ""

#: 
msgid "|666c5d119e5c466f901fb9f79c94b2ee|"
msgstr ""

#: 
msgid "|860fafe1f0624f0eb125f4fc268f617d|"
msgstr ""

#: 
msgid "|37fceb52e2344c87adf9b4895ec9d06d|"
msgstr ""

#: 
msgid "|6d8c593ec3474661b8488b2b7c5d19c1|"
msgstr ""

#: 
msgid "|cff78c1a77fa45aba383cbe29d956dd8|"
msgstr ""

#: 
msgid "|32180910290e4a4c8b328cda7274f522|"
msgstr ""

#: 
msgid "|2f3aa4a767924aa5ab76914acbcd0429|"
msgstr ""

#: 
msgid "|54ecec3b913440bb83186efd0fe9ea15|"
msgstr ""

#: 
msgid "|305caa5c712f4cd390290579b04e5861|"
msgstr ""

#: 
msgid "|cdfae51bd0f54bc1942fe7904fa71514|"
msgstr ""

#: 
msgid "|1ffa65f19ba34f1f9f3e7502090f5891|"
msgstr ""

#: 
msgid "|03b92b598bf24f0099c867327d32e1d0|"
msgstr ""

#: 
msgid "|a079cade4fed4ebea1b8a342fb7241e1|"
msgstr ""

#: 
msgid "|f9aa613963c5402babfd4a8a13c7164b|"
msgstr ""

#: 
msgid "|c78f172f8c1c4199b77a43bd93756daf|"
msgstr ""

#: 
msgid "|f8552dc8ca584ccd9d7af43851c20852|"
msgstr ""

#: 
msgid "|961fc3525d0b4247b64e1a4a4d5a7c3c|"
msgstr ""

#: 
msgid "|dcc9428506314bf1a496c52e6641cb62|"
msgstr ""

#: 
msgid "|2bd0cb273959475d82089107836c2921|"
msgstr ""

#: 
msgid "|80c2819a5e70420fa7dbfb383fa535ef|"
msgstr ""

#: 
msgid "|c74b2083299e42d4909d6d307c864f02|"
msgstr ""

#: 
msgid "|35cf6fd7023c434fae85bfc5262eacb8|"
msgstr ""

#: 
msgid "|f5ddfeabc6a44155b25ac56dee9430df|"
msgstr ""

#: 
msgid "|8a486f3c95c54c769e96f9d77fb84ef6|"
msgstr ""

#: 
msgid "|24fe40ec0a1345bd9243f3cc75486f93|"
msgstr ""

#: 
msgid "|dd5fe5774ca04bd3b7022a76db36b09c|"
msgstr ""

#: 
msgid "|5ec322c654414a579650a43d3ec3a102|"
msgstr ""

#: 
msgid "|027a690ba1074195b8c0ddc909a887a7|"
msgstr ""

#: 
msgid "|cd3606512875432e91687f1df5fad8b8|"
msgstr ""

#: 
msgid "|1f9ceed9d129449eb79dfc7924f6893a|"
msgstr ""

#: 
msgid "|f9d1aaeb79a34190abf131b3d5250c56|"
msgstr ""

#: 
msgid "|0103edc08f884f8bb5653aacb6ac67c7|"
msgstr ""

#: 
msgid "|a8cad855162f4dafbcb98907607e0ee4|"
msgstr ""

#: 
msgid "|a655bb5ac1a14dbbbccc31d83a64c25f|"
msgstr ""

#: 
msgid "|8f6ad5160a864677baf9a2dd24ed0cbb|"
msgstr ""

#: 
msgid "|b9ac729373ac4542b4411ca19e7187c8|"
msgstr ""

#: 
msgid "|8edd2995a3104af28532a2c8e23ed939|"
msgstr ""

#: 
msgid "|fcefdd7ae6ea4eb9860f5f90d03fac74|"
msgstr ""

#: 
msgid "|2014ab95d650454c9232e0925a759258|"
msgstr ""

#: 
msgid "|202bcba9b2e747baba758fb0020d64db|"
msgstr ""

#: 
msgid "|329c8ca38cb24ec58d68fc15f8ca2fe4|"
msgstr ""

#: 
msgid "|132b2e95816543cfba027a32a6a1c5cc|"
msgstr ""

#: 
msgid "132b2e95816543cfba027a32a6a1c5cc"
msgstr ""

#: 
msgid "|7fa353cacc88470eb308d171d8f659d2|"
msgstr ""

#: 
msgid "|065988e4fd6c4f28b7953178a316081d|"
msgstr ""

#: 
msgid "|9c1533b7a39b40a89a210b3d620420e8|"
msgstr ""

#: 
msgid "9c1533b7a39b40a89a210b3d620420e8"
msgstr ""

#: 
msgid "|35afa0d8456d475992c2b98335758fd1|"
msgstr ""

#: 
msgid "35afa0d8456d475992c2b98335758fd1"
msgstr ""

#: 
msgid "|1909b4e487e64bdbaf9d7ec05155c4ed|"
msgstr ""

#: 
msgid "1909b4e487e64bdbaf9d7ec05155c4ed"
msgstr ""

#: 
msgid "|cadb3c20c3d941299afbca2d6ba7c9f8|"
msgstr ""

#: 
msgid "cadb3c20c3d941299afbca2d6ba7c9f8"
msgstr ""

#: 
msgid "|01189c6b623f4f158c7f039820e794fc|"
msgstr ""

#: 
msgid "01189c6b623f4f158c7f039820e794fc"
msgstr ""

#: 
msgid "|72fe49401f434bfa837803b98741f1d8|"
msgstr ""

#: 
msgid "72fe49401f434bfa837803b98741f1d8"
msgstr ""

#: 
msgid "|65f19af16b9b496bbce45631d3c433f8|"
msgstr ""

#: 
msgid "65f19af16b9b496bbce45631d3c433f8"
msgstr ""

#: 
msgid "|60fda924c4a3498c8473c1dd85f40c77|"
msgstr ""

#: 
msgid "60fda924c4a3498c8473c1dd85f40c77"
msgstr ""

#: 
msgid "|c7641934c10643dca2bedc483b434247|"
msgstr ""

#: 
msgid "c7641934c10643dca2bedc483b434247"
msgstr ""

#: 
msgid "|f68ab988ffc84bcda79affc918855487|"
msgstr ""

#: 
msgid "f68ab988ffc84bcda79affc918855487"
msgstr ""

#: 
msgid "|b710902a8b094ccd8f0a6f4810d27f5e|."
msgstr ""

#: 
msgid "b710902a8b094ccd8f0a6f4810d27f5e"
msgstr ""

#: 
msgid "ALOS/ALOS-2 PALSAR/PALSAR-2 Annual Mosaics |a3504845262b4fbeaf0eb8742f555a12|"
msgstr ""

#: 
msgid "a3504845262b4fbeaf0eb8742f555a12"
msgstr ""

#: 
msgid "|ed09b51f2fc94691a9264c45da54e622|"
msgstr ""

#: 
msgid "ed09b51f2fc94691a9264c45da54e622"
msgstr ""

#: 
msgid "|52664d78dbe74a8a88c929372a8fdcad|"
msgstr ""

#: 
msgid "52664d78dbe74a8a88c929372a8fdcad"
msgstr ""

#: 
msgid "Landsat Surface Reflectance |f16af3c3a81f403eae6db04989b17d32|"
msgstr ""

#: 
msgid "f16af3c3a81f403eae6db04989b17d32"
msgstr ""

#: 
msgid "Landsat Surface Temperature |e7a180a922d44f368ff92b89b2c08450|"
msgstr ""

#: 
msgid "e7a180a922d44f368ff92b89b2c08450"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |78de64a78b1d446ea7791999b350edf7| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "78de64a78b1d446ea7791999b350edf7"
msgstr ""

#: 
msgid "Sentinel-1 |f1db45302fb747aa97dd312fa89fe9cc|"
msgstr ""

#: 
msgid "f1db45302fb747aa97dd312fa89fe9cc"
msgstr ""

#: 
msgid "Sentinel-2 |98a3b1a4f30b4844835ed5a555ac6f03|"
msgstr ""

#: 
msgid "98a3b1a4f30b4844835ed5a555ac6f03"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |653f2e9741a64db5bc0b910a28944690| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "653f2e9741a64db5bc0b910a28944690"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |45ecc22ed91448678baae7a37284e834| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "45ecc22ed91448678baae7a37284e834"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |951788d0598844f1a850e36b21a28aa1| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "951788d0598844f1a850e36b21a28aa1"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |3c0ba816180d4a0f9f2d1068f5161015| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "3c0ba816180d4a0f9f2d1068f5161015"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |3a88f50c7b1449f5ac393de599df1415| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "3a88f50c7b1449f5ac393de599df1415"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |2ee035bcf0f047d5bf01c7cb06ff4de4| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "2ee035bcf0f047d5bf01c7cb06ff4de4"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |f178f6cfa8504a509be445de1d33b123| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "f178f6cfa8504a509be445de1d33b123"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |906242b82db949ac84f3441a21fa6702| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "906242b82db949ac84f3441a21fa6702"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |31af29f124ee463a9ade819d5317d5b4| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "31af29f124ee463a9ade819d5317d5b4"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |b28739265c79442d889663c8c5c93c16| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "b28739265c79442d889663c8c5c93c16"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |ac6e7472f02940d087b792b6917229b3| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "ac6e7472f02940d087b792b6917229b3"
msgstr ""

#: 
msgid "Displaying satellite imagery on a web map |70a69662378848bf9e64dce4add82d46|"
msgstr ""

#: 
msgid "70a69662378848bf9e64dce4add82d46"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |8f6891d6520d4ec1ae12171adec72f26| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "8f6891d6520d4ec1ae12171adec72f26"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |4bb55700ec994c488d9d61a82a675cf4| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "4bb55700ec994c488d9d61a82a675cf4"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |617fdd3c31764e21a472cbcf49ad5f8d| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "617fdd3c31764e21a472cbcf49ad5f8d"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |3f7742cac8674def9563a25ed30e3c2b| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "3f7742cac8674def9563a25ed30e3c2b"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |493cc53073ec49aea8a48fc0a409df5d| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "493cc53073ec49aea8a48fc0a409df5d"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |896ef1ee7b2d48b1bb23ef76dbe88d71| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "896ef1ee7b2d48b1bb23ef76dbe88d71"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |7020fb116a444df99c12bb73162e4733| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "7020fb116a444df99c12bb73162e4733"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |83b44650a7354227be3e0411e38b85fb| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "83b44650a7354227be3e0411e38b85fb"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |f02eabd54b49458caf1a954fb1379563| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "f02eabd54b49458caf1a954fb1379563"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |420cdb72ca02444890dabc5497fe71fa| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "420cdb72ca02444890dabc5497fe71fa"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |32bde514c0ab42a992e78472984e5977| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "32bde514c0ab42a992e78472984e5977"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |0bfa9eeda5514ad1af23fd1beecc8f54| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "0bfa9eeda5514ad1af23fd1beecc8f54"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |3b56b5d19aae4ac981fb2b444e1805cf| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "3b56b5d19aae4ac981fb2b444e1805cf"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |cf52a0b726394996a99a700cb326a143| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "cf52a0b726394996a99a700cb326a143"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |cfeef7b5b3ba4ec2af95b2c3db8cf385| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "cfeef7b5b3ba4ec2af95b2c3db8cf385"
msgstr ""

#: 
msgid "|009c4f68be834fdd97541b79bc96ec73|"
msgstr ""

#: 
msgid "009c4f68be834fdd97541b79bc96ec73"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |d27bc756fab9451faacfc460b4c8ea8a| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "d27bc756fab9451faacfc460b4c8ea8a"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |edc0afc7fc534a79b6e51177f03c4cdb| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "edc0afc7fc534a79b6e51177f03c4cdb"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |38d9705dacf843cbaa2e8dce12c61993| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "38d9705dacf843cbaa2e8dce12c61993"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |c896dffb237644318c9bb0a9d986eefa| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "c896dffb237644318c9bb0a9d986eefa"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |a98eaafc051b4299859613ac9b3226f9| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "a98eaafc051b4299859613ac9b3226f9"
msgstr ""

#: 
msgid "Water detection with Sentinel-1 |65970bb6a5cb426484e30a25bd3f82d3|"
msgstr ""

#: 
msgid "65970bb6a5cb426484e30a25bd3f82d3"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |224b97595cb743fe8de278dcc64407cd| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "224b97595cb743fe8de278dcc64407cd"
msgstr ""

#: 
msgid "|7cfd8fb2f504420d93119e5b6f447684|"
msgstr ""

#: 
msgid "7cfd8fb2f504420d93119e5b6f447684"
msgstr ""

#: 
msgid "|5aa63a5b7d7e44dd82d8c2f6c97ed83f|"
msgstr ""

#: 
msgid "5aa63a5b7d7e44dd82d8c2f6c97ed83f"
msgstr ""

#: 
msgid "|577a94fdfb37450690e63f9ae8521be6|"
msgstr ""

#: 
msgid "577a94fdfb37450690e63f9ae8521be6"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |1438162295d4431e9f4a7e9e71c56468| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "1438162295d4431e9f4a7e9e71c56468"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |a34793397b3a44558aed5b1b2cdfa9ca| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "a34793397b3a44558aed5b1b2cdfa9ca"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |54614cf79eaf45e9a7595e99d9271f0f| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "54614cf79eaf45e9a7595e99d9271f0f"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |2393470158884f158b42634e489a7b02| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "2393470158884f158b42634e489a7b02"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |fa919782907d4abca3331b4a4916218b| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "fa919782907d4abca3331b4a4916218b"
msgstr ""

#: 
msgid "By uploading a polygon as a ``GeoJSON or Esri Shapefile``. If you choose this option, you will need to upload the geojson or ESRI shapefile into the Sandbox using Upload Files button |8e9e613afa684a55af0121a76ea56a47| in the top left corner of the Jupyter Notebook interface. ESRI shapefiles must be uploaded with all the related files ``(.cpg, .dbf, .shp, .shx)``. Once uploaded, you can use the shapefile or geojson to define the area of interest. Remember to update the code to call the file you have uploaded."
msgstr ""

#: 
msgid "8e9e613afa684a55af0121a76ea56a47"
msgstr ""

#: 
msgid "|050f9ba63eb142509e6f36b20e39ffb0|"
msgstr ""

#: 
msgid "050f9ba63eb142509e6f36b20e39ffb0"
msgstr ""

#: 
msgid "|55683e486b95468d95bf15280896bced|"
msgstr ""

#: 
msgid "55683e486b95468d95bf15280896bced"
msgstr ""

#: 
msgid "|664f5f9de47f400487f774f6906089d8|"
msgstr ""

#: 
msgid "|a18af3fc35464347a26f5a409b2725f9|"
msgstr ""

#: 
msgid "|176c1e7175e546b7809d927757de3c3c|"
msgstr ""

#: 
msgid "|0af5835aebd24b0dbb283cd51cd67b56|"
msgstr ""

#: 
msgid "|1b44fcf3202d427195a2f138e8ea52eb|"
msgstr ""

#: 
msgid "|2e216db7dac34d2c8b0ef21a4f555e58|"
msgstr ""

#: 
msgid "|5184e7c03b704819bfe6b5c37391500b|"
msgstr ""

#: 
msgid "|c52e0ff414484d8b8902173837a38c86|"
msgstr ""

#: 
msgid "|d76c280174c04aa6b5e2c4108cc20bf4|"
msgstr ""

#: 
msgid "|808c30e4286b496f8ce138ffa847cff7| |dafe63423f77484b9562421078b1e8cb|"
msgstr ""

#: 
msgid "808c30e4286b496f8ce138ffa847cff7"
msgstr ""

#: 
msgid "dafe63423f77484b9562421078b1e8cb"
msgstr ""

#: 
msgid "|bcadda9ae4d247fdaad9ac063a29ece8|"
msgstr ""

#: 
msgid "bcadda9ae4d247fdaad9ac063a29ece8"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:84
msgid "ESRI World Imagery"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:85
msgid "Sentinel-2 Geomedian"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:100
msgid "Select parameters and AOI"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:124
msgid "Total polygon area"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:128
msgid "Area falls within recommended limit"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:131
msgid "Area is too large, please update your polygon"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:151
msgid "Map Overlays"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:176
msgid "Run"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:183
msgid "Map Overlay:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:185
msgid "Start Date:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:187
msgid "End Date:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:189
msgid "Minimum Good Data:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:191
msgid "Resampling Frequency:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:193
msgid "Output CSV:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:195
msgid "Output Plot:"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:308
msgid "Progress"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:326
msgid "WIT complete"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:328
msgid "No polygon selected"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:365
msgid "open water"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:367
msgid "green veg"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:368
msgid "dry veg"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:369
msgid "bare soil"
msgstr ""

#: Tools/deafrica_tools/app/wetlandsinsighttool.py:382
msgid "Percentage Fractional Cover, Wetness, and Water"
msgstr ""

